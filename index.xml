<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy blog </title>
    <link>https://kingjcy.github.io/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2018</rights>
    <updated>2018-12-25 14:27:45 &#43;0800 CST</updated>

    
      
        <item>
          <title>Golang使用系列---- Bufio</title>
          <link>https://kingjcy.github.io/post/golang/go-bufio/</link>
          <pubDate>Tue, 25 Dec 2018 14:27:45 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/golang/go-bufio/</guid>
          <description>&lt;p&gt;bufio 包实现了缓存IO。它包装了 io.Reader 和 io.Writer 对象，创建了另外的Reader和Writer对象，它们也实现了 io.Reader 和 io.Writer 接口，不过它们是有缓存的。该包同时为文本I/O提供了一些便利操作。&lt;/p&gt;

&lt;h1 id=&#34;类型和方法&#34;&gt;类型和方法&lt;/h1&gt;

&lt;h2 id=&#34;reader-类型和方法&#34;&gt;Reader 类型和方法&lt;/h2&gt;

&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;

&lt;p&gt;bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口。&lt;/p&gt;

&lt;p&gt;Reader 结构没有任何导出的字段，结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Reader struct {
    buf          []byte        // 缓存
    rd           io.Reader    // 底层的io.Reader
    // r:从buf中读走的字节（偏移）；w:buf中填充内容的偏移；
    // w - r 是buf中可被读的长度（缓存数据的大小），也是Buffered()方法的返回值
    r, w         int
    err          error        // 读过程中遇到的错误
    lastByte     int        // 最后一次读到的字节（ReadByte/UnreadByte)
    lastRuneSize int        // 最后一次读到的Rune的大小 (ReadRune/UnreadRune)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;实例化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;bufio 包提供了两个实例化 bufio.Reader 对象的函数：NewReader 和 NewReaderSize。其中，NewReader 函数是调用 NewReaderSize 函数实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewReader(rd io.Reader) *Reader {
    // 默认缓存大小：defaultBufSize=4096
    return NewReaderSize(rd, defaultBufSize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看一下NewReaderSize的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewReaderSize(rd io.Reader, size int) *Reader {
    // 已经是bufio.Reader类型，且缓存大小不小于 size，则直接返回
    b, ok := rd.(*Reader)
    if ok &amp;amp;&amp;amp; len(b.buf) &amp;gt;= size {
        return b
    }
    // 缓存大小不会小于 minReadBufferSize （16字节）
    if size &amp;lt; minReadBufferSize {
        size = minReadBufferSize
    }
    // 构造一个bufio.Reader实例
    return &amp;amp;Reader{
        buf:          make([]byte, size),
        rd:           rd,
        lastByte:     -1,
        lastRuneSize: -1,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见需要一个id.reader的实例来进行初始化，一般我们都是使用string或者[]byte的reader类型来创建。&lt;/p&gt;

&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;ReadSlice、ReadBytes、ReadString 和 ReadLine 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之所以将这几个方法放在一起，是因为他们有着类似的行为。事实上，后三个方法最终都是调用ReadSlice来实现的。所以，我们先来看看ReadSlice方法(感觉这一段直接看源码较好)。&lt;/p&gt;

&lt;p&gt;1.ReadSlice方法签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReadSlice 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 slice，在下次调用读操作（read）时，这些字节会无效。举例说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reader := bufio.NewReader(strings.NewReader(&amp;quot;http://studygolang.com. \nIt is the home of gophers&amp;quot;))
line, _ := reader.ReadSlice(&#39;\n&#39;)
fmt.Printf(&amp;quot;the line:%s\n&amp;quot;, line)
// 这里可以换上任意的 bufio 的 Read/Write 操作
n, _ := reader.ReadSlice(&#39;\n&#39;)
fmt.Printf(&amp;quot;the line:%s\n&amp;quot;, line)
fmt.Println(string(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;the line:http://studygolang.com.

the line:It is the home of gophers
It is the home of gophers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从结果可以看出，第一次ReadSlice的结果（line），在第二次调用读操作后，内容发生了变化。也就是说，ReadSlice 返回的 []byte 是指向 Reader 中的 buffer ，而不是 copy 一份返回。正因为ReadSlice 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择使用 ReadBytes 或者 ReadString 来代替。读者可以将上面代码中的 ReadSlice 改为 ReadBytes 或 ReadString ，看看结果有什么不同。&lt;/p&gt;

&lt;p&gt;注意，这里的界定符可以是任意的字符，可以将上面代码中的&amp;rsquo;\n&amp;rsquo;改为&amp;rsquo;m&amp;rsquo;试试。同时，返回的结果是包含界定符本身的，上例中，输出结果有一空行就是&amp;rsquo;\n&amp;rsquo;本身(line携带一个&amp;rsquo;\n&amp;rsquo;,printf又追加了一个&amp;rsquo;\n&amp;rsquo;)。&lt;/p&gt;

&lt;p&gt;如果 ReadSlice 在找到界定符之前遇到了 error ，它就会返回缓存中所有的数据和错误本身（经常是 io.EOF）。如果在找到界定符之前缓存已经满了，ReadSlice 会返回 bufio.ErrBufferFull 错误。当且仅当返回的结果（line）没有以界定符结束的时候，ReadSlice 返回err != nil，也就是说，如果ReadSlice 返回的结果 line 不是以界定符 delim 结尾，那么返回的 er r也一定不等于 nil（可能是bufio.ErrBufferFull或io.EOF）。 例子代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reader := bufio.NewReaderSize(strings.NewReader(&amp;quot;http://studygolang.com&amp;quot;),16)
line, err := reader.ReadSlice(&#39;\n&#39;)
fmt.Printf(&amp;quot;line:%s\terror:%s\n&amp;quot;, line, err)
line, err = reader.ReadSlice(&#39;\n&#39;)
fmt.Printf(&amp;quot;line:%s\terror:%s\n&amp;quot;, line, err)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;line:http://studygola    error:bufio: buffer full
line:ng.com    error:EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.ReadBytes方法签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b *Reader) ReadBytes(delim byte) (line []byte, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法的参数和返回值类型与 ReadSlice 都一样。 ReadBytes 从输入中读取直到遇到界定符（delim）为止，返回的 slice 包含了从当前到界定符的内容 （包括界定符）。如果 ReadBytes 在遇到界定符之前就捕获到一个错误，它会返回遇到错误之前已经读取的数据，和这个捕获到的错误（经常是 io.EOF）。跟 ReadSlice 一样，如果 ReadBytes 返回的结果 line 不是以界定符 delim 结尾，那么返回的 err 也一定不等于 nil（可能是bufio.ErrBufferFull 或 io.EOF）。&lt;/p&gt;

&lt;p&gt;从这个说明可以看出，ReadBytes和ReadSlice功能和用法都很像，那他们有什么不同呢？&lt;/p&gt;

&lt;p&gt;在讲解ReadSlice时说到，它返回的 []byte 是指向 Reader 中的 buffer，而不是 copy 一份返回，也正因为如此，通常我们会使用 ReadBytes 或 ReadString。很显然，ReadBytes 返回的 []byte 不会是指向 Reader 中的 buffer，通过查看源码可以证实这一点。&lt;/p&gt;

&lt;p&gt;还是上面的例子，我们将 ReadSlice 改为 ReadBytes：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reader := bufio.NewReader(strings.NewReader(&amp;quot;http://studygolang.com. \nIt is the home of gophers&amp;quot;))
line, _ := reader.ReadBytes(&#39;\n&#39;)
fmt.Printf(&amp;quot;the line:%s\n&amp;quot;, line)
// 这里可以换上任意的 bufio 的 Read/Write 操作
n, _ := reader.ReadBytes(&#39;\n&#39;)
fmt.Printf(&amp;quot;the line:%s\n&amp;quot;, line)
fmt.Println(string(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;the line:http://studygolang.com.

the line:http://studygolang.com.

It is the home of gophers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.ReadString方法&lt;/p&gt;

&lt;p&gt;看一下该方法的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b *Reader) ReadString(delim byte) (line string, err error) {
    bytes, err := b.ReadBytes(delim)
    return string(bytes), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它调用了 ReadBytes 方法，并将结果的 []byte 转为 string 类型。&lt;/p&gt;

&lt;p&gt;4.ReadLine方法签名如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReadLine 是一个底层的原始行读取命令。许多调用者或许会使用 ReadBytes(&amp;rsquo;\n&amp;rsquo;) 或者 ReadString(&amp;rsquo;\n&amp;rsquo;) 来代替这个方法。&lt;/p&gt;

&lt;p&gt;ReadLine 尝试返回单独的行，不包括行尾的换行符。如果一行大于缓存，isPrefix 会被设置为 true，同时返回该行的开始部分（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，isPrefix 将会是 false 。跟 ReadSlice 一样，返回的 line 只是 buffer 的引用，在下次执行IO操作时，line 会无效。可以将 ReadSlice 中的例子该为 ReadLine 试试。&lt;/p&gt;

&lt;p&gt;注意，返回值中，要么 line 不是 nil，要么 err 非 nil，两者不会同时非 nil。ReadLine 返回的文本不会包含行结尾（&amp;rdquo;\r\n&amp;rdquo;或者&amp;rdquo;\n&amp;rdquo;）。如果输入中没有行尾标识符，不会返回任何指示或者错误。&lt;/p&gt;

&lt;p&gt;个人建议可以这么实现读取一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;line, err := reader.ReadBytes(&#39;\n&#39;)
line = bytes.TrimRight(line, &amp;quot;\r\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样既读取了一行，也去掉了行尾结束符（当然，如果你希望留下行尾结束符，只用ReadBytes即可）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Peek 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从方法的名称可以猜到，该方法只是“窥探”一下 Reader 中没有读取的 n 个字节。好比栈数据结构中的取栈顶元素，但不出栈。&lt;/p&gt;

&lt;p&gt;方法的签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b *Reader) Peek(n int) ([]byte, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同上面介绍的 ReadSlice一样，返回的 []byte 只是 buffer 中的引用，在下次IO操作后会无效，可见该方法（以及ReadSlice这样的，返回buffer引用的方法）对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。&lt;/p&gt;

&lt;p&gt;我们通过例子来证明一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;bufio&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;strings&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {
    reader := bufio.NewReaderSize(strings.NewReader(&amp;quot;http://studygolang.com.\t It is the home of gophers&amp;quot;), 14)
    go Peek(reader)
    go reader.ReadBytes(&#39;\t&#39;)
    time.Sleep(1e8)
}

func Peek(reader *bufio.Reader) {
    line, _ := reader.Peek(14)
    fmt.Printf(&amp;quot;%s\n&amp;quot;, line)
    // time.Sleep(1)
    fmt.Printf(&amp;quot;%s\n&amp;quot;, line)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://studygo
http://studygo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果和预期的一致。然而，这是由于目前的 goroutine 调度方式导致的结果。如果我们将例子中注释掉的 time.Sleep(1) 取消注释（这样调度其他 goroutine 执行），再次运行，得到的结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://studygo
ng.com.     It is
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 err != nil ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;其他方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Reader 的其他方法都是实现了 io 包中的接口，它们的使用方法在io包中都有介绍，在此不赘述。&lt;/p&gt;

&lt;p&gt;这些方法包括：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b *Reader) Read(p []byte) (n int, err error)
func (b *Reader) ReadByte() (c byte, err error)
func (b *Reader) ReadRune() (r rune, size int, err error)
func (b *Reader) UnreadByte() error
func (b *Reader) UnreadRune() error
func (b *Reader) WriteTo(w io.Writer) (n int64, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该知道它们都是哪个接口的方法吧。&lt;/p&gt;

&lt;h2 id=&#34;scanner-类型和方法&#34;&gt;Scanner 类型和方法&lt;/h2&gt;

&lt;h3 id=&#34;类型-1&#34;&gt;类型&lt;/h3&gt;

&lt;p&gt;对于简单的读取一行，在 Reader 类型中，感觉没有让人特别满意的方法。于是，Go1.1增加了一个类型：Scanner。官方关于Go1.1增加该类型的说明如下：&lt;/p&gt;

&lt;p&gt;在 bufio 包中有多种方式获取文本输入，ReadBytes、ReadString 和独特的 ReadLine，对于简单的目的这些都有些过于复杂了。在 Go 1.1 中，添加了一个新类型，Scanner，以便更容易的处理如按行读取输入序列或空格分隔单词等，这类简单的任务。它终结了如输入一个很长的有问题的行这样的输入错误，并且提供了简单的默认行为：基于行的输入，每行都剔除分隔标识。这里的代码展示一次输入一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scanner := bufio.NewScanner(os.Stdin)
for scanner.Scan() {
    fmt.Println(scanner.Text()) // Println will add back the final &#39;\n&#39;
}
if err := scanner.Err(); err != nil {
    fmt.Fprintln(os.Stderr, &amp;quot;reading standard input:&amp;quot;, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入的行为可以通过一个函数控制，来控制输入的每个部分（参阅 SplitFunc 的文档），但是对于复杂的问题或持续传递错误的，可能还是需要原有接口。&lt;/p&gt;

&lt;p&gt;Scanner 类型和 Reader 类型一样，没有任何导出的字段，同时它也包装了一个 io.Reader 对象，但它没有实现 io.Reader 接口。&lt;/p&gt;

&lt;p&gt;Scanner 的结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Scanner struct {
    r            io.Reader // The reader provided by the client.
    split        SplitFunc // The function to split the tokens.
    maxTokenSize int       // Maximum size of a token; modified by tests.
    token        []byte    // Last token returned by split.
    buf          []byte    // Buffer used as argument to split.
    start        int       // First non-processed byte in buf.
    end          int       // End of data in buf.
    err          error     // Sticky error.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 split、maxTokenSize 和 token 需要讲解一下。&lt;/p&gt;

&lt;h4 id=&#34;split&#34;&gt;split&lt;/h4&gt;

&lt;p&gt;split对应的类型是SplitFunc ，我们需要了解一下SplitFunc类型，定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SplitFunc 定义了 用于对输入进行分词的 split 函数的签名。参数 data 是还未处理的数据，atEOF 标识 Reader 是否还有更多数据（是否到了EOF）。返回值 advance 表示从输入中读取的字节数，token 表示下一个结果数据，err 则代表可能的错误。&lt;/p&gt;

&lt;p&gt;举例说明一下这里的 token 代表的意思：&lt;/p&gt;

&lt;p&gt;有数据 &amp;ldquo;studygolang\tpolaris\tgolangchina&amp;rdquo;，通过&amp;rdquo;\t&amp;rdquo;进行分词，那么会得到三个token，它们的内容分别是：studygolang、polaris 和 golangchina。而 SplitFunc 的功能是：进行分词，并返回未处理的数据中第一个 token。对于这个数据，就是返回 studygolang。
如果 data 中没有一个完整的 token，例如，在扫描行（scanning lines）时没有换行符，SplitFunc 会返回(0,nil,nil)通知 Scanner 读取更多数据到 slice 中。&lt;/p&gt;

&lt;p&gt;如果 err != nil，扫描停止，同时该错误会返回。&lt;/p&gt;

&lt;p&gt;如果参数 data 为空的 slice，除非 atEOF 为 true，否则该函数永远不会被调用。如果 atEOF 为 true，这时 data 可以非空，这时的数据是没有处理的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SplitFunc 的实例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 bufio 包中预定义了一些 split 函数，也就是说，在 Scanner 结构中的 split 字段，可以通过这些预定义的 split 赋值，同时 Scanner 类型的 Split 方法也可以接收这些预定义函数作为参数。所以，我们可以说，这些预定义 split 函数都是 SplitFunc 类型的实例。这些函数包括：ScanBytes、ScanRunes、ScanWords 和 ScanLines。（由于都是 SplitFunc 的实例，自然这些函数的签名都和 SplitFunc 一样）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ScanBytes 返回单个字节作为一个 token。&lt;/li&gt;
&lt;li&gt;ScanRunes 返回单个 UTF-8 编码的 rune 作为一个 token。返回的 rune 序列（token）和 range string类型 返回的序列是等价的，也就是说，对于无效的 UTF-8 编码会解释为 U+FFFD = &amp;ldquo;\xef\xbf\xbd&amp;rdquo;。&lt;/li&gt;
&lt;li&gt;ScanWords 返回通过“空格”分词的单词。如：study golang，调用会返回study。注意，这里的“空格”是 unicode.IsSpace()，即包括：&amp;rsquo;\t&amp;rsquo;, &amp;lsquo;\n&amp;rsquo;, &amp;lsquo;\v&amp;rsquo;, &amp;lsquo;\f&amp;rsquo;, &amp;lsquo;\r&amp;rsquo;, &amp;lsquo; &amp;lsquo;, U+0085 (NEL), U+00A0 (NBSP)。&lt;/li&gt;
&lt;li&gt;ScanLines 返回一行文本，不包括行尾的换行符。这里的换行包括了Windows下的&amp;rdquo;\r\n&amp;rdquo;和Unix下的&amp;rdquo;\n&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般地，我们不会单独使用这些函数，而是提供给 Scanner 实例使用。&lt;/p&gt;

&lt;h4 id=&#34;maxtokensize&#34;&gt;maxTokenSize&lt;/h4&gt;

&lt;p&gt;maxTokenSize 字段 表示通过 split 分词后的一个 token 允许的最大长度。在该包中定义了一个常量 MaxScanTokenSize = 64 * 1024，这是允许的最大 token 长度（64k）。&lt;/p&gt;

&lt;h3 id=&#34;方法-1&#34;&gt;方法&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;实例化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Scanner 没有导出任何字段，而它需要有外部的 io.Reader 对象，因此，我们不能直接实例化 Scanner 对象，必须通过 bufio 包提供的实例化函数来实例化。实例化函数签名以及内部实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewScanner(r io.Reader) *Scanner {
    return &amp;amp;Scanner{
        r:            r,
        split:        ScanLines,
        maxTokenSize: MaxScanTokenSize,
        buf:          make([]byte, 4096), // Plausible starting size; needn&#39;t be large.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，返回的 Scanner 实例默认的 split 函数是 ScanLines。这边实例化也是需要一个id.reader的实例，所以我们一般也是使用string或者[]byte的实例来做创建参数使用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Split 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面我们提到过可以通过 Split 方法为 Scanner 实例设置分词行为。由于 Scanner 实例的默认 split 总是 ScanLines，如果我们想要用其他的 split，可以通过 Split 方法做到。&lt;/p&gt;

&lt;p&gt;比如，我们想要统计一段英文有多少个单词（不排除重复），我们可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const input = &amp;quot;This is The Golang Standard Library.\nWelcome you!&amp;quot;
scanner := bufio.NewScanner(strings.NewReader(input))
scanner.Split(bufio.ScanWords)
count := 0
for scanner.Scan() {
    count++
}
if err := scanner.Err(); err != nil {
    fmt.Fprintln(os.Stderr, &amp;quot;reading input:&amp;quot;, err)
}
fmt.Println(count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们实例化 Scanner 后，通过调用 scanner.Split(bufio.ScanWords) 来更改 split 函数。注意，我们应该在调用 Scan 方法之前调用 Split 方法。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Scan 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;该方法好比 iterator 中的 Next 方法，它用于将 Scanner 获取下一个 token，以便 Bytes 和 Text 方法可用。当扫描停止时，它返回false，这时候，要么是到了输入的末尾要么是遇到了一个错误。注意，当 Scan 返回 false 时，通过 Err 方法可以获取第一个遇到的错误（但如果错误是 io.EOF，Err 方法会返回 nil）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bytes 和 Text 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这两个方法的行为一致，都是返回最近的 token，无非 Bytes 返回的是 []byte，Text 返回的是 string。该方法应该在 Scan 调用后调用，而且，下次调用 Scan 会覆盖这次的 token。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scanner := bufio.NewScanner(strings.NewReader(&amp;quot;http://studygolang.com. \nIt is the home of gophers&amp;quot;))
if scanner.Scan() {
    scanner.Scan()
    fmt.Printf(&amp;quot;%s&amp;quot;, scanner.Text())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;It is the home of gophers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而不是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://studygolang.com.
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Err 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面已经提到，通过 Err 方法可以获取第一个遇到的错误（但如果错误是 io.EOF，Err 方法会返回 nil）。&lt;/p&gt;

&lt;h3 id=&#34;完整实例&#34;&gt;完整实例&lt;/h3&gt;

&lt;p&gt;我们经常会有这样的需求：读取文件中的数据，一次读取一行。在学习了 Reader 类型，我们可以使用它的 ReadBytes 或 ReadString来实现，甚至使用 ReadLine 来实现。然而，在 Go1.1 中，我们可以使用 Scanner 来做这件事，而且更简单好用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file, err := os.Create(&amp;quot;scanner.txt&amp;quot;)
if err != nil {
    panic(err)
}
defer file.Close()
file.WriteString(&amp;quot;http://studygolang.com.\nIt is the home of gophers.\nIf you are studying golang, welcome you!&amp;quot;)
// 将文件 offset 设置到文件开头
file.Seek(0, os.SEEK_SET)
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    fmt.Println(scanner.Text())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://studygolang.com.
It is the home of gophers.
If you are studying golang, welcome you!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;writer-类型和方法&#34;&gt;Writer 类型和方法&lt;/h2&gt;

&lt;h3 id=&#34;类型-2&#34;&gt;类型&lt;/h3&gt;

&lt;p&gt;bufio.Writer 结构包装了一个 io.Writer 对象，提供缓存功能，同时实现了 io.Writer 接口。&lt;/p&gt;

&lt;p&gt;Writer 结构没有任何导出的字段，结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Writer struct {
    err error        // 写过程中遇到的错误
    buf []byte        // 缓存
    n   int            // 当前缓存中的字节数
    wr  io.Writer    // 底层的 io.Writer 对象
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相比 bufio.Reader, bufio.Writer 结构定义简单很多。&lt;/p&gt;

&lt;p&gt;注意：如果在写数据到 Writer 的时候出现了一个错误，不会再允许有数据被写进来了，并且所有随后的写操作都会返回该错误。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;实例化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;和 Reader 类型一样，bufio 包提供了两个实例化 bufio.Writer 对象的函数：NewWriter 和 NewWriterSize。其中，NewWriter 函数是调用 NewWriterSize 函数实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewWriter(wr io.Writer) *Writer {
    // 默认缓存大小：defaultBufSize=4096
    return NewWriterSize(wr, defaultBufSize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看一下 NewWriterSize 的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewWriterSize(wr io.Writer, size int) *Writer {
    // 已经是 bufio.Writer 类型，且缓存大小不小于 size，则直接返回
    b, ok := wr.(*Writer)
    if ok &amp;amp;&amp;amp; len(b.buf) &amp;gt;= size {
        return b
    }
    if size &amp;lt;= 0 {
        size = defaultBufSize
    }
    return &amp;amp;Writer{
        buf: make([]byte, size),
        wr:  w,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法-2&#34;&gt;方法&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Available 和 Buffered 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Available 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）；&lt;/p&gt;

&lt;p&gt;Buffered 方法获取写入当前缓存中的字节数（字段 n 的值）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Flush 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;该方法将缓存中的所有数据写入底层的 io.Writer 对象中。使用 bufio.Writer 时，在所有的 Write 操作完成之后，应该调用 Flush 方法使得缓存都写入 io.Writer 对象中。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;其他方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Writer 类型其他方法是一些实际的写方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 实现了 io.ReaderFrom 接口
func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)

// 实现了 io.Writer 接口
func (b *Writer) Write(p []byte) (nn int, err error)

// 实现了 io.ByteWriter 接口
func (b *Writer) WriteByte(c byte) error

// io 中没有该方法的接口，它用于写入单个 Unicode 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 rune 的范围调用 WriteByte 或 WriteString
func (b *Writer) WriteRune(r rune) (size int, err error)

// 写入字符串，如果返回写入的字节数比 len(s) 小，返回的error会解释原因
func (b *Writer) WriteString(s string) (int, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些写方法在缓存满了时会调用 Flush 方法。另外，这些写方法源码开始处，有这样的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if b.err != nil {
    return b.err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，只要写的过程中遇到了错误，再次调用写操作会直接返回该错误。&lt;/p&gt;

&lt;h2 id=&#34;readwriter-类型和实例化&#34;&gt;ReadWriter 类型和实例化&lt;/h2&gt;

&lt;h3 id=&#34;类型-3&#34;&gt;类型&lt;/h3&gt;

&lt;p&gt;ReadWriter 结构存储了 bufio.Reader 和 bufio.Writer 类型的指针（内嵌），它实现了 io.ReadWriter 结构。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ReadWriter struct {
    *Reader
    *Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;

&lt;p&gt;ReadWriter 的实例化可以跟普通结构类型一样，也可以通过调用 bufio.NewReadWriter 函数来实现：只是简单的实例化 ReadWriter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewReadWriter(r *Reader, w *Writer) *ReadWriter {
    return &amp;amp;ReadWriter{r, w}
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
      
    
      
        <item>
          <title>Golang使用系列---- Bytes</title>
          <link>https://kingjcy.github.io/post/golang/go-bytes/</link>
          <pubDate>Mon, 25 Dec 2017 14:28:17 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/golang/go-bytes/</guid>
          <description>&lt;p&gt;该包定义了一些操作 byte slice 的便利操作。因为字符串可以表示为 []byte，因此，bytes 包定义的函数、方法等和 strings 包很类似，所以讲解时会和 strings 包类似甚至可以直接参考。&lt;/p&gt;

&lt;h1 id=&#34;基本使用&#34;&gt;基本使用&lt;/h1&gt;

&lt;h2 id=&#34;是否存在某个子-slice&#34;&gt;是否存在某个子 slice&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// 子 slice subslice 在 b 中，返回 true
func Contains(b, subslice []byte) bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数的内部调用了 bytes.Index 函数（在后面会讲解）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Contains(b, subslice []byte) bool {
    return Index(b, subslice) != -1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;题外：对比 strings.Contains 你会发现，一个判断 &amp;gt;=0，一个判断 != -1，可见库不是一个人写的，没有做到一致性。&lt;/p&gt;

&lt;h2 id=&#34;byte-出现次数&#34;&gt;[]byte 出现次数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// slice sep 在 s 中出现的次数（无重叠）
func Count(s, sep []byte) int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和 strings 实现不同，此包中的 Count 核心代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count := 0
c := sep[0]
i := 0
t := s[:len(s)-n+1]
for i &amp;lt; len(t) {
    // 判断 sep 第一个字节是否在 t[i:] 中
    // 如果在，则比较之后相应的字节
    if t[i] != c {
        o := IndexByte(t[i:], c)
        if o &amp;lt; 0 {
            break
        }
        i += o
    }
    // 执行到这里表示 sep[0] == t[i]
    if n == 1 || Equal(s[i:i+n], sep) {
        count++
        i += n
        continue
    }
    i++
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;runes-类型转换&#34;&gt;Runes 类型转换&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// 将 []byte 转换为 []rune
func Runes(s []byte) []rune
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数将 []byte 转换为 []rune ，适用于汉字等多字节字符，示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b:=[]byte(&amp;quot;你好，世界&amp;quot;)
for k,v:=range b{
    fmt.Printf(&amp;quot;%d:%s |&amp;quot;,k,string(v))
}
r:=bytes.Runes(b)
for k,v:=range r{
    fmt.Printf(&amp;quot;%d:%s|&amp;quot;,k,string(v))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0:ä |1:½ |2:  |3:å |4:¥ |5:½ |6:ï |7:¼ |8:  |9:ä |10:¸ |11:  |12:ç |13:  |14: |
0:你|1:好|2:，|3:世|4:界|
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它函数&#34;&gt;其它函数&lt;/h2&gt;

&lt;p&gt;其它大部分函数、方法与 strings 包下的函数、方法类似，只是数据源从 string 变为了 []byte ，请参考 strings 包的用法。&lt;/p&gt;

&lt;h1 id=&#34;类型&#34;&gt;类型&lt;/h1&gt;

&lt;h2 id=&#34;reader-类型&#34;&gt;Reader 类型&lt;/h2&gt;

&lt;p&gt;看到名字就能猜到，这是实现了 io 包中的接口。其实这就是缓存io，对缓存中的[]byte进行读写操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Reader struct {
    s        []byte
    i        int64 // 当前读取下标
    prevRune int   // 前一个字符的下标，也可能 &amp;lt; 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bytes 包下的 Reader 类型实现了 io 包下的 Reader, ReaderAt, RuneReader, RuneScanner, ByteReader, ByteScanner, ReadSeeker, Seeker, WriterTo 等多个接口。主要用于 Read 数据。&lt;/p&gt;

&lt;p&gt;我们需要在通过 bytes.NewReader 方法来初始化 bytes.Reader 类型的对象。初始化时传入 []byte 类型的数据。NewReader 函数签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewReader(b []byte) *Reader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果直接声明该对象了，可以通过 Reset 方法重新写入数据，示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x:=[]byte(&amp;quot;你好，世界&amp;quot;)

r1:=bytes.NewReader(x)
d1:=make([]byte,len(x))
n,_:=r1.Read(d1)
fmt.Println(n,string(d1))

r2:=bytes.Reader{}
r2.Reset(x)
d2:=make([]byte,len(x))
n,_=r2.Read(d2)
fmt.Println(n,string(d2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;15 你好，世界
15 你好，世界
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reader 包含了 8 个读取相关的方法，实现了前面提到的 io 包下的 9 个接口（ReadSeeker 接口内嵌 Reader 和 Seeker 两个接口）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 读取数据至 b
func (r *Reader) Read(b []byte) (n int, err error)
// 读取一个字节
func (r *Reader) ReadByte() (byte, error)
// 读取一个字符
func (r *Reader) ReadRune() (ch rune, size int, err error)
// 读取数据至 w
func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
// 进度下标指向前一个字节，如果 r.i &amp;lt;= 0 返回错误。
func (r *Reader) UnreadByte()
// 进度下标指向前一个字符，如果 r.i &amp;lt;= 0 返回错误，且只能在每次 ReadRune 方法后使用一次，否则返回错误。
func (r *Reader) UnreadRune()
// 读取 r.s[off:] 的数据至b，该方法忽略进度下标 i，不使用也不修改。
func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
// 根据 whence 的值，修改并返回进度下标 i ，当 whence == 0 ，进度下标修改为 off，当 whence == 1 ，进度下标修改为 i+off，当 whence == 2 ，进度下标修改为 len[s]+off.
// off 可以为负数，whence 的只能为 0，1，2，当 whence 为其他值或计算后的进度下标越界，则返回错误。
func (r *Reader) Seek(offset int64, whence int) (int64, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x := []byte(&amp;quot;你好，世界&amp;quot;)
r1 := bytes.NewReader(x)

ch, size, _ := r1.ReadRune()
fmt.Println(size, string(ch))
_ = r1.UnreadRune()
ch, size, _ = r1.ReadRune()
fmt.Println(size, string(ch))
_ = r1.UnreadRune()

by, _ := r1.ReadByte()
fmt.Println(by)
_ = r1.UnreadByte()
by, _ = r1.ReadByte()
fmt.Println(by)
_ = r1.UnreadByte()

d1 := make([]byte, 6)
n, _ := r1.Read(d1)
fmt.Println(n, string(d1))

d2 := make([]byte, 6)
n, _ = r1.ReadAt(d2, 0)
fmt.Println(n, string(d2))

w1 := &amp;amp;bytes.Buffer{}
_, _ = r1.Seek(0, 0)
_, _ = r1.WriteTo(w1)
fmt.Println(w1.String())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 你
3 你
228
228
6 你好
6 你好
你好，世界
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;buffer-类型&#34;&gt;Buffer 类型&lt;/h2&gt;

&lt;p&gt;buffer类型也实现了缓存io，也是对[]byte进行读写操作，提供了多种实现化函数对象，个人感觉是对string，byte的reader的综合使用实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Buffer struct {
    buf      []byte
    off      int
    lastRead readOp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上一个示例的最后，我们使用了 bytes.Buffer 类型，该类型实现了 io 包下的 ByteScanner, ByteWriter, ReadWriter, Reader, ReaderFrom, RuneReader, RuneScanner, StringWriter, Writer, WriterTo 等接口，可以方便的进行读写操作。&lt;/p&gt;

&lt;p&gt;对象可读取数据为 buf[off : len(buf)], off 表示进度下标，lastRead 表示最后读取的一个字符所占字节数，方便 Unread* 相关操作。&lt;/p&gt;

&lt;p&gt;Buffer 可以通过 3 中方法初始化对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := bytes.NewBufferString(&amp;quot;Hello World&amp;quot;)
b := bytes.NewBuffer([]byte(&amp;quot;Hello World&amp;quot;))
c := bytes.Buffer{}

fmt.Println(a)
fmt.Println(b)
fmt.Println(c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello World
Hello World
{[] 0 0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Buffer 包含了 21 个读写相关的方法，大部分同名方法的用法与前面讲的类似，这里只讲演示其中的 3 个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 读取到字节 delim 后，以字节数组的形式返回该字节及前面读取到的字节。如果遍历 b.buf 也找不到匹配的字节，则返回错误(一般是 EOF)
func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)
// 读取到字节 delim 后，以字符串的形式返回该字节及前面读取到的字节。如果遍历 b.buf 也找不到匹配的字节，则返回错误(一般是 EOF)
func (b *Buffer) ReadString(delim byte) (line string, err error)
// 截断 b.buf , 舍弃 b.off+n 之后的数据。n == 0 时，调用 Reset 方法重置该对象，当 n 越界时（n &amp;lt; 0 || n &amp;gt; b.Len() ）方法会触发 panic.
func (b *Buffer) Truncate(n int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := bytes.NewBufferString(&amp;quot;Good Night&amp;quot;)

x, err := a.ReadBytes(&#39;t&#39;)
if err != nil {
    fmt.Println(&amp;quot;delim:t err:&amp;quot;, err)
} else {
    fmt.Println(string(x))
}

a.Truncate(0)
a.WriteString(&amp;quot;Good Night&amp;quot;)
fmt.Println(a.Len())
a.Truncate(5)
fmt.Println(a.Len())
y, err := a.ReadString(&#39;N&#39;)
if err != nil {
    fmt.Println(&amp;quot;delim:N err:&amp;quot;, err)
} else {
    fmt.Println(y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Good Night
10
5
delim:N err: EOF
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
      
    
      
        <item>
          <title>UML</title>
          <link>https://kingjcy.github.io/post/architecture/map/uml/</link>
          <pubDate>Wed, 08 Nov 2017 11:40:49 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/architecture/map/uml/</guid>
          <description>&lt;p&gt;UML（Unified Modeling Language）是一种统一建模语言，为面向对象开发系统的产品进行说明、可视化、和编制文档的一种标准语言。下面将对UML的九种图的基本概念进行介绍以及各个图的使用场景。&lt;/p&gt;

&lt;h1 id=&#34;基本概念&#34;&gt;基本概念　　&lt;/h1&gt;

&lt;p&gt;如下图所示，UML图分为用例视图、设计视图、进程视图、实现视图和拓扑视图，又可以静动分为静态视图和动态视图。&lt;/p&gt;

&lt;p&gt;静态图分为：用例图，类图，对象图，包图，构件图，部署图。&lt;/p&gt;

&lt;p&gt;动态图分为：状态图，活动图，协作图，序列图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;用例图-usecase-diagrams&#34;&gt;用例图（UseCase Diagrams）&lt;/h2&gt;

&lt;p&gt;用例图主要回答了两个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、是谁用软件。
2、软件的功能。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从用户的角度描述了系统的功能，并指出各个功能的执行者，强调用户的使用者，系统为执行者完成哪些功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;类图-class-diagrams&#34;&gt;类图（Class Diagrams）&lt;/h2&gt;

&lt;p&gt;用户根据用例图抽象成类，描述类的内部结构和类与类之间的关系，是一种静态结构图。 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。&lt;/p&gt;

&lt;p&gt;各种关系的强弱顺序： 泛化 = 实现 &amp;gt; 组合 &amp;gt; 聚合 &amp;gt; 关联 &amp;gt; 依赖&lt;/p&gt;

&lt;p&gt;1.泛化&lt;/p&gt;

&lt;p&gt;泛化关系：是一种继承关系，表示一般与特殊的关系，它指定了子类如何继承父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.实现&lt;/p&gt;

&lt;p&gt;实现关系：是一种类与接口的关系，表示类是接口所有特征和行为的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;3.关联&lt;/p&gt;

&lt;p&gt;关联关系：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;4.共享聚合　&lt;/p&gt;

&lt;p&gt;聚合关系：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。&lt;/p&gt;

&lt;p&gt;聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml5.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;5.组合集合&lt;/p&gt;

&lt;p&gt;组合关系：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。&lt;/p&gt;

&lt;p&gt;组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml6.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;6.依赖　　&lt;/p&gt;

&lt;p&gt;依赖关系：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml7.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;7 各种类图关系&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml8.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;对象图-object-diagrams&#34;&gt;对象图（Object Diagrams）&lt;/h2&gt;

&lt;p&gt;描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml9.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;状态图-statechart-diagrams&#34;&gt;状态图（Statechart Diagrams）&lt;/h2&gt;

&lt;p&gt;一种由状态、变迁、事件和活动组成的状态机，用来描述类的对象所有可能的状态以及时间发生时状态的转移条件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml10.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;活动图-activity-diagrams&#34;&gt;活动图（Activity Diagrams）：&lt;/h2&gt;

&lt;p&gt;状态图的一种特殊情况，这些状态大都处于活动状态。本质是一种流程图，它描述了活动到活动的控制流。　　　　&lt;/p&gt;

&lt;p&gt;交互图强调的是对象到对象的控制流，而活动图则强调的是从活动到活动的控制流。&lt;/p&gt;

&lt;p&gt;活动图是一种表述过程基理、业务过程以及工作流的技术。它可以用来对业务过程、工作流建模，也可以对用例实现甚至是程序实现来建模。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml11.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;1.带泳道的活动图&lt;/p&gt;

&lt;p&gt;泳道表明每个活动是由哪些人或哪些部门负责完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml12.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.带对象流的活动图&lt;/p&gt;

&lt;p&gt;用活动图描述某个对象时，可以把涉及到的对象放置在活动图中，并用一个依赖将其连接到进行创建、修改和撤销的动作状态或者活动状态上，对象的这种使用方法就构成了对象流。对象流用带有箭头的虚线表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml13.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;序列图-时序图-sequence-diagrams&#34;&gt;序列图-时序图（Sequence Diagrams）&lt;/h2&gt;

&lt;p&gt;交互图的一种，描述了对象之间消息发送的先后顺序，强调时间顺序。&lt;/p&gt;

&lt;p&gt;序列图的主要用途是把用例表达的需求，转化为进一步、更加正式层次的精细表达。用例常常被细化为一个或者更多的序列图。同时序列图更有效地描述如何分配各个类的职责以及各类具有相应职责的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml14.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;消息用从一个对象的生命线到另一个对象生命线的箭头表示。箭头以时间顺序在图中从上到下排列。&lt;/p&gt;

&lt;p&gt;序列图中涉及的元素：&lt;/p&gt;

&lt;p&gt;1.角色&lt;/p&gt;

&lt;p&gt;系统角色，可以是人、及其甚至其他的系统或者子系统&lt;/p&gt;

&lt;p&gt;2.对象&lt;/p&gt;

&lt;p&gt;对象包括三种命名方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  第一种方式包括对象名和类名；

  第二中方式只显示类名不显示对象名，即表示他是一个匿名对象；

  第三种方式只显示对象名不显示类。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.生命线&lt;/p&gt;

&lt;p&gt;生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。&lt;/p&gt;

&lt;p&gt;生命线名称可带下划线。当使用下划线时，意味着序列图中的生命线代表一个类的特定实例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml15.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;4.控制焦点&lt;/p&gt;

&lt;p&gt;控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示&lt;/p&gt;

&lt;p&gt;5.同步消息&lt;/p&gt;

&lt;p&gt;同步等待消息&lt;/p&gt;

&lt;p&gt;消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml16.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;6.异步消息&lt;/p&gt;

&lt;p&gt;异步发送消息，不需等待&lt;/p&gt;

&lt;p&gt;消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml17.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;7.注释&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml18.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;8.约束&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml19.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;9.组合　　&lt;/p&gt;

&lt;p&gt;组合片段用来解决交互执行的条件及方式。它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。常用的组合片段有：抉择、选项、循环、并行。&lt;/p&gt;

&lt;h2 id=&#34;协作图-collaboration-diagrams&#34;&gt;协作图（Collaboration Diagrams）&lt;/h2&gt;

&lt;p&gt;交互图的一种，描述了收发消息的对象的组织关系，强调对象之间的合作关系。时序图按照时间顺序布图，而写作图按照空间结构布图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml20.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;构件图-component-diagrams&#34;&gt;构件图（Component Diagrams）：&lt;/h2&gt;

&lt;p&gt;构件图是用来表示系统中构件与构件之间，类或接口与构件之间的关系图。其中，构建图之间的关系表现为依赖关系，定义的类或接口与类之间的关系表现为依赖关系或实现关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml21.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;部署图-deployment-diagrams&#34;&gt;部署图（Deployment Diagrams）：&lt;/h2&gt;

&lt;p&gt;描述了系统运行时进行处理的结点以及在结点上活动的构件的配置。强调了物理设备以及之间的连接关系。&lt;/p&gt;

&lt;p&gt;部署模型的目的：&lt;/p&gt;

&lt;p&gt;描述一个具体应用的主要部署结构，通过对各种硬件，在硬件中的软件以及各种连接协议的显示，可以很好的描述系统是如何部署的；平衡系统运行时的计算资源分布；可以通过连接描述组织的硬件网络结构或者是嵌入式系统等具有多种硬件和软件相关的系统运行模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/architecture/map/uml/uml22.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
        </item>
      
    
      
        <item>
          <title>Golang使用系列---- Net/Http 应用层</title>
          <link>https://kingjcy.github.io/post/golang/go-net-http/</link>
          <pubDate>Tue, 26 Sep 2017 17:05:22 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/golang/go-net-http/</guid>
          <description>&lt;p&gt;http包提供了HTTP协议的客户端和服务端的实现。&lt;/p&gt;

&lt;h1 id=&#34;http客户端&#34;&gt;HTTP客户端&lt;/h1&gt;

&lt;h2 id=&#34;直接使用http方法&#34;&gt;直接使用http方法&lt;/h2&gt;

&lt;p&gt;直接使用http方法，其实就是使用标准库默认的结构体client，transport等来实现请求。&lt;/p&gt;

&lt;p&gt;http包中封装了Get、Head、Post和PostForm函数可以直接发出HTTP/ HTTPS请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;)
...
resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf)
...
resp, err := http.PostForm(&amp;quot;http://example.com/form&amp;quot;,
    url.Values{&amp;quot;key&amp;quot;: {&amp;quot;Value&amp;quot;}, &amp;quot;id&amp;quot;: {&amp;quot;123&amp;quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序在使用完回复后必须关闭回复的主体。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;)
if err != nil {
    // handle error
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;原理解析&#34;&gt;原理解析&lt;/h3&gt;

&lt;p&gt;http直接提供的Post等方法实现在client.go文件中，以Post为例，其他都是一样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Post(url, contentType string, body io.Reader) (resp *Response, err error) {
    return DefaultClient.Post(url, contentType, body)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际是调用了默认结构体client的Post方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var DefaultClient = &amp;amp;Client{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来看Post方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error) {
    req, err := NewRequest(&amp;quot;POST&amp;quot;, url, body)
    if err != nil {
        return nil, err
    }
    req.Header.Set(&amp;quot;Content-Type&amp;quot;, contentType)
    return c.Do(req)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据url和请求体body新建一个reqest，然后调用DefaultClient的Do方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Client) Do(req *Request) (*Response, error) {
    return c.do(req)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用内部的do方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Client) do(req *Request) (retres *Response, reterr error) {
    if testHookClientDoResult != nil {
        defer func() { testHookClientDoResult(retres, reterr) }()
    }
    if req.URL == nil {
        req.closeBody()
        return nil, &amp;amp;url.Error{
            Op:  urlErrorOp(req.Method),
            Err: errors.New(&amp;quot;http: nil Request.URL&amp;quot;),
        }
    }

    var (
        deadline      = c.deadline()
        reqs          []*Request
        resp          *Response
        copyHeaders   = c.makeHeadersCopier(req)
        reqBodyClosed = false // have we closed the current req.Body?

        // Redirect behavior:
        redirectMethod string
        includeBody    bool
    )
    uerr := func(err error) error {
        // the body may have been closed already by c.send()
        if !reqBodyClosed {
            req.closeBody()
        }
        var urlStr string
        if resp != nil &amp;amp;&amp;amp; resp.Request != nil {
            urlStr = stripPassword(resp.Request.URL)
        } else {
            urlStr = stripPassword(req.URL)
        }
        return &amp;amp;url.Error{
            Op:  urlErrorOp(reqs[0].Method),
            URL: urlStr,
            Err: err,
        }
    }
    for {
        // For all but the first request, create the next
        // request hop and replace req.
        if len(reqs) &amp;gt; 0 {
            loc := resp.Header.Get(&amp;quot;Location&amp;quot;)
            if loc == &amp;quot;&amp;quot; {
                resp.closeBody()
                return nil, uerr(fmt.Errorf(&amp;quot;%d response missing Location header&amp;quot;, resp.StatusCode))
            }
            u, err := req.URL.Parse(loc)
            if err != nil {
                resp.closeBody()
                return nil, uerr(fmt.Errorf(&amp;quot;failed to parse Location header %q: %v&amp;quot;, loc, err))
            }
            host := &amp;quot;&amp;quot;
            if req.Host != &amp;quot;&amp;quot; &amp;amp;&amp;amp; req.Host != req.URL.Host {
                // If the caller specified a custom Host header and the
                // redirect location is relative, preserve the Host header
                // through the redirect. See issue #22233.
                if u, _ := url.Parse(loc); u != nil &amp;amp;&amp;amp; !u.IsAbs() {
                    host = req.Host
                }
            }
            ireq := reqs[0]
            req = &amp;amp;Request{
                Method:   redirectMethod,
                Response: resp,
                URL:      u,
                Header:   make(Header),
                Host:     host,
                Cancel:   ireq.Cancel,
                ctx:      ireq.ctx,
            }
            if includeBody &amp;amp;&amp;amp; ireq.GetBody != nil {
                req.Body, err = ireq.GetBody()
                if err != nil {
                    resp.closeBody()
                    return nil, uerr(err)
                }
                req.ContentLength = ireq.ContentLength
            }

            // Copy original headers before setting the Referer,
            // in case the user set Referer on their first request.
            // If they really want to override, they can do it in
            // their CheckRedirect func.
            copyHeaders(req)

            // Add the Referer header from the most recent
            // request URL to the new one, if it&#39;s not https-&amp;gt;http:
            if ref := refererForURL(reqs[len(reqs)-1].URL, req.URL); ref != &amp;quot;&amp;quot; {
                req.Header.Set(&amp;quot;Referer&amp;quot;, ref)
            }
            err = c.checkRedirect(req, reqs)

            // Sentinel error to let users select the
            // previous response, without closing its
            // body. See Issue 10069.
            if err == ErrUseLastResponse {
                return resp, nil
            }

            // Close the previous response&#39;s body. But
            // read at least some of the body so if it&#39;s
            // small the underlying TCP connection will be
            // re-used. No need to check for errors: if it
            // fails, the Transport won&#39;t reuse it anyway.
            const maxBodySlurpSize = 2 &amp;lt;&amp;lt; 10
            if resp.ContentLength == -1 || resp.ContentLength &amp;lt;= maxBodySlurpSize {
                io.CopyN(ioutil.Discard, resp.Body, maxBodySlurpSize)
            }
            resp.Body.Close()

            if err != nil {
                // Special case for Go 1 compatibility: return both the response
                // and an error if the CheckRedirect function failed.
                // See https://golang.org/issue/3795
                // The resp.Body has already been closed.
                ue := uerr(err)
                ue.(*url.Error).URL = loc
                return resp, ue
            }
        }

        reqs = append(reqs, req)
        var err error
        var didTimeout func() bool
        //调用 send
        if resp, didTimeout, err = c.send(req, deadline); err != nil {
            // c.send() always closes req.Body
            reqBodyClosed = true
            if !deadline.IsZero() &amp;amp;&amp;amp; didTimeout() {
                err = &amp;amp;httpError{
                    // TODO: early in cycle: s/Client.Timeout exceeded/timeout or context cancelation/
                    err:     err.Error() + &amp;quot; (Client.Timeout exceeded while awaiting headers)&amp;quot;,
                    timeout: true,
                }
            }
            return nil, uerr(err)
        }

        var shouldRedirect bool
        redirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[0])
        if !shouldRedirect {
            return resp, nil
        }

        req.closeBody()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用send方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Client) send(req *Request, deadline time.Time) (resp *Response, didTimeout func() bool, err error) {
    if c.Jar != nil {
        for _, cookie := range c.Jar.Cookies(req.URL) {
            req.AddCookie(cookie)
        }
    }
    resp, didTimeout, err = send(req, c.transport(), deadline)
    if err != nil {
        return nil, didTimeout, err
    }
    if c.Jar != nil {
        if rc := resp.Cookies(); len(rc) &amp;gt; 0 {
            c.Jar.SetCookies(req.URL, rc)
        }
    }
    return resp, nil, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边需要确定实现transport的结构体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Client) transport() RoundTripper {
    if c.Transport != nil {
        return c.Transport
    }
    return DefaultTransport
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用默认的DefaultTransport（如果transport自定义了，就使用自定义的，否则使用默认的），这边这个接口调用就是DefaultTransport，也就是Transport.go中的Transport结构体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var DefaultTransport RoundTripper = &amp;amp;Transport{
    Proxy: ProxyFromEnvironment,
    DialContext: (&amp;amp;net.Dialer{
        Timeout:   30 * time.Second,
        KeepAlive: 30 * time.Second,
        DualStack: true,
    }).DialContext,
    MaxIdleConns:          100,
    IdleConnTimeout:       90 * time.Second,
    TLSHandshakeTimeout:   10 * time.Second,
    ExpectContinueTimeout: 1 * time.Second,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再看Transport结构体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Transport struct {
    idleMu     sync.Mutex
    wantIdle   bool                                // user has requested to close all idle conns
    idleConn   map[connectMethodKey][]*persistConn // most recently used at end
    idleConnCh map[connectMethodKey]chan *persistConn
    idleLRU    connLRU

    reqMu       sync.Mutex
    reqCanceler map[*Request]func(error)

    altMu    sync.Mutex   // guards changing altProto only
    altProto atomic.Value // of nil or map[string]RoundTripper, key is URI scheme

    connCountMu          sync.Mutex
    connPerHostCount     map[connectMethodKey]int
    connPerHostAvailable map[connectMethodKey]chan struct{}

    // Proxy specifies a function to return a proxy for a given
    // Request. If the function returns a non-nil error, the
    // request is aborted with the provided error.
    //
    // The proxy type is determined by the URL scheme. &amp;quot;http&amp;quot;,
    // &amp;quot;https&amp;quot;, and &amp;quot;socks5&amp;quot; are supported. If the scheme is empty,
    // &amp;quot;http&amp;quot; is assumed.
    //
    // If Proxy is nil or returns a nil *URL, no proxy is used.
    Proxy func(*Request) (*url.URL, error)

    // DialContext specifies the dial function for creating unencrypted TCP connections.
    // If DialContext is nil (and the deprecated Dial below is also nil),
    // then the transport dials using package net.
    //
    // DialContext runs concurrently with calls to RoundTrip.
    // A RoundTrip call that initiates a dial may end up using
    // a connection dialed previously when the earlier connection
    // becomes idle before the later DialContext completes.
    DialContext func(ctx context.Context, network, addr string) (net.Conn, error)

    // Dial specifies the dial function for creating unencrypted TCP connections.
    //
    // Dial runs concurrently with calls to RoundTrip.
    // A RoundTrip call that initiates a dial may end up using
    // a connection dialed previously when the earlier connection
    // becomes idle before the later Dial completes.
    //
    // Deprecated: Use DialContext instead, which allows the transport
    // to cancel dials as soon as they are no longer needed.
    // If both are set, DialContext takes priority.
    Dial func(network, addr string) (net.Conn, error)

    // DialTLS specifies an optional dial function for creating
    // TLS connections for non-proxied HTTPS requests.
    //
    // If DialTLS is nil, Dial and TLSClientConfig are used.
    //
    // If DialTLS is set, the Dial hook is not used for HTTPS
    // requests and the TLSClientConfig and TLSHandshakeTimeout
    // are ignored. The returned net.Conn is assumed to already be
    // past the TLS handshake.
    DialTLS func(network, addr string) (net.Conn, error)

    // TLSClientConfig specifies the TLS configuration to use with
    // tls.Client.
    // If nil, the default configuration is used.
    // If non-nil, HTTP/2 support may not be enabled by default.
    TLSClientConfig *tls.Config

    // TLSHandshakeTimeout specifies the maximum amount of time waiting to
    // wait for a TLS handshake. Zero means no timeout.
    TLSHandshakeTimeout time.Duration

    // DisableKeepAlives, if true, disables HTTP keep-alives and
    // will only use the connection to the server for a single
    // HTTP request.
    //
    // This is unrelated to the similarly named TCP keep-alives.
    DisableKeepAlives bool

    // DisableCompression, if true, prevents the Transport from
    // requesting compression with an &amp;quot;Accept-Encoding: gzip&amp;quot;
    // request header when the Request contains no existing
    // Accept-Encoding value. If the Transport requests gzip on
    // its own and gets a gzipped response, it&#39;s transparently
    // decoded in the Response.Body. However, if the user
    // explicitly requested gzip it is not automatically
    // uncompressed.
    DisableCompression bool

    // MaxIdleConns controls the maximum number of idle (keep-alive)
    // connections across all hosts. Zero means no limit.
    MaxIdleConns int

    // MaxIdleConnsPerHost, if non-zero, controls the maximum idle
    // (keep-alive) connections to keep per-host. If zero,
    // DefaultMaxIdleConnsPerHost is used.
    MaxIdleConnsPerHost int

    // MaxConnsPerHost optionally limits the total number of
    // connections per host, including connections in the dialing,
    // active, and idle states. On limit violation, dials will block.
    //
    // Zero means no limit.
    //
    // For HTTP/2, this currently only controls the number of new
    // connections being created at a time, instead of the total
    // number. In practice, hosts using HTTP/2 only have about one
    // idle connection, though.
    MaxConnsPerHost int

    // IdleConnTimeout is the maximum amount of time an idle
    // (keep-alive) connection will remain idle before closing
    // itself.
    // Zero means no limit.
    IdleConnTimeout time.Duration

    // ResponseHeaderTimeout, if non-zero, specifies the amount of
    // time to wait for a server&#39;s response headers after fully
    // writing the request (including its body, if any). This
    // time does not include the time to read the response body.
    ResponseHeaderTimeout time.Duration

    // ExpectContinueTimeout, if non-zero, specifies the amount of
    // time to wait for a server&#39;s first response headers after fully
    // writing the request headers if the request has an
    // &amp;quot;Expect: 100-continue&amp;quot; header. Zero means no timeout and
    // causes the body to be sent immediately, without
    // waiting for the server to approve.
    // This time does not include the time to send the request header.
    ExpectContinueTimeout time.Duration

    // TLSNextProto specifies how the Transport switches to an
    // alternate protocol (such as HTTP/2) after a TLS NPN/ALPN
    // protocol negotiation. If Transport dials an TLS connection
    // with a non-empty protocol name and TLSNextProto contains a
    // map entry for that key (such as &amp;quot;h2&amp;quot;), then the func is
    // called with the request&#39;s authority (such as &amp;quot;example.com&amp;quot;
    // or &amp;quot;example.com:1234&amp;quot;) and the TLS connection. The function
    // must return a RoundTripper that then handles the request.
    // If TLSNextProto is not nil, HTTP/2 support is not enabled
    // automatically.
    TLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper

    // ProxyConnectHeader optionally specifies headers to send to
    // proxies during CONNECT requests.
    ProxyConnectHeader Header

    // MaxResponseHeaderBytes specifies a limit on how many
    // response bytes are allowed in the server&#39;s response
    // header.
    //
    // Zero means to use a default limit.
    MaxResponseHeaderBytes int64

    // nextProtoOnce guards initialization of TLSNextProto and
    // h2transport (via onceSetNextProtoDefaults)
    nextProtoOnce sync.Once
    h2transport   h2Transport // non-nil if http2 wired up
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中文讲解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Transport struct {
    // Proxy指定一个对给定请求返回代理的函数。
    // 如果该函数返回了非nil的错误值，请求的执行就会中断并返回该错误。
    // 如果Proxy为nil或返回nil的*URL置，将不使用代理。
    Proxy func(*Request) (*url.URL, error)

    // Dial指定创建TCP连接的拨号函数。如果Dial为nil，会使用net.Dial。
    //Dial获取一个tcp 连接，也就是net.Conn结构，你就记住可以往里面写request
    //然后从里面搞到response就行了
    Dial func(network, addr string) (net.Conn, error)

    // TLSClientConfig指定用于tls.Client的TLS配置信息。
    // 如果该字段为nil，会使用默认的配置信息。
    TLSClientConfig *tls.Config

    // TLSHandshakeTimeout指定等待TLS握手完成的最长时间。零值表示不设置超时。
    TLSHandshakeTimeout time.Duration

    // 如果DisableKeepAlives为真，会禁止不同HTTP请求之间TCP连接的重用。
    DisableKeepAlives bool

    // 如果DisableCompression为真，会禁止Transport在请求中没有Accept-Encoding头时，
    // 主动添加&amp;quot;Accept-Encoding: gzip&amp;quot;头，以获取压缩数据。
    // 如果Transport自己请求gzip并得到了压缩后的回复，它会主动解压缩回复的主体。
    // 但如果用户显式的请求gzip压缩数据，Transport是不会主动解压缩的。
    DisableCompression bool

    // 如果MaxIdleConnsPerHost!=0，会控制每个主机下的最大闲置连接。
    // 如果MaxIdleConnsPerHost==0，会使用DefaultMaxIdleConnsPerHost。
    MaxIdleConnsPerHost int

    // ResponseHeaderTimeout指定在发送完请求（包括其可能的主体）之后，
    // 等待接收服务端的回复的头域的最大时间。零值表示不设置超时。
    // 该时间不包括获取回复主体的时间。
    ResponseHeaderTimeout time.Duration

    // 内含隐藏或非导出字段



    //保存从 connectMethodKey （代表着不同的协议 不同的host，也就是不同的请求）到 persistConn 的映射
    idleConn   map[connectMethodKey][]*persistConn // most recently used at end
    //用来在并发http请求的时候在多个 goroutine 里面相互发送持久连接，也就是说， 这些持久连接是可以重复利用的， 你的http请求用某个persistConn用完了，通过这个channel发送给其他http请求使用这个persistConn，然后我们找到transport的RoundTrip方法
    idleConnCh map[connectMethodKey]chan *persistConn
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用内部send方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error) {
    req := ireq // req is either the original request, or a modified fork

    if rt == nil {
        req.closeBody()
        return nil, alwaysFalse, errors.New(&amp;quot;http: no Client.Transport or DefaultTransport&amp;quot;)
    }

    if req.URL == nil {
        req.closeBody()
        return nil, alwaysFalse, errors.New(&amp;quot;http: nil Request.URL&amp;quot;)
    }

    if req.RequestURI != &amp;quot;&amp;quot; {
        req.closeBody()
        return nil, alwaysFalse, errors.New(&amp;quot;http: Request.RequestURI can&#39;t be set in client requests.&amp;quot;)
    }

    // forkReq forks req into a shallow clone of ireq the first
    // time it&#39;s called.
    forkReq := func() {
        if ireq == req {
            req = new(Request)
            *req = *ireq // shallow clone
        }
    }

    // Most the callers of send (Get, Post, et al) don&#39;t need
    // Headers, leaving it uninitialized. We guarantee to the
    // Transport that this has been initialized, though.
    if req.Header == nil {
        forkReq()
        req.Header = make(Header)
    }

    if u := req.URL.User; u != nil &amp;amp;&amp;amp; req.Header.Get(&amp;quot;Authorization&amp;quot;) == &amp;quot;&amp;quot; {
        username := u.Username()
        password, _ := u.Password()
        forkReq()
        req.Header = ireq.Header.clone()
        req.Header.Set(&amp;quot;Authorization&amp;quot;, &amp;quot;Basic &amp;quot;+basicAuth(username, password))
    }

    if !deadline.IsZero() {
        forkReq()
    }
    stopTimer, didTimeout := setRequestCancel(req, rt, deadline)

    resp, err = rt.RoundTrip(req)
    if err != nil {
        stopTimer()
        if resp != nil {
            log.Printf(&amp;quot;RoundTripper returned a response &amp;amp; error; ignoring response&amp;quot;)
        }
        if tlsErr, ok := err.(tls.RecordHeaderError); ok {
            // If we get a bad TLS record header, check to see if the
            // response looks like HTTP and give a more helpful error.
            // See golang.org/issue/11111.
            if string(tlsErr.RecordHeader[:]) == &amp;quot;HTTP/&amp;quot; {
                err = errors.New(&amp;quot;http: server gave HTTP response to HTTPS client&amp;quot;)
            }
        }
        return nil, didTimeout, err
    }
    if !deadline.IsZero() {
        resp.Body = &amp;amp;cancelTimerBody{
            stop:          stopTimer,
            rc:            resp.Body,
            reqDidTimeout: didTimeout,
        }
    }
    return resp, nil, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用DefaultTransport也就是Transport.go中的Transport结构体的RoundTrip方法（当出现自定义的时候，就调用对应的Transport的RoundTrip方法，这边直接使用这个借口就是DefaultTransport），可见使用golang net/http库发送http请求，最后都是调用 http transport的 RoundTrip方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// roundTrip implements a RoundTripper over HTTP.
func (t *Transport) roundTrip(req *Request) (*Response, error) {
    t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)
    ctx := req.Context()
    trace := httptrace.ContextClientTrace(ctx)

    if req.URL == nil {
        req.closeBody()
        return nil, errors.New(&amp;quot;http: nil Request.URL&amp;quot;)
    }
    if req.Header == nil {
        req.closeBody()
        return nil, errors.New(&amp;quot;http: nil Request.Header&amp;quot;)
    }
    scheme := req.URL.Scheme
    isHTTP := scheme == &amp;quot;http&amp;quot; || scheme == &amp;quot;https&amp;quot;
    if isHTTP {
        for k, vv := range req.Header {
            if !httpguts.ValidHeaderFieldName(k) {
                return nil, fmt.Errorf(&amp;quot;net/http: invalid header field name %q&amp;quot;, k)
            }
            for _, v := range vv {
                if !httpguts.ValidHeaderFieldValue(v) {
                    return nil, fmt.Errorf(&amp;quot;net/http: invalid header field value %q for key %v&amp;quot;, v, k)
                }
            }
        }
    }

    if t.useRegisteredProtocol(req) {
        altProto, _ := t.altProto.Load().(map[string]RoundTripper)
        if altRT := altProto[scheme]; altRT != nil {
            if resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol {
                return resp, err
            }
        }
    }
    if !isHTTP {
        req.closeBody()
        return nil, &amp;amp;badStringError{&amp;quot;unsupported protocol scheme&amp;quot;, scheme}
    }
    if req.Method != &amp;quot;&amp;quot; &amp;amp;&amp;amp; !validMethod(req.Method) {
        return nil, fmt.Errorf(&amp;quot;net/http: invalid method %q&amp;quot;, req.Method)
    }
    if req.URL.Host == &amp;quot;&amp;quot; {
        req.closeBody()
        return nil, errors.New(&amp;quot;http: no Host in request URL&amp;quot;)
    }

    for {
        select {
        case &amp;lt;-ctx.Done():
            req.closeBody()
            return nil, ctx.Err()
        default:
        }

        // treq gets modified by roundTrip, so we need to recreate for each retry.
        treq := &amp;amp;transportRequest{Request: req, trace: trace}
        cm, err := t.connectMethodForRequest(treq)
        if err != nil {
            req.closeBody()
            return nil, err
        }

        // Get the cached or newly-created connection to either the
        // host (for http or https), the http proxy, or the http proxy
        // pre-CONNECTed to https server. In any case, we&#39;ll be ready
        // to send it requests.
        pconn, err := t.getConn(treq, cm)
        if err != nil {
            t.setReqCanceler(req, nil)
            req.closeBody()
            return nil, err
        }

        var resp *Response
        if pconn.alt != nil {
            // HTTP/2 path.
            t.decHostConnCount(cm.key()) // don&#39;t count cached http2 conns toward conns per host
            t.setReqCanceler(req, nil)   // not cancelable with CancelRequest
            resp, err = pconn.alt.RoundTrip(req)
        } else {
            resp, err = pconn.roundTrip(treq)
        }
        if err == nil {
            return resp, nil
        }
        if !pconn.shouldRetryRequest(req, err) {
            // Issue 16465: return underlying net.Conn.Read error from peek,
            // as we&#39;ve historically done.
            if e, ok := err.(transportReadFromServerError); ok {
                err = e.err
            }
            return nil, err
        }
        testHookRoundTripRetried()

        // Rewind the body if we&#39;re able to.
        if req.GetBody != nil {
            newReq := *req
            var err error
            newReq.Body, err = req.GetBody()
            if err != nil {
                return nil, err
            }
            req = &amp;amp;newReq
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面对输入的错误处理部分我们忽略， 其实就2步，先获取一个TCP长连接，所谓TCP长连接就是三次握手建立连接后不close而是一直保持重复使用（节约环保） 然后调用这个持久连接persistConn 这个struct的roundTrip方法。我们先看获取连接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (t *Transport) getConn(req *Request, cm connectMethod) (*persistConn, error) {
    if pc := t.getIdleConn(cm); pc != nil {
        // set request canceler to some non-nil function so we
        // can detect whether it was cleared between now and when
        // we enter roundTrip
        t.setReqCanceler(req, func() {})
        return pc, nil
    }

    type dialRes struct {
        pc  *persistConn
        err error
    }
    dialc := make(chan dialRes)
    //定义了一个发送 persistConn的channel

    prePendingDial := prePendingDial
    postPendingDial := postPendingDial

    handlePendingDial := func() {
        if prePendingDial != nil {
            prePendingDial()
        }
        go func() {
            if v := &amp;lt;-dialc; v.err == nil {
                t.putIdleConn(v.pc)
            }
            if postPendingDial != nil {
                postPendingDial()
            }
        }()
    }

    cancelc := make(chan struct{})
    t.setReqCanceler(req, func() { close(cancelc) })

    // 启动了一个goroutine, 这个goroutine 获取里面调用dialConn搞到
    // persistConn, 然后发送到上面建立的channel  dialc里面，
    go func() {
        pc, err := t.dialConn(cm)
        dialc &amp;lt;- dialRes{pc, err}
    }()

    idleConnCh := t.getIdleConnCh(cm)
    select {
    case v := &amp;lt;-dialc:
        // dialc 我们的 dial 方法先搞到通过 dialc通道发过来了
        return v.pc, v.err
    case pc := &amp;lt;-idleConnCh:
        // 这里代表其他的http请求用完了归还的persistConn通过idleConnCh这个
        // channel发送来的
        handlePendingDial()
        return pc, nil
    case &amp;lt;-req.Cancel:
        handlePendingDial()
        return nil, errors.New(&amp;quot;net/http: request canceled while waiting for connection&amp;quot;)
    case &amp;lt;-cancelc:
        handlePendingDial()
        return nil, errors.New(&amp;quot;net/http: request canceled while waiting for connection&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面的代码写的很有讲究 , 上面代码里面我也注释了， 定义了一个发送 persistConn的channel dialc， 启动了一个goroutine, 这个goroutine 获取里面调用dialConn搞到persistConn, 然后发送到dialc里面，主协程goroutine在 select里面监听多个channel,看看哪个通道里面先发过来 persistConn，就用哪个，然后return。&lt;/p&gt;

&lt;p&gt;这里要注意的是 idleConnCh 这个通道里面发送来的是其他的http请求用完了归还的persistConn， 如果从这个通道里面搞到了，dialc这个通道也等着发呢，不能浪费，就通过handlePendingDial这个方法把dialc通道里面的persistConn也发到idleConnCh，等待后续给其他http请求使用。&lt;/p&gt;

&lt;p&gt;每个新建的persistConn的时候都把tcp连接里地输入流，和输出流用br（br *bufio.Reader）,和bw(bw *bufio.Writer)包装了一下，往bw写就写到tcp输入流里面了，读输出流也是通过br读，并启动了读循环和写循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pconn.br = bufio.NewReader(noteEOFReader{pconn.conn, &amp;amp;pconn.sawEOF})
pconn.bw = bufio.NewWriter(pconn.conn)
go pconn.readLoop()
go pconn.writeLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再看pconn.roundTrip 调用这个持久连接persistConn 这个struct的roundTrip方法。先瞄一下 persistConn 这个struct&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type persistConn struct {
    t        *Transport
    cacheKey connectMethodKey
    conn     net.Conn
    tlsState *tls.ConnectionState
    br       *bufio.Reader       // 从tcp输出流里面读
    sawEOF   bool                // whether we&#39;ve seen EOF from conn; owned by readLoop
    bw       *bufio.Writer       // 写到tcp输入流
     reqch    chan requestAndChan // 主goroutine 往channnel里面写，读循环从     
                                 // channnel里面接受
    writech  chan writeRequest   // 主goroutine 往channnel里面写                                      
                                 // 写循环从channel里面接受
    closech  chan struct{}       // 通知关闭tcp连接的channel 

    writeErrCh chan error

    lk                   sync.Mutex // guards following fields
    numExpectedResponses int
    closed               bool // whether conn has been closed
    broken               bool // an error has happened on this connection; marked broken so it&#39;s not reused.
    canceled             bool // whether this conn was broken due a CancelRequest
    // mutateHeaderFunc is an optional func to modify extra
    // headers on each outbound request before it&#39;s written. (the
    // original Request given to RoundTrip is not modified)
    mutateHeaderFunc func(Header)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;里面是各种channel, 用的是出神入化， 各位要好好理解一下，这里有三个goroutine，有两个channel writeRequest 和 requestAndChan&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type writeRequest struct {
    req *transportRequest
    ch  chan&amp;lt;- error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主goroutine 往writeRequest里面写，写循环从writeRequest里面接受&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type responseAndError struct {
    res *Response
    err error
}

type requestAndChan struct {
    req *Request
    ch  chan responseAndError
    addedGzip bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主goroutine 往requestAndChan里面写，读循环从requestAndChan里面接受。&lt;/p&gt;

&lt;p&gt;注意这里的channel都是双向channel，也就是channel 的struct里面有一个chan类型的字段， 比如 reqch chan requestAndChan 这里的 requestAndChan 里面的 ch chan responseAndError。&lt;/p&gt;

&lt;p&gt;这个是很牛叉，主 goroutine 通过 reqch 发送requestAndChan 给读循环，然后读循环搞到response后通过 requestAndChan 里面的通道responseAndError把response返给主goroutine，所以我画了一个双向箭头。&lt;/p&gt;

&lt;p&gt;我们研究一下代码，我理解下来其实就是三个goroutine通过channel互相协作的过程。&lt;/p&gt;

&lt;p&gt;主循环：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) {
    ... 忽略
    // Write the request concurrently with waiting for a response,
    // in case the server decides to reply before reading our full
    // request body.
    writeErrCh := make(chan error, 1)
    pc.writech &amp;lt;- writeRequest{req, writeErrCh}
    //把request发送给写循环
    resc := make(chan responseAndError, 1)
    pc.reqch &amp;lt;- requestAndChan{req.Request, resc, requestedGzip}
    //发送给读循环
    var re responseAndError
    var respHeaderTimer &amp;lt;-chan time.Time
    cancelChan := req.Request.Cancel
WaitResponse:
    for {
        select {
        case err := &amp;lt;-writeErrCh:
            if isNetWriteError(err) {
                //写循环通过这个channel报告错误
                select {
                case re = &amp;lt;-resc:
                    pc.close()
                    break WaitResponse
                case &amp;lt;-time.After(50 * time.Millisecond):
                    // Fall through.
                }
            }
            if err != nil {
                re = responseAndError{nil, err}
                pc.close()
                break WaitResponse
            }
            if d := pc.t.ResponseHeaderTimeout; d &amp;gt; 0 {
                timer := time.NewTimer(d)
                defer timer.Stop() // prevent leaks
                respHeaderTimer = timer.C
            }
        case &amp;lt;-pc.closech:
            // 如果长连接挂了， 这里的channel有数据， 进入这个case, 进行处理

            select {
            case re = &amp;lt;-resc:
                if fn := testHookPersistConnClosedGotRes; fn != nil {
                    fn()
                }
            default:
                re = responseAndError{err: errClosed}
                if pc.isCanceled() {
                    re = responseAndError{err: errRequestCanceled}
                }
            }
            break WaitResponse
        case &amp;lt;-respHeaderTimer:
            pc.close()
            re = responseAndError{err: errTimeout}
            break WaitResponse
            // 如果timeout，这里的channel有数据， break掉for循环
        case re = &amp;lt;-resc:
            break WaitResponse
           // 获取到读循环的response, break掉 for循环
        case &amp;lt;-cancelChan:
            pc.t.CancelRequest(req.Request)
            cancelChan = nil
        }
    }

    if re.err != nil {
        pc.t.setReqCanceler(req.Request, nil)
    }
    return re.res, re.err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码主要就干了三件事&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;主goroutine -&amp;gt;requestAndChan -&amp;gt; 读循环goroutine

主goroutine -&amp;gt;writeRequest-&amp;gt; 写循环goroutine

主goroutine 通过select 监听各个channel上的数据， 比如请求取消， timeout，长连接挂了，写流出错，读流出错， 都是其他goroutine 发送过来的， 跟中断一样，然后相应处理，上面也提到了，有些channel是主goroutine通过channel发送给其他goroutine的struct里面包含的channel, 比如 case err := &amp;lt;-writeErrCh: case re = &amp;lt;-resc:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读循环代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (pc *persistConn) readLoop() {

    ... 忽略
    alive := true
    for alive {

        ... 忽略
        rc := &amp;lt;-pc.reqch

        var resp *Response
        if err == nil {
            resp, err = ReadResponse(pc.br, rc.req)
            if err == nil &amp;amp;&amp;amp; resp.StatusCode == 100 {
                //100  Continue  初始的请求已经接受，客户应当继续发送请求的其 
                // 余部分
                resp, err = ReadResponse(pc.br, rc.req)
                // 读pc.br（tcp输出流）中的数据，这里的代码在response里面
                //解析statusCode，头字段， 转成标准的内存中的response 类型
                //  http在tcp数据流里面，head和body以 /r/n/r/n分开， 各个头
                // 字段 以/r/n分开
            }
        }

        if resp != nil {
            resp.TLS = pc.tlsState
        }

        ...忽略
        //上面处理一些http协议的一些逻辑行为，
        rc.ch &amp;lt;- responseAndError{resp, err} //把读到的response返回给    
                                             //主goroutine

        .. 忽略
        //忽略部分， 处理cancel req中断， 发送idleConnCh归还pc（持久连接）到持久连接池中（map）    
    pc.close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无关代码忽略，这段代码主要干了一件事情&lt;/p&gt;

&lt;p&gt;读循环goroutine 通过channel requestAndChan 接受主goroutine发送的request(rc := &amp;lt;-pc.reqch), 并从tcp输出流中读取response， 然后反序列化到结构体中， 最后通过channel 返给主goroutine (rc.ch &amp;lt;- responseAndError{resp, err} )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (pc *persistConn) writeLoop() {
    for {
        select {
        case wr := &amp;lt;-pc.writech:   //接受主goroutine的 request
            if pc.isBroken() {
                wr.ch &amp;lt;- errors.New(&amp;quot;http: can&#39;t write HTTP request on broken connection&amp;quot;)
                continue
            }
            err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra)   //写入tcp输入流
            if err == nil {
                err = pc.bw.Flush()
            }
            if err != nil {
                pc.markBroken()
                wr.req.Request.closeBody()
            }
            pc.writeErrCh &amp;lt;- err 
            wr.ch &amp;lt;- err         //  出错的时候返给主goroutineto 
        case &amp;lt;-pc.closech:
            return
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写循环就更简单了，select channel中主gouroutine的request，然后写入tcp输入流，如果出错了，channel 通知调用者。&lt;/p&gt;

&lt;p&gt;整体看下来，过程都很简单，但是代码中有很多值得我们学习的地方，比如高并发请求如何复用tcp连接，这里是连接池的做法，如果使用多个 goroutine相互协作完成一个http请求，出现错误的时候如何通知调用者中断错误，代码风格也有很多可以借鉴的地方。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;http.Client 表示一个http client端，用来处理HTTP相关的工作，例如cookies, redirect, timeout等工作，其内部包含一个Transport，tranport用来建立一个连接，其中维护了一个空闲连接池idleConn map[connectMethodKey][]*persistConn，其中的每个成员都是一个persistConn对象，persistConn是个具体的连接实例，包含了连接的上下文，会启动两个groutine分别执行readLoop和writeLoop, 每当transport调用roundTrip的时候，就会从连接池中选择一个空闲的persistConn，然后调用其roundTrip方法，将读写请求通过channel分别发送到readLoop和writeLoop中，然后会进行select各个channel的信息，包括连接关闭，请求超时，writeLoop出错， readLoop返回读取结果等。在writeLoop中发送请求，在readLoop中获取response并通过channe返回给roundTrip函数中，并再次将自己加入到idleConn中，等待下次请求到来。&lt;/p&gt;

&lt;h2 id=&#34;自定义client&#34;&gt;自定义client&lt;/h2&gt;

&lt;p&gt;在上面我们说到调用结构体的成员函数都是默认的结构体的成员函数，但是如果我们有一些特殊的需求，我们就需要重新定义这些结构体，然后实现自己的逻辑，整个http请求也就会按着我们的逻辑进行处理，这也是我们实现一些功能的必要手段。最基本的就是自定义client，也是我们编程常用的，深入一些就需要了解一些传输transport等。&lt;/p&gt;

&lt;p&gt;1、要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;client := &amp;amp;http.Client{
    CheckRedirect: redirectPolicyFunc,
}
resp, err := client.Get(&amp;quot;http://example.com&amp;quot;)
// ...
req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://example.com&amp;quot;, nil)
// ...
req.Header.Add(&amp;quot;If-None-Match&amp;quot;, `W/&amp;quot;wyzzy&amp;quot;`)
resp, err := client.Do(req)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就是在上面的基础上增加了对client结构体的设置，而不是使用DefaultClient，我们来看一下client的结构体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Client struct {
    // Transport指定执行独立、单次HTTP请求的机制。
    // 如果Transport为nil，则使用DefaultTransport。
    Transport RoundTripper
    // CheckRedirect指定处理重定向的策略。
    // 如果CheckRedirect不为nil，客户端会在执行重定向之前调用本函数字段。
    // 参数req和via是将要执行的请求和已经执行的请求（切片，越新的请求越靠后）。
    // 如果CheckRedirect返回一个错误，本类型的Get方法不会发送请求req，
    // 而是返回之前得到的最后一个回复和该错误。（包装进url.Error类型里）
    //
    // 如果CheckRedirect为nil，会采用默认策略：连续10此请求后停止。
    CheckRedirect func(req *Request, via []*Request) error
    // Jar指定cookie管理器。
    // 如果Jar为nil，请求中不会发送cookie，回复中的cookie会被忽略。
    Jar CookieJar
    // Timeout指定本类型的值执行请求的时间限制。
    // 该超时限制包括连接时间、重定向和读取回复主体的时间。
    // 计时器会在Head、Get、Post或Do方法返回后继续运作并在超时后中断回复主体的读取。
    //
    // Timeout为零值表示不设置超时。
    //
    // Client实例的Transport字段必须支持CancelRequest方法，
    // 否则Client会在试图用Head、Get、Post或Do方法执行请求时返回错误。
    // 本类型的Transport字段默认值（DefaultTransport）支持CancelRequest方法。
    Timeout time.Duration
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是对这些结构体中的成员的如何运用才是重点，然后就调用client的Get，Do等方法就是上面的执行逻辑，这边只是简单的client的处理，后面的逻辑依然使用的是默认的Transport。&lt;/p&gt;

&lt;p&gt;2、要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tr := &amp;amp;http.Transport{
    TLSClientConfig:    &amp;amp;tls.Config{RootCAs: pool},
    DisableCompression: true,
}
client := &amp;amp;http.Client{Transport: tr}
resp, err := client.Get(&amp;quot;https://example.com&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client和Transport类型都可以安全的被多个go程同时使用。出于效率考虑，应该一次建立、尽量重用。&lt;/p&gt;

&lt;p&gt;这边在client的基础上对client的transport的管理代理、TLS配置、keep-alive、压缩和其他设置，然后后面的逻辑中主要是切换到自定义的transport的逻辑运行。&lt;/p&gt;

&lt;h1 id=&#34;http服务端&#34;&gt;http服务端&lt;/h1&gt;

&lt;h2 id=&#34;http-status&#34;&gt;http status&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;const (
    StatusContinue           = 100
    StatusSwitchingProtocols = 101
    StatusOK                   = 200
    StatusCreated              = 201
    StatusAccepted             = 202
    StatusNonAuthoritativeInfo = 203
    StatusNoContent            = 204
    StatusResetContent         = 205
    StatusPartialContent       = 206
    StatusMultipleChoices   = 300
    StatusMovedPermanently  = 301
    StatusFound             = 302
    StatusSeeOther          = 303
    StatusNotModified       = 304
    StatusUseProxy          = 305
    StatusTemporaryRedirect = 307
    StatusBadRequest                   = 400
    StatusUnauthorized                 = 401
    StatusPaymentRequired              = 402
    StatusForbidden                    = 403
    StatusNotFound                     = 404
    StatusMethodNotAllowed             = 405
    StatusNotAcceptable                = 406
    StatusProxyAuthRequired            = 407
    StatusRequestTimeout               = 408
    StatusConflict                     = 409
    StatusGone                         = 410
    StatusLengthRequired               = 411
    StatusPreconditionFailed           = 412
    StatusRequestEntityTooLarge        = 413
    StatusRequestURITooLong            = 414
    StatusUnsupportedMediaType         = 415
    StatusRequestedRangeNotSatisfiable = 416
    StatusExpectationFailed            = 417
    StatusTeapot                       = 418
    StatusInternalServerError     = 500
    StatusNotImplemented          = 501
    StatusBadGateway              = 502
    StatusServiceUnavailable      = 503
    StatusGatewayTimeout          = 504
    StatusHTTPVersionNotSupported = 505
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们比较常用的就是404（服务未发现），503（服务不可用）等。&lt;/p&gt;

&lt;h2 id=&#34;http-header&#34;&gt;http header&lt;/h2&gt;

&lt;p&gt;Header代表HTTP头域的键值对。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Header map[string][]string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (h Header) Get(key string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get返回键对应的第一个值，如果键不存在会返回&amp;rdquo;&amp;ldquo;。如要获取该键对应的值切片，请直接用规范格式的键访问map。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (h Header) Set(key, value string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Set添加键值对到h，如键已存在则会用只有新值一个元素的切片取代旧值切片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (h Header) Add(key, value string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add添加键值对到h，如键已存在则会将新的值附加到旧值切片后面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (h Header) Del(key string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Del删除键值对。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (h Header) Write(w io.Writer) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write以有线格式将头域写入w。&lt;/p&gt;

&lt;h2 id=&#34;用于http客户端和服务端的结构体&#34;&gt;用于http客户端和服务端的结构体&lt;/h2&gt;

&lt;p&gt;type Request&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Request struct {
    // Method指定HTTP方法（GET、POST、PUT等）。对客户端，&amp;quot;&amp;quot;代表GET。
    Method string
    // URL在服务端表示被请求的URI，在客户端表示要访问的URL。
    //
    // 在服务端，URL字段是解析请求行的URI（保存在RequestURI字段）得到的，
    // 对大多数请求来说，除了Path和RawQuery之外的字段都是空字符串。
    // （参见RFC 2616, Section 5.1.2）
    //
    // 在客户端，URL的Host字段指定了要连接的服务器，
    // 而Request的Host字段（可选地）指定要发送的HTTP请求的Host头的值。
    URL *url.URL
    // 接收到的请求的协议版本。本包生产的Request总是使用HTTP/1.1
    Proto      string // &amp;quot;HTTP/1.0&amp;quot;
    ProtoMajor int    // 1
    ProtoMinor int    // 0
    // Header字段用来表示HTTP请求的头域。如果头域（多行键值对格式）为：
    //  accept-encoding: gzip, deflate
    //  Accept-Language: en-us
    //  Connection: keep-alive
    // 则：
    //  Header = map[string][]string{
    //      &amp;quot;Accept-Encoding&amp;quot;: {&amp;quot;gzip, deflate&amp;quot;},
    //      &amp;quot;Accept-Language&amp;quot;: {&amp;quot;en-us&amp;quot;},
    //      &amp;quot;Connection&amp;quot;: {&amp;quot;keep-alive&amp;quot;},
    //  }
    // HTTP规定头域的键名（头名）是大小写敏感的，请求的解析器通过规范化头域的键名来实现这点。
    // 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。
    Header Header
    // Body是请求的主体。
    //
    // 在客户端，如果Body是nil表示该请求没有主体买入GET请求。
    // Client的Transport字段会负责调用Body的Close方法。
    //
    // 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF。
    // Server会关闭请求的主体，ServeHTTP处理器不需要关闭Body字段。
    Body io.ReadCloser
    // ContentLength记录相关内容的长度。
    // 如果为-1，表示长度未知，如果&amp;gt;=0，表示可以从Body字段读取ContentLength字节数据。
    // 在客户端，如果Body非nil而该字段为0，表示不知道Body的长度。
    ContentLength int64
    // TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示&amp;quot;identity&amp;quot;编码。
    // 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除&amp;quot;chunked&amp;quot;传输编码。
    TransferEncoding []string
    // Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接。
    Close bool
    // 在服务端，Host指定URL会在其上寻找资源的主机。
    // 根据RFC 2616，该值可以是Host头的值，或者URL自身提供的主机名。
    // Host的格式可以是&amp;quot;host:port&amp;quot;。
    //
    // 在客户端，请求的Host字段（可选地）用来重写请求的Host头。
    // 如过该字段为&amp;quot;&amp;quot;，Request.Write方法会使用URL字段的Host。
    Host string
    // Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。
    // 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。
    Form url.Values
    // PostForm是解析好的POST或PUT的表单数据。
    // 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。
    PostForm url.Values
    // MultipartForm是解析好的多部件表单，包括上传的文件。
    // 本字段只有在调用ParseMultipartForm后才有效。
    // 在客户端，会忽略请求中的本字段而使用Body替代。
    MultipartForm *multipart.Form
    // Trailer指定了会在请求主体之后发送的额外的头域。
    //
    // 在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。
    // （客户端会声明哪些trailer会发送）
    // 在处理器从Body读取时，不能使用本字段。
    // 在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。
    // （如果客户端发送了这些键值对），此时才可以访问本字段。
    //
    // 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射。（值可以是nil或其终值）
    // ContentLength字段必须是0或-1，以启用&amp;quot;chunked&amp;quot;传输编码发送请求。
    // 在开始发送请求后，Trailer可以在读取请求主体期间被修改，
    // 一旦请求主体返回EOF，调用者就不可再修改Trailer。
    //
    // 很少有HTTP客户端、服务端或代理支持HTTP trailer。
    Trailer Header
    // RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志。
    // 本字段不是ReadRequest函数填写的，也没有定义格式。
    // 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为&amp;quot;IP:port&amp;quot;格式的地址。
    // 客户端会忽略请求中的RemoteAddr字段。
    RemoteAddr string
    // RequestURI是被客户端发送到服务端的请求的请求行中未修改的请求URI
    // （参见RFC 2616, Section 5.1）
    // 一般应使用URI字段，在客户端设置请求的本字段会导致错误。
    RequestURI string
    // TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息
    // 本字段不是ReadRequest函数填写的。
    // 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。
    // 客户端会忽略请求中的TLS字段。
    TLS *tls.ConnectionState
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Request类型代表一个服务端接受到的或者客户端发送出去的HTTP请求。&lt;/p&gt;

&lt;p&gt;Request各字段的意义和用途在服务端和客户端是不同的。除了字段本身上方文档，还可参见Request.Write方法和RoundTripper接口的文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Response struct {
    Status     string // 例如&amp;quot;200 OK&amp;quot;
    StatusCode int    // 例如200
    Proto      string // 例如&amp;quot;HTTP/1.0&amp;quot;
    ProtoMajor int    // 例如1
    ProtoMinor int    // 例如0
    // Header保管头域的键值对。
    // 如果回复中有多个头的键相同，Header中保存为该键对应用逗号分隔串联起来的这些头的值
    // （参见RFC 2616 Section 4.2）
    // 被本结构体中的其他字段复制保管的头（如ContentLength）会从Header中删掉。
    //
    // Header中的键都是规范化的，参见CanonicalHeaderKey函数
    Header Header
    // Body代表回复的主体。
    // Client类型和Transport类型会保证Body字段总是非nil的，即使回复没有主体或主体长度为0。
    // 关闭主体是调用者的责任。
    // 如果服务端采用&amp;quot;chunked&amp;quot;传输编码发送的回复，Body字段会自动进行解码。
    Body io.ReadCloser
    // ContentLength记录相关内容的长度。
    // 其值为-1表示长度未知（采用chunked传输编码）
    // 除非对应的Request.Method是&amp;quot;HEAD&amp;quot;，其值&amp;gt;=0表示可以从Body读取的字节数
    ContentLength int64
    // TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示&amp;quot;identity&amp;quot;编码。
    TransferEncoding []string
    // Close记录头域是否指定应在读取完主体后关闭连接。（即Connection头）
    // 该值是给客户端的建议，Response.Write方法的ReadResponse函数都不会关闭连接。
    Close bool
    // Trailer字段保存和头域相同格式的trailer键值对，和Header字段相同类型
    Trailer Header
    // Request是用来获取此回复的请求
    // Request的Body字段是nil（因为已经被用掉了）
    // 这个字段是被Client类型发出请求并获得回复后填充的
    Request *Request
    // TLS包含接收到该回复的TLS连接的信息。 对未加密的回复，本字段为nil。
    // 返回的指针是被（同一TLS连接接收到的）回复共享的，不应被修改。
    TLS *tls.ConnectionState
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Response代表一个HTTP请求的回复&lt;/p&gt;

&lt;p&gt;type ResponseWriter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ResponseWriter interface {
    // Header返回一个Header类型值，该值会被WriteHeader方法发送。
    // 在调用WriteHeader或Write方法后再改变该对象是没有意义的。
    Header() Header
    // WriteHeader该方法发送HTTP回复的头域和状态码。
    // 如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)
    // WriterHeader的显式调用主要用于发送错误码。
    WriteHeader(int)
    // Write向连接中写入作为HTTP的一部分回复的数据。
    // 如果被调用时还未调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)
    // 如果Header中没有&amp;quot;Content-Type&amp;quot;键，
    // 本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值。
    Write([]byte) (int, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResponseWriter接口被HTTP处理器用于构造HTTP回复。这个一般用于服务端处理请求&lt;/p&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;p&gt;正常我们使用的返回方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
 &amp;quot;net/http&amp;quot;
)

func main() {

 http.HandleFunc(&amp;quot;/&amp;quot;, func (w http.ResponseWriter, r *http.Request){


   w.Header().Set(&amp;quot;name&amp;quot;, &amp;quot;my name is smallsoup&amp;quot;)
   w.WriteHeader(500)
   w.Write([]byte(&amp;quot;hello world\n&amp;quot;))

 })

 http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;type CloseNotifier&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type CloseNotifier interface {
    // CloseNotify返回一个通道，该通道会在客户端连接丢失时接收到唯一的值
    CloseNotify() &amp;lt;-chan bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTP处理器ResponseWriter接口参数的下层如果实现了CloseNotifier接口，可以让用户检测下层的连接是否停止。如果客户端在回复准备好之前关闭了连接，该机制可以用于取消服务端耗时较长的操作。&lt;/p&gt;

&lt;h2 id=&#34;http-服务端使用和原理解析&#34;&gt;http 服务端使用和原理解析&lt;/h2&gt;

&lt;p&gt;ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。Handle和HandleFunc函数可以向DefaultServeMux添加处理器。如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.Handle(&amp;quot;/foo&amp;quot;, fooHandler)
http.HandleFunc(&amp;quot;/bar&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &amp;quot;Hello, %q&amp;quot;, html.EscapeString(r.URL.Path))
})
log.Fatal(http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ListenAndServe该方法用于在指定的TCP网络地址addr进行监听，然后调用服务端处理程序来处理传入的连接请求。该方法有两个参数：第一个参数addr 即监听地址；第二个参数表示服务端处理程序，通常为空，这意味着服务端调用 http.DefaultServeMux 进行处理，而服务端编写的业务逻辑处理程序 http.Handle() 或 http.HandleFunc() 默认注入 http.DefaultServeMux 中。&lt;/p&gt;

&lt;p&gt;理解HTTP相关的网络应用，主要关注两个地方-客户端(client)和服务端(server)，两者的交互主要是client的request以及server的response,主要就在于如何接受client的request并向client返回response。&lt;/p&gt;

&lt;p&gt;接收request的过程中，最重要的莫过于路由（router），即实现一个Multiplexer器。Go http中既可以使用内置的mutilplexer &amp;mdash; DefautServeMux，也可以自定义。Multiplexer路由的目的就是为了找到处理器函数（handler），后者将对request进行处理，同时构建response&lt;/p&gt;

&lt;p&gt;流程为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Clinet -&amp;gt; Requests -&amp;gt;  Multiplexer(router) -&amp;gt; handler  -&amp;gt; Response -&amp;gt; Clinet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于一个http服务，大致需要理解这两个封装的过程就可以理解上面的实现了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.首先需要注册路由，即提供url模式和handler函数的映射.
2.其次就是实例化一个server对象，并开启对客户端的监听。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再看go http服务的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.HandleFunc(&amp;quot;/&amp;quot;, indexHandler) -----即是注册路由。
http.ListenAndServe(&amp;quot;127.0.0.1:8000&amp;quot;, nil)---启动server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server := &amp;amp;Server{Addr: addr, Handler: handler}
server.ListenAndServe()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;注册路由&#34;&gt;注册路由&lt;/h3&gt;

&lt;p&gt;net/http包暴露的注册路由的api很简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.HandleFunc(&amp;quot;/&amp;quot;, indexHandler) -----即是注册路由。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HandlerFunc是一个函数类型，如下定义，同时实现了Handler接口的ServeHTTP方法。使用HandlerFunc类型包装一下路由定义的indexHandler函数，其目的就是为了让这个函数也实现ServeHTTP方法，即转变成一个handler处理器(函数)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们最开始写的例子中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.HandleFunc(&amp;quot;/&amp;quot;,Indexhandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样 IndexHandler 函数也有了ServeHTTP方法。&lt;/p&gt;

&lt;p&gt;ServeMux和handler处理器函数的连接桥梁就是Handler接口。ServeMux的ServeHTTP方法实现了寻找注册路由的handler的函数（可以看下面的监控服务流程），并调用该handler的ServeHTTP方法。ServeHTTP方法就是真正处理请求和构造响应的地方。&lt;/p&gt;

&lt;p&gt;Go其实支持外部实现的路由器 ListenAndServe的第二个参数就是 用以配置外部路由器的，它是一个Handler接口，即外部路由器只要实现了Handler接口就可以,我们可以在自己实现 的路由器的ServHTTP里面实现自定义路由功能。&lt;/p&gt;

&lt;p&gt;如下代码所示，我们自己实现了一个简易的路由器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import ( 
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot; 
    )
type MyMux struct { }

func (p *MyMux) ServeHTTP(w http.ResponseWriter, r *http.Request) { if r.URL.Path == &amp;quot;/&amp;quot; {
    sayhelloName(w, r)
    return 
}
    http.NotFound(w, r)
    return 
}

func sayhelloName(w http.ResponseWriter, r *http.Request) { f
    mt.Fprintf(w, &amp;quot;Hello myroute!&amp;quot;)
}

func main() {
    mux := &amp;amp;MyMux{}
    http.ListenAndServe(&amp;quot;:9090&amp;quot;, mux) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;multiplexer&#34;&gt;multiplexer&lt;/h3&gt;

&lt;p&gt;http.HandleFunc选取了DefaultServeMux作为multiplexer：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DefaultServeMux是ServeMux的一个实例。当然http包也提供了NewServeMux方法创建一个ServeMux实例，默认则创建一个DefaultServeMux：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// NewServeMux allocates and returns a new ServeMux.
func NewServeMux() *ServeMux { return new(ServeMux) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DefaultServeMux的代码定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// DefaultServeMux is the default ServeMux used by Serve.
var DefaultServeMux = &amp;amp;defaultServeMux
var defaultServeMux ServeMux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以是其他可以实现的实例 ，比如上面实现的mux。&lt;/p&gt;

&lt;p&gt;路由结构体ServeMux&lt;/p&gt;

&lt;p&gt;ServeMux的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ServeMux struct {
    mu    sync.RWMutex                      //锁，由于请求涉及到并发处理，因此这里需要一个锁机制
    m     map[string]muxEntry               // 路由规则，一个string对应一个mux实体，这里的string就是注册的路由
    hosts bool 
}

type muxEntry struct {
    explicit bool                // 是否精确匹配
    h        Handler              // 这个路由表达式对应哪个handler
    pattern  string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServeMux结构中最重要的字段为m，这是一个map，key是一些url模式，value是一个muxEntry结构，后者里定义存储了具体的url模式和handler。&lt;/p&gt;

&lt;p&gt;当然，所谓的ServeMux也实现了ServeHTTP接口，也算是一个handler，不过ServeMux的ServeHTTP方法不是用来处理request和respone，而是用来找到路由注册的handler，可以看服务监听时候的调用过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    if handler == nil {
        panic(&amp;quot;http: nil handler&amp;quot;)
    }
    mux.Handle(pattern, HandlerFunc(handler))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServeMux的Handle方法，将会对pattern和handler函数做一个map映射：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Handle registers the handler for the given pattern.
// If a handler already exists for pattern, Handle panics.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
    mux.mu.Lock()
    defer mux.mu.Unlock()

    if pattern == &amp;quot;&amp;quot; {
        panic(&amp;quot;http: invalid pattern &amp;quot; + pattern)
    }
    if handler == nil {
        panic(&amp;quot;http: nil handler&amp;quot;)
    }
    if mux.m[pattern].explicit {
        panic(&amp;quot;http: multiple registrations for &amp;quot; + pattern)
    }

    if mux.m == nil {
        mux.m = make(map[string]muxEntry)
    }
    mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

    if pattern[0] != &#39;/&#39; {
        mux.hosts = true
    }

    // Helpful behavior:
    // If pattern is /tree/, insert an implicit permanent redirect for /tree.
    // It can be overridden by an explicit registration.
    n := len(pattern)
    if n &amp;gt; 0 &amp;amp;&amp;amp; pattern[n-1] == &#39;/&#39; &amp;amp;&amp;amp; !mux.m[pattern[0:n-1]].explicit {
        // If pattern contains a host name, strip it and use remaining
        // path for redirect.
        path := pattern
        if pattern[0] != &#39;/&#39; {
            // In pattern, at least the last character is a &#39;/&#39;, so
            // strings.Index can&#39;t be -1.
            path = pattern[strings.Index(pattern, &amp;quot;/&amp;quot;):]
        }
        url := &amp;amp;url.URL{Path: path}
        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handle函数的主要目的在于把handler和pattern模式绑定到map[string]muxEntry的map上，其中muxEntry保存了更多pattern和handler的信息，还记得前面讨论的Server结构吗？Server的m字段就是map[string]muxEntry这样一个map。&lt;/p&gt;

&lt;p&gt;此时，pattern和handler的路由注册完成。接下来就是如何开始server的监听，以接收客户端的请求。&lt;/p&gt;

&lt;h3 id=&#34;启动服务&#34;&gt;启动服务&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;http.ListenAndServe(&amp;quot;127.0.0.1:8000&amp;quot;, nil)---启动server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server := &amp;amp;Server{Addr: addr, Handler: handler}

server.ListenAndServe()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注册好路由之后，启动web服务还需要开启服务器监听。http的ListenAndServer方法中可以看到创建了一个Server对象，并调用了Server对象的同名方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ListenAndServe(addr string, handler Handler) error {
    server := &amp;amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
// If srv.Addr is blank, &amp;quot;:http&amp;quot; is used.
// ListenAndServe always returns a non-nil error.
func (srv *Server) ListenAndServe() error {
    addr := srv.Addr
    if addr == &amp;quot;&amp;quot; {
        addr = &amp;quot;:http&amp;quot;
    }
    ln, err := net.Listen(&amp;quot;tcp&amp;quot;, addr)
    if err != nil {
        return err
    }
    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server的ListenAndServe方法中，会初始化监听地址Addr，同时调用Listen方法设置监听。最后将监听的TCP对象传入Serve方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
//
// For HTTP/2 support, srv.TLSConfig should be initialized to the
// provided listener&#39;s TLS Config before calling Serve. If
// srv.TLSConfig is non-nil and doesn&#39;t include the string &amp;quot;h2&amp;quot; in
// Config.NextProtos, HTTP/2 support is not enabled.
//
// Serve always returns a non-nil error. After Shutdown or Close, the
// returned error is ErrServerClosed.
func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    if fn := testHookServerServe; fn != nil {
        fn(srv, l)
    }
    var tempDelay time.Duration // how long to sleep on accept failure

    if err := srv.setupHTTP2_Serve(); err != nil {
        return err
    }

    srv.trackListener(l, true)
    defer srv.trackListener(l, false)

    baseCtx := context.Background() // base is always background, per Issue 16220
    ctx := context.WithValue(baseCtx, ServerContextKey, srv)
    for {
        rw, e := l.Accept()
        if e != nil {
            select {
            case &amp;lt;-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            if ne, ok := e.(net.Error); ok &amp;amp;&amp;amp; ne.Temporary() {
                if tempDelay == 0 {
                    tempDelay = 5 * time.Millisecond
                } else {
                    tempDelay *= 2
                }
                if max := 1 * time.Second; tempDelay &amp;gt; max {
                    tempDelay = max
                }
                srv.logf(&amp;quot;http: Accept error: %v; retrying in %v&amp;quot;, e, tempDelay)
                time.Sleep(tempDelay)
                continue
            }
            return e
        }
        tempDelay = 0
        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve(ctx)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;监听开启之后，一旦客户端请求到达，创建一个conn结构体，这个conn中保留了这次请求的信息，go就开启一个协程serve处理请求，主要逻辑都在serve方法之中。&lt;/p&gt;

&lt;p&gt;serve方法比较长，其主要职能就是，创建一个上下文对象，然后调用Listener的Accept方法用来　获取连接数据并使用newConn方法创建连接对象。最后使用goroutein协程的方式处理连接请求。因为每一个连接都开起了一个协程，请求的上下文都不同，同时又保证了go的高并发。serve也是一个长长的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Serve a new connection.
func (c *conn) serve(ctx context.Context) {
    c.remoteAddr = c.rwc.RemoteAddr().String()
    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())
    defer func() {
        if err := recover(); err != nil &amp;amp;&amp;amp; err != ErrAbortHandler {
            const size = 64 &amp;lt;&amp;lt; 10
            buf := make([]byte, size)
            buf = buf[:runtime.Stack(buf, false)]
            c.server.logf(&amp;quot;http: panic serving %v: %v\n%s&amp;quot;, c.remoteAddr, err, buf)
        }
        if !c.hijacked() {
            c.close()
            c.setState(c.rwc, StateClosed)
        }
    }()

    if tlsConn, ok := c.rwc.(*tls.Conn); ok {
        if d := c.server.ReadTimeout; d != 0 {
            c.rwc.SetReadDeadline(time.Now().Add(d))
        }
        if d := c.server.WriteTimeout; d != 0 {
            c.rwc.SetWriteDeadline(time.Now().Add(d))
        }
        if err := tlsConn.Handshake(); err != nil {
            c.server.logf(&amp;quot;http: TLS handshake error from %s: %v&amp;quot;, c.rwc.RemoteAddr(), err)
            return
        }
        c.tlsState = new(tls.ConnectionState)
        *c.tlsState = tlsConn.ConnectionState()
        if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
            if fn := c.server.TLSNextProto[proto]; fn != nil {
                h := initNPNRequest{tlsConn, serverHandler{c.server}}
                fn(c.server, tlsConn, h)
            }
            return
        }
    }

    // HTTP/1.x from here on.

    ctx, cancelCtx := context.WithCancel(ctx)
    c.cancelCtx = cancelCtx
    defer cancelCtx()

    c.r = &amp;amp;connReader{conn: c}
    c.bufr = newBufioReader(c.r)
    c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&amp;lt;&amp;lt;10)

    for {
        w, err := c.readRequest(ctx)
        if c.r.remain != c.server.initialReadLimitSize() {
            // If we read any bytes off the wire, we&#39;re active.
            c.setState(c.rwc, StateActive)
        }
        if err != nil {
            const errorHeaders = &amp;quot;\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n&amp;quot;

            if err == errTooLarge {
                // Their HTTP client may or may not be
                // able to read this if we&#39;re
                // responding to them and hanging up
                // while they&#39;re still writing their
                // request. Undefined behavior.
                const publicErr = &amp;quot;431 Request Header Fields Too Large&amp;quot;
                fmt.Fprintf(c.rwc, &amp;quot;HTTP/1.1 &amp;quot;+publicErr+errorHeaders+publicErr)
                c.closeWriteAndWait()
                return
            }
            if isCommonNetReadError(err) {
                return // don&#39;t reply
            }

            publicErr := &amp;quot;400 Bad Request&amp;quot;
            if v, ok := err.(badRequestError); ok {
                publicErr = publicErr + &amp;quot;: &amp;quot; + string(v)
            }

            fmt.Fprintf(c.rwc, &amp;quot;HTTP/1.1 &amp;quot;+publicErr+errorHeaders+publicErr)
            return
        }

        // Expect 100 Continue support
        req := w.req
        if req.expectsContinue() {
            if req.ProtoAtLeast(1, 1) &amp;amp;&amp;amp; req.ContentLength != 0 {
                // Wrap the Body reader with one that replies on the connection
                req.Body = &amp;amp;expectContinueReader{readCloser: req.Body, resp: w}
            }
        } else if req.Header.get(&amp;quot;Expect&amp;quot;) != &amp;quot;&amp;quot; {
            w.sendExpectationFailed()
            return
        }

        c.curReq.Store(w)

        if requestBodyRemains(req.Body) {
            registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)
        } else {
            if w.conn.bufr.Buffered() &amp;gt; 0 {
                w.conn.r.closeNotifyFromPipelinedRequest()
            }
            w.conn.r.startBackgroundRead()
        }

        // HTTP cannot have multiple simultaneous active requests.[*]
        // Until the server replies to this request, it can&#39;t read another,
        // so we might as well run the handler in this goroutine.
        // [*] Not strictly true: HTTP pipelining. We could let them all process
        // in parallel even if their responses need to be serialized.
        // But we&#39;re not going to implement HTTP pipelining because it
        // was never deployed in the wild and the answer is HTTP/2.
        serverHandler{c.server}.ServeHTTP(w, w.req)
        w.cancelCtx()
        if c.hijacked() {
            return
        }
        w.finishRequest()
        if !w.shouldReuseConnection() {
            if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
                c.closeWriteAndWait()
            }
            return
        }
        c.setState(c.rwc, StateIdle)
        c.curReq.Store((*response)(nil))

        if !w.conn.server.doKeepAlives() {
            // We&#39;re in shutdown mode. We might&#39;ve replied
            // to the user without &amp;quot;Connection: close&amp;quot; and
            // they might think they can send another
            // request, but such is life with HTTP/1.1.
            return
        }

        if d := c.server.idleTimeout(); d != 0 {
            c.rwc.SetReadDeadline(time.Now().Add(d))
            if _, err := c.bufr.Peek(4); err != nil {
                return
            }
        }
        c.rwc.SetReadDeadline(time.Time{})
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用defer定义了函数退出时，连接关闭相关的处理。然后就是读取连接的网络数据，并处理读取完毕时候的状态。接下来就是调用serverHandler{c.server}.ServeHTTP(w, w.req)方法处理请求了。最后就是请求处理完毕的逻辑。serverHandler是一个重要的结构，它近有一个字段，即Server结构，同时它也实现了Handler接口方法ServeHTTP，并在该接口方法中做了一个重要的事情，初始化multiplexer路由多路复用器。如果server对象没有指定Handler，则使用默认的DefaultServeMux作为路由Multiplexer。并调用初始化Handler的ServeHTTP方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// serverHandler delegates to either the server&#39;s Handler or
// DefaultServeMux and also handles &amp;quot;OPTIONS *&amp;quot; requests.
type serverHandler struct {
    srv *Server
}

func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    handler := sh.srv.Handler
    if handler == nil {
        handler = DefaultServeMux
    }
    if req.RequestURI == &amp;quot;*&amp;quot; &amp;amp;&amp;amp; req.Method == &amp;quot;OPTIONS&amp;quot; {
        handler = globalOptionsHandler{}
    }
    handler.ServeHTTP(rw, req)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里DefaultServeMux的ServeHTTP方法其实也是定义在ServeMux结构中的，相关代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Find a handler on a handler map given a path string.
// Most-specific (longest) pattern wins.
func (mux *ServeMux) match(path string) (h Handler, pattern string) {
    // Check for exact match first.
    v, ok := mux.m[path]
    if ok {
        return v.h, v.pattern
    }

    // Check for longest valid match.
    var n = 0
    for k, v := range mux.m {
        if !pathMatch(k, path) {
            continue
        }
        if h == nil || len(k) &amp;gt; n {
            n = len(k)
            h = v.h
            pattern = v.pattern
        }
    }
    return
}
func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {

    // CONNECT requests are not canonicalized.
    if r.Method == &amp;quot;CONNECT&amp;quot; {
        return mux.handler(r.Host, r.URL.Path)
    }

    // All other requests have any port stripped and path cleaned
    // before passing to mux.handler.
    host := stripHostPort(r.Host)
    path := cleanPath(r.URL.Path)
    if path != r.URL.Path {
        _, pattern = mux.handler(host, path)
        url := *r.URL
        url.Path = path
        return RedirectHandler(url.String(), StatusMovedPermanently), pattern
    }

    return mux.handler(host, r.URL.Path)
}

// handler is the main implementation of Handler.
// The path is known to be in canonical form, except for CONNECT methods.
func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
    mux.mu.RLock()
    defer mux.mu.RUnlock()

    // Host-specific pattern takes precedence over generic ones
    if mux.hosts {
        h, pattern = mux.match(host + path)
    }
    if h == nil {
        h, pattern = mux.match(path)
    }
    if h == nil {
        h, pattern = NotFoundHandler(), &amp;quot;&amp;quot;
    }
    return
}

// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
    if r.RequestURI == &amp;quot;*&amp;quot; {
        if r.ProtoAtLeast(1, 1) {
            w.Header().Set(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)
        }
        w.WriteHeader(StatusBadRequest)
        return
    }
    h, _ := mux.Handler(r)
    h.ServeHTTP(w, r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mux的ServeHTTP方法通过调用其Handler方法寻找注册到路由上的handler函数，并调用该函数的ServeHTTP方法，本例则是IndexHandler函数。&lt;/p&gt;

&lt;p&gt;mux的Handler方法对URL简单的处理，然后调用handler方法，后者会创建一个锁，同时调用match方法返回一个handler和pattern。&lt;/p&gt;

&lt;p&gt;在match方法中，mux的m字段是map[string]muxEntry图，后者存储了pattern和handler处理器函数，因此通过迭代m寻找出注册路由的patten模式与实际url匹配的handler函数并返回。&lt;/p&gt;

&lt;p&gt;返回的结构一直传递到mux的ServeHTTP方法，接下来调用handler函数的ServeHTTP方法，即IndexHandler函数，然后把response写到http.RequestWirter对象返回给客户端。&lt;/p&gt;

&lt;p&gt;上述函数运行结束即serverHandler{c.server}.ServeHTTP(w, w.req)运行结束。接下来就是对请求处理完毕之后上希望和连接断开的相关逻辑。&lt;/p&gt;

&lt;p&gt;至此，Golang中一个完整的http服务介绍完毕，包括注册路由，开启监听，处理连接，路由处理函数。
多数的web应用基于HTTP协议，客户端和服务器通过request-response的方式交互。一个server并不可少的两部分莫过于路由注册和连接处理。Golang通过一个ServeMux实现了的multiplexer路由多路复用器来管理路由。同时提供一个Handler接口提供ServeHTTP用来实现handler处理其函数，后者可以处理实际request并构造response。&lt;/p&gt;

&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;理解go中的http服务，最重要就是要理解Multiplexer和handler，Golang中的Multiplexer基于ServeMux结构，同时也实现了Handler接口。下面对几个重要概念说明，两个重要的结构体和一个接口&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Handler类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Golang没有继承，类多态的方式可以通过接口实现。所谓接口则是定义声明了函数签名，任何结构只要实现了与接口函数签名相同的方法，就等同于实现了接口。go的http服务都是基于handler进行处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何结构体，只要实现了ServeHTTP方法，这个结构就可以称之为handler对象。ServeMux会使用handler并调用其ServeHTTP方法处理请求并返回响应。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;handler处理器(函数)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;handler处理器(函数)-就是HandleFunc的第二个参数，是一个函数： 具有func(w http.ResponseWriter, r *http.Requests)签名的函数，经过HandlerFunc结构包装的handler函数，它实现了ServeHTTP接口方法的函数。调用handler处理器的ServeHTTP方法时，即调用handler函数本身。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;handler对象：实现了Handler接口ServeHTTP方法的结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ServeMux和handler处理器函数的连接桥梁就是Handler接口。ServeMux的ServeHTTP方法实现了寻找注册路由的handler的函数，并调用该handler的ServeHTTP方法。ServeHTTP方法就是真正处理请求和构造响应的地方。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Server结构体&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从http.ListenAndServe的源码可以看出，它还是创建了一个server对象，并调用server对象的ListenAndServe方法来实现监听路由：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ListenAndServe(addr string, handler Handler) error {
    server := &amp;amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看server的结构如下，其实上面已经解释过：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Server struct {
    Addr         string        
    Handler      Handler       
    ReadTimeout  time.Duration 
    WriteTimeout time.Duration 
    TLSConfig    *tls.Config   

    MaxHeaderBytes int

    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)

    ConnState func(net.Conn, ConnState)
    ErrorLog *log.Logger
    disableKeepAlives int32     nextProtoOnce     sync.Once 
    nextProtoErr      error     
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;server结构存储了服务器处理请求常见的字段。其中Handler字段也保留Handler接口。如果Server接口没有提供Handler结构对象，那么会使用DefautServeMux做multiplexer，后面再做分析。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;路由结构体ServeMux&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ServeMux的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ServeMux struct {
    mu    sync.RWMutex                      //锁，由于请求涉及到并发处理，因此这里需要一个锁机制
    m     map[string]muxEntry               // 路由规则，一个string对应一个mux实体，这里的string就是注册的路由
    hosts bool 
}

type muxEntry struct {
    explicit bool                // 是否精确匹配
    h        Handler              // 这个路由表达式对应哪个handler
    pattern  string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServeMux结构中最重要的字段为m，这是一个map，key是一些url模式，value是一个muxEntry结构，后者里定义存储了具体的url模式和handler。&lt;/p&gt;

&lt;p&gt;当然，所谓的ServeMux也实现了ServeHTTP接口，也算是一个handler，不过ServeMux的ServeHTTP方法不是用来处理request和respone，而是用来找到路由注册的handler&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Go代码的执行流程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。&lt;/p&gt;

&lt;p&gt;1、首先调用Http.HandleFunc&lt;/p&gt;

&lt;p&gt;按顺序做了几件事:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 调用了DefaultServerMux的HandleFunc
2 调用了DefaultServerMux的Handle
3 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、其次调用http.ListenAndServe(&amp;rdquo;:9090&amp;rdquo;, nil)&lt;/p&gt;

&lt;p&gt;按顺序做了几件事情:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 实例化Server
2 调用Server的ListenAndServe()
3 调用net.Listen(&amp;quot;tcp&amp;quot;, addr)监听端口
4 启动一个for循环，在循环体中Accept请求
5 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()
6 读取每个请求的内容w, err := c.readRequest()
7 判断handler是否为空，如果没有设置handler(这个例子就没有设置handler)，handler就设置为 DefaultServeMux
8 调用handler的ServeHttp
9 在这个例子中，下面就进入到DefaultServerMux.ServeHttp
10 根据request选择handler，并且进入到这个handler的ServeHTTP mux.handler(r).ServeHTTP(w, r)
11 选择handler:
    A 判断是否有路由能满足这个request(循环遍历ServerMux的muxEntry)
    B 如果有路由满足，调用这个路由handler的ServeHttp
    C 如果没有路由满足，调用NotFoundHandler的ServeHttp
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义server&#34;&gt;自定义server&lt;/h2&gt;

&lt;p&gt;要管理服务端的行为，可以创建一个自定义的Server：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s := &amp;amp;http.Server{
    Addr:           &amp;quot;:8080&amp;quot;,
    Handler:        myHandler,
    ReadTimeout:    10 * time.Second,
    WriteTimeout:   10 * time.Second,
    MaxHeaderBytes: 1 &amp;lt;&amp;lt; 20,
}
log.Fatal(s.ListenAndServe())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也是上面的流程，就是新增了一个server结构体的，做对应的操作，来看一下server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Server struct {
    Addr           string        // TCP address to listen on, &amp;quot;:http&amp;quot; if empty
    Handler        Handler       // handler to invoke, http.DefaultServeMux if nil
    ReadTimeout    time.Duration // maximum duration before timing out read of the request
    WriteTimeout   time.Duration // maximum duration before timing out write of the response
    MaxHeaderBytes int           // maximum size of request headers, DefaultMaxHeaderBytes if 0
    TLSConfig      *tls.Config   // optional TLS config, used by ListenAndServeTLS

    // TLSNextProto optionally specifies a function to take over
    // ownership of the provided TLS connection when an NPN
    // protocol upgrade has occurred.  The map key is the protocol
    // name negotiated. The Handler argument should be used to
    // handle HTTP requests and will initialize the Request&#39;s TLS
    // and RemoteAddr if not already set.  The connection is
    // automatically closed when the function returns.
    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)

    // ConnState specifies an optional callback function that is
    // called when a client connection changes state. See the
    // ConnState type and associated constants for details.
    ConnState func(net.Conn, ConnState)

    // ErrorLog specifies an optional logger for errors accepting
    // connections and unexpected behavior from handlers.
    // If nil, logging goes to os.Stderr via the log package&#39;s
    // standard logger.
    ErrorLog *log.Logger
    // contains filtered or unexported fields
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都是什么作用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Server struct {
    Addr           string        // 监听的TCP地址，如果为空字符串会使用&amp;quot;:http&amp;quot;
    Handler        Handler       // 调用的处理器，如为nil会调用http.DefaultServeMux
    ReadTimeout    time.Duration // 请求的读取操作在超时前的最大持续时间
    WriteTimeout   time.Duration // 回复的写入操作在超时前的最大持续时间
    MaxHeaderBytes int           // 请求的头域最大长度，如为0则用DefaultMaxHeaderBytes
    TLSConfig      *tls.Config   // 可选的TLS配置，用于ListenAndServeTLS方法
    // TLSNextProto（可选地）指定一个函数来在一个NPN型协议升级出现时接管TLS连接的所有权。
    // 映射的键为商谈的协议名；映射的值为函数，该函数的Handler参数应处理HTTP请求，
    // 并且初始化Handler.ServeHTTP的*Request参数的TLS和RemoteAddr字段（如果未设置）。
    // 连接在函数返回时会自动关闭。
    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)
    // ConnState字段指定一个可选的回调函数，该函数会在一个与客户端的连接改变状态时被调用。
    // 参见ConnState类型和相关常数获取细节。
    ConnState func(net.Conn, ConnState)
    // ErrorLog指定一个可选的日志记录器，用于记录接收连接时的错误和处理器不正常的行为。
    // 如果本字段为nil，日志会通过log包的标准日志记录器写入os.Stderr。
    ErrorLog *log.Logger
    // 内含隐藏或非导出字段
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Server
func (s *Server) SetKeepAlivesEnabled(v bool)
func (srv *Server) Serve(l net.Listener) error
func (srv *Server) ListenAndServe() error
func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error

func (*Server) SetKeepAlivesEnabled
func (s *Server) SetKeepAlivesEnabled(v bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SetKeepAlivesEnabled控制是否允许HTTP闲置连接重用（keep-alive）功能。默认该功能总是被启用的。只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (*Server) Serve
func (srv *Server) Serve(l net.Listener) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用srv.Handler回复请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (*Server) ListenAndServe
func (srv *Server) ListenAndServe() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ListenAndServe监听srv.Addr指定的TCP地址，并且会调用Serve方法接收到的连接。如果srv.Addr为空字符串，会使用&amp;rdquo;:http&amp;rdquo;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (*Server) ListenAndServeTLS
func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve方法处理接收到的连接。必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用&amp;rdquo;:https&amp;rdquo;。&lt;/p&gt;</description>
        </item>
      
    
      
        <item>
          <title>Golang使用系列---- Strings</title>
          <link>https://kingjcy.github.io/post/golang/go-strings/</link>
          <pubDate>Wed, 12 Oct 2016 19:37:30 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/golang/go-strings/</guid>
          <description>&lt;p&gt;平时在开发过程中， 和字符串打交道还是比较多的，比如分割， 去除， 替换等等常用的方法， 这些都是由strings包来提供的。&lt;/p&gt;

&lt;h1 id=&#34;基本应用&#34;&gt;基本应用&lt;/h1&gt;

&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;

&lt;p&gt;Compare 函数，用于比较两个字符串的大小，如果两个字符串相等，返回为 0。如果 a 小于 b ，返回 -1 ，反之返回 1 。不推荐使用这个函数，直接使用 == != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= 等一系列运算符更加直观。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Compare(a, b string) int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EqualFold 函数，计算 s 与 t 忽略字母大小写后是否相等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func EqualFold(s, t string) bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := &amp;quot;gopher&amp;quot;
b := &amp;quot;hello world&amp;quot;
fmt.Println(strings.Compare(a, b))
fmt.Println(strings.Compare(a, a))
fmt.Println(strings.Compare(b, a))

fmt.Println(strings.EqualFold(&amp;quot;GO&amp;quot;, &amp;quot;go&amp;quot;))
fmt.Println(strings.EqualFold(&amp;quot;壹&amp;quot;, &amp;quot;一&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-1
0
1
true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;是否存在某个字符或子串&#34;&gt;是否存在某个字符或子串&lt;/h2&gt;

&lt;p&gt;有三个函数做这件事：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 子串 substr 在 s 中，返回 true
func Contains(s, substr string) bool
// chars 中任何一个 Unicode 代码点在 s 中，返回 true
func ContainsAny(s, chars string) bool
// Unicode 代码点 r 在 s 中，返回 true
func ContainsRune(s string, r rune) bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里对 ContainsAny 函数进行一下说明，看如下例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(strings.ContainsAny(&amp;quot;team&amp;quot;, &amp;quot;i&amp;quot;))
fmt.Println(strings.ContainsAny(&amp;quot;failure&amp;quot;, &amp;quot;u &amp;amp; i&amp;quot;))
fmt.Println(strings.ContainsAny(&amp;quot;in failure&amp;quot;, &amp;quot;s g&amp;quot;))
fmt.Println(strings.ContainsAny(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;))
fmt.Println(strings.ContainsAny(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;false
true
true
false
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，第二个参数 chars 中任意一个字符（Unicode Code Point）如果在第一个参数 s 中存在，则返回 true。&lt;/p&gt;

&lt;p&gt;查看这三个函数的源码，发现它们只是调用了相应的 Index 函数（子串出现的位置），然后和 0 作比较返回 true 或 fale。如，Contains：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Contains(s, substr string) bool {
  return Index(s, substr) &amp;gt;= 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;index则使用了我们常用的字符串匹配算法的rk算法。&lt;/p&gt;

&lt;h2 id=&#34;子串出现次数-字符串匹配&#34;&gt;子串出现次数 ( 字符串匹配 )&lt;/h2&gt;

&lt;p&gt;在数据结构与算法中，可能会讲解以下字符串匹配算法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;朴素匹配算法
KMP 算法
Rabin-Karp 算法
Boyer-Moore 算法
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有其他的算法，这里不一一列举，感兴趣的可以网上搜一下。&lt;/p&gt;

&lt;p&gt;在 Go 中，查找子串出现次数即字符串模式匹配，根据长度，分别实现的是BF和 Rabin-Karp 算法。Count 函数的签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Count(s, sep string) int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Count 的实现中，处理了几种特殊情况，属于字符匹配预处理的一部分。这里要特别说明一下的是当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(strings.Count(&amp;quot;cheese&amp;quot;, &amp;quot;e&amp;quot;))
fmt.Println(len(&amp;quot;谷歌中国&amp;quot;))
fmt.Println(strings.Count(&amp;quot;谷歌中国&amp;quot;, &amp;quot;&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3
12
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于 Rabin-Karp 算法的实现，有兴趣的可以看看 Count 的源码。&lt;/p&gt;

&lt;p&gt;另外，Count 是计算子串在字符串中出现的无重叠的次数，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(strings.Count(&amp;quot;fivevev&amp;quot;, &amp;quot;vev&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字符串分割为-string&#34;&gt;字符串分割为[]string&lt;/h2&gt;

&lt;p&gt;这个需求很常见，倒不一定是为了得到[]string。&lt;/p&gt;

&lt;p&gt;该包提供了六个三组分割函数：Fields和FieldsFunc、Split和SplitAfter、SplitN和SplitAfterN。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Fields和FieldsFunc&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func Fields(s string) []string
func FieldsFunc(s string, f func(rune) bool) []string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fields 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）。如果字符串 s 只包含空格，则返回空列表 ([]string 的长度为 0）。其中，空格的定义是 unicode.IsSpace，之前已经介绍过。&lt;/p&gt;

&lt;p&gt;常见间隔符包括：&amp;rsquo;\t&amp;rsquo;, &amp;lsquo;\n&amp;rsquo;, &amp;lsquo;\v&amp;rsquo;, &amp;lsquo;\f&amp;rsquo;, &amp;lsquo;\r&amp;rsquo;, &amp;lsquo; &amp;lsquo;, U+0085 (NEL), U+00A0 (NBSP)&lt;/p&gt;

&lt;p&gt;由于是用空格分隔，因此结果中不会含有空格或空子字符串，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;Fields are: %q&amp;quot;, strings.Fields(&amp;quot;  foo bar  baz   &amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fields are: [&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FieldsFunc通过实现一个回调函数来指定分隔字符串 s 的字符。比如上面的例子，我们通过 FieldsFunc 来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(strings.FieldsFunc(&amp;quot;  foo bar  baz   &amp;quot;, unicode.IsSpace))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，Fields 函数就是调用 FieldsFunc 实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Fields(s string) []string {
  return FieldsFunc(s, unicode.IsSpace)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Split和SplitAfter、SplitN和SplitAfterN&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之所以将这四个函数放在一起讲，是因为它们都是通过一个同一个内部函数来实现的。它们的函数签名及其实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }
func SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }
func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }
func SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它们都调用了 genSplit 函数。&lt;/p&gt;

&lt;p&gt;这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;&amp;rdquo;)，得到的是[a b c]。&lt;/p&gt;

&lt;p&gt;Split(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。&lt;/p&gt;

&lt;p&gt;那么，Split 和 SplitAfter 有啥区别呢？通过这两句代码的结果就知道它们的区别了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;foo,bar,baz&amp;quot;, &amp;quot;,&amp;quot;))
fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitAfter(&amp;quot;foo,bar,baz&amp;quot;, &amp;quot;,&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;]
[&amp;quot;foo,&amp;quot; &amp;quot;bar,&amp;quot; &amp;quot;baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep。&lt;/p&gt;

&lt;p&gt;带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n &amp;lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &amp;gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;foo,bar,baz&amp;quot;, &amp;quot;,&amp;quot;, 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;foo&amp;quot; &amp;quot;bar,baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外看一下官方文档提供的例子，注意一下输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;a,b,c&amp;quot;, &amp;quot;,&amp;quot;))
fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;a man a plan a canal panama&amp;quot;, &amp;quot;a &amp;quot;))
fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot; xyz &amp;quot;, &amp;quot;&amp;quot;))
fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;&amp;quot;, &amp;quot;Bernardo O&#39;Higgins&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;]
[&amp;quot;&amp;quot; &amp;quot;man &amp;quot; &amp;quot;plan &amp;quot; &amp;quot;canal panama&amp;quot;]
[&amp;quot; &amp;quot; &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot; &amp;quot; &amp;quot;]
[&amp;quot;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字符串是否有某个前缀或后缀&#34;&gt;字符串是否有某个前缀或后缀&lt;/h2&gt;

&lt;p&gt;这两个函数比较简单，源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// s 中是否以 prefix 开始
func HasPrefix(s, prefix string) bool {
  return len(s) &amp;gt;= len(prefix) &amp;amp;&amp;amp; s[0:len(prefix)] == prefix
}
// s 中是否以 suffix 结尾
func HasSuffix(s, suffix string) bool {
  return len(s) &amp;gt;= len(suffix) &amp;amp;&amp;amp; s[len(s)-len(suffix):] == suffix
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 prefix 或 suffix 为 &amp;ldquo;&amp;rdquo; , 返回值总是 true。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(strings.HasPrefix(&amp;quot;Gopher&amp;quot;, &amp;quot;Go&amp;quot;))
fmt.Println(strings.HasPrefix(&amp;quot;Gopher&amp;quot;, &amp;quot;C&amp;quot;))
fmt.Println(strings.HasPrefix(&amp;quot;Gopher&amp;quot;, &amp;quot;&amp;quot;))
fmt.Println(strings.HasSuffix(&amp;quot;Amigo&amp;quot;, &amp;quot;go&amp;quot;))
fmt.Println(strings.HasSuffix(&amp;quot;Amigo&amp;quot;, &amp;quot;Ami&amp;quot;))
fmt.Println(strings.HasSuffix(&amp;quot;Amigo&amp;quot;, &amp;quot;&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;true
false
true
true
false
true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字符或子串在字符串中出现的位置&#34;&gt;字符或子串在字符串中出现的位置&lt;/h2&gt;

&lt;p&gt;有一序列函数与该功能有关：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引
func Index(s, sep string) int
// 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引
func IndexByte(s string, c byte) int
// chars 中任何一个 Unicode 代码点在 s 中首次出现的位置
func IndexAny(s, chars string) int
// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true
func IndexFunc(s string, f func(rune) bool) int
// Unicode 代码点 r 在 s 中第一次出现的位置
func IndexRune(s string, r rune) int

// 有三个对应的查找最后一次出现的位置
func LastIndex(s, sep string) int
func LastIndexByte(s string, c byte) int
func LastIndexAny(s, chars string) int
func LastIndexFunc(s string, f func(rune) bool) int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一序列函数，只举 IndexFunc 的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;han := func(c rune) bool {
    return unicode.Is(unicode.Han, c) // 汉字
}
fmt.Println(strings.IndexFunc(&amp;quot;Hello, world&amp;quot;, han))
fmt.Println(strings.IndexFunc(&amp;quot;Hello, 世界&amp;quot;, han))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-1
7
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字符串-join-操作&#34;&gt;字符串 JOIN 操作&lt;/h2&gt;

&lt;p&gt;将字符串数组（或 slice）连接起来可以通过 Join 实现，函数签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Join(a []string, sep string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如没有这个库函数，我们自己实现一个，我们会这么实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Join(str []string, sep string) string {
  // 特殊情况应该做处理
  if len(str) == 0 {
      return &amp;quot;&amp;quot;
  }
  if len(str) == 1 {
      return str[0]
  }
  buffer := bytes.NewBufferString(str[0])
  for _, s := range str[1:] {
      buffer.WriteString(sep)
      buffer.WriteString(s)
  }
  return buffer.String()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，我们使用了 bytes 包的 Buffer 类型，避免大量的字符串连接操作（因为 Go 中字符串是不可变的）。我们再看一下标准库的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Join(a []string, sep string) string {
  if len(a) == 0 {
      return &amp;quot;&amp;quot;
  }
  if len(a) == 1 {
      return a[0]
  }
  n := len(sep) * (len(a) - 1)
  for i := 0; i &amp;lt; len(a); i++ {
      n += len(a[i])
  }

  b := make([]byte, n)
  bp := copy(b, a[0])
  for _, s := range a[1:] {
      bp += copy(b[bp:], sep)
      bp += copy(b[bp:], s)
  }
  return string(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标准库的实现没有用 bytes 包，当然也不会简单的通过 + 号连接字符串。Go 中是不允许循环依赖的，标准库中很多时候会出现代码拷贝，而不是引入某个包。这里 Join 的实现方式挺好，我个人观点认为，不直接使用 bytes 包，也是不想依赖 bytes 包（其实 bytes 中的实现也是 copy 方式）。&lt;/p&gt;

&lt;p&gt;简单使用示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(Join([]string{&amp;quot;name=xxx&amp;quot;, &amp;quot;age=xx&amp;quot;}, &amp;quot;&amp;amp;&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name=xxx&amp;amp;age=xx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字符串重复几次&#34;&gt;字符串重复几次&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;func Repeat(s string, count int) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 s 重复 count 次，如果 count 为负数或返回值长度 len(s)*count 超出 string 上限会导致 panic，这个函数使用很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(&amp;quot;ba&amp;quot; + strings.Repeat(&amp;quot;na&amp;quot;, 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;banana
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字符替换&#34;&gt;字符替换&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;map&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func Map(mapping func(rune) rune, s string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Map 函数，将 s 的每一个字符按照 mapping 的规则做映射替换，如果 mapping 返回值 &amp;lt;0 ，则舍弃该字符。该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapping := func(r rune) rune {
    switch {
    case r &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;Z&#39;: // 大写字母转小写
        return r + 32
    case r &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;z&#39;: // 小写字母不处理
        return r
    case unicode.Is(unicode.Han, r): // 汉字换行
        return &#39;\n&#39;
    }
    return -1 // 过滤所有非字母、汉字的字符
}
fmt.Println(strings.Map(mapping, &amp;quot;Hello你#￥%……\n（&#39;World\n,好Hello^(&amp;amp;(*界gopher...&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello
world
hello
gopher
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;replace&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;进行字符串替换时，考虑到性能问题，能不用正则尽量别用，应该用这里的函数。&lt;/p&gt;

&lt;p&gt;字符串替换的函数签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 用 new 替换 s 中的 old，一共替换 n 个。
// 如果 n &amp;lt; 0，则不限制替换次数，即全部替换
func Replace(s, old, new string, n int) string
// 该函数内部直接调用了函数 Replace(s, old, new , -1)
func ReplaceAll(s, old, new string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(strings.Replace(&amp;quot;oink oink oink&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;ky&amp;quot;, 2))
fmt.Println(strings.Replace(&amp;quot;oink oink oink&amp;quot;, &amp;quot;oink&amp;quot;, &amp;quot;moo&amp;quot;, -1))
fmt.Println(strings.ReplaceAll(&amp;quot;oink oink oink&amp;quot;, &amp;quot;oink&amp;quot;, &amp;quot;moo&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;oinky oinky oink
moo moo moo
moo moo moo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们希望一次替换多个，比如我们希望替换 This is &lt;b&gt;HTML&lt;/b&gt; 中的 &amp;lt; 和 &amp;gt; 为 &amp;lt; 和 &amp;gt;，可以调用上面的函数两次。但标准库提供了另外的方法进行这种替换。&lt;/p&gt;

&lt;h2 id=&#34;大小写转换&#34;&gt;大小写转换&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;func ToLower(s string) string
func ToLowerSpecial(c unicode.SpecialCase, s string) string
func ToUpper(s string) string
func ToUpperSpecial(c unicode.SpecialCase, s string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大小写转换包含了 4 个相关函数，ToLower,ToUpper 用于大小写转换。ToLowerSpecial,ToUpperSpecial 可以转换特殊字符的大小写。 举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(strings.ToLower(&amp;quot;HELLO WORLD&amp;quot;))
fmt.Println(strings.ToLower(&amp;quot;Ā Á Ǎ À&amp;quot;))
fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, &amp;quot;壹&amp;quot;))
fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, &amp;quot;HELLO WORLD&amp;quot;))
fmt.Println(strings.ToLower(&amp;quot;Önnek İş&amp;quot;))
fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, &amp;quot;Önnek İş&amp;quot;))

fmt.Println(strings.ToUpper(&amp;quot;hello world&amp;quot;))
fmt.Println(strings.ToUpper(&amp;quot;ā á ǎ à&amp;quot;))
fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, &amp;quot;一&amp;quot;))
fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, &amp;quot;hello world&amp;quot;))
fmt.Println(strings.ToUpper(&amp;quot;örnek iş&amp;quot;))
fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, &amp;quot;örnek iş&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello world
ā á ǎ à
壹
hello world
önnek iş
önnek iş
HELLO WORLD
Ā Á Ǎ À       // 汉字拼音有效
一           //  汉字无效
HELLO WORLD
ÖRNEK IŞ
ÖRNEK İŞ    // 有细微差别
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标题处理&#34;&gt;标题处理&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;func Title(s string) string
func ToTitle(s string) string
func ToTitleSpecial(c unicode.SpecialCase, s string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标题处理包含 3 个相关函数，其中 Title 会将 s 每个单词的首字母大写，不处理该单词的后续字符。ToTitle 将 s 的每个字母大写。ToTitleSpecial 将 s 的每个字母大写，并且会将一些特殊字母转换为其对应的特殊大写字母。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(strings.Title(&amp;quot;hElLo wOrLd&amp;quot;))
fmt.Println(strings.ToTitle(&amp;quot;hElLo wOrLd&amp;quot;))
fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, &amp;quot;hElLo wOrLd&amp;quot;))
fmt.Println(strings.Title(&amp;quot;āáǎà ōóǒò êēéěè&amp;quot;))
fmt.Println(strings.ToTitle(&amp;quot;āáǎà ōóǒò êēéěè&amp;quot;))
fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, &amp;quot;āáǎà ōóǒò êēéěè&amp;quot;))
fmt.Println(strings.Title(&amp;quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&amp;quot;))
fmt.Println(strings.ToTitle(&amp;quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&amp;quot;))
fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, &amp;quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HElLo WOrLd
HELLO WORLD
HELLO WORLD
Āáǎà Ōóǒò Êēéěè
ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ
ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ
Dünyanın Ilk Borsa Yapısı Aizonai Kabul Edilir
DÜNYANIN ILK BORSA YAPISI AIZONAI KABUL EDILIR
DÜNYANIN İLK BORSA YAPISI AİZONAİ KABUL EDİLİR
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;修剪&#34;&gt;修剪&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉
func Trim(s string, cutset string) string
// 将 s 左侧的匹配 cutset 中的任一字符的字符去掉
func TrimLeft(s string, cutset string) string
// 将 s 右侧的匹配 cutset 中的任一字符的字符去掉
func TrimRight(s string, cutset string) string
// 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。
func TrimPrefix(s, prefix string) string
// 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。
func TrimSuffix(s, suffix string) string
// 将 s 左侧和右侧的间隔符去掉。常见间隔符包括：&#39;\t&#39;, &#39;\n&#39;, &#39;\v&#39;, &#39;\f&#39;, &#39;\r&#39;, &#39; &#39;, U+0085 (NEL)
func TrimSpace(s string) string
// 将 s 左侧和右侧的匹配 f 的字符去掉
func TrimFunc(s string, f func(rune) bool) string
// 将 s 左侧的匹配 f 的字符去掉
func TrimLeftFunc(s string, f func(rune) bool) string
// 将 s 右侧的匹配 f 的字符去掉
func TrimRightFunc(s string, f func(rune) bool) string
包含了 9 个相关函数用于修剪字符串。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x := &amp;quot;!!!@@@你好,!@#$ Gophers###$$$&amp;quot;
fmt.Println(strings.Trim(x, &amp;quot;@#$!%^&amp;amp;*()_+=-&amp;quot;))
fmt.Println(strings.TrimLeft(x, &amp;quot;@#$!%^&amp;amp;*()_+=-&amp;quot;))
fmt.Println(strings.TrimRight(x, &amp;quot;@#$!%^&amp;amp;*()_+=-&amp;quot;))
fmt.Println(strings.TrimSpace(&amp;quot; \t\n Hello, Gophers \n\t\r\n&amp;quot;))
fmt.Println(strings.TrimPrefix(x, &amp;quot;!&amp;quot;))
fmt.Println(strings.TrimSuffix(x, &amp;quot;$&amp;quot;))

f := func(r rune) bool {
    return !unicode.Is(unicode.Han, r) // 非汉字返回 true
}
fmt.Println(strings.TrimFunc(x, f))
fmt.Println(strings.TrimLeftFunc(x, f))
fmt.Println(strings.TrimRightFunc(x, f))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;你好,!@#$ Gophers
你好,!@#$ Gophers###$$$
!!!@@@你好,!@#$ Gophers
Hello, Gophers
!!@@@你好,!@#$ Gophers###$$$
!!!@@@你好,!@#$ Gophers###$$
你好
你好,!@#$ Gophers###$$$
!!!@@@你好
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;类型&#34;&gt;类型&lt;/h1&gt;

&lt;h2 id=&#34;replacer-类型&#34;&gt;Replacer 类型&lt;/h2&gt;

&lt;p&gt;这是一个结构，没有导出任何字段，实例化通过 func NewReplacer(oldnew &amp;hellip;string) *Replacer 函数进行，其中不定参数 oldnew 是 old-new 对，即进行多个替换。如果 oldnew 长度与奇数，会导致 panic.&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r := strings.NewReplacer(&amp;quot;&amp;lt;&amp;quot;, &amp;quot;&amp;amp;lt;&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, &amp;quot;&amp;amp;gt;&amp;quot;)
fmt.Println(r.Replace(&amp;quot;This is &amp;lt;b&amp;gt;HTML&amp;lt;/b&amp;gt;!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is &amp;amp;lt;b&amp;amp;gt;HTML&amp;amp;lt;/b&amp;amp;gt;!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，Replacer 还提供了另外一个方法，它在替换之后将结果写入 io.Writer 中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reader-类型&#34;&gt;Reader 类型&lt;/h2&gt;

&lt;p&gt;看到名字就能猜到，这是实现了 io 包中的接口。其实这就是缓存io，对缓存中的string进行读写操作。&lt;/p&gt;

&lt;p&gt;它实现了 io.Reader（Read 方法），io.ReaderAt（ReadAt 方法），io.Seeker（Seek 方法），io.WriterTo（WriteTo 方法），io.ByteReader（ReadByte 方法），io.ByteScanner（ReadByte 和 UnreadByte 方法），io.RuneReader（ReadRune 方法） 和 io.RuneScanner（ReadRune 和 UnreadRune 方法）。&lt;/p&gt;

&lt;p&gt;Reader 结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Reader struct {
    s        string    // Reader 读取的数据来源
    i        int // current reading index（当前读的索引位置）
    prevRune int // index of previous rune; or &amp;lt; 0（前一个读取的 rune 索引位置）
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见 Reader 结构没有导出任何字段，而是提供一个实例化方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewReader(s string) *Reader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法接收一个字符串，返回的 Reader 实例就是从该参数字符串读数据。&lt;/p&gt;

&lt;p&gt;在后面学习了 &lt;a href=&#34;https://kingjcy.github.io/post/golang/go-bytes/#reader-类型&#34;&gt;bytes&lt;/a&gt; 包之后，可以知道 bytes.NewBufferString 有类似的功能，不过，如果只是为了读取，NewReader 会更高效。&lt;/p&gt;

&lt;h2 id=&#34;builder-类型&#34;&gt;Builder 类型&lt;/h2&gt;

&lt;p&gt;这个类型也是缓存io的一种实现方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Builder struct {
    addr *Builder // of receiver, to detect copies by value
    buf  []byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该类型实现了 io 包下的 Writer, ByteWriter, StringWriter 等接口，可以向该对象内写入数据，Builder 没有实现 Reader 等接口，所以该类型不可读，但提供了 String 方法可以获取对象内的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 该方法向 b 写入一个字节
func (b *Builder) WriteByte(c byte) error
// WriteRune 方法向 b 写入一个字符
func (b *Builder) WriteRune(r rune) (int, error)
// WriteRune 方法向 b 写入字节数组 p
func (b *Builder) Write(p []byte) (int, error)
// WriteRune 方法向 b 写入字符串 s
func (b *Builder) WriteString(s string) (int, error)
// Len 方法返回 b 的数据长度。
func (b *Builder) Len() int
// Cap 方法返回 b 的 cap。
func (b *Builder) Cap() int
// Grow 方法将 b 的 cap 至少增加 n (可能会更多)。如果 n 为负数，会导致 panic。
func (b *Builder) Grow(n int)
// Reset 方法将 b 清空 b 的所有内容。
func (b *Builder) Reset()
// String 方法将 b 的数据以 string 类型返回。
func (b *Builder) String() string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Builder 有 4 个与写入相关的方法，这 4 个方法的 error 都总是为 nil.&lt;/p&gt;

&lt;p&gt;Builder 的 cap 会自动增长，一般不需要手动调用 Grow 方法。&lt;/p&gt;

&lt;p&gt;String 方法可以方便的获取 Builder 的内容。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b := strings.Builder{}
_ = b.WriteByte(&#39;7&#39;)
n, _ := b.WriteRune(&#39;夕&#39;)
fmt.Println(n)
n, _ = b.Write([]byte(&amp;quot;Hello, World&amp;quot;))
fmt.Println(n)
n, _ = b.WriteString(&amp;quot;你好，世界&amp;quot;)
fmt.Println(n)
fmt.Println(b.Len())
fmt.Println(b.Cap())
b.Grow(100)
fmt.Println(b.Len())
fmt.Println(b.Cap())
fmt.Println(b.String())
b.Reset()
fmt.Println(b.String())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3
12
15
31
32
31
164
7夕Hello, World你好，世界
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这边主要是要注意，使用返回值作为新值，原来值是不变的。&lt;/strong&gt;&lt;/p&gt;</description>
        </item>
      
    
      
        <item>
          <title>Golang使用系列---- Io</title>
          <link>https://kingjcy.github.io/post/golang/go-io/</link>
          <pubDate>Sat, 30 Jul 2016 20:39:03 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/golang/go-io/</guid>
          <description>&lt;p&gt;io包提供了所有需要交互的输入输出模式的基础。&lt;/p&gt;

&lt;h1 id=&#34;基本概念&#34;&gt;基本概念&lt;/h1&gt;

&lt;h2 id=&#34;stream&#34;&gt;stream&lt;/h2&gt;

&lt;p&gt;我们先介绍一下stream的概念。stream就是数据流，数据流的概念其实非常基础，最早是在通讯领域使用的概念，这个概念最初在 1998 年由 Henzinger 在文献中提出，他将数据流定义为 “只能以事先规定好的顺序被读取一次的数据的一个序列”&lt;/p&gt;

&lt;p&gt;数据流就是由数据形成的流，就像由水形成的水流，非常形象，现代语言中，基本上都会有流的支持，比如 C++ 的 iostream，Node.js 的 stream 模块，以及 golang 的 io 包。&lt;/p&gt;

&lt;p&gt;Stream in Golang与流密切相关的就是 bufio io io/ioutil 这几个包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、io 为 IO 原语（I/O primitives）提供基本的接口
2、io/ioutil 封装一些实用的 I/O 函数
3、fmt 实现格式化 I/O，类似 C 语言中的 printf 和 scanf
4、bufio 实现带缓冲I/O
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;io&#34;&gt;io&lt;/h2&gt;

&lt;p&gt;io 包为 I/O 原语提供了基本的接口。在 io 包中最重要的是两个接口：Reader 和 Writer 接口。本章所提到的各种 IO 包，都跟这两个接口有关，也就是说，只要满足这两个接口，它就可以使用 IO 包的功能。&lt;/p&gt;

&lt;h1 id=&#34;接口&#34;&gt;接口&lt;/h1&gt;

&lt;h2 id=&#34;读取器&#34;&gt;读取器&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;type Reader interface {
    //Read() 方法有两个返回值，一个是读取到的字节数，一个是发生错误时的错误。如果资源内容已全部读取完毕，应该返回 io.EOF 错误。
    Read(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;io.Reader 表示一个读取器，它将数据从某个资源读取到传输缓冲区p。在缓冲区中，数据可以被流式传输和使用。&lt;/p&gt;

&lt;p&gt;实现这个接口需要实现如下功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)） 以及任何遇到的错误。

&lt;ul&gt;
&lt;li&gt;即使 Read 返回的 n &amp;lt; len(p)，它也会在调用过程中占用 len(p) 个字节作为暂存空间。&lt;/li&gt;
&lt;li&gt;若可读取的数据不到 len(p) 个字节，Read 会返回可用数据，而不是等待更多数据。&lt;/li&gt;
&lt;li&gt;当读取的时候没有数据也没有EOF的时候，会阻塞在这边等待。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当 Read 在成功读取 n &amp;gt; 0 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数。

&lt;ul&gt;
&lt;li&gt;它可能会同时在本次的调用中返回一个non-nil错误,或在下一次的调用中返回这个错误（且 n 为 0）。&lt;/li&gt;
&lt;li&gt;一般情况下, Reader会返回一个非0字节数n, 若 n = len(p) 个字节从输入源的结尾处由 Read 返回，Read可能返回 err == EOF 或者 err == nil。并且之后的 Read() 都应该返回 (n:0, err:EOF)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许EOF的出现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于要用作读取器的类型，它必须实现 io.Reader 接口的唯一一个方法 Read(p []byte)。换句话说，只要实现了 Read(p []byte) ，那它就是一个读取器，使用标准库中已经实现的读写器，来举例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    reader := strings.NewReader(&amp;quot;Clear is better than clever&amp;quot;)
    p := make([]byte, 4)

    for {
        n, err := reader.Read(p)
        if err != nil{
            if err == io.EOF {
                fmt.Println(&amp;quot;EOF:&amp;quot;, n)
                break
            }
            fmt.Println(err)
            os.Exit(1)
        }
        fmt.Println(n, string(p[:n]))
    }
}

输出打印的内容：

4 Clea
4 r is
4  bet
4 ter 
4 than
4  cle
3 ver
EOF: 0 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自定义reader&#34;&gt;自定义Reader&lt;/h3&gt;

&lt;p&gt;现在，让我们看看如何自己实现一个。它的功能是从流中过滤掉非字母字符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type alphaReader struct {
    // 资源
    src string
    // 当前读取到的位置 
    cur int
}

// 创建一个实例
func newAlphaReader(src string) *alphaReader {
    return &amp;amp;alphaReader{src: src}
}

// 过滤函数
func alpha(r byte) byte {
    if (r &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;Z&#39;) || (r &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;z&#39;) {
        return r
    }
    return 0
}

// Read 方法，read函数是阻塞的
func (a *alphaReader) Read(p []byte) (int, error) {
    // 当前位置 &amp;gt;= 字符串长度 说明已经读取到结尾 返回 EOF
    if a.cur &amp;gt;= len(a.src) {
        return 0, io.EOF
    }

    // x 是剩余未读取的长度
    x := len(a.src) - a.cur
    n, bound := 0, 0
    if x &amp;gt;= len(p) {
        // 剩余长度超过缓冲区大小，说明本次可完全填满缓冲区
        bound = len(p)
    } else if x &amp;lt; len(p) {
        // 剩余长度小于缓冲区大小，使用剩余长度输出，缓冲区不补满
        bound = x
    }

    buf := make([]byte, bound)
    for n &amp;lt; bound {
        // 每次读取一个字节，执行过滤函数
        if char := alpha(a.src[a.cur]); char != 0 {
            buf[n] = char
        }
        n++
        a.cur++
    }
    // 将处理后得到的 buf 内容复制到 p 中
    copy(p, buf)
    return n, nil
}

func main() {
    reader := newAlphaReader(&amp;quot;Hello! It&#39;s 9am, where is the sun?&amp;quot;)
    p := make([]byte, 4)
    for {
        n, err := reader.Read(p)
        if err == io.EOF {
            break
        }
        fmt.Print(string(p[:n]))
    }
    fmt.Println()
}
输出打印的内容：
HelloItsamwhereisthesun
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tcp粘包拆包&#34;&gt;TCP粘包拆包&lt;/h3&gt;

&lt;p&gt;这边讲解一下TCP粘包拆包问题，先看下面这个实例&lt;/p&gt;

&lt;p&gt;服务端代码 server/main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:4044&amp;quot;)
    if err != nil {
        panic(err)
    }
    fmt.Println(&amp;quot;listen to 4044&amp;quot;)
    for {
        // 监听到新的连接，创建新的 goroutine 交给 handleConn函数 处理
        conn, err := l.Accept()
        if err != nil {
            fmt.Println(&amp;quot;conn err:&amp;quot;, err)
        } else {
            go handleConn(conn)
        }
    }
}

func handleConn(conn net.Conn) {
    defer conn.Close()
    defer fmt.Println(&amp;quot;关闭&amp;quot;)
    fmt.Println(&amp;quot;新连接：&amp;quot;, conn.RemoteAddr())

    result := bytes.NewBuffer(nil)
    var buf [1024]byte
    for {
        n, err := conn.Read(buf[0:])
        result.Write(buf[0:n])
        if err != nil {
            if err == io.EOF {
                continue
            } else {
                fmt.Println(&amp;quot;read err:&amp;quot;, err)
                break
            }
        } else {
            fmt.Println(&amp;quot;recv:&amp;quot;, result.String())
        }
        result.Reset()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端代码 client/main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    data := []byte(&amp;quot;[这里才是一个完整的数据包]&amp;quot;)
    conn, err := net.DialTimeout(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:4044&amp;quot;, time.Second*30)
    if err != nil {
        fmt.Printf(&amp;quot;connect failed, err : %v\n&amp;quot;, err.Error())
        return
    }
    for i := 0; i &amp;lt;1000; i++ {
        _, err = conn.Write(data)
        if err != nil {
            fmt.Printf(&amp;quot;write failed , err : %v\n&amp;quot;, err)
            break
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;listen to 4044
新连接： [::1]:53079
recv: [这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据�
recv: �][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
...省略其它的...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从服务端的控制台输出可以看出，存在三种类型的输出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种是正常的一个数据包输出。&lt;/li&gt;
&lt;li&gt;一种是多个数据包“粘”在了一起，我们定义这种读到的包为粘包。&lt;/li&gt;
&lt;li&gt;一种是一个数据包被“拆”开，形成一个破碎的包，我们定义这种包为半包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么会出现半包和粘包？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端一段时间内发送包的速度太多，服务端没有全部处理完。于是数据就会积压起来，产生粘包。&lt;/li&gt;
&lt;li&gt;定义的读的buffer不够大，而数据包太大或者由于粘包产生，服务端不能一次全部读完，产生半包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;什么时候需要考虑处理半包和粘包？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP连接是长连接，即一次连接多次发送数据。&lt;/li&gt;
&lt;li&gt;每次发送的数据是结构的，比如 JSON格式的数据 或者 数据包的协议是由我们自己定义的（包头部包含实际数据长度、协议魔数等）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决思路&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定长分隔(每个数据包最大为该长度，不足时使用特殊字符填充) ，但是数据不足时会浪费传输资源&lt;/li&gt;
&lt;li&gt;使用特定字符来分割数据包，但是若数据中含有分割字符则会出现Bug&lt;/li&gt;
&lt;li&gt;在数据包中添加长度字段，弥补了以上两种思路的不足，推荐使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过上述分析，我们最好通过第三种思路来解决拆包粘包问题。&lt;/p&gt;

&lt;p&gt;Golang的bufio库中有为我们提供了Scanner，来解决这类分割数据的问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Scanner
Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the &#39;tokens&#39; of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单来讲即是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scanner为 读取数据 提供了方便的 接口。连续调用Scan方法会逐个得到文件的“tokens”，跳过 tokens 之间的字节。token 的规范由 SplitFunc 类型的函数定义。我们可以改为提供自定义拆分功能。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来看看 SplitFunc 类型的函数是什么样子的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    // An artificial input source.
    const input = &amp;quot;1234 5678 1234567901234567890&amp;quot;
    scanner := bufio.NewScanner(strings.NewReader(input))
    // Create a custom split function by wrapping the existing ScanWords function.
    split := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
        advance, token, err = bufio.ScanWords(data, atEOF)
        if err == nil &amp;amp;&amp;amp; token != nil {
            _, err = strconv.ParseInt(string(token), 10, 32)
        }
        return
    }
    // Set the split function for the scanning operation.
    scanner.Split(split)
    // Validate the input
    for scanner.Scan() {
        fmt.Printf(&amp;quot;%s\n&amp;quot;, scanner.Text())
    }

    if err := scanner.Err(); err != nil {
        fmt.Printf(&amp;quot;Invalid input: %s&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，我们可以这样改写我们的程序：&lt;/p&gt;

&lt;p&gt;服务端代码 server/main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:4044&amp;quot;)
    if err != nil {
        panic(err)
    }
    fmt.Println(&amp;quot;listen to 4044&amp;quot;)
    for {
        conn, err := l.Accept()
        if err != nil {
            fmt.Println(&amp;quot;conn err:&amp;quot;, err)
        } else {
            go handleConn2(conn)
        }
    }
}

func packetSlitFunc(data []byte, atEOF bool) (advance int, token []byte, err error) {
        // 检查 atEOF 参数 和 数据包头部的四个字节是否 为 0x123456(我们定义的协议的魔数)
    if !atEOF &amp;amp;&amp;amp; len(data) &amp;gt; 6 &amp;amp;&amp;amp; binary.BigEndian.Uint32(data[:4]) == 0x123456 {
        var l int16
                // 读出 数据包中 实际数据 的长度(大小为 0 ~ 2^16)
        binary.Read(bytes.NewReader(data[4:6]), binary.BigEndian, &amp;amp;l)
        pl := int(l) + 6
        if pl &amp;lt;= len(data) {
            return pl, data[:pl], nil
        }
    }
    return
}

func handleConn2(conn net.Conn) {
    defer conn.Close()
    defer fmt.Println(&amp;quot;关闭&amp;quot;)
    fmt.Println(&amp;quot;新连接：&amp;quot;, conn.RemoteAddr())
    result := bytes.NewBuffer(nil)
        var buf [65542]byte // 由于 标识数据包长度 的只有两个字节 故数据包最大为 2^16+4(魔数)+2(长度标识)
    for {
        n, err := conn.Read(buf[0:])
        result.Write(buf[0:n])
        if err != nil {
            if err == io.EOF {
                continue
            } else {
                fmt.Println(&amp;quot;read err:&amp;quot;, err)
                break
            }
        } else {
            scanner := bufio.NewScanner(result)
            scanner.Split(packetSlitFunc)
            for scanner.Scan() {
                fmt.Println(&amp;quot;recv:&amp;quot;, string(scanner.Bytes()[6:]))
            }
        }
        result.Reset()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制代码客户端代码 client/main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    data := []byte(&amp;quot;[这里才是一个完整的数据包]&amp;quot;)
    l := len(data)
    fmt.Println(l)
    magicNum := make([]byte, 4)
    binary.BigEndian.PutUint32(magicNum, 0x123456)
    lenNum := make([]byte, 2)
    binary.BigEndian.PutUint16(lenNum, uint16(l))
    packetBuf := bytes.NewBuffer(magicNum)
    packetBuf.Write(lenNum)
    packetBuf.Write(data)
    conn, err := net.DialTimeout(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:4044&amp;quot;, time.Second*30)
    if err != nil {
        fmt.Printf(&amp;quot;connect failed, err : %v\n&amp;quot;, err.Error())
                return
    }
    for i := 0; i &amp;lt;1000; i++ {
        _, err = conn.Write(packetBuf.Bytes())
        if err != nil {
            fmt.Printf(&amp;quot;write failed , err : %v\n&amp;quot;, err)
            break
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制代码运行结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;listen to 4044
新连接： [::1]:55738
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
...省略其它的...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编写器&#34;&gt;编写器&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;type Writer
type Writer interface {
    //Write() 方法有两个返回值，一个是写入到目标资源的字节数，一个是发生错误时的错误。
    Write(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;io.Writer 表示一个编写器，它从缓冲区读取数据，并将数据写入目标资源。&lt;/p&gt;

&lt;p&gt;实现这个接口就需要实现如下的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n &amp;lt; len(p)，它就必须返回一个 非nil 的错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于要用作编写器的类型，必须实现 io.Writer 接口的唯一一个方法 Write(p []byte),同样，只要实现了 Write(p []byte) ，那它就是一个编写器。举例，标准库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    proverbs := []string{
        &amp;quot;Channels orchestrate mutexes serialize&amp;quot;,
        &amp;quot;Cgo is not Go&amp;quot;,
        &amp;quot;Errors are values&amp;quot;,
        &amp;quot;Don&#39;t panic&amp;quot;,
    }
    var writer bytes.Buffer

    for _, p := range proverbs {
        n, err := writer.Write([]byte(p))
        if err != nil {
            fmt.Println(err)
            os.Exit(1)
        }
        if n != len(p) {
            fmt.Println(&amp;quot;failed to write data&amp;quot;)
            os.Exit(1)
        }
    }

    fmt.Println(writer.String())
}
输出打印的内容：
Channels orchestrate mutexes serializeCgo is not GoErrors are valuesDon&#39;t panic
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自定义writer&#34;&gt;自定义Writer&lt;/h3&gt;

&lt;p&gt;下面我们来实现一个名为 chanWriter 的自定义 io.Writer ，它将其内容作为字节序列写入 channel 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type chanWriter struct {
    // ch 实际上就是目标资源
    ch chan byte
}

func newChanWriter() *chanWriter {
    return &amp;amp;chanWriter{make(chan byte, 1024)}
}

func (w *chanWriter) Chan() &amp;lt;-chan byte {
    return w.ch
}

func (w *chanWriter) Write(p []byte) (int, error) {
    n := 0
    // 遍历输入数据，按字节写入目标资源
    for _, b := range p {
        w.ch &amp;lt;- b
        n++
    }
    return n, nil
}

func (w *chanWriter) Close() error {
    close(w.ch)
    return nil
}

func main() {
    writer := newChanWriter()
    go func() {
        defer writer.Close()
        writer.Write([]byte(&amp;quot;Stream &amp;quot;))
        writer.Write([]byte(&amp;quot;me!&amp;quot;))
    }()
    for c := range writer.Chan() {
        fmt.Printf(&amp;quot;%c&amp;quot;, c)
    }
    fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要使用这个 Writer，只需在函数 main() 中调用 writer.Write()（在单独的goroutine中）。&lt;/p&gt;

&lt;p&gt;因为 chanWriter 还实现了接口 io.Closer ，所以调用方法 writer.Close() 来正确地关闭channel，以避免发生泄漏和死锁。&lt;/p&gt;

&lt;h2 id=&#34;closer&#34;&gt;closer&lt;/h2&gt;

&lt;p&gt;Closer 接口包装了基本的 Close 方法，用于关闭数据读写。Close 一般用于关闭文件，关闭通道，关闭连接，关闭数据库等，在不同的标准库实现中实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Closer interface {
    Close() error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;seeker&#34;&gt;seeker&lt;/h2&gt;

&lt;p&gt;Seeker 接口包装了基本的 Seek 方法，用于移动数据的读写指针。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Seeker interface {
    Seek(offset int64, whence int) (ret int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seek 设置下一次读写操作的指针位置，每次的读写操作都是从指针位置开始的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;whence 的含义：

&lt;ul&gt;
&lt;li&gt;如果 whence 为 0：表示从数据的开头开始移动指针。&lt;/li&gt;
&lt;li&gt;如果 whence 为 1：表示从数据的当前指针位置开始移动指针。&lt;/li&gt;
&lt;li&gt;如果 whence 为 2：表示从数据的尾部开始移动指针。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;offset 是指针移动的偏移量。&lt;/li&gt;
&lt;li&gt;返回新指针位置和遇到的错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;whence 的值，在 io 包中定义了相应的常量，应该使用这些常量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const (
  SeekStart   = 0 // seek relative to the origin of the file
  SeekCurrent = 1 // seek relative to the current offset
  SeekEnd     = 2 // seek relative to the end
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而原先 os 包中的常量已经被标注为Deprecated&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.
const (
  SEEK_SET int = 0 // seek relative to the origin of the file
  SEEK_CUR int = 1 // seek relative to the current offset
  SEEK_END int = 2 // seek relative to the end
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;组合接口&#34;&gt;组合接口&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;type ReadWriter interface {
    Reader
    Writer
}

type ReadSeeker interface {
    Reader
    Seeker
}

type WriteSeeker interface {
    Writer
    Seeker
}

type ReadWriteSeeker interface {
    Reader
    Writer
    Seeker
}

type ReadCloser interface {
    Reader
    Closer
}

type WriteCloser interface {
    Writer
    Closer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。可见，io 包中有大量的“小接口”，这样方便组合为“大接口”。&lt;/p&gt;

&lt;h2 id=&#34;其他接口&#34;&gt;其他接口&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;ReaderFrom&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ReaderFrom 接口包装了基本的 ReadFrom 方法，用于从 r 中读取数据存入自身。直到遇到 EOF 或读取出错为止，返回读取的字节数和遇到的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ReaderFrom interface {
    ReadFrom(r Reader) (n int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要实现接口的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。其返回值 n 为读取的字节数。除 io.EOF 之外，在读取过程中遇到的任何错误也将被返回。&lt;/li&gt;
&lt;li&gt;如果 ReaderFrom 可用，Copy 函数就会使用它。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实例：将文件中的数据全部读取（显示在标准输出）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file, err := os.Open(&amp;quot;writeAt.txt&amp;quot;)
if err != nil {
    panic(err)
}
defer file.Close()
writer := bufio.NewWriter(os.Stdout)
writer.ReadFrom(file)
writer.Flush()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，我们可以通过 ioutil 包的 ReadFile 函数获取文件全部内容。其实，跟踪一下 ioutil.ReadFile 的源码，会发现其实也是通过 ReadFrom 方法实现（用的是 bytes.Buffer，它实现了 ReaderFrom 接口）。&lt;/p&gt;

&lt;p&gt;如果不通过 ReadFrom 接口来做这件事，而是使用 io.Reader 接口，我们有两种思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先获取文件的大小（File 的 Stat 方法），之后定义一个该大小的 []byte，通过 Read 一次性读取&lt;/li&gt;
&lt;li&gt;定义一个小的 []byte，不断的调用 Read 方法直到遇到 EOF，将所有读取到的 []byte 连接到一起&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;WriterTo&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;WriterTo 接口包装了基本的 WriteTo 方法，用于将自身的数据写入 w 中。直到数据全部写入完毕或遇到错误为止，返回写入的字节数和遇到的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type WriterTo interface {
    WriteTo(w Writer) (n int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要实现接口的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。&lt;/li&gt;
&lt;li&gt;如果 WriterTo 可用，Copy 函数就会使用它。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读者是否发现，其实 ReaderFrom 和 WriterTo 接口的方法接收的参数是 io.Reader 和 io.Writer 类型。根据 io.Reader 和 io.Writer 接口的讲解，对该接口的使用应该可以很好的掌握。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ReaderAt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ReaderAt 接口包装了基本的 ReadAt 方法，用于将自身的数据写入 p 中。ReadAt 忽略之前的读写位置，从起始位置的 off 偏移处开始读取。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ReaderAt interface {
    ReadAt(p []byte, off int64) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要实现接口的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的错误。&lt;/li&gt;
&lt;li&gt;当 ReadAt 返回的 n &amp;lt; len(p) 时，它就会返回一个 非nil 的错误来解释 为什么没有返回更多的字节。在这一点上，ReadAt 比 Read 更严格。&lt;/li&gt;
&lt;li&gt;即使 ReadAt 返回的 n &amp;lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若可读取的数据不到 len(p) 字节，ReadAt 就会阻塞,直到所有数据都可用或一个错误发生。 在这一点上 ReadAt 不同于 Read。&lt;/li&gt;
&lt;li&gt;若 n = len(p) 个字节从输入源的结尾处由 ReadAt 返回，Read可能返回 err == EOF 或者 err == nil&lt;/li&gt;
&lt;li&gt;若 ReadAt 携带一个偏移量从输入源读取，ReadAt 应当既不影响偏移量也不被它所影响。&lt;/li&gt;
&lt;li&gt;可对相同的输入源并行执行 ReadAt 调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标准库上面说的很多都是实现了这个接口，简单示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reader := strings.NewReader(&amp;quot;Go语言中文网&amp;quot;)
p := make([]byte, 6)
n, err := reader.ReadAt(p, 2)
if err != nil {
    panic(err)
}
fmt.Printf(&amp;quot;%s, %d\n&amp;quot;, p, n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;语言, 6
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;WriterAt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;WriterAt 接口包装了基本的 WriteAt 方法，用于将 p 中的数据写入自身。ReadAt 忽略之前的读写位置，从起始位置的 off 偏移处开始写入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type WriterAt interface {
    WriteAt(p []byte, off int64) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要实现接口的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。它返回从 p 中被写入的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 WriteAt 返回的 n &amp;lt; len(p)，它就必须返回一个 非nil 的错误。&lt;/li&gt;
&lt;li&gt;若 WriteAt 携带一个偏移量写入到目标中，WriteAt 应当既不影响偏移量也不被它所影响。&lt;/li&gt;
&lt;li&gt;若被写区域没有重叠，可对相同的目标并行执行 WriteAt 调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;os.File 实现了 WriterAt 接口，实例如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file, err := os.Create(&amp;quot;writeAt.txt&amp;quot;)
if err != nil {
    panic(err)
}
defer file.Close()
file.WriteString(&amp;quot;Golang中文社区——这里是多余&amp;quot;)
n, err := file.WriteAt([]byte(&amp;quot;Go语言中文网&amp;quot;), 24)
if err != nil {
    panic(err)
}
fmt.Println(n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Golang中文社区——Go语言中文网。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析：file.WriteString(&amp;ldquo;Golang中文社区——这里是多余&amp;rdquo;) 往文件中写入 Golang中文社区——这里是多余，之后 file.WriteAt([]byte(&amp;ldquo;Go语言中文网&amp;rdquo;), 24) 在文件流的 offset=24 处写入 Go语言中文网（会覆盖该位置的内容）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ByteReader和ByteWriter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ByteReader 接口包装了基本的 ReadByte 方法，用于从自身读出一个字节。返回读出的字节和遇到的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ByteReader interface {
    ReadByte() (c byte, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ByteWriter 接口包装了基本的 WriteByte 方法，用于将一个字节写入自身返回遇到的错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ByteWriter interface {
    WriteByte(c byte) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这组接口在标准库中也有实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bufio.Reader/Writer 分别实现了io.ByteReader 和 io.ByteWriter
bytes.Buffer 同时实现了 io.ByteReader 和 io.ByteWriter
bytes.Reader 实现了 io.ByteReader
strings.Reader 实现了 io.ByteReader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ch byte
fmt.Scanf(&amp;quot;%c\n&amp;quot;, &amp;amp;ch)

buffer := new(bytes.Buffer)
err := buffer.WriteByte(ch)
if err == nil {
    fmt.Println(&amp;quot;写入一个字节成功！准备读取该字节……&amp;quot;)
    newCh, _ := buffer.ReadByte()
    fmt.Printf(&amp;quot;读取的字节：%c\n&amp;quot;, newCh)
} else {
    fmt.Println(&amp;quot;写入错误&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;ByteScanner&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ByteScanner 在 ByteReader 的基础上增加了一个 UnreadByte 方法，用于撤消最后一次的 ReadByte 操作，以便下次的 ReadByte 操作可以读出与前一次一样的数据。UnreadByte 之前必须是 ReadByte 才能撤消成功，否则可能会返回一个错误信息（根据不同的需求，UnreadByte 也可能返回 nil，允许随意调用 UnreadByte，但只有最后一次的 ReadByte 可以被撤销，其它 UnreadByte 不执行任何操作）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ByteScanner interface {
    ByteReader
    UnreadByte() error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;RuneReader&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RuneReader 接口包装了基本的 ReadRune 方法，用于从自身读取一个 UTF-8 编码的字符到 r 中。返回读取的字符、字符的编码长度和遇到的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type RuneReader interface {
    ReadRune() (r rune, size int, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;RuneScanner&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RuneScanner 在 RuneReader 的基础上增加了一个 UnreadRune 方法，用于撤消最后一次的 ReadRune 操作，以便下次的 ReadRune 操作可以读出与前一次一样的数据。UnreadRune 之前必须是 ReadRune 才能撤消成功，否则可能会返回一个错误信息（根据不同的需求，UnreadRune 也可能返回 nil，允许随意调用 UnreadRune，但只有最后一次的 ReadRune 可以被撤销，其它 UnreadRune 不执行任何操作）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type RuneScanner interface {
    RuneReader
    UnreadRune() error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;

&lt;p&gt;bytes.NewBuffer 实现了很多基本的接口，可以通过 bytes 包学习接口的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    buf := bytes.NewBuffer([]byte(&amp;quot;Hello World!&amp;quot;))
    b := make([]byte, buf.Len())

    n, err := buf.Read(b)
    fmt.Printf(&amp;quot;%s   %v\n&amp;quot;, b[:n], err)
    // Hello World!   &amp;lt;nil&amp;gt;

    buf.WriteString(&amp;quot;ABCDEFG\n&amp;quot;)
    buf.WriteTo(os.Stdout)
    // ABCDEFG

    n, err = buf.Write(b)
    fmt.Printf(&amp;quot;%d   %s   %v\n&amp;quot;, n, buf.String(), err)
    // 12   Hello World!   &amp;lt;nil&amp;gt;

    c, err := buf.ReadByte()
    fmt.Printf(&amp;quot;%c   %s   %v\n&amp;quot;, c, buf.String(), err)
    // H   ello World!   &amp;lt;nil&amp;gt;

    c, err = buf.ReadByte()
    fmt.Printf(&amp;quot;%c   %s   %v\n&amp;quot;, c, buf.String(), err)
    // e   llo World!   &amp;lt;nil&amp;gt;

    err = buf.UnreadByte()
    fmt.Printf(&amp;quot;%s   %v\n&amp;quot;, buf.String(), err)
    // ello World!   &amp;lt;nil&amp;gt;

    err = buf.UnreadByte()
    fmt.Printf(&amp;quot;%s   %v\n&amp;quot;, buf.String(), err)
    // ello World!   bytes.Buffer: UnreadByte: previous operation was not a read
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;类型&#34;&gt;类型&lt;/h1&gt;

&lt;p&gt;io包中定义了很多原生的类型。都是实现了上面的接口，可以直接创建使用的类型。&lt;/p&gt;

&lt;h2 id=&#34;sectionreader-类型&#34;&gt;SectionReader 类型&lt;/h2&gt;

&lt;p&gt;SectionReader 是一个 struct（没有任何导出的字段），实现了 Read, Seek 和 ReadAt，同时，内嵌了 ReaderAt 接口。结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SectionReader struct {
    r     ReaderAt    // 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现
    base  int64        // NewSectionReader 会将 base 设置为 off
    off   int64        // 从 r 中的 off 偏移处开始读取数据
    limit int64        // limit - off = SectionReader 流的长度
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从名称我们可以猜到，该类型读取数据流中部分数据。看一下常见的创建函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。也就是说，SectionReader 只是内部（内嵌）ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。&lt;/p&gt;

&lt;h2 id=&#34;limitedreader-类型&#34;&gt;LimitedReader 类型&lt;/h2&gt;

&lt;p&gt;LimitedReader 结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type LimitedReader struct {
    R Reader // underlying reader，最终的读取操作通过 R.Read 完成
    N int64  // max bytes remaining
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从 R 读取但将返回的数据量限制为 N 字节。每调用一次 Read 都将更新 N 来反应新的剩余数量。也就是说，最多只能返回 N 字节数据。LimitedReader 只实现了 Read 方法（Reader 接口）。&lt;/p&gt;

&lt;p&gt;使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;content := &amp;quot;This Is LimitReader Example&amp;quot;
reader := strings.NewReader(content)
limitReader := &amp;amp;io.LimitedReader{R: reader, N: 8}
for limitReader.N &amp;gt; 0 {
    tmp := make([]byte, 2)
    limitReader.Read(tmp)
    fmt.Printf(&amp;quot;%s&amp;quot;, tmp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This Is
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，通过该类型可以达到 只允许读取一定长度数据 的目的。&lt;/p&gt;

&lt;p&gt;在 io 包中，LimitReader 函数的实现其实就是调用 LimitedReader：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func LimitReader(r Reader, n int64) Reader { return &amp;amp;LimitedReader{r, n} }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pipereader-和-pipewriter-类型&#34;&gt;PipeReader 和 PipeWriter 类型&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;PipeReader&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PipeReader（一个没有任何导出字段的 struct）是管道的读取端。它实现了 io.Reader 和 io.Closer 接口。结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type PipeReader struct {
    p *pipe
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于 PipeReader.Read 方法的说明：从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 error（即调用 CloseWithError 关闭），该Read返回的 err 就是写入端传递的error；否则 err 为 EOF。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PipeWriter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PipeWriter（一个没有任何导出字段的 struct）是管道的写入端。它实现了 io.Writer 和 io.Closer 接口。结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type PipeWriter struct {
    p *pipe
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于 PipeWriter.Write 方法的说明：写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时带有 error（即调用 CloseWithError 关闭），该Write返回的 err 就是读取端传递的error；否则 err 为 ErrClosedPipe。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pipe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;io.Pipe() 用于创建一个同步的内存管道 (synchronous in-memory pipe)，函数签名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Pipe() (*PipeReader, *PipeWriter)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它将 io.Reader 连接到 io.Writer。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 Read 和 Write 以及其它函数或 Close 来说都是安全的。一旦等待的 I/O 结束，Close 就会完成。并行调用 Read 或并行调用 Write 也同样安全：同种类的调用将按顺序进行控制。&lt;/p&gt;

&lt;p&gt;正因为是同步的，因此不能在一个 goroutine 中进行读和写。&lt;/p&gt;

&lt;p&gt;读关闭管道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (r *PipeReader) Close() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读关闭管道并传入错误信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (r *PipeReader) CloseWithError(err error) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从管道中读取数据，如果管道被关闭，则会返会一个错误信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、如果写入端通过 CloseWithError 方法关闭了管道，则返回关闭时传入的错误信息。&lt;/li&gt;
&lt;li&gt;2、如果写入端通过 Close 方法关闭了管道，则返回 io.EOF。&lt;/li&gt;
&lt;li&gt;3、如果是读取端关闭了管道，则返回 io.ErrClosedPipe。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：管道（读取端关闭）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    r, w := io.Pipe()
    // 启用一个例程进行读取
    go func() {
        buf := make([]byte, 5)
        for n, err := 0, error(nil); err == nil; {
            n, err = r.Read(buf)
            r.CloseWithError(errors.New(&amp;quot;管道被读取端关闭&amp;quot;))
            fmt.Printf(&amp;quot;读取：%d, %v, %s\n&amp;quot;, n, err, buf[:n])
        }
    }()
    // 主例程进行写入
    n, err := w.Write([]byte(&amp;quot;Hello World !&amp;quot;))
    fmt.Printf(&amp;quot;写入：%d, %v\n&amp;quot;, n, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写关闭管道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (w *PipeWriter) Close() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写关闭管道并传入错误信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (w *PipeWriter) CloseWithError(err error) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;向管道中写入数据，如果管道被关闭，则会返会一个错误信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、如果读取端通过 CloseWithError 方法关闭了管道，则返回关闭时传入的错误信息。&lt;/li&gt;
&lt;li&gt;2、如果读取端通过 Close 方法关闭了管道，则返回 io.ErrClosedPipe。&lt;/li&gt;
&lt;li&gt;3、如果是写入端关闭了管道，则返回 io.ErrClosedPipe。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：管道（写入端关闭）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    r, w := io.Pipe()
    // 启用一个例程进行读取
    go func() {
        buf := make([]byte, 5)
        for n, err := 0, error(nil); err == nil; {
            n, err = r.Read(buf)
            fmt.Printf(&amp;quot;读取：%d, %v, %s\n&amp;quot;, n, err, buf[:n])
        }
    }()
    // 主例程进行写入
    n, err := w.Write([]byte(&amp;quot;Hello World !&amp;quot;))
    fmt.Printf(&amp;quot;写入：%d, %v\n&amp;quot;, n, err)

    w.CloseWithError(errors.New(&amp;quot;管道被写入端关闭&amp;quot;))
    n, err = w.Write([]byte(&amp;quot;Hello World !&amp;quot;))
    fmt.Printf(&amp;quot;写入：%d, %v\n&amp;quot;, n, err)
    time.Sleep(time.Second * 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;综合使用实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    pipeReader, pipeWriter := io.Pipe()
    go PipeWrite(pipeWriter)
    go PipeRead(pipeReader)
    time.Sleep(30 * time.Second)
}

func PipeWrite(writer *io.PipeWriter){
    data := []byte(&amp;quot;Go语言中文网&amp;quot;)
    for i := 0; i &amp;lt; 3; i++{
        n, err := writer.Write(data)
        if err != nil{
            fmt.Println(err)
            return
        }
        fmt.Printf(&amp;quot;写入字节 %d\n&amp;quot;,n)
    }
    writer.CloseWithError(errors.New(&amp;quot;写入段已关闭&amp;quot;))
}

func PipeRead(reader *io.PipeReader){
    buf := make([]byte, 128)
    for{
        fmt.Println(&amp;quot;接口端开始阻塞5秒钟...&amp;quot;)
        time.Sleep(5 * time.Second)
        fmt.Println(&amp;quot;接收端开始接受&amp;quot;)
        n, err := reader.Read(buf)
        if err != nil{
            fmt.Println(err)
            return
        }
        fmt.Printf(&amp;quot;收到字节: %d\n buf内容: %s\n&amp;quot;,n,buf)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;

&lt;p&gt;io包中也有一下原生实现可以使用的函数。其实都是直接操作结构体的函数。&lt;/p&gt;

&lt;h2 id=&#34;writestring&#34;&gt;WriteString&lt;/h2&gt;

&lt;p&gt;WriteString 将字符串 s 写入到 w 中，返回写入的字节数和遇到的错误。如果 w 实现了 WriteString 方法，则优先使用该方法将 s 写入 w 中。否则，将 s 转换为 []byte，然后调用 w.Write 方法将数据写入 w 中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func WriteString(w Writer, s string) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;readatleast&#34;&gt;ReadAtLeast&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;ReadAtLeast&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ReadAtLeast 从 r 中读取数据到 buf 中，要求至少读取 min 个字节。返回读取的字节数和遇到的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 min 超出了 buf 的容量，则 err 返回 io.ErrShortBuffer，否则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、读出的数据长度 == 0  ，则 err 返回 EOF。&lt;/li&gt;
&lt;li&gt;2、读出的数据长度 &amp;lt;  min，则 err 返回 io.ErrUnexpectedEOF。&lt;/li&gt;
&lt;li&gt;3、读出的数据长度 &amp;gt;= min，则 err 返回 nil。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;ReadFull&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ReadFull 的功能和 ReadAtLeast 一样，只不过 min = len(buf)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ReadFull(r Reader, buf []byte) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：WriteString、ReadAtLeast、ReadFull&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    io.WriteString(os.Stdout, &amp;quot;Hello World!\n&amp;quot;)
    // Hello World!

    r := strings.NewReader(&amp;quot;Hello World!&amp;quot;)
    b := make([]byte, 15)

    n, err := io.ReadAtLeast(r, b, 20)
    fmt.Printf(&amp;quot;%q   %d   %v\n&amp;quot;, b[:n], n, err)
    // &amp;quot;&amp;quot;   0   short buffer

    r.Seek(0, 0)
    b = make([]byte, 15)

    n, err = io.ReadFull(r, b)
    fmt.Printf(&amp;quot;%q   %d   %v\n&amp;quot;, b[:n], n, err)
    // &amp;quot;Hello World!&amp;quot;   12   unexpected EOF
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;LimitReader&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LimitReader 对 r 进行封装，使其最多只能读取 n 个字节的数据。相当于对 r 做了一个切片 r[:n] 返回。底层实现是一个 *LimitedReader（只有一个 Read 方法）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func LimitReader(r Reader, n int64) Reader
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;MultiReader&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MultiReader 将多个 Reader 封装成一个单独的 Reader，多个 Reader 会按顺序读取，当多个 Reader 都返回 EOF 之后，单独的 Reader 才返回 EOF，否则返回读取过程中遇到的任何错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MultiReader(readers ...Reader) Reader
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;MultiWriter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MultiWriter 将向自身写入的数据同步写入到所有 writers 中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MultiWriter(writers ...Writer) Writer
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;TeeReader&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TeeReader 对 r 进行封装，使 r 在读取数据的同时，自动向 w 中写入数据。它是一个无缓冲的 Reader，所以对 w 的写入操作必须在 r 的 Read 操作结束之前完成。所有写入时遇到的错误都会被作为 Read 方法的 err 返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func TeeReader(r Reader, w Writer) Reader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例 LimitReader&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    r := strings.NewReader(&amp;quot;Hello World!&amp;quot;)
    lr := io.LimitReader(r, 5)

    n, err := io.Copy(os.Stdout, lr)  // Hello
    fmt.Printf(&amp;quot;\n%d   %v\n&amp;quot;, n, err) // 5   &amp;lt;nil&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例 MultiReader&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    r1 := strings.NewReader(&amp;quot;Hello World!&amp;quot;)
    r2 := strings.NewReader(&amp;quot;ABCDEFG&amp;quot;)
    r3 := strings.NewReader(&amp;quot;abcdefg&amp;quot;)
    b := make([]byte, 15)
    mr := io.MultiReader(r1, r2, r3)

    for n, err := 0, error(nil); err == nil; {
        n, err = mr.Read(b)
        fmt.Printf(&amp;quot;%q\n&amp;quot;, b[:n])
    }
    // &amp;quot;Hello World!&amp;quot;
    // &amp;quot;ABCDEFG&amp;quot;
    // &amp;quot;abcdefg&amp;quot;
    // &amp;quot;&amp;quot;

    r1.Seek(0, 0)
    r2.Seek(0, 0)
    r3.Seek(0, 0)
    mr = io.MultiReader(r1, r2, r3)
    io.Copy(os.Stdout, mr)
    // Hello World!ABCDEFGabcdefg
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例 MultiWriter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    r := strings.NewReader(&amp;quot;Hello World!\n&amp;quot;)
    mw := io.MultiWriter(os.Stdout, os.Stdout, os.Stdout)

    r.WriteTo(mw)
    // Hello World!
    // Hello World!
    // Hello World!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例 TeeReader&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    r := strings.NewReader(&amp;quot;Hello World!&amp;quot;)
    b := make([]byte, 15)
    tr := io.TeeReader(r, os.Stdout)

    n, err := tr.Read(b)                  // Hello World!
    fmt.Printf(&amp;quot;\n%s   %v\n&amp;quot;, b[:n], err) // Hello World!   &amp;lt;nil&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copy&#34;&gt;Copy&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;CopyN&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CopyN 从 src 中复制 n 个字节的数据到 dst 中，返回复制的字节数和遇到的错误。只有当 written = n 时，err 才返回 nil。如果 dst 实现了 ReadFrom 方法，则优先调用该方法执行复制操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func CopyN(dst Writer, src Reader, n int64) (written int64, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Copy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Copy 从 src 中复制数据到 dst 中，直到所有数据都复制完毕，返回复制的字节数和遇到的错误。如果复制过程成功结束，则 err 返回 nil，而不是 EOF，因为 Copy 的定义为“直到所有数据都复制完毕”，所以不会将 EOF 视为错误返回。如果 src 实现了 WriteTo 方法，则调用 src.WriteTo(dst) 复制数据，否则如果 dst 实现了 ReadeFrom 方法，则调用 dst.ReadeFrom(src) 复制数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Copy(dst Writer, src Reader) (written int64, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;CopyBuffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CopyBuffer 相当于 Copy，只不 Copy 在执行的过程中会创建一个临时的缓冲区来中转数据，而 CopyBuffer 则可以单独提供一个缓冲区，让多个复制操作共用同一个缓冲区，避免每次复制操作都创建新的缓冲区。如果 buf == nil，则 CopyBuffer 会自动创建缓冲区。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：CopyN、Copy、CopyBuffer&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    r := strings.NewReader(&amp;quot;Hello World!&amp;quot;)
    buf := make([]byte, 32)

    n, err := io.CopyN(os.Stdout, r, 5) // Hello
    fmt.Printf(&amp;quot;\n%d   %v\n\n&amp;quot;, n, err) // 5   &amp;lt;nil&amp;gt;

    r.Seek(0, 0)
    n, err = io.Copy(os.Stdout, r)      // Hello World!
    fmt.Printf(&amp;quot;\n%d   %v\n\n&amp;quot;, n, err) // 12   &amp;lt;nil&amp;gt;

    r.Seek(0, 0)
    r2 := strings.NewReader(&amp;quot;ABCDEFG&amp;quot;)
    r3 := strings.NewReader(&amp;quot;abcdefg&amp;quot;)

    n, err = io.CopyBuffer(os.Stdout, r, buf) // Hello World!
    fmt.Printf(&amp;quot;\n%d   %v\n&amp;quot;, n, err)         // 12   &amp;lt;nil&amp;gt;

    n, err = io.CopyBuffer(os.Stdout, r2, buf) // ABCDEFG
    fmt.Printf(&amp;quot;\n%d   %v\n&amp;quot;, n, err)          // 7   &amp;lt;nil&amp;gt;

    n, err = io.CopyBuffer(os.Stdout, r3, buf) // abcdefg
    fmt.Printf(&amp;quot;\n%d   %v\n&amp;quot;, n, err)          // 7   &amp;lt;nil&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数还是我们在网络消息流量转发的时候还是经常使用的。&lt;/p&gt;

&lt;h1 id=&#34;场景举例&#34;&gt;场景举例&lt;/h1&gt;

&lt;h2 id=&#34;base64编码成字符串&#34;&gt;base64编码成字符串&lt;/h2&gt;

&lt;p&gt;encoding/base64包中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个用来做base64编码，但是仔细观察发现，它需要一个io.Writer作为输出目标，并用返回的WriteCloser的Write方法将结果写入目标，下面是Go官方文档的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input := []byte(&amp;quot;foo\x00bar&amp;quot;)
encoder := base64.NewEncoder(base64.StdEncoding, os.Stdout)
encoder.Write(input)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子是将结果写入到Stdout，如果我们希望得到一个字符串呢？可以用bytes.Buffer作为目标io.Writer：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input := []byte(&amp;quot;foo\x00bar&amp;quot;)
buffer := new(bytes.Buffer)
encoder := base64.NewEncoder(base64.StdEncoding, buffer)
encoder.Write(input)
fmt.Println(string(buffer.Bytes())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;byte和struct之间正反序列化&#34;&gt;[]byte和struct之间正反序列化&lt;/h2&gt;

&lt;p&gt;这种场景经常用在基于字节的协议上，比如有一个具有固定长度的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Protocol struct {
    Version     uint8
    BodyLen     uint16
    Reserved    [2]byte
    Unit        uint8
    Value       uint32
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过一个[]byte来反序列化得到这个Protocol，一种思路是遍历这个[]byte，然后逐一赋值。其实在encoding/binary包中有个方便的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Read(r io.Reader, order ByteOrder, data interface{}) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法从一个io.Reader中读取字节，并已order指定的端模式，来给填充data（data需要是fixed-sized的结构或者类型）。要用到这个方法首先要有一个io.Reader，从上面的图中不难发现，我们可以这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p Protocol
var bin []byte
//...
binary.Read(bytes.NewReader(bin), binary.LittleEndian, &amp;amp;p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，我们将一个[]byte转成了一个io.Reader。&lt;/p&gt;

&lt;p&gt;反过来，我们需要将Protocol序列化得到[]byte，使用encoding/binary包中有个对应的Write方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Write(w io.Writer, order ByteOrder, data interface{}) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过将[]byte转成一个io.Writer即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p Protocol
buffer := new(bytes.Buffer)
//...
binary.Writer(buffer, binary.LittleEndian, p)
bin := buffer.Bytes()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;从流中按行读取&#34;&gt;从流中按行读取&lt;/h2&gt;

&lt;p&gt;比如对于常见的基于文本行的HTTP协议的读取，我们需要将一个流按照行来读取。本质上，我们需要一个基于缓冲的读写机制（读一些到缓冲，然后遍历缓冲中我们关心的字节或字符）。在Go中有一个bufio的包可以实现带缓冲的读写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewReader(rd io.Reader) *Reader
func (b *Reader) ReadString(delim byte) (string, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个ReadString方法从io.Reader中读取字符串，直到delim，就返回delim和之前的字符串。如果将delim设置为\n，相当于按行来读取了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var conn net.Conn
//...
reader := NewReader(conn)
for {
    line, err := reader.ReadString([]byte(&#39;\n&#39;))
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string-to-byte&#34;&gt;string to byte&lt;/h2&gt;

&lt;p&gt;花式技（zuo）巧（si）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string转[]byte
a := &amp;quot;Hello, playground&amp;quot;
fmt.Println([]byte(a))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := &amp;quot;Hello, playground&amp;quot;
buf := new(bytes.Buffer)
buf.ReadFrom(strings.NewReader(a))
fmt.Println(buf.Bytes())
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;标准库中实现的读取器和编写器的实例&#34;&gt;标准库中实现的读取器和编写器的实例&lt;/h1&gt;

&lt;p&gt;目前，Go 文档中还没有直接列出实现了某个接口的所有类型。不过，我们可以通过查看标准库文档，列出实现了 io.Reader 或 io.Writer 接口的类型（导出的类型）：（注：godoc 命令支持额外参数 -analysis ，能列出都有哪些类型实现了某个接口，相关参考 godoc -h 或 Static analysis features of godoc。另外，还有一个地址：&lt;a href=&#34;http://docs.studygolang.com。&#34;&gt;http://docs.studygolang.com。&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kingjcy.github.io/post/golang/go-os/&#34;&gt;os.File&lt;/a&gt; 同时实现了 io.Reader 和 io.Writer&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kingjcy.github.io/post/golang/go-strings/#reader-类型&#34;&gt;strings.Reader&lt;/a&gt; 实现了 io.Reader&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kingjcy.github.io/post/golang/go-bufio/&#34;&gt;bufio.Reader/Writer&lt;/a&gt; 分别实现了 io.Reader 和 io.Writer&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kingjcy.github.io/post/golang/go-bytes/&#34;&gt;bytes.Buffer&lt;/a&gt; 同时实现了 io.Reader 和 io.Writer&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kingjcy.github.io/post/golang/go-bytes/&#34;&gt;bytes.Reader&lt;/a&gt; 实现了 io.Reader&lt;/li&gt;
&lt;li&gt;compress/gzip.Reader/Writer 分别实现了 io.Reader 和 io.Writer&lt;/li&gt;
&lt;li&gt;crypto/cipher.StreamReader/StreamWriter 分别实现了 io.Reader 和 io.Writer&lt;/li&gt;
&lt;li&gt;crypto/tls.Conn 同时实现了 io.Reader 和 io.Writer&lt;/li&gt;
&lt;li&gt;encoding/csv.Reader/Writer 分别实现了 io.Reader 和 io.Writer&lt;/li&gt;
&lt;li&gt;mime/multipart.Part 实现了 io.Reader&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kingjcy.github.io/post/golang/go-net/&#34;&gt;net.Conn&lt;/a&gt; 分别实现了 io.Reader 和 io.Writer(Conn接口定义了Read/Write)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，io 包本身也有这两个接口的实现类型。如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现了 Reader 的类型：&lt;a href=&#34;#limitedreader-类型&#34;&gt;LimitedReader&lt;/a&gt;、&lt;a href=&#34;#pipereader-和-pipewriter-类型&#34;&gt;PipeReader&lt;/a&gt;、&lt;a href=&#34;#sectionreader-类型&#34;&gt;SectionReader&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;实现了 Writer 的类型：&lt;a href=&#34;#pipereader-和-pipewriter-类型&#34;&gt;PipeWriter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上类型中，常用的类型有，文件IO，缓冲IO，网络IO，在标准库中都有实现&lt;/p&gt;

&lt;p&gt;网络io/文件io/标准io&amp;ndash;其实就是操作网络数据和文件中的数据
- &lt;a href=&#34;https://kingjcy.github.io/post/golang/go-net/&#34;&gt;net.Conn&lt;/a&gt;, &lt;a href=&#34;https://kingjcy.github.io/post/golang/go-os/&#34;&gt;os.Stdin&lt;/a&gt;, &lt;a href=&#34;https://kingjcy.github.io/post/golang/go-os/&#34;&gt;os.File&lt;/a&gt;: 网络、标准输入输出、文件的流读取，对应&amp;mdash;frp就是基于这个基础上实现的&lt;/p&gt;

&lt;p&gt;缓存io&amp;ndash;其实就是操作缓存中的string，[]byte
- &lt;a href=&#34;https://kingjcy.github.io/post/golang/go-strings/#reader-类型&#34;&gt;strings.Reader&lt;/a&gt;，&lt;a href=&#34;https://kingjcy.github.io/post/golang/go-strings/#builder-类型&#34;&gt;strings.Builder&lt;/a&gt;: 把字符串抽象成Reader
- &lt;a href=&#34;https://kingjcy.github.io/post/golang/go-bytes/#reader-类型&#34;&gt;bytes.Reader&lt;/a&gt;: 把[]byte抽象成Reader
- &lt;a href=&#34;https://kingjcy.github.io/post/golang/go-bytes/#buffer-类型&#34;&gt;bytes.Buffer&lt;/a&gt;: 把[]byte抽象成Reader和Writer&lt;/p&gt;

&lt;p&gt;缓存io&amp;ndash;还是使用缓存，但是主要是对io.reader实例进行读写
- &lt;a href=&#34;https://kingjcy.github.io/post/golang/go-bufio/&#34;&gt;bufio.Reader/Writer&lt;/a&gt;: 抽象成带缓冲的流读取（比如按行读写）&lt;/p&gt;</description>
        </item>
      
    
      
        <item>
          <title>Golang使用系列---- Go Net 协议层</title>
          <link>https://kingjcy.github.io/post/golang/go-net/</link>
          <pubDate>Mon, 11 Jul 2016 17:34:34 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/golang/go-net/</guid>
          <description>&lt;p&gt;网络编程是go语言使用的一个核心模块。golang的网络封装使用对于底层socket或者上层的http，甚至是web服务都很友好。&lt;/p&gt;

&lt;h1 id=&#34;net&#34;&gt;net&lt;/h1&gt;

&lt;p&gt;net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket等方式的通信。其中每一种通信方式都使用 xxConn 结构体来表示，诸如IPConn、TCPConn等，这些结构体都实现了Conn接口，Conn接口实现了基本的读、写、关闭、获取远程和本地地址、设置timeout等功能。&lt;/p&gt;

&lt;p&gt;conn的接口定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Conn interface {
    // Read从连接中读取数据
    // Read方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真
    Read(b []byte) (n int, err error)
    // Write从连接中写入数据
    // Write方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真
    Write(b []byte) (n int, err error)
    // Close方法关闭该连接
    // 并会导致任何阻塞中的Read或Write方法不再阻塞并返回错误
    Close() error
    // 返回本地网络地址
    LocalAddr() Addr
    // 返回远端网络地址
    RemoteAddr() Addr
    // 设定该连接的读写deadline，等价于同时调用SetReadDeadline和SetWriteDeadline
    // deadline是一个绝对时间，超过该时间后I/O操作就会直接因超时失败返回而不会阻塞
    // deadline对之后的所有I/O操作都起效，而不仅仅是下一次的读或写操作
    // 参数t为零值表示不设置期限
    SetDeadline(t time.Time) error
    // 设定该连接的读操作deadline，参数t为零值表示不设置期限
    SetReadDeadline(t time.Time) error
    // 设定该连接的写操作deadline，参数t为零值表示不设置期限
    // 即使写入超时，返回值n也可能&amp;gt;0，说明成功写入了部分数据
    SetWriteDeadline(t time.Time) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后每种类型都是对应的结构体实现这些接口。&lt;/p&gt;

&lt;p&gt;还有一个常用的接口定义PacketConn&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type PacketConn interface {
    // ReadFrom方法从连接读取一个数据包，并将有效信息写入b
    // ReadFrom方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真
    // 返回写入的字节数和该数据包的来源地址
    ReadFrom(b []byte) (n int, addr Addr, err error)
    // WriteTo方法将有效数据b写入一个数据包发送给addr
    // WriteTo方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真
    // 在面向数据包的连接中，写入超时非常罕见
    WriteTo(b []byte, addr Addr) (n int, err error)
    // Close方法关闭该连接
    // 会导致任何阻塞中的ReadFrom或WriteTo方法不再阻塞并返回错误
    Close() error
    // 返回本地网络地址
    LocalAddr() Addr
    // 设定该连接的读写deadline
    SetDeadline(t time.Time) error
    // 设定该连接的读操作deadline，参数t为零值表示不设置期限
    // 如果时间到达deadline，读操作就会直接因超时失败返回而不会阻塞
    SetReadDeadline(t time.Time) error
    // 设定该连接的写操作deadline，参数t为零值表示不设置期限
    // 如果时间到达deadline，写操作就会直接因超时失败返回而不会阻塞
    // 即使写入超时，返回值n也可能&amp;gt;0，说明成功写入了部分数据
    SetWriteDeadline(t time.Time) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ip&#34;&gt;ip&lt;/h2&gt;

&lt;p&gt;使用IPConn结构体来表示，它实现了Conn、PacketConn两种接口。使用如下两个函数进行Dial（连接）和Listen（监听）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DialIP在网络协议netProto上连接本地地址laddr和远端地址raddr，netProto必须是&amp;rdquo;ip&amp;rdquo;、&amp;rdquo;ip4&amp;rdquo;或&amp;rdquo;ip6&amp;rdquo;后跟冒号和协议名或协议号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ListenIP创建一个接收目的地是本地地址laddr的IP数据包的网络连接，返回的*IPConn的ReadFrom和WriteTo方法可以用来发送和接收IP数据包。（每个包都可获取来源址或者设置目标地址）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、IPAddr类型&lt;/p&gt;

&lt;p&gt;位于iprawsock.go中在net包的许多函数和方法会返回一个指向IPAddr的指针。这不过只是一个包含IP类型的结构体。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type IPAddr struct {
    IP   IP
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类型的另一个主要用途是通过IP主机名执行DNS查找。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ResolveIPAddr
ResolveIPAddr有两个参数第一个参数.必须为&amp;quot;ip&amp;quot;,&amp;quot;ip4&amp;quot;,&amp;quot;ip6&amp;quot;,第二个参数多为要解析的域名.返回一个IPAddr的指针类型

addr, _ := net.ResolveIPAddr(&amp;quot;ip&amp;quot;, &amp;quot;www.baidu.com&amp;quot;)
fmt.Println(addr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ip.go 中还定义了三个类型.分别是IP,IPMask,IPNet&lt;/p&gt;

&lt;p&gt;2、IP类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type IP []byte
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IP类型被定义为一个字节数组。 ParseIP(String) 可以将字符窜转换为一个IP类型.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name := &amp;quot;127.0.0.1&amp;quot;
addr := net.ParseIP(name)
fmt.Println(addr.IsLoopback())// IsLoopback reports whether ip is a loopback address.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、IPMask类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// An IP mask is an IP address.
type IPMask []byte
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个掩码的字符串形式是一个十六进制数，如掩码255.255.0.0为ffff0000。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func IPv4Mask(a, b, c, d byte) IPMask :用一个4字节的IPv4地址来创建一个掩码.
func CIDRMask(ones, bits int) IPMask : 用ones和bits来创建一个掩码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、IPNet类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// An IPNet represents an IP network.
type IPNet struct {
    IP   IP     // network number
    Mask IPMask // network mask
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由IP类型和IPMask组成一个网段,其字符串形式是CIDR地址,如:“192.168.100.1/24”或“2001:DB8::/ 48”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    mask := net.IPv4Mask(byte(255), byte(255), byte(255), byte(0))
    ip := net.ParseIP(&amp;quot;192.168.1.125&amp;quot;).Mask(mask)
    in := &amp;amp;net.IPNet{ip, mask}
    fmt.Println(in)         //  192.168.1.0/24
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这边插播一个经常使用的实例：获取本地IP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net&amp;quot;
    &amp;quot;os&amp;quot;
)
func main() {
    addrs, err := net.InterfaceAddrs()
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
    for _, address := range addrs {
        // 检查ip地址判断是否回环地址
        if ipnet, ok := address.(*net.IPNet); ok &amp;amp;&amp;amp; !ipnet.IP.IsLoopback() {
            if ipnet.IP.To4() != nil {
                fmt.Println(ipnet.IP.String())
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tcp&#34;&gt;tcp&lt;/h2&gt;

&lt;p&gt;使用TCPConn结构体来表示，它实现了Conn接口。&lt;/p&gt;

&lt;p&gt;使用DialTCP进行Dial操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DialTCP在网络协议net上连接本地地址laddr和远端地址raddr。net必须是&amp;rdquo;tcp&amp;rdquo;、&amp;rdquo;tcp4&amp;rdquo;、&amp;rdquo;tcp6&amp;rdquo;；如果laddr不是nil，将使用它作为本地地址，否则自动选择一个本地地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 ListenTCP函数进行Listen，产生一个TCPListener结构体，使用TCPListener的AcceptTCP方法建立通信链路，得到TCPConn。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TCPAddr类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;位于tcpsock.go中TCPAddr类型包含一个IP和一个port的结构:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type TCPAddr struct {
    IP   IP
    Port int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResolveTCPAddr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ResolveTCPAddr(net, addr string) (*TCPAddr, os.Error) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数用来创建一个TCPAddr,第一个参数为,tcp,tcp4或者tcp6,addr是一个字符串，由主机名或IP地址，以及&amp;rdquo;:&amp;ldquo;后跟随着端口号组成，例如： &amp;ldquo;www.google.com:80&amp;rdquo; 或 &amp;lsquo;127.0.0.1:22&amp;rdquo;。如果地址是一个IPv6地址，由于已经有冒号，主机部分，必须放在方括号内, 例如：&amp;rdquo;[::1]:23&amp;rdquo;. 另一种特殊情况是经常用于服务器, 主机地址为0, 因此，TCP地址实际上就是端口名称, 例如：&amp;rdquo;:80&amp;rdquo; 用来表示HTTP服务器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addr, _ := net.ResolveTCPAddr(&amp;quot;tcp&amp;quot;, &amp;quot;www.baidu.com:80&amp;quot;)
fmt.Println(addr)   //220.181.111.147:80
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;udp&#34;&gt;udp&lt;/h2&gt;

&lt;p&gt;使用UDPConn接口体来表示，它实现了Conn、PacketConn两种接口。使用如下两个函数进行Dial和Listen。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DialTCP在网络协议net上连接本地地址laddr和远端地址raddr。net必须是&amp;rdquo;udp&amp;rdquo;、&amp;rdquo;udp4&amp;rdquo;、&amp;rdquo;udp6&amp;rdquo;；如果laddr不是nil，将使用它作为本地地址，否则自动选择一个本地地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ListenUDP创建一个接收目的地是本地地址laddr的UDP数据包的网络连接。net必须是&amp;rdquo;udp&amp;rdquo;、&amp;rdquo;udp4&amp;rdquo;、&amp;rdquo;udp6&amp;rdquo;；如果laddr端口为0，函数将选择一个当前可用的端口，可以用Listener的Addr方法获得该端口。返回的*UDPConn的ReadFrom和WriteTo方法可以用来发送和接收UDP数据包（每个包都可获得来源地址或设置目标地址）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、UDPAddr类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type UDPAddr struct {
    IP   IP
    Port int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResolveUDPAddr同样的功能&lt;/p&gt;

&lt;p&gt;2、UnixAddr类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type UnixAddr struct {
    Name string
    Net  string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResolveUnixAddr同样的功能&lt;/p&gt;

&lt;h2 id=&#34;unix&#34;&gt;unix&lt;/h2&gt;

&lt;p&gt;UnixConn实现了Conn、PacketConn两种接口，其中unix又分为SOCK_DGRAM、SOCK_STREAM。&lt;/p&gt;

&lt;p&gt;1.对于unix（SOCK_DGRAM），使用如下两个函数进行Dial和Listen。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)    

func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.对于unix（SOCK_STREAM）&lt;/p&gt;

&lt;p&gt;客户端使用DialUnix进行Dial操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端使用ListenUnix函数进行Listen操作，然后使用UnixListener进行AcceptUnix&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;函数整合&#34;&gt;函数整合&lt;/h1&gt;

&lt;p&gt;为了使用方便，golang将上面一些重复的操作集中到一个函数中。在参数中制定上面不同协议类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ListenPacket(net, laddr string) (PacketConn, error)　
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数用于侦听ip、udp、unix（DGRAM）等协议，返回一个PacketConn接口，同样根据侦听的协议不同，这个接口可以包含IPCon、UDPConn、UnixConn等，它们都实现了PacketConn。可以发现与ip、unix（stream）协议不同，直接返回的是xxConn，不是间接的通过Listener进行Accept操作后，才得到一个Conn。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Listen(net, laddr string) (Listener, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数用于侦听tcp、unix（stream）等协议，返回一个Listener接口、根据侦听的协议不同，这个接口可以包含TCPListener、UnixListener等，它们都实现了Listener接口，然后通过调用其Accept方法可以得到Conn接口，进行通信。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Dial(network, address string) (Conn, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数对于所有的协议都是相同的操作，返回一个Conn接口，根据协议的不同实际上包含IPConn、UDPConn、UnixConn、IPConn，它们都实现了Conn接口&lt;/p&gt;

&lt;h1 id=&#34;基本c-s功能&#34;&gt;基本c/s功能&lt;/h1&gt;

&lt;p&gt;在 Unix/Linux 中的 Socket 编程主要通过调用 listen, accept, write read 等函数来实现的. 具体如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/golang/net/unix_socket.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;服务端&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;服务端listen, accept&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func connHandler(c net.Conn) {
    for {
        cnt, err := c.Read(buf)
        c.Write(buf)
    }
}
func main() {
    server, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:1208&amp;quot;)
    for {
        conn, err := server.Accept()
        go connHandler(conn)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接使用net的listen返回的就是对应协议已经定义好的结构体，比如tcp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type TCPListener struct {
    fd *netFD
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个结构体实现了listener接口的所有接口，所以可以作为返回值返回。其他协议类型也是一样。&lt;/p&gt;

&lt;p&gt;accept后返回的conn是一个存储着连接信息的结构体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Network file descriptor.
type netFD struct {
    pfd poll.FD

    // immutable until Close
    family      int
    sotype      int
    isConnected bool // handshake completed or use of association with peer
    net         string
    laddr       Addr
    raddr       Addr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;客户端dial&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func connHandler(c net.Conn) {
    for {
        c.Write(...)
        c.Read(...)
    }
}
func main() {
    conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:1208&amp;quot;)
    connHandler(conn)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Dial(net, addr string) (Conn, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中net参数是网络协议的名字， addr参数是IP地址或域名，而端口号以“:”的形式跟随在地址
或域名的后面，端口号可选。如果连接成功，返回连接对象，否则返回error。&lt;/p&gt;

&lt;p&gt;Dial() 函数支持如下几种网络协议：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;tcp&amp;quot; 、 &amp;quot;tcp4&amp;quot; （仅限IPv4）、 &amp;quot;tcp6&amp;quot; （仅限IPv6）、 &amp;quot;udp&amp;quot; 、 &amp;quot;udp4&amp;quot;（仅限IPv4）、 &amp;quot;udp6&amp;quot;（仅限IPv6）、 &amp;quot;ip&amp;quot; 、 &amp;quot;ip4&amp;quot;（仅限IPv4）和&amp;quot;ip6&amp;quot;（仅限IPv6）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以直接用相关协议的函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err error)
func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error)
func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)
func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;特性功能&#34;&gt;特性功能&lt;/h2&gt;

&lt;p&gt;1、控制TCP连接&lt;/p&gt;

&lt;p&gt;TCP连接有很多控制函数，我们平常用到比较多的有如下几个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *TCPConn) SetTimeout(nsec int64) os.Error
func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个函数用来设置超时时间，客户端和服务器端都适用，当超过设置的时间时那么该链接就失效。&lt;/p&gt;

&lt;p&gt;第二个函数用来设置客户端是否和服务器端一直保持着连接，即使没有任何的数据发送&lt;/p&gt;

&lt;h1 id=&#34;实例&#34;&gt;实例&lt;/h1&gt;

&lt;p&gt;从零开始写Socket Server： Socket-Client框架&lt;/p&gt;

&lt;p&gt;在golang中，网络协议已经被封装的非常完好了，想要写一个Socket的Server，我们并不用像其他语言那样需要为socket、bind、listen、receive等一系列操作头疼，只要使用Golang中自带的net包即可很方便的完成连接等操作~&lt;/p&gt;

&lt;p&gt;在这里，给出一个最最基础的基于Socket的Server的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;os&amp;quot;
)


func main() {

//建立socket，监听端口
    netListen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:1024&amp;quot;)
    CheckError(err)
    defer netListen.Close()

    Log(&amp;quot;Waiting for clients&amp;quot;)
    for {
        conn, err := netListen.Accept()
        if err != nil {
            continue
        }

        Log(conn.RemoteAddr().String(), &amp;quot; tcp connect success&amp;quot;)
        handleConnection(conn)
    }
}
//处理连接
func handleConnection(conn net.Conn) {

    buffer := make([]byte, 2048)

    for {

        n, err := conn.Read(buffer)

        if err != nil {
            Log(conn.RemoteAddr().String(), &amp;quot; connection error: &amp;quot;, err)
            return
        }


        Log(conn.RemoteAddr().String(), &amp;quot;receive data string:\n&amp;quot;, string(buffer[:n]))

    }

}
func Log(v ...interface{}) {
    log.Println(v...)
}

func CheckError(err error) {
    if err != nil {
        fmt.Fprintf(os.Stderr, &amp;quot;Fatal error: %s&amp;quot;, err.Error())
        os.Exit(1)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唔，抛除Go语言里面10行代码有5行error的蛋疼之处,你可以看到，Server想要建立并接受一个Socket，其核心流程就是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;netListen, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:1024&amp;quot;)
conn, err := netListen.Accept()
n, err := conn.Read(buffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三步，通过Listen、Accept 和Read，我们就成功的绑定了一个端口，并能够读取从该端口传来的内容~&lt;/p&gt;

&lt;p&gt;这边插播一个内容，关于read是阻塞的，如果读取不到内容，代码会阻塞在这边，直到有内容可以读取，包括connection断掉返回的io.EOF,一般对这个都有特殊处理。一般重conn读取数据也是在for循环中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;net&amp;quot;
)

func main(){
    ln, err := net.Listen(&amp;quot;tcp&amp;quot;,&amp;quot;127.0.0.1:10051&amp;quot;)

    if err != nil {
        panic(err)
    }

    for {
        conn, _ := ln.Accept() //The loop will be held here
        fmt.Println(&amp;quot;get connect&amp;quot;)
        go handleread(conn)


    }
}

func handleread(conn net.Conn){
    defer conn.Close()

    var tatalBuffer  []byte
    var all int
    for {
        buffer := make([]byte, 2)
        n,err := conn.Read(buffer)
        if err == io.EOF{
            fmt.Println(err,n)
            break
        }

        tatalBuffer = append(tatalBuffer,buffer...)
        all += n

        fmt.Println(string(buffer),n,string(tatalBuffer[:all]),all)
    }



}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个例子中，会重conn中两个字符循环读取内容，这边slice不会动态扩容，所以需要使用append来获取全部内容。&lt;/p&gt;

&lt;p&gt;还有一点，buffer := make([]byte, 2)这个代码，放在for循环中，浪费内存，可以放在gor循环外部，然后使用n来截取buf[:n]可以解决buf最后一部分重复的问题。&lt;/p&gt;

&lt;p&gt;插播结束，回到server。&lt;/p&gt;

&lt;p&gt;Server写好之后，接下来就是Client方面啦，我手写一个HelloWorld给大家：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net&amp;quot;
    &amp;quot;os&amp;quot;
)

func sender(conn net.Conn) {
        words := &amp;quot;hello world!&amp;quot;
        conn.Write([]byte(words))
    fmt.Println(&amp;quot;send over&amp;quot;)

}



func main() {
    server := &amp;quot;127.0.0.1:1024&amp;quot;
    tcpAddr, err := net.ResolveTCPAddr(&amp;quot;tcp4&amp;quot;, server)
    if err != nil {
        fmt.Fprintf(os.Stderr, &amp;quot;Fatal error: %s&amp;quot;, err.Error())
        os.Exit(1)
    }

    conn, err := net.DialTCP(&amp;quot;tcp&amp;quot;, nil, tcpAddr)
    if err != nil {
        fmt.Fprintf(os.Stderr, &amp;quot;Fatal error: %s&amp;quot;, err.Error())
        os.Exit(1)
    }


    fmt.Println(&amp;quot;connect success&amp;quot;)
    sender(conn)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，Client这里的关键在于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcpAddr, err := net.ResolveTCPAddr(&amp;quot;tcp4&amp;quot;, server)
conn, err := net.DialTCP(&amp;quot;tcp&amp;quot;, nil, tcpAddr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两步，主要是负责解析端口和连接。&lt;/p&gt;

&lt;p&gt;这边插播一个tcp协议的三次握手图，加强理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kingjcy.github.io/media/golang/net/tcp_open_close.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;扩展&#34;&gt;扩展&lt;/h1&gt;

&lt;p&gt;其实我们最常用的还是&lt;a href=&#34;https://kingjcy.github.io/post/golang/go-net-http/&#34;&gt;http协议&lt;/a&gt;，也即是应用层的协议，其实http协议是在tcp协议的基础上进行封装，最终还是使用的这边基本的网络IO，所以在网络传输中，网络IO的基本协议的实现是基础。&lt;/p&gt;</description>
        </item>
      
    
      
        <item>
          <title>Golang使用系列---- Os</title>
          <link>https://kingjcy.github.io/post/golang/go-os/</link>
          <pubDate>Thu, 02 Jun 2016 09:52:35 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/golang/go-os/</guid>
          <description>&lt;p&gt;os包中实现了不依赖平台的操作系统函数接口(平台无关的接口)，设计向Unix风格，但是错误处理是go风格，当os包使用时，如果失败之后返回错误类型而不是错误数量,返回错误值而非错误码,可以包含更多信息。&lt;/p&gt;

&lt;h1 id=&#34;os&#34;&gt;os&lt;/h1&gt;

&lt;p&gt;os 依赖于 syscall。在实际编程中，我们应该总是优先使用 os 中提供的功能，而不是 syscall。&lt;/p&gt;

&lt;p&gt;os包提供了操作系统函数的不依赖平台的接口。一般都是linux下的一些基本命令的操作，比如文件，目录操作之类。&lt;/p&gt;

&lt;p&gt;我们运行程序常用的命令行参数就是在这个包中可以获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Args []string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Args保管了命令行参数，第一个是程序名。&lt;/p&gt;

&lt;h2 id=&#34;文件io&#34;&gt;文件io&lt;/h2&gt;

&lt;p&gt;文件IO就是对文件的读写操作，我们先了解一些os中的基本概念。&lt;/p&gt;

&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;文件描述符&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所有 I/O 操作以文件描述符 ( 一个非负整数 , 通常是小整数 ) 来指代打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。&lt;/p&gt;

&lt;p&gt;在 Go 中，文件描述符封装在 os.File 结构中，通过 File.Fd() 可以获得底层的文件描述符：fd。&lt;/p&gt;

&lt;p&gt;File结构体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type File struct {
    *file
}
// file is the real representation of *File.
// The extra level of indirection ensures that no clients of os
// can overwrite this data, which could cause the finalizer
// to close the wrong file descriptor.
type file struct {
    fd      int
    name    string
    dirinfo *dirInfo // nil unless directory being read
}

// Auxiliary information if the File describes a directory
type dirInfo struct {
    buf  []byte // buffer for directory I/O
    nbuf int    // length of buf; return value from Getdirentries
    bufp int    // location of next record in buf.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;标准定义&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;按照惯例，大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。os 包提供了 3 个 File 对象，分别代表这 3 种标准描述符：Stdin、Stdout 和 Stderr，它们对应的文件名分别是：/dev/stdin、/dev/stdout 和 /dev/stderr。&lt;/p&gt;

&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func NewFile(fd uintptr, name string) *File
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NewFile使用给出的Unix文件描述符和名称创建一个文件。&lt;/p&gt;

&lt;p&gt;正常使用create来创建一个文件，比如文件不存在，就创建一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file,er:=os.Open(&amp;quot;xxx&amp;quot;)
defer func(){file.Close()}()
if er!=nil &amp;amp;&amp;amp; os.IfNotExist(er
r){
  file = os.Create(&amp;quot;xx&amp;quot;)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;打开&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func Open(name string) (file *File, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。&lt;/p&gt;

&lt;p&gt;位掩码参数 flag 用于指定文件的访问模式，可用的值在 os 中定义为常量（以下值并非所有操作系统都可用）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const (
    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件
    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件
    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件
    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部
    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件
    O_EXCL   int = syscall.O_EXCL   // 和 O_CREATE 配合使用，文件必须不存在
    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步 I/O
    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O_TRUNC这个参数可以用来清空文件，如果可以的话，还可以用这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;os.Truncate(name, size)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) Truncate(size int64) error
size 填0 就把文件清空了。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面有详细的说明&lt;/p&gt;

&lt;p&gt;位掩码参数 perm 指定了文件的模式和权限位，类型是 os.FileMode，文件模式位常量定义在 os 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const (
    // 单字符是被 String 方法用于格式化的属性缩写。
    ModeDir        FileMode = 1 &amp;lt;&amp;lt; (32 - 1 - iota) // d: 目录
    ModeAppend                                     // a: 只能写入，且只能写入到末尾
    ModeExclusive                                  // l: 用于执行
    ModeTemporary                                  // T: 临时文件（非备份文件）
    ModeSymlink                                    // L: 符号链接（不是快捷方式文件）
    ModeDevice                                     // D: 设备
    ModeNamedPipe                                  // p: 命名管道（FIFO）
    ModeSocket                                     // S: Unix 域 socket
    ModeSetuid                                     // u: 表示文件具有其创建者用户 id 权限
    ModeSetgid                                     // g: 表示文件具有其创建者组 id 的权限
    ModeCharDevice                                 // c: 字符设备，需已设置 ModeDevice
    ModeSticky                                     // t: 只有 root/ 创建者能删除 / 移动文件

    // 覆盖所有类型位（用于通过 &amp;amp; 获取类型位），对普通文件，所有这些位都不应被设置
    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice
    ModePerm FileMode = 0777 // 覆盖所有 Unix 权限位（用于通过 &amp;amp; 获取类型位）
)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;read&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) Read(b []byte) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read 方法从 f 中读取最多 len(b) 字节数据并写入 b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回值 err 为 io.EOF。&lt;/p&gt;

&lt;p&gt;从方法声明可以知道，File 实现了 io.Reader 接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) ReadAt(b []byte, off int64) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReadAt 从指定的位置（相对于文件开始位置）读取长度为 len(b) 个字节数据并写入 b。它返回读取的字节数和可能遇到的任何错误。当 n&amp;lt;len(b) 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 err 会是 io.EOF。它对应的系统调用是 pread。&lt;/p&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var chunks []byte
buf := make([]byte, 1024)
var count = 0
for {
    n, err := f.Read(buf)
    if err != nil &amp;amp;&amp;amp; err != io.EOF {
        panic(err)
    }
    if 0 == n {
        break
    }
    count = count + n
    chunks = append(chunks, buf[:n]...)
}
r.logger.Debugf(&amp;quot;read file content : %s&amp;quot;,string(chunks[:count]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边这个实例主要是要说明一下几个重点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、buf必须make，不然会panic
2、read必须for循环，直到io.EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;write&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) Write(b []byte) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write 向文件中写入 len(b) 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值 n!=len(b)，本方法会返回一个非 nil 的错误。&lt;/p&gt;

&lt;p&gt;从方法声明可以知道，File 实现了 io.Writer 接口。&lt;/p&gt;

&lt;p&gt;Write 与 WriteAt 的区别同 Read 与 ReadAt 的区别一样。为了方便，还提供了 WriteString 方法，它实际是对 Write 的封装。&lt;/p&gt;

&lt;p&gt;注意：Write 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会影响性能），有两种办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 打开文件时指定 `os.O_SYNC`；
2. 调用 `File.Sync()` 方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：File.Sync() 底层调用的是 fsync 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件数据），需要自己封装，调用 fdatasync（syscall.Fdatasync） 系统调用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;close&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;close() 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当进程终止时，将自动关闭其已打开的所有文件描述符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) Close() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;os.File.Close() 是对 close() 的封装。我们应该养成关闭不需要的文件的良好编程习惯。文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，长期运行的服务可能会把文件描述符耗尽。&lt;/p&gt;

&lt;p&gt;以下两种情况会导致 Close 返回错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 关闭一个未打开的文件；
2. 两次关闭同一个文件；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常，我们不会去检查 Close 的错误&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;seek&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) Seek(offset int64, whence int) (ret int64, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seek 设置下一次读 / 写的位置。offset 为相对偏移量，而 whence 决定相对位置：0 为相对文件开头，1 为相对当前位置，2 为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。使用中，whence 应该使用 os 包中的常量：SEEK_SET、SEEK_CUR 和 SEEK_END&lt;/p&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file.Seek(0, os.SEEK_SET)    // 文件开始处
file.Seek(0, SEEK_END)        // 文件结尾处的下一个字节
file.Seek(-1, SEEK_END)        // 文件最后一个字节
file.Seek(-10, SEEK_CUR)     // 当前位置前 10 个字节
file.Seek(1000, SEEK_END)    // 文件结尾处的下 1001 个字节
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;trucate&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;trucate 和 ftruncate 系统调用将文件大小设置为 size 参数指定的值；Go 语言中相应的包装函数是 os.Truncate 和 os.File.Truncate。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Truncate(name string, size int64) error
func (f *File) Truncate(size int64) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果文件当前长度大于参数 size，调用将丢弃超出部分，若小于参数 size，调用将在文件尾部添加一系列空字节或是一个文件空洞。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;remove&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func Remove(name string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remove删除name指定的文件或目录。如果出错，会返回*PathError底层类型的错误。&lt;/p&gt;

&lt;h2 id=&#34;文件属性&#34;&gt;文件属性&lt;/h2&gt;

&lt;h3 id=&#34;文件信息&#34;&gt;文件信息&lt;/h3&gt;

&lt;p&gt;可以通过包里的函数 Stat、Lstat 和 File.Stat 可以得到os.FileInfo 接口的信息。这三个函数对应三个系统调用：stat、lstat 和 fstat。&lt;/p&gt;

&lt;p&gt;这三个函数的区别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stat 会返回所命名文件的相关信息。&lt;/li&gt;
&lt;li&gt;lstat 与 stat 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。&lt;/li&gt;
&lt;li&gt;fstat 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Stat 和 Lstat 无需对其所操作的文件本身拥有任何权限，但针对指定 name 的父目录要有执行（搜索）权限。而只要 File 对象 ok，File.Stat 总是成功。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) Stat() (fi FileInfo, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stat返回描述文件f的FileInfo类型值。如果出错，错误底层类型是*PathError。这个方法也可以用于检查文件是否有问题，上面说到文件的信息是存储在FileInfo 接口中的，我们来看一下这个接口&lt;/p&gt;

&lt;p&gt;FileInfo是一个接口，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A FileInfo describes a file and is returned by Stat and Lstat.
type FileInfo interface {
    Name() string       // base name of the file 文件的名字（不含扩展名）
    Size() int64        // length in bytes for regular files; system-dependent for others  普通文件返回值表示其大小；其他文件的返回值含义各系统不同
    Mode() FileMode     // file mode bits   文件的模式位
    ModTime() time.Time // modification time    文件的修改时间
    IsDir() bool        // abbreviation for Mode().IsDir()  等价于 Mode().IsDir()
    Sys() interface{}   // underlying data source (can return nil)  底层数据来源（可以返回 nil）
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该接口提供了一个sys函数，Sys() 底层数据的 C 语言 结构 statbuf 格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct stat {
  dev_t    st_dev;    // 设备 ID
  ino_t    st_ino;    // 文件 i 节点号
  mode_t    st_mode;    // 位掩码，文件类型和文件权限
  nlink_t    st_nlink;    // 硬链接数
  uid_t    st_uid;    // 文件属主，用户 ID
  gid_t    st_gid;    // 文件属组，组 ID
  dev_t    st_rdev;    // 如果针对设备 i 节点，则此字段包含主、辅 ID
  off_t    st_size;    // 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小
  blksize_t    st_blsize;    // 分配给文件的总块数，块大小为 512 字节
  blkcnt_t    st_blocks;    // 实际分配给文件的磁盘块数量
  time_t    st_atime;        // 对文件上次访问时间
  time_t    st_mtime;        // 对文件上次修改时间
  time_t    st_ctime;        // 文件状态发生改变的上次时间
}
Go 中 syscal.Stat_t 与该结构对应。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们要获取 FileInfo 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fileInfo, err := os.Stat(&amp;quot;test.log&amp;quot;)
if err != nil {
  log.Fatal(err)
}
sys := fileInfo.Sys()
stat := sys.(*syscall.Stat_t)
fmt.Println(time.Unix(stat.Atimespec.Unix()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常返回的是实现这个接口的结构体，也就是fileStat，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A fileStat is the implementation of FileInfo returned by Stat and Lstat.
type fileStat struct {
    name    string
    size    int64
    mode    FileMode
    modTime time.Time
    sys     syscall.Stat_t
}

func (fs *fileStat) Size() int64        { return fs.size }
func (fs *fileStat) Mode() FileMode     { return fs.mode }
func (fs *fileStat) ModTime() time.Time { return fs.modTime }
func (fs *fileStat) Sys() interface{}   { return &amp;amp;fs.sys }

func sameFile(fs1, fs2 *fileStat) bool {
    return fs1.sys.Dev == fs2.sys.Dev &amp;amp;&amp;amp; fs1.sys.Ino == fs2.sys.Ino
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中有一个syscall.Stat_t，源于syscall的结构体，这个结构体是需要区分系统的，不同的系统调用不一样，不然编译不通过，报错如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;registry/delete.go:49:27: stat.Ctimespec undefined (type *syscall.Stat_t has no field or method Ctimespec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是因为在linux下结构体成名名是Ctim，在drawin下是Ctimespec，导致跨平台编译报错。&lt;/p&gt;

&lt;h3 id=&#34;文件时间&#34;&gt;文件时间&lt;/h3&gt;

&lt;p&gt;通过包里的Chtimes函数可以显式改变文件的访问时间和修改时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Chtimes(name string, atime time.Time, mtime time.Time) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chtimes 修改 name 指定的文件对象的访问时间和修改时间，类似 Unix 的 utime() 或 utimes() 函数。底层的文件系统可能会截断 / 舍入时间单位到更低的精确度。如果出错，会返回 *PathError 类型的错误。在 Unix 中，底层实现会调用 utimenstat()，它提供纳秒级别的精度&lt;/p&gt;

&lt;h3 id=&#34;文件权限&#34;&gt;文件权限&lt;/h3&gt;

&lt;p&gt;系统调用 chown、lchown 和 fchown 可用来改变文件的属主和属组，Go 中os包中对应的函数或方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Chown(name string, uid, gid int) error
func Lchown(name string, uid, gid int) error
func (f *File) Chown(uid, gid int) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它们的区别和上文提到的 Stat 相关函数类似。&lt;/p&gt;

&lt;p&gt;在文件相关操作报错时，可以通过 os.IsPermission 检查是否是权限的问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func IsPermission(err error) bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。ErrPermission 和一些系统调用错误会使它返回真。&lt;/p&gt;

&lt;p&gt;另外，syscall.Access 可以获取文件的权限。这对应系统调用 access。&lt;/p&gt;

&lt;p&gt;os.Chmod 和 os.File.Chmod 可以修改文件权限（包括 sticky 位），分别对应系统调用 chmod 和 fchmod。&lt;/p&gt;

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;p&gt;在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在其 i-node 条目中，会将目录标记为一种不同的文件类型。&lt;/li&gt;
&lt;li&gt;目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 i-node 标号&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;目录操作&#34;&gt;目录操作&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func Mkdir(name string, perm FileMode) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mkdir 使用指定的权限和名称创建一个目录。如果出错，会返回 *PathError 类型的错误。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;name 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 os.ErrExist 错误。&lt;/li&gt;
&lt;li&gt;perm 参数指定了新目录的权限。对该位掩码值的指定方式和 os.OpenFile 相同，也可以直接赋予八进制数值。注意，perm 值还将于进程掩码相与（&amp;amp;）。如果 perm 中设置了 sticky 位，那么将对新目录设置该权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为 Mkdir 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。os.MkdirAll 用于递归创建所有不存在的目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MkdirAll(path string, perm FileMode) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MkdirAll使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回nil，否则返回错误。权限位perm会应用在每一个被本函数创建的目录上。如果path指定了一个已经存在的目录，MkdirAll不做任何操作并返回nil。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func Remove(name string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remove 删除 name 指定的文件或目录。如果出错，会返回 *PathError 类型的错误。如果目录不为空，Remove 会返回失败。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func RemoveAll(path string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RemoveAll 删除 path 指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果 path 指定的对象不存在，RemoveAll 会返回 nil 而不返回错误。&lt;/p&gt;

&lt;p&gt;RemoveAll 的内部实现逻辑如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调用 Remove 尝试进行删除，如果成功或返回 path 不存在，则直接返回 nil；&lt;/li&gt;
&lt;li&gt;调用 Lstat 获取 path 信息，以便判断是否是目录。注意，这里使用 Lstat，表示不对符号链接解引用；&lt;/li&gt;
&lt;li&gt;调用 Open 打开目录，递归读取目录中内容，执行删除操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;读&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) Readdirnames(n int) (names []string, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Readdirnames 读取目录 f 的内容，返回一个最多有 n 个成员的[]string，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一次调用会返回上一次调用未读取的内容的信息。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果 n&amp;gt;0，Readdirnames 函数会返回一个最多 n 个成员的切片。这时，如果 Readdirnames 返回一个空切片，它会返回一个非 nil 的错误说明原因。如果到达了目录 f 的结尾，返回值 err 会是 io.EOF。&lt;/li&gt;
&lt;li&gt;如果 n&amp;lt;=0，Readdirnames 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 Readdirnames 调用成功（读取所有内容直到结尾），它会返回该切片和 nil 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Readdir 内部会调用 Readdirnames，将得到的 names 构造路径，通过 Lstat 构造出 []FileInfo。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (f *File) Readdir(n int) (fi []FileInfo, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;连接&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func Link(oldname, newname string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Link 创建一个名为 newname 指向 oldname 的硬链接。如果出错，会返回 *LinkError 类型的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Symlink(oldname, newname string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Symlink 创建一个名为 newname 指向 oldname 的符号链接。如果出错，会返回 *LinkError 类型的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Readlink(name string) (string, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Readlink 获取 name 指定的符号链接指向的文件的路径。如果出错，会返回 *PathError 类型的错误。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;更改文件名&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;func Rename(oldpath, newpath string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rename 修改一个文件的名字或移动一个文件。如果 newpath 已经存在，则替换它。注意，可能会有一些个操作系统特定的限制。&lt;/p&gt;

&lt;h1 id=&#34;os-singal&#34;&gt;os/singal&lt;/h1&gt;

&lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;

&lt;p&gt;Signal是一个接口，所有的信号都实现了这个接口，可以直接传递，我们传递信号的时候，需要定义这个类型的channel来传递信号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Signal interface {
    String() string
    Signal() // to distinguish from other Stringers
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;syscall 包中定义了所有的信号常量，比如syscall.SIGINT，其实就是一个int的数字信号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SIGINT    = Signal(0x2)
type Signal int

func (s Signal) Signal() {}

func (s Signal) String() string {
    if 0 &amp;lt;= s &amp;amp;&amp;amp; int(s) &amp;lt; len(signals) {
        str := signals[s]
        if str != &amp;quot;&amp;quot; {
            return str
        }
    }
    return &amp;quot;signal &amp;quot; + itoa(int(s))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Notify&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;singnal主要是用于信号的传递，一般程序中需要使用信号的时候使用。主要使用下面两个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Notify(c chan&amp;lt;- os.Signal, sig ...os.Signal)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notify函数让signal包将输入信号转发到c。如果没有列出要传递的信号，会将所有输入信号传递到c；否则只传递列出的输入信号。&lt;/p&gt;

&lt;p&gt;signal包不会为了向c发送信息而阻塞（就是说如果发送时c阻塞了，signal包会直接放弃）：调用者应该保证c有足够的缓存空间可以跟上期望的信号频率。对使用单一信号用于通知的通道，缓存为1就足够了。&lt;/p&gt;

&lt;p&gt;可以使用同一通道多次调用Notify：每一次都会扩展该通道接收的信号集。可以使用同一信号和不同通道多次调用Notify：每一个通道都会独立接收到该信号的一个拷贝。&lt;/p&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
import &amp;quot;fmt&amp;quot;
import &amp;quot;os&amp;quot;
import &amp;quot;os/signal&amp;quot;
import &amp;quot;syscall&amp;quot;
func main() {
    sigs := make(chan os.Signal, 1)
    done := make(chan bool, 1)
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        sig := &amp;lt;-sigs
        fmt.Println()
        fmt.Println(sig)
        done &amp;lt;- true
    }()

    fmt.Println(&amp;quot;awaiting signal&amp;quot;)
    &amp;lt;-done
    fmt.Println(&amp;quot;exiting&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;stop&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;唯一从信号集去除信号的方法是调用Stop。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Stop(c chan&amp;lt;- os.Signal)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stop函数让signal包停止向c转发信号。它会取消之前使用c调用的所有Notify的效果。当Stop返回后，会保证c不再接收到任何信号。&lt;/p&gt;

&lt;h1 id=&#34;os-exec&#34;&gt;os/exec&lt;/h1&gt;

&lt;h2 id=&#34;进程io&#34;&gt;进程io&lt;/h2&gt;

&lt;p&gt;exec包用于执行外部命令。它包装了os.StartProcess函数以便更容易的修正输入和输出，使用管道连接I/O。主要用于创建一个子进程来执行相关的命令。创建子进程一定要wait，不能出现僵死进程。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;调用脚本命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在golang标准库中提供了两种方式可以用来启动进程调用脚本&lt;/p&gt;

&lt;p&gt;第一种是在os库中的Process类型，Process类型包含一系列方法用来启动进程并对进程进行操作（参考： &lt;a href=&#34;https://golang.org/pkg/os/#Process）&#34;&gt;https://golang.org/pkg/os/#Process）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;示例 使用Process执行脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
)

func main() {
    shellPath := &amp;quot;/home/xx/test.sh&amp;quot;
    argv := make([]string, 1) 
    attr := new(os.ProcAttr)
    newProcess, err := os.StartProcess(shellPath, argv, attr)  //运行脚本
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(&amp;quot;Process PID&amp;quot;, newProcess.Pid)
    processState, err := newProcess.Wait() //等待命令执行完
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(&amp;quot;processState PID:&amp;quot;, processState.Pid())//获取PID
    fmt.Println(&amp;quot;ProcessExit:&amp;quot;, processState.Exited())//获取进程是否退出
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种是在os/exec库种通过Cmd类型的各个函数实现对脚本的调用，实际上Cmd是对Process中各种方法的高层次封装（参考： &lt;a href=&#34;https://golang.org/pkg/os/exec/）&#34;&gt;https://golang.org/pkg/os/exec/）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1、LookPath&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func LookPath(file string) (string, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在环境变量PATH指定的目录中搜索可执行文件，如file中有斜杠，则只在当前目录搜索。返回完整路径或者相对于当前目录的一个相对路径。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    output, err := exec.LookPath(&amp;quot;ls&amp;quot;)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf(output)
}

output:

[ `go run test.go` | done: 616.254982ms ]
  /bin/ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、Cmd&lt;/p&gt;

&lt;p&gt;Cmd代表一个正在准备或者在执行中的外部命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Cmd struct {
    // Path是将要执行的命令的路径。
    //
    // 该字段不能为空，如为相对路径会相对于Dir字段。
    Path string
    // Args保管命令的参数，包括命令名作为第一个参数；如果为空切片或者nil，相当于无参数命令。
    //
    // 典型用法下，Path和Args都应被Command函数设定。
    Args []string
    // Env指定进程的环境，如为nil，则是在当前进程的环境下执行。
    Env []string
    // Dir指定命令的工作目录。如为空字符串，会在调用者的进程当前目录下执行。
    Dir string
    // Stdin指定进程的标准输入，如为nil，进程会从空设备读取（os.DevNull）
    Stdin io.Reader
    // Stdout和Stderr指定进程的标准输出和标准错误输出。
    //
    // 如果任一个为nil，Run方法会将对应的文件描述符关联到空设备（os.DevNull）
    //
    // 如果两个字段相同，同一时间最多有一个线程可以写入。
    Stdout io.Writer
    Stderr io.Writer
    // ExtraFiles指定额外被新进程继承的已打开文件流，不包括标准输入、标准输出、标准错误输出。
    // 如果本字段非nil，entry i会变成文件描述符3+i。
    //
    // BUG: 在OS X 10.6系统中，子进程可能会继承不期望的文件描述符。
    // http://golang.org/issue/2603
    ExtraFiles []*os.File
    // SysProcAttr保管可选的、各操作系统特定的sys执行属性。
    // Run方法会将它作为os.ProcAttr的Sys字段传递给os.StartProcess函数。
    SysProcAttr *syscall.SysProcAttr
    // Process是底层的，只执行一次的进程。
    Process *os.Process
    // ProcessState包含一个已经存在的进程的信息，只有在调用Wait或Run后才可用。
    ProcessState *os.ProcessState
    // 内含隐藏或非导出字段
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用Command来创建cmd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Command(name string, arg ...string) *Cmd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数返回一个*Cmd，用于使用给出的参数执行name指定的程序。返回值只设定了Path和Args两个参数。&lt;/p&gt;

&lt;p&gt;如果name不含路径分隔符，将使用LookPath获取完整路径；否则直接使用name。参数arg不应包含命令名&lt;/p&gt;

&lt;p&gt;使用Run运行cmd命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Cmd) Run() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run执行c包含的命令，并阻塞直到完成。如果命令成功执行，stdin、stdout、stderr的转交没有问题，并且返回状态码为0，方法的返回值为nil；如果命令没有执行或者执行失败，会返回错误；&lt;/p&gt;

&lt;p&gt;使用Start和wait来运行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Cmd) Start() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start开始执行c包含的命令，但并不会等待该命令完成即返回。可以配合使用Wait方法来达到和Run一样的效果。wait方法会返回命令的返回状态码并在命令返回后释放相关的资源。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Cmd) Wait() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wait会阻塞直到该命令执行完成，该命令必须是被Start方法开始执行的。&lt;/p&gt;

&lt;p&gt;通过Run的源码可以看出其实Run方法内部也是调用了Start和Wait方法。Run方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Cmd) Run() error {
    if err := c.Start(); err != nil {
        return err
    }
    return c.Wait()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    cmd := exec.Command(&amp;quot;tr&amp;quot;, &amp;quot;a-z&amp;quot;, &amp;quot;A-Z&amp;quot;)
    cmd.Stdin = strings.NewReader(&amp;quot;abc def&amp;quot;)
    var out bytes.Buffer
    cmd.Stdout = &amp;amp;out
    err := cmd.Run()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&amp;quot;GOGOGO: %q\n&amp;quot;, out.String())
}

output:

[ `go run test.go` | done: 286.798242ms ]
  GOGOGO: &amp;quot;ABC DEF&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用Output输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Cmd) Output() ([]byte, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行命令并返回标准输出的切片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Cmd) CombinedOutput() ([]byte, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行命令并返回标准输出和错误输出合并的切片.&lt;/p&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    out, err := exec.Command(&amp;quot;date&amp;quot;).Output()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&amp;quot;The date is %s\n&amp;quot;, out)
}

output:

[ `go run test.go` | done: 585.495467ms ]
  The date is Tue Aug  1 19:24:11 CST 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用pipe&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (*Cmd) StdinPipe
func (c *Cmd) StdinPipe() (io.WriteCloser, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StdinPipe方法返回一个在命令Start后与命令标准输入关联的管道。Wait方法获知命令结束后会关闭这个管道。必要时调用者可以调用Close方法来强行关闭管道，例如命令在输入关闭后才会执行返回时需要显式关闭管道。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (*Cmd) StdoutPipe
func (c *Cmd) StdoutPipe() (io.ReadCloser, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StdoutPipe方法返回一个在命令Start后与命令标准输出关联的管道。Wait方法获知命令结束后会关闭这个管道，一般不需要显式的关闭该管道。但是在从管道读取完全部数据之前调用Wait是错误的；同样使用StdoutPipe方法时调用Run函数也是错误的。例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (*Cmd) StderrPipe
func (c *Cmd) StderrPipe() (io.ReadCloser, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StderrPipe方法返回一个在命令Start后与命令标准错误输出关联的管道。Wait方法获知命令结束后会关闭这个管道，一般不需要显式的关闭该管道。但是在从管道读取完全部数据之前调用Wait是错误的；同样使用StderrPipe方法时调用Run函数也是错误的。请参照StdoutPipe的例子。&lt;/p&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    cmd := exec.Command(&amp;quot;echo&amp;quot;, &amp;quot;-n&amp;quot;, `{&amp;quot;Name&amp;quot;: &amp;quot;Bob&amp;quot;, &amp;quot;Age&amp;quot;: 32}`)
    stdout, err := cmd.StdoutPipe()
    if err != nil {
        log.Fatal(err)
    }
    if err := cmd.Start(); err != nil {
        log.Fatal(err)
    }
    var person struct {
        Name string
        Age  int
    }
    json.NewDecoder(r)
    if err := json.NewDecoder(stdout).Decode(&amp;amp;person); err != nil {
        log.Fatal(err)
    }
    if err := cmd.Wait(); err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&amp;quot;%s is %d years old\n&amp;quot;, person.Name, person.Age)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取命令返回值&lt;/p&gt;

&lt;p&gt;实际上脚本或命令执行完后，会将结果返回到ProcessState中的status去， 但是status不是export的，所以我们需要通过一些手段将脚本返回值从syscall.WaitStatus找出来&lt;/p&gt;

&lt;p&gt;ProcessState定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ProcessState struct {
    pid    int                // The process&#39;s id.
    status syscall.WaitStatus // System-dependent status info.
    rusage *syscall.Rusage
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于上面使用Cmd的例子，可以在进程退出后可以通过以下语句获取到返回值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(&amp;quot;Exit Code&amp;quot;, command.ProcessState.Sys().(syscall.WaitStatus).ExitStatus())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用Process方式的也可以通过对ProcessState通过相同的方式获取到返回结果。&lt;/p&gt;

&lt;h1 id=&#34;os-user&#34;&gt;os/user&lt;/h1&gt;

&lt;p&gt;os/user 模块的主要作用是通过用户名或者 id 从而获取系统用户的相关属性。&lt;/p&gt;

&lt;h2 id=&#34;类型-1&#34;&gt;类型&lt;/h2&gt;

&lt;p&gt;User 结构体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User struct {
    Uid      string
    Gid      string
    Username string
    Name     string
    HomeDir  string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;User 代表一个用户账户：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Uid ：用户的 ID&lt;/li&gt;
&lt;li&gt;Gid ：用户所属组的 ID，如果属于多个组，那么此 ID 为主组的 ID&lt;/li&gt;
&lt;li&gt;Username ：用户名&lt;/li&gt;
&lt;li&gt;Name ：属组名称，如果属于多个组，那么此名称为主组的名称&lt;/li&gt;
&lt;li&gt;HomeDir ：用户的宿主目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;返回当前用户。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Current() (*User, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过用户名查找用户，如果没有找到这个用户那么将返回 UnknownUserError 错误类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Lookup(username string) (*User, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过用户 ID 查找用户，如果没有找到这个用户那么将返回 UnknownUserIdError 错误类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func LookupId(uid string) (*User, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;os/user&amp;quot;
    &amp;quot;reflect&amp;quot;
)

func main() {
    fmt.Println(&amp;quot;== 测试 Current 正常情况 ==&amp;quot;)
    if u, err := user.Current(); err == nil {
        fmt.Println(&amp;quot;用户ID: &amp;quot; + u.Uid)
        fmt.Println(&amp;quot;主组ID: &amp;quot; + u.Gid)
        fmt.Println(&amp;quot;用户名: &amp;quot; + u.Username)
        fmt.Println(&amp;quot;主组名: &amp;quot; + u.Name)
        fmt.Println(&amp;quot;家目录: &amp;quot; + u.HomeDir)
    }

    fmt.Println(&amp;quot;== 测试 Lookup 正常情况 ==&amp;quot;)
    if u, err := user.Lookup(&amp;quot;root&amp;quot;); err == nil {
        fmt.Println(&amp;quot;用户ID: &amp;quot; + u.Uid)
        fmt.Println(&amp;quot;主组ID: &amp;quot; + u.Gid)
        fmt.Println(&amp;quot;用户名: &amp;quot; + u.Username)
        fmt.Println(&amp;quot;主组名: &amp;quot; + u.Name)
        fmt.Println(&amp;quot;家目录: &amp;quot; + u.HomeDir)
    }
    fmt.Println(&amp;quot;== 测试 Lookup 异常情况 ==&amp;quot;)
    if _, err := user.Lookup(&amp;quot;roo&amp;quot;); err == nil {
    } else {
        fmt.Println(&amp;quot;错误信息: &amp;quot; + err.Error())
        fmt.Print(&amp;quot;错误类型: &amp;quot;)
        fmt.Println(reflect.TypeOf(err))
    }

    fmt.Println(&amp;quot;== 测试 LookupId 正常情况 ==&amp;quot;)
    if u, err := user.LookupId(&amp;quot;0&amp;quot;); err == nil {
        fmt.Println(&amp;quot;用户ID: &amp;quot; + u.Uid)
        fmt.Println(&amp;quot;主组ID: &amp;quot; + u.Gid)
        fmt.Println(&amp;quot;用户名: &amp;quot; + u.Username)
        fmt.Println(&amp;quot;主组名: &amp;quot; + u.Name)
        fmt.Println(&amp;quot;家目录: &amp;quot; + u.HomeDir)
    }
    fmt.Println(&amp;quot;== 测试 LookupId 异常情况 ==&amp;quot;)
    if _, err := user.LookupId(&amp;quot;10000&amp;quot;); err == nil {
    } else {
        fmt.Println(&amp;quot;错误信息: &amp;quot; + err.Error())
        fmt.Print(&amp;quot;错误类型: &amp;quot;)
        fmt.Println(reflect.TypeOf(err))
    }

}
输出结果如下：

== 测试 Current 正常情况 ==
用户ID: 0
主组ID: 0
用户名: root
主组名: root
家目录: /root
== 测试 Lookup 正常情况 ==
用户ID: 0
主组ID: 0
用户名: root
主组名: root
家目录: /root
== 测试 Lookup 异常情况 ==
错误信息: user: unknown user roo
错误类型: user.UnknownUserError
== 测试 LookupId 正常情况 ==
用户ID: 0
主组ID: 0
用户名: root
主组名: root
家目录: /root
== 测试 LookupId 异常情况 ==
错误信息: user: unknown userid 10000
错误类型: user.UnknownUserIdError
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
      
    
      
        <item>
          <title>用hugo&#43;github构建自己的blog</title>
          <link>https://kingjcy.github.io/post/tool/hugo-blog-build/</link>
          <pubDate>Fri, 29 Aug 2014 09:29:40 CST</pubDate>
          <author></author>
          <guid>https://kingjcy.github.io/post/tool/hugo-blog-build/</guid>
          <description>&lt;p&gt;这个是我用hugo+github搭建起个人blog写的第一篇文章，有点小兴奋。。。首先把搭建测过程写起来和大家分享一下吧。&lt;/p&gt;

&lt;p&gt;首先，作为一个程序员，不拥有自己搭建的blog，而去用别人搭建好的去注册一下，我是无法接受的！！搭建个人blog需要两个东西：&lt;/p&gt;

&lt;p&gt;1、静态网页生成器，有jekyll，hexo，hugo等，由于最近在玩go语言，所以就选择了hugo，其他的也没有深入了解，后面搭建起来，发现hugo还是比较简单。&lt;/p&gt;

&lt;p&gt;2、github pages 这个是github提供的一个托管工作，相当好用。&lt;/p&gt;

&lt;h1 id=&#34;静态页面生成器hugo&#34;&gt;静态页面生成器hugo&lt;/h1&gt;

&lt;p&gt;这个比较方便的静态页面生成器，首先需要安装，我的系统是centos 64位的.&lt;/p&gt;

&lt;p&gt;现在换成了macos系统了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;install&#34;&gt;install&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、直接下载二进制文件，这也是我说的方便的地方。&lt;/p&gt;

&lt;p&gt;Hugo二进制下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2。使用macos系统后直接使用homebrew进行安装更新，这个就是一个类似于linux的yum的工具。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install hugo
brew upgrade hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;use&#34;&gt;use&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;下载下来后，首先要生成自己的站点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`hugo new site mysite`--这边hugo的二进制文件不一定是这个名字，可以起个别名alias来用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时会在mysite目录下生成一些目录和文件，这边简单的介绍一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、config.toml是网站的配置文件，这是它的作者GitHub联合创始人Tom Preston-Werner 觉得YAML不够优雅，捣鼓出来的一个新格式。如果你不喜欢这种格式，你可以将config.toml替换为YAML格式的config.yaml，或者json格式的config.json。hugo都支持。
2、content目录里放的是你写的markdown文章。
3、layouts目录里放的是网站的模板文件。
4、static目录里放的是一些图片、css、js等资源。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入站点目录mysite，新建文档&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`cd mysite`

`hugo new about.md`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边新建一个md文件会出现在content目录下，一般这个about.md文件是一个关于本站的介绍或者blog个人介绍，在这边将一下md文件的编辑，其实就是MarkDown格式文件的编写，具体的格式可以参考本文的编辑，或者去网上去搜索一下就ok,这边我说几点，我经常记错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、就是&amp;quot;+++&amp;quot;内的赋值用&amp;quot;=&amp;quot;，&amp;quot;---&amp;quot;内的用&amp;quot;:&amp;quot;。

2、`###`后面必须有空格。

3、有空行才能换行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般我们写博文，会放在content/post下，正如我这边编写的第一篇文&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`hugo new post/first.md`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用vim编辑器进行编辑，编辑好后，就可以将你编辑的文字生成静态网页了，当然你肯定需要一个模板，这样可以使你的网页根据美观，这边在讲一下模板的使用&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;模版&#34;&gt;模版&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、模板放在站点的themes下，一般木有这个文件夹，我们需要新增一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`mkdir themes`

`cd themes`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、模板可以到hugo官网上去找,那边可以showcase预览一下自己喜欢的，具体的安装方式也有介绍，就是用&lt;code&gt;git clone&lt;/code&gt;把源码下到themes目录下就好&lt;/p&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;https://gohugo.io/overview/introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、编辑模板的配置文件，这个视具体模板，可以参考我的配置&lt;a href=&#34;https://github.com/kingjcy/&#34;&gt;https://github.com/kingjcy/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面就是生成我们需要的静态网页了，也就是前端的html文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`hugo --theme=hyde --baseUrl=&amp;quot;http://kingjcy.github.io/&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不出意外的话，应该在站点目录下生成一个public文件夹，这个就是我们需要的所有文件了，至此第一步已经完成了。可以看见直接编译是hugo，启动一个web服务是hugo server&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、huo new XXXX生成文件是可以直接生成自己想要的内容的，取决于模版，默认是archetypes/default.md，可以对其进行修改，变成自己的样子。&lt;/p&gt;

&lt;p&gt;2、使用图片，默认把图片放在media目录下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![](/media/worklife/baby/XXX.JPG)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;github-pages托管&#34;&gt;github pages托管&lt;/h1&gt;

&lt;p&gt;这个就简单了，因为本身就是github提供现成的东西，首先新增一个repo，命名为：&lt;code&gt;kingjcy.github.io&lt;/code&gt; （kingjcy替换为你的github用户名）。&lt;/p&gt;

&lt;p&gt;然后将第一步的public加入git版本，上传到这个项目，就可以访问你的个人blog：&lt;code&gt;http://kingjcy.github.io/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;至于git版本控制和github直接的传输，这边就不多讲了，如果需要可以参考我的另外一篇博文《git和github的使用》。&lt;/p&gt;

&lt;p&gt;这边简单列举一些过程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd public
$ git init
$ git remote add origin https://github.com/kingjcy/kingjcy.github.io.git
$ git add -A
$ git commit -m &amp;quot;first commit&amp;quot;
$ git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于搭建完了，欢迎指正,tks。&lt;/p&gt;</description>
        </item>
      
    
      
    

  </channel>
</rss>
