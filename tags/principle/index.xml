<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Principle on kingjcy blog</title>
    <link>https://kingjcy.github.io/tags/principle/</link>
    <description>Recent content in Principle on kingjcy blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2020. All rights reserved.</copyright>
    <lastBuildDate>Thu, 14 Mar 2019 16:29:55 +0800</lastBuildDate>
    
	<atom:link href="https://kingjcy.github.io/tags/principle/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>容器系列---- Docker Principle</title>
      <link>https://kingjcy.github.io/post/cloud/paas/docker/docker-principle/</link>
      <pubDate>Thu, 14 Mar 2019 16:29:55 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/cloud/paas/docker/docker-principle/</guid>
      <description> cgroup和namespace类似，也是将进程进行分组，但它的目的和namespace不一样，namespace是为了隔离进程组之间的资源，而cgroup是为了对一组进程进行统一的资源监控和限制。
架构 原理  docker原理  docker在版本0.9之前是以lxc（linux container）为基础的，0.9以后又引入了自己开发的libcontainer，试图设计出更加通用的容器化技术。
docker采用c/s架构，服务端默认在后台运行，进行容器的创建等相关操作，客户端就是我们调用的命令行操作.每次客户端运行完就会退出等待再次调用，客户端和服务端是通过socket进行通信的，默认是unix:///var/run/docker.sock,可以通过-H参数修改端口。
docker都是独立的系统，是对操作系统的一种虚拟化。所以需要对其内核，文件系统，网络，PID，UID，IPC，内存，硬盘，cpu进行限制隔离，我们就是通过命名空间namespace，控制组cgroup，联合文件系统UFS，虚拟网络来完成的隔离独立运行。
docker是一种轻量级的操作系统虚拟化方案，基于LXC，相对于传统的vm，它只虚拟来操作系统而没有虚拟内核，基于docker engine共享内核，即虚拟出运行库即可运行app，而传统的vm都是虚拟出完整的内核和运行库文件的操作系统。即虚拟出运行库即可运行app，而传统的vm都是虚拟出完整的内核和运行库文件的操作系统。
docker网络原理（todo） </description>
    </item>
    
    <item>
      <title>prometheus系列---- Prometheus Principle</title>
      <link>https://kingjcy.github.io/post/monitor/prometheus/prometheus-principle/</link>
      <pubDate>Sun, 13 May 2018 17:56:03 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/monitor/prometheus/prometheus-principle/</guid>
      <description>&lt;p&gt;本篇文章主要是对prometheus的一些原理进行解析。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nsq Principle</title>
      <link>https://kingjcy.github.io/post/middleware/mq/nsq-principle/</link>
      <pubDate>Tue, 20 Jun 2017 20:22:38 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/middleware/mq/nsq-principle/</guid>
      <description>&lt;p&gt;nsq的原理解析&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>redis系列---- redis集群的原理</title>
      <link>https://kingjcy.github.io/post/database/redis/redis_cluster_principle/</link>
      <pubDate>Sun, 12 Feb 2017 16:55:06 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/database/redis/redis_cluster_principle/</guid>
      <description>&lt;p&gt;自从研究了redis的监控工具之后，对于redis的集群实现方案又回头做了一个系统的研究。&lt;/p&gt;

&lt;p&gt;首先，先说一下redis，是一个高性能的key-value类型的NoSQL数据库，支持较为丰富的数据类型，单机Redis在普通的服务器上通常ops上限在5w左右，开启pipeline的情况下在20-30w左右。对于大多数中小公司来说，通常单机的Redis已经足够，最多根据不同业务分散到多台Redis。但是随着数据的越来越多，也迫切需求支持分布式集群。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>