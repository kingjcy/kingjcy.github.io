<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Golang">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:title" content="Golang - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Golang - kingjcy blog
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="posts">
    
    
<article class="post li">
    <header>
        <div class="post-date">
            2020年01月10日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>
        </h2>
    </header>
    <div class="post-content">
        性能压测是我们写接口或者程序的时候经常需要进行的一项工作，golang有很多的压测工具，这边做一个整理。
基本概念 1.压测是什么
压测，即压力测试，是确立系统稳定性的一种测试方法，通常在系统正常运作范围之外进行，以考察其功能极限和隐患。
主要检测服务器的承受能力，包括用户承受能力（多少用户同时玩基本不影响质量）、流量承受等。
2.为什么要压测
压测的目的就是通过压测(模拟真实用户的行为)，测算出机器的性能(单台机器的QPS)，从而推算出系统在承受指定用户数(100W)时，需要多少机器能支撑得住
压测是在上线前为了应对未来可能达到的用户数量的一次预估(提前演练)，压测以后通过优化程序的性能或准备充足的机器，来保证用户的体验。
3.压测名词解释
压测类型解释
压力测试(Stress Testing) 也称之为强度测试，测试一个系统的最大抗压能力，在强负载(大数据、高并发)的情况下，测试系统所能承受的最大压力，预估系统的瓶颈 并发测试(Concurrency Testing) 通过模拟很多用户同一时刻访问系统或对系统某一个功能进行操作，来测试系统的性能，从中发现问题(并发读写、线程控制、资源争抢) 耐久性测试(Configuration Testing) 通过对系统在大负荷的条件下长时间运行，测试系统、机器的长时间运行下的状况,从中发现问题(内存泄漏、数据库连接池不释放、资源不回收)  压测名词解释
并发(Concurrency) 指一个处理器同时处理多个任务的能力(逻辑上处理的能力) 并行(Parallel) 多个处理器或者是多核的处理器同时处理多个不同的任务(物理上同时执行) QPS(每秒钟查询数量 Query Per Second) 服务器每秒钟处理请求数量 (req/sec 请求数/秒 一段时间内总请求数/请求时间) 事务(Transactions) 是用户一次或者是几次请求的集合 TPS(每秒钟处理事务数量 Transaction Per Second) 服务器每秒钟处理事务数量(一个事务可能包括多个请求) 请求成功数(Request Success Number) 在一次压测中，请求成功的数量 请求失败数(Request Failures Number) 在一次压测中，请求失败的数量 错误率(Error Rate) 在压测中，请求成功的数量与请求失败数量的比率 最大响应时间(Max Response Time) 在一次事务中，从发出请求或指令系统做出的反映(响应)的最大时间 最少响应时间(Mininum Response Time) 在一次事务中，从发出请求或指令系统做出的反映(响应)的最少时间 平均响应时间(Average Response Time) 在一次事务中，从发出请求或指令系统做出的反映(响应)的平均时间  4.机器性能指标解释
CUP利用率(CPU Usage) CUP 利用率分用户态、系统态和空闲态，CPU利用率是指:CPU执行非系统空闲进程的时间与CPU总执行时间的比率 内存使用率(Memory usage) 内存使用率指的是此进程所开销的内存。 IO(Disk input/ output) 磁盘的读写包速率 网卡负载(Network Load) 网卡的进出带宽,包量  5.
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年11月19日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>
        </h2>
    </header>
    <div class="post-content">
        <p>传输层安全协议（Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年11月10日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>
        </h2>
    </header>
    <div class="post-content">
        <p>企图利用Web应用漏洞的攻击者，对于Web程序安全这个话题都给予了越来越多的关注。特别是最近CSDN密码泄露事件，更是让我们对Web安全这个话题更加重视，所有人都谈密码色变，都开始检测自己的系统是否存在漏洞。那么我们作为一名Go程序的开发者，一定也需要知道我们的应用程序随时会成为众多攻击者的目标，并提前做好防范的准备。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年11月10日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>
        </h2>
    </header>
    <div class="post-content">
        <p>限流器是后台服务中的非常重要的组件，可以用来限制请求速率，保护服务，以免服务过载。限流器的实现方法有很多种，例如滑动窗口法、Token Bucket、Leaky Bucket等。</p>

<p>其实golang标准库中就自带了限流算法的实现，即golang.org/x/time/rate。该限流器是基于Token Bucket(令牌桶)实现的。</p>

<p>令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放Token，桶满则暂时不放。而用户则从桶中取Token，如果有剩余Token就可以一直取。如果没有剩余Token，则需要等到系统中被放置了Token才行。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年10月11日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-container-list/">golang使用系列---- List</a>
        </h2>
    </header>
    <div class="post-content">
        <p>list是一个双向链表。该结构具有链表的所有功能。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年10月11日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>
        </h2>
    </header>
    <div class="post-content">
        <p>堆（Heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年10月07日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>
        </h2>
    </header>
    <div class="post-content">
        <p>这边主要是go 如何实现代理转发的</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年08月27日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-gc/">golang使用系列---- Gc</a>
        </h2>
    </header>
    <div class="post-content">
        <p>以下是Golang GC算法的里程碑：</p>

<pre><code>v1.1 STW（停止所有运行时）
v1.3 Mark（标记） STW（停止所有运行时）, Sweep（清除） 并行
v1.5 三色标记法
v1.8 三色标记法 + hybrid write barrier（混合屏障）
</code></pre>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年06月17日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-encode/">Golang使用系列---- encode</a>
        </h2>
    </header>
    <div class="post-content">
        <p>编码是我们编程过程中常用的方法，encoding包定义了供其它包使用的可以将数据在字节和文本之间转换的接口。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年06月06日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>
        </h2>
    </header>
    <div class="post-content">
        <p>Golang的加密库都放在crypto目录下。在crypto这个文件中搜集了常用的密码（算法）常量。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年03月04日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-threadsafety/">Go Threadsafety</a>
        </h2>
    </header>
    <div class="post-content">
        <p>golang中的线程安全问题是如何解决的？</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年03月01日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-websocket/">Go Websocket</a>
        </h2>
    </header>
    <div class="post-content">
        <p>最近工作需要，对 WebSocket 进行了一点研究， WebSocket 协议、WebSocket 的 Go 语言实现，以及 socket.io 服务端库的 Go 语言实现的理解。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年02月28日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-map/">golang使用系列---- Map</a>
        </h2>
    </header>
    <div class="post-content">
        map map就是k/v的映射，map持有对底层数据结构的引用。如果将map传递给函数，其对map的内容做了改变，则这些改变对于调用者是可见的。
 map的实现
 所有的Map底层一般都是使用数组+链表的hashmap来实现，会借用哈希算法辅助。对于给定的 key，一般先进行 hash 操作，然后相对哈希表的长度取模，将 key 映射到指定的链表中。
Golang的map正常是使用哈希表作为底层实现
hashtable是一种根据key，key在通过hash函数来对应的数组的数据。 hashmap是hashtable使用拉链法实现的一种方式，数组+链表的实现方式  正常情况下，golang使用数组+桶（buckets）来实现，默认每个桶的数量是8个，在超出8个的情况下，新增一个桶，使用链表连接起来，这是时候就变成了hash数组 + 桶 + 溢出的桶链表了。
其实map不是并发安全的，也是因为hashmap不是并发安全的，实现并发安全的几种方式，可以参考并发安全
数据结构
map数据结构由runtime/map.go/hmap定义:
hmap
type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra }   count 表示当前哈希表中的元素数量；类似于buckets[count] B表示当前哈希表持有的buckets数量，但是因为哈希表中桶的数量都2的倍数，所以该字段会存储对数，也就是 len(buckets) == 2^B；类似于buckets[2^B] hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入； oldbuckets 是哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半；  bmap
type bmap struct { tophash [8]uint8 //存储哈希值的高8位 //data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。 data byte[1] //key value数据:key/key/key/.
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年02月28日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-sync/">golang使用系列---- Sync</a>
        </h2>
    </header>
    <div class="post-content">
        sync sync包提供了基本的同步基元，如互斥锁。除了Once和WaitGroup类型，大部分都是适用于低水平程序线程，高水平的同步使用channel通信（csp）更好一些。
Once 的使用
定义
type Once struct { // 非暴露字段 } func (o *Once) Do(f func())  使用前先定义 Once 类型变量：
var once Once  使用的时候向 Once 类型变量传入函数：
once.Do(func() { init() })  多次调用 once.Do(f) 只会触发一次 f 的执行，即第一次 f 的执行。
用法实例
某些操作只需要执行一次（比如一些初始化动作），这时就可使用 Once，如：
func main() { var once sync.Once onceBody := func() { fmt.Println(&quot;Only once&quot;) } done := make(chan bool) // 创建 10 个 goroutine，但是 onceBody 只会执行 1 次 for i := 0; i &lt; 10; i++ { go func() { once.
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年02月28日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-mutex/">golang使用系列---- mutex</a>
        </h2>
    </header>
    <div class="post-content">
        <p>锁是一种常见的并发控制技术，我们一般会将锁分成乐观锁和悲观锁，即乐观并发控制和悲观并发控制。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年02月01日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-sort/">golang使用系列---- Sort</a>
        </h2>
    </header>
    <div class="post-content">
        <p>golang中也实现了排序算法的包sort包．</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2019年02月01日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-math/">Go Math</a>
        </h2>
    </header>
    <div class="post-content">
        <p>math包实现的就是数学函数计算。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2018年12月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-bufio/">golang使用系列---- Bufio</a>
        </h2>
    </header>
    <div class="post-content">
        缓存IO bufio 包实现了缓存IO。它包装了 io.Reader 和 io.Writer 对象，创建了另外的Reader和Writer对象，它们也实现了 io.Reader 和 io.Writer 接口，不过它们是有缓存的。该包同时为文本I/O提供了一些便利操作。
Reader 类型和方法 类型 bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口。
Reader 结构没有任何导出的字段，结构定义如下：
type Reader struct { buf []byte // 缓存 rd io.Reader // 底层的io.Reader // r:从buf中读走的字节（偏移）；w:buf中填充内容的偏移； // w - r 是buf中可被读的长度（缓存数据的大小），也是Buffered()方法的返回值 r, w int err error // 读过程中遇到的错误 lastByte int // 最后一次读到的字节（ReadByte/UnreadByte) lastRuneSize int // 最后一次读到的Rune的大小 (ReadRune/UnreadRune) }  实例化
bufio 包提供了两个实例化 bufio.Reader 对象的函数：NewReader 和 NewReaderSize。其中，NewReader 函数是调用 NewReaderSize 函数实现的：
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2018年12月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-syscall/">golang使用系列---- Syscall</a>
        </h2>
    </header>
    <div class="post-content">
        
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2018年09月26日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-net-http-pporf/">golang使用系列---- net/http/pprof</a>
        </h2>
    </header>
    <div class="post-content">
        PProf 想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：
runtime/pprof：采集程序（非 Server）的运行数据进行分析 net/http/pprof：采集 HTTP Server 的运行时数据进行分析  其实net/http/pprof中只是使用runtime/pprof包来进行封装了一下，并在http端口上暴露出来
原理 pprof 是用于可视化和分析性能分析数据的工具
pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）
profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式
使用 支持什么使用模式
Report generation：报告生成 Interactive terminal use：交互式终端使用 Web interface：Web 界面  可以做什么
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况  实例 我们将编写一个简单且有点问题的例子，用于基本的程序初步分析
package main import ( &quot;log&quot; &quot;net/http&quot; _ &quot;net/http/pprof&quot; &quot;github.
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2018年05月09日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/future/blockchain/">Blockchain</a>
        </h2>
    </header>
    <div class="post-content">
        区块链发展方向主要有三个，新建公有链、私有链和侧链。
目前比特币是全世界最大也是应用最广的系统，大家借鉴比特币技术运用区块链技术来往其它领域应用，目前大概有这几个方向，
第一个，新建一条新的区块链，跟比特币没有关系，典型的如以太坊，这个区块链是公有的，每个人都可以参加。
另外一个是私有链，大家熟悉的，像R3、Hyper ledger就属于这种，已经实现了在区块链上分布式结算，可以给银行用。比如R3找每家银行谈，让银行加入联盟，一起来搞一个联盟来研究。目前全球有100多家银行加入了，比如摩根士丹利。
第三是侧链，这是很有意思的事情，因为比特币的区块链设计，当最初的设计只是想由我来做一种信任，所以在区块结构上没有支持很多复杂的数据结构以及操作，Blockstream把起点放在区块链的某一个节点上，比特币强大的计算力来维护这一套节点的真实性。然后我往后可以定义我自己复杂的结构，可以实现以太坊所有的功能，但是他可以定期把他的往后延伸节点再做Hash，用比特币的区块链来辅助证明他这一套公有链的信用。
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2018年02月26日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-server/">Go Server</a>
        </h2>
    </header>
    <div class="post-content">
        <p>基于go-net的http协议和go-rpc的协议实现服务器框架</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2018年01月13日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-ioutil/">golang使用系列---- Ioutil</a>
        </h2>
    </header>
    <div class="post-content">
        <p>Package ioutil implements some I/O utility functions.主要是提供了一些常用、方便的IO操作函数。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年12月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-bytes/">golang使用系列---- Bytes</a>
        </h2>
    </header>
    <div class="post-content">
        <p>该包定义了一些操作 byte slice 的便利操作。因为字符串可以表示为 []byte，因此，bytes 包定义的函数、方法等和 strings 包很类似，所以讲解时会和 strings 包类似甚至可以直接参考。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年12月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-archive/">golang使用系列---- Archive</a>
        </h2>
    </header>
    <div class="post-content">
        archive就是使用tar和zip两种方式对文档进行归档。压缩看compress包。
 tar和zip有什么不同
 二者使用平台不同，对于 Windows 平台而言，最常用的格式是 zip 和 rar，国内大多数是用 rar，国外大多数是用 zip。而对于类 Unix 平台而言，常用的格式是 tar 和 tar.gz，zip 比较少一些，rar 则几乎没有。
zip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip 有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。
严格的说，tar 只是一种打包格式，并不对文件进行压缩，主要是为了便于文件的管理，所以打包后的文档大小一般远远大于 zip 和 tar.gz，但这种格式也有很明显的优点，例如打包速度非常快，打包时 CPU 占用率也很低，因为不需要压缩嘛。
archive/tar 单个文件操作 这个非常简单，就是读取一个文件，进行打包及解包操作即可。
1.单个文件打包
从 /etc/passwd 下复制了一个 passwd 文件到当前目录下，用来做压缩测试。什么文件都是可以的，自己随意写一个也行。这里的示例主要为了说明 tar ，没有处理路径，所以过程全部假设是在当前目录下执行。
cp /etc/passwd .  关于文件的打包直接查看示例代码，已经在示例代码中做了详细的注释。
package main import ( &quot;os&quot; &quot;log&quot; &quot;archive/tar&quot; &quot;fmt&quot; &quot;io&quot; ) func main() { // 准备打包的源文件 var srcFile = &quot;passwd&quot; // 打包后的文件 var desFile = fmt.
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年07月07日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-config/">config</a>
        </h2>
    </header>
    <div class="post-content">
        <p>go语言中使用YAML、json、xml、ini作为配置文件。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年06月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/frame/echo/">echo</a>
        </h2>
    </header>
    <div class="post-content">
        
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年06月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/frame/beego/">golang框架系列---- Beego</a>
        </h2>
    </header>
    <div class="post-content">
        <p>beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年06月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/frame/frame/">golang框架系列---- 概述</a>
        </h2>
    </header>
    <div class="post-content">
        go目前已经有很多框架可以使用了，但是并木有像java一样的spring一统天下，我们还是需要按着需要去选择。
大多数 Gopher 应该对于 Awesome-go[https://awesome-go.com/]应该都不陌生。 Awesome-go 是个很优秀的项目，里面收录了很多优秀的用 Go 编写的开源库、框架、软件 截至目前，Awesome-go 已经收录了Web框架、机器学习、分布式系统、编译器、物联网、持续集成等方方面面共计 81 类大项， 1777 个用 Go 编写的仓库，很多我们平常开发上所需要的库都能在上面能找到，为我们省去了不少时间。
awesome-go-cn[https://github.com/yinggaozhen/awesome-go-cn] 在 awesome-go 基础上，针对我们日常使用中的痛点做了一系列改进，你或许可以简单理解为它是 中文加强版awesome-go。
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年06月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/frame/iris/">iris</a>
        </h2>
    </header>
    <div class="post-content">
        
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年06月25日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/frame/martini/">martini</a>
        </h2>
    </header>
    <div class="post-content">
        
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年03月26日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-concurrence/">golang使用系列---- Concurrence</a>
        </h2>
    </header>
    <div class="post-content">
        <p>并发编程是我们计算机技术中最常用的一种编程技术。是一种基于多元程序的一种应用</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年03月12日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-unicode/">Go Unicode</a>
        </h2>
    </header>
    <div class="post-content">
        <p>Unicode只是定义了一个字符和一个编码的映射，但是呢，对应的存储却没有制定。 比如一个编码0x0041代表大写字母A，那么可能有一种存储至少有4个字节，那可能0x00000041来存储代表A。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年01月31日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-log/">golang使用系列---- Log</a>
        </h2>
    </header>
    <div class="post-content">
        <p>日志分析，就是根据输出的日志信息，分析挖掘可能的问题，排查解决问题都十分重要。</p>

<p>golang标准库的日志框架非常简单，仅仅提供了print，panic和fatal三个函数对于更精细的日志级别、日志文件分割以及日志分发等方面并没有提供支持。所以催生了很多第三方的日志库，但是在golang的世界里，没有一个日志库像slf4j那样在Java中具有绝对统治地位。golang中，流行的日志框架包括logrus、zap、zerolog、seelog、beegolog等</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年01月29日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-compress/">golang使用系列---- Compress</a>
        </h2>
    </header>
    <div class="post-content">
        archive一般用于打包，compress一般用于压缩。
bzip2 一、bzip2的简介
bzip2包实现bzip2的解压缩，bzip2是对单个文件进行压缩，可以先进行tar归档，然后进行压缩。
二、bzip2的使用
go标准库中提供了一个对bzip2压缩包进行读取的操作，但是并没有提供进行bzip2压缩操作。
package main import ( &quot;compress/bzip2&quot; &quot;os&quot; &quot;log&quot; &quot;fmt&quot; ) func main() { fz, err := os.Open(&quot;1.go.bz2&quot;) if err != nil { log.Fatal(err) } w := bzip2.NewReader(fz) buf := make([]byte, 1024 * 100) for { n, err := w.Read(buf) if n == 0 || err != nil { break } fmt.Println(string(buf[:n])) } }  deflate DEFLATE是同时使用了LZ77算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。它最初是由菲尔·卡茨（Phil Katz）为他的PKZIP软件第二版所定义的，后来被RFC 1951标准化。很多压缩方式都是在这个基础上封装开发的。
const ( NoCompression = 0 // 不压缩 BestSpeed = 1 // 最快速度压缩 BestCompression = 9 // 最佳压缩比压缩 DefaultCompression = -1 // 默认压缩 )  1）func NewReader(r io.
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2017年01月28日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/designpatterns/">golang使用系列---- DesignPatterns</a>
        </h2>
    </header>
    <div class="post-content">
        <p>设计模式其实和语言关系不大，但是在项目工程的设计中有着很大的作用，这边使用golang实现相关的设计模式，也算是对过去看过用过的设计模式的回顾和总结。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年12月08日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-rpc/">golang使用系列---- Rpc</a>
        </h2>
    </header>
    <div class="post-content">
        <p>golang中实现基本的RPC框架</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年11月12日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-template/">golang使用系列---- Go Template</a>
        </h2>
    </header>
    <div class="post-content">
        <p>golang提供了两个标准库用来处理模板text/template和html/template</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年10月12日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-strings/">Go Strings</a>
        </h2>
    </header>
    <div class="post-content">
        <p>平时在开发过程中， 和字符串打交道还是比较多的，比如分割， 去除， 替换等等常用的方法， 这些都是由strings包来提供的。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年10月12日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-strconv/">Go Strconv</a>
        </h2>
    </header>
    <div class="post-content">
        <p>strconv包实现了基本数据类型和其字符串表示的相互转换。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年09月12日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-signal/">Go Signal</a>
        </h2>
    </header>
    <div class="post-content">
        <p>os/signal包实现对信号的处理</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年08月29日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-error/">Go Error</a>
        </h2>
    </header>
    <div class="post-content">
        <p>Go 语言使用 error 类型来返回函数执行过程中遇到的错误，如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年08月26日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-script/">Go Script</a>
        </h2>
    </header>
    <div class="post-content">
        <p>在golang标准库中提供了两种方式可以用来启动进程调用脚本</p>

<p>第一种是在os库中的Process类型，Process类型包含一系列方法用来启动进程并对进程进行操作（参考： <a href="https://golang.org/pkg/os/#Process）">https://golang.org/pkg/os/#Process）</a></p>

<p>第二种是在os/exec库种通过Cmd类型的各个函数实现对脚本的调用，实际上Cmd是对Process中各种方法的高层次封装（参考： <a href="https://golang.org/pkg/os/exec/）">https://golang.org/pkg/os/exec/）</a></p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年08月16日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-mux/">Go Mux</a>
        </h2>
    </header>
    <div class="post-content">
        <p>mux 是一个用来执行http请求的路由和分发的第三方扩展包。</p>

<p>mux 其名称来源于HTTP request multiplexer，类似于官方包http.ServeMux，mux.Router将会定义一个路由列表，其中每一个路由都会定义对应的请求url，及其处理方法。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年07月30日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-io/">Golang使用系列---- Io</a>
        </h2>
    </header>
    <div class="post-content">
        <p>io包提供了所有需要交互的输入输出模式的基础。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年07月22日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-reflect/">Go Reflect</a>
        </h2>
    </header>
    <div class="post-content">
        <p>反射规则</p>

<p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年07月11日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-net-web/">Go Net</a>
        </h2>
    </header>
    <div class="post-content">
        <p>网络编程是go语言使用的一个核心模块。golang的网络封装使用对于底层socket或者上层的http，甚至是web服务都很友好。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年07月11日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-net/">Go Net</a>
        </h2>
    </header>
    <div class="post-content">
        <p>网络编程是go语言使用的一个核心模块。golang的网络封装使用对于底层socket或者上层的http，甚至是web服务都很友好。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年06月28日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-builtin/">Go Builtin</a>
        </h2>
    </header>
    <div class="post-content">
        <p>builtin包是go的预声明定义，包括go语言中常用的各种类型和方法声明，包括变量和常量两部分．</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年06月24日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-package/">Go Package</a>
        </h2>
    </header>
    <div class="post-content">
        <p>在go语言项目中，包的管理很重要，下面看看，有哪些包管理工具。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年06月22日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-path/">golang系列---- Go Path</a>
        </h2>
    </header>
    <div class="post-content">
        path path 包实现了一系列实用函数， 这些函数可以对实用斜杠进行分隔的路径进行处理。
直接上实例
package main; import ( &quot;fmt&quot; &quot;path&quot; ) //go语言path包的学习 func main() { //返回路径的最后一个元素 fmt.Println(path.Base(&quot;./a/b/c&quot;)); //如果路径为空字符串，返回. fmt.Println(path.Base(&quot;&quot;)); //如果路径只有斜线，返回/ fmt.Println(path.Base(&quot;///&quot;)); //返回等价的最短路径 //1.用一个斜线替换多个斜线 //2.清除当前路径. //3.清除内部的..和他前面的元素 //4.以/..开头的，变成/ fmt.Println(path.Clean(&quot;./a/b/../&quot;)); //返回路径最后一个元素的目录 //路径为空则返回. fmt.Println(path.Dir(&quot;./a/b/c&quot;)); //返回路径中的扩展名 //如果没有点，返回空 fmt.Println(path.Ext(&quot;./a/b/c/d.jpg&quot;)); //判断路径是不是绝对路径 fmt.Println(path.IsAbs(&quot;./a/b/c&quot;)); fmt.Println(path.IsAbs(&quot;/a/b/c&quot;)); //连接路径，返回已经clean过的路径 fmt.Println(path.Join(&quot;./a&quot;, &quot;b/c&quot;, &quot;../d/&quot;)); //匹配文件名，完全匹配则返回true fmt.Println(path.Match(&quot;*&quot;, &quot;a&quot;)); fmt.Println(path.Match(&quot;*&quot;, &quot;a/b/c&quot;)); fmt.Println(path.Match(&quot;\\b&quot;, &quot;b&quot;)); //分割路径中的目录与文件 fmt.Println(path.Split(&quot;./a/b/c/d.jpg&quot;)); }  path/filepath filepath包实现了兼容各操作系统的文件路径的实用操作函数。
Abs函数返回path代表的绝对路径，如果path不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返回的绝对路径是唯一指向该地址的绝对路径。&mdash;-返回带绝对路径的文件
Dir返回路径除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用Split去掉最后一个元素后，会简化路径并去掉末尾的斜杠。如果路径是空字符串，会返回&rdquo;.&ldquo;；如果路径由1到多个路径分隔符后跟0到多个非路径分隔符字符组成，会返回单个路径分隔符；其他任何情况下都不会返回以路径分隔符结尾的路径。&mdash;&mdash;返回当前文件的路径
直接上实例
package main; import ( &quot;path/filepath&quot; &quot;fmt&quot; &quot;os&quot; ) //学习filepath包，兼容各操作系统的文件路径 func main() { //返回所给路径的绝对路径 path, _ := filepath.
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年06月06日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-context/">golang使用系列---- Go Context</a>
        </h2>
    </header>
    <div class="post-content">
        <p>控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context(简单的可以直接用channel通知)，今天我就谈谈这两种模式。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年06月02日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-os/">golang使用系列---- Os</a>
        </h2>
    </header>
    <div class="post-content">
        <p>os包中实现了不依赖平台的操作系统函数接口(平台无关的接口)，设计向Unix风格，但是错误处理是go风格，当os包使用时，如果失败之后返回错误类型而不是错误数量,返回错误值而非错误码,通常可以里包含更多信息。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年05月30日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-fmt/">Go Fmt</a>
        </h2>
    </header>
    <div class="post-content">
        <p>fmt是实现了格式化的I/O函数，这点类似Ｃ语言中的printf和scanf，但是更加简单．</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年05月29日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-cobra/">Golang使用系列---- flag</a>
        </h2>
    </header>
    <div class="post-content">
        <p>golang自身带的命令行包，各种case，有代码洁癖的人看着就令人头大,有flag，pflag，cobra等，cobra是个非常不错的命令行包(golang命令行解析库)，docker，hugo都在使用.</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年05月24日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-goroutinechannel/">golang使用系列---- Goroutine</a>
        </h2>
    </header>
    <div class="post-content">
        <p>goroutine和channel是go语言的两大基石，这边主要来研究一下goroutine。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年05月24日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-channel/">golang使用系列---- channel</a>
        </h2>
    </header>
    <div class="post-content">
        <p>不是通过共享内存来通信，而是通过通信来共享内存。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年04月24日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-interface/">golang使用系列---- Interface</a>
        </h2>
    </header>
    <div class="post-content">
        <p>在Go语言的实际编程中，几乎所有的数据结构都围绕接口展开，接口是Go语言中所有数据结构的核心。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年04月24日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-clinet/">Go Clinet</a>
        </h2>
    </header>
    <div class="post-content">
        <h1 id="go命令行工具">go命令行工具</h1>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年04月12日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-time/">golang使用系列---- Time</a>
        </h2>
    </header>
    <div class="post-content">
        <p>time包中包括两类时间：时间点（某一时刻）和时长（某一段时间）</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年03月23日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go/">golang使用系列---- go基本使用积累</a>
        </h2>
    </header>
    <div class="post-content">
        <p>学习使用go语言已经有一段时间了，积累了很多的经验，这边进行不断接触的知识点进行零散的整理并持续积累，也便于后期的备忘。</p>
    </div>
    </article>
<hr>

    
    
<article class="post li">
    <header>
        <div class="post-date">
            2016年03月22日
        </div>
        <h2 class="post-title">
            <a href="/post/golang/go-test/">Golang基础包系列---Test</a>
        </h2>
    </header>
    <div class="post-content">
        <p>go语言的单元测试采用内置的测试框架,通过引入testing包以及go test来提供测试功能。</p>
    </div>
    </article>
<hr>

    
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

