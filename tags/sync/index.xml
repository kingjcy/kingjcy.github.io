<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sync on kingjcy blog</title>
    <link>https://kingjcy.github.io/tags/sync/</link>
    <description>Recent content in Sync on kingjcy blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2020. All rights reserved.</copyright>
    <lastBuildDate>Thu, 28 Feb 2019 17:42:24 +0800</lastBuildDate>
    
	<atom:link href="https://kingjcy.github.io/tags/sync/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golang使用系列---- Map</title>
      <link>https://kingjcy.github.io/post/golang/go-map/</link>
      <pubDate>Thu, 28 Feb 2019 17:42:24 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-map/</guid>
      <description>map map就是k/v的映射，map持有对底层数据结构的引用。如果将map传递给函数，其对map的内容做了改变，则这些改变对于调用者是可见的。
 map的实现
 所有的Map底层一般都是使用数组+链表的hashmap来实现，会借用哈希算法辅助。对于给定的 key，一般先进行 hash 操作，然后相对哈希表的长度取模，将 key 映射到指定的链表中。
Golang的map正常是使用哈希表作为底层实现
hashtable是一种根据key，key在通过hash函数来对应的数组的数据。 hashmap是hashtable使用拉链法实现的一种方式，数组+链表的实现方式  正常情况下，golang使用数组+桶（buckets）来实现，默认每个桶的数量是8个，在超出8个的情况下，新增一个桶，使用链表连接起来，这是时候就变成了hash数组 + 桶 + 溢出的桶链表了。
其实map不是并发安全的，也是因为hashmap不是并发安全的，实现并发安全的几种方式，可以参考并发安全
数据结构
map数据结构由runtime/map.go/hmap定义:
hmap
type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra }   count 表示当前哈希表中的元素数量；类似于buckets[count] B表示当前哈希表持有的buckets数量，但是因为哈希表中桶的数量都2的倍数，所以该字段会存储对数，也就是 len(buckets) == 2^B；类似于buckets[2^B] hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入； oldbuckets 是哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半；  bmap
type bmap struct { tophash [8]uint8 //存储哈希值的高8位 //data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。 data byte[1] //key value数据:key/key/key/.</description>
    </item>
    
    <item>
      <title>golang使用系列---- Sync</title>
      <link>https://kingjcy.github.io/post/golang/go-sync/</link>
      <pubDate>Thu, 28 Feb 2019 17:42:24 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-sync/</guid>
      <description>sync sync包提供了基本的同步基元，如互斥锁。除了Once和WaitGroup类型，大部分都是适用于低水平程序线程，高水平的同步使用channel通信（csp）更好一些。
Once 的使用
定义
type Once struct { // 非暴露字段 } func (o *Once) Do(f func())  使用前先定义 Once 类型变量：
var once Once  使用的时候向 Once 类型变量传入函数：
once.Do(func() { init() })  多次调用 once.Do(f) 只会触发一次 f 的执行，即第一次 f 的执行。
用法实例
某些操作只需要执行一次（比如一些初始化动作），这时就可使用 Once，如：
func main() { var once sync.Once onceBody := func() { fmt.Println(&amp;quot;Only once&amp;quot;) } done := make(chan bool) // 创建 10 个 goroutine，但是 onceBody 只会执行 1 次 for i := 0; i &amp;lt; 10; i++ { go func() { once.</description>
    </item>
    
    <item>
      <title>golang使用系列---- mutex</title>
      <link>https://kingjcy.github.io/post/golang/go-mutex/</link>
      <pubDate>Thu, 28 Feb 2019 17:42:24 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-mutex/</guid>
      <description>&lt;p&gt;锁是一种常见的并发控制技术，我们一般会将锁分成乐观锁和悲观锁，即乐观并发控制和悲观并发控制。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>