<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compile on kingjcy blog</title>
    <link>https://kingjcy.github.io/tags/compile/</link>
    <description>Recent content in Compile on kingjcy blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2020. All rights reserved.</copyright>
    <lastBuildDate>Sat, 16 Apr 2016 19:21:21 +0800</lastBuildDate>
    
	<atom:link href="https://kingjcy.github.io/tags/compile/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Compile</title>
      <link>https://kingjcy.github.io/post/linux/c&#43;&#43;/compile/</link>
      <pubDate>Sat, 16 Apr 2016 19:21:21 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/linux/c&#43;&#43;/compile/</guid>
      <description>使用extern &amp;ldquo;C&amp;rdquo; 主要是因为C编译器编译函数时不带参数的类型信息，只包含函数的符号名字。如
int foo( float x )
C编译器会将此函数编译成类似_foo的符号，C连接器只要找到了调用函数的符号，就认为连接成功。
而C++编译器为了实现函数重载，会在编译时带上函数的参数信息。如它可以把上面的函数编译成类似于_foo_float这样的符号。
所以，C调用C++，使用extern &amp;ldquo;C&amp;rdquo;则是告诉编译器依照C的方式来编译封装接口，当然接口函数里面的C++语法还是按C++方式编译。
要明白为何使用extern &amp;ldquo;C&amp;rdquo;，还得从cpp中对函数的重载处理开始说起。在c++中，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等等.而在C中，只是简单的函数名字而已，不会加入其他的信息.也就是说:C++和C对产生的函数名字的处理是不一样的.
明白了加入与不加入extern &amp;ldquo;C&amp;rdquo;之后对函数名称产生的影响，我们继续我们的讨论:为什么需要使用extern &amp;ldquo;C&amp;rdquo;呢？C++之父在设计C++之时，考虑到当时已经存在了大量的C代码，为了支持原来的C代码和已经写好C库，需要在C++中尽可能的支持C，而extern &amp;ldquo;C&amp;rdquo;就是其中的一个策略。
　试想这样的情况:一个库文件已经用C写好了而且运行得很良好，这个时候我们需要使用这个库文件，但是我们需要使用C++来写这个新的代码。如果这个代码使用的是C++的方式链接这个C库文件的话，那么就会出现链接错误.
现在我们有了一个C库文件，它的头文件是f.h，产生的lib文件是f.lib，那么我们如果要在C++中使用这个库文件，我们需要这样写:
extern &amp;quot;C&amp;quot; { #include &amp;quot;f.h&amp;quot; }  </description>
    </item>
    
  </channel>
</rss>