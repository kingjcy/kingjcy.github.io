<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Map on kingjcy blog</title>
    <link>https://kingjcy.github.io/tags/map/</link>
    <description>Recent content in Map on kingjcy blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2020. All rights reserved.</copyright>
    <lastBuildDate>Thu, 28 Feb 2019 17:42:24 +0800</lastBuildDate>
    
	<atom:link href="https://kingjcy.github.io/tags/map/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golang使用系列---- Map</title>
      <link>https://kingjcy.github.io/post/golang/go-map/</link>
      <pubDate>Thu, 28 Feb 2019 17:42:24 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-map/</guid>
      <description>map map就是k/v的映射，map持有对底层数据结构的引用。如果将map传递给函数，其对map的内容做了改变，则这些改变对于调用者是可见的。
 map的实现
 所有的Map底层一般都是使用数组+链表的hashmap来实现，会借用哈希算法辅助。对于给定的 key，一般先进行 hash 操作，然后相对哈希表的长度取模，将 key 映射到指定的链表中。
Golang的map正常是使用哈希表作为底层实现
hashtable是一种根据key，key在通过hash函数来对应的数组的数据。 hashmap是hashtable使用拉链法实现的一种方式，数组+链表的实现方式  正常情况下，golang使用数组+桶（buckets）来实现，默认每个桶的数量是8个，在超出8个的情况下，新增一个桶，使用链表连接起来，这是时候就变成了hash数组 + 桶 + 溢出的桶链表了。
其实map不是并发安全的，也是因为hashmap不是并发安全的，实现并发安全的几种方式，可以参考并发安全
数据结构
map数据结构由runtime/map.go/hmap定义:
hmap
type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra }   count 表示当前哈希表中的元素数量；类似于buckets[count] B表示当前哈希表持有的buckets数量，但是因为哈希表中桶的数量都2的倍数，所以该字段会存储对数，也就是 len(buckets) == 2^B；类似于buckets[2^B] hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入； oldbuckets 是哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半；  bmap
type bmap struct { tophash [8]uint8 //存储哈希值的高8位 //data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。 data byte[1] //key value数据:key/key/key/.</description>
    </item>
    
  </channel>
</rss>