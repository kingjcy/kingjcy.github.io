<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ops on kingjcy blog</title>
    <link>https://kingjcy.github.io/tags/ops/</link>
    <description>Recent content in Ops on kingjcy blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2020. All rights reserved.</copyright>
    <lastBuildDate>Wed, 06 Nov 2019 14:58:43 +0800</lastBuildDate>
    
	<atom:link href="https://kingjcy.github.io/tags/ops/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>运维管理平台</title>
      <link>https://kingjcy.github.io/post/devops/ops/</link>
      <pubDate>Wed, 06 Nov 2019 14:58:43 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/devops/ops/</guid>
      <description>应用运维工作说白了大体可以分为两种情况：1. 在某个或某些服务器上执行某个脚本或命令；2.将某个或某些文件传输到某个或某些特定的服务器的特定位置上。在服务器数量较少的情况下，可以通过ssh或scp命令实现上面两个操作；服务器数量较多的情况下，我们可以通过包装ssh或者使用批量ssh工具，如pssh，ansible等来解决问题，但这种方式大多数都是一次性的方式，无论使用方法以及后续跟踪来看都并不友好。
发布
应用程序升级面临最大挑战是新旧业务切换，将软件从测试的最后阶段带到生产环境，同时要保证系统不间断提供服务。
长期以来，业务升级渐渐形成了几个发布策略：蓝绿发布、灰度发布和滚动发布，目的是尽可能避免因发布导致的流量丢失或服务不可用问题。
一、 蓝绿发布
项目逻辑上分为AB组，在项目系统时，首先把A组从负载均衡中摘除，进行新版本的部署。B组仍然继续提供服务。
当A组升级完毕，负载均衡重新接入A组，再把B组从负载列表中摘除，进行新版本的部署。A组重新提供服务。
最后，B组也升级完成，负载均衡重新接入B组，此时，AB组版本都已经升级完成，并且都对外提供服务。
特点 如果出问题，影响范围较大；
发布策略简单；
用户无感知，平滑过渡；
升级/回滚速度快。
缺点 需要准备正常业务使用资源的两倍以上服务器，防止升级期间单组无法承载业务突发；
短时间内浪费一定资源成本；
基础设施无改动，增大升级稳定性。
蓝绿发布在早期物理服务器时代，还是比较昂贵的，由于云计算普及，成本也大大降低。
二、 灰度发布 灰度发布只升级部分服务，即让一部分用户继续用老版本，一部分用户开始用新版本，如果用户对新版本没什么意见，那么逐步扩大范围，把所有用户都迁移到新版本上面来。
特点 保证整体系统稳定性，在初始灰度的时候就可以发现、调整问题，影响范围可控；
新功能逐步评估性能，稳定性和健康状况，如果出问题影响范围很小，相对用户体验也少；
用户无感知，平滑过渡。
缺点 自动化要求高
部署过程 从LB摘掉灰度服务器，升级成功后再加入LB；
少量用户流量到新版本；
如果灰度服务器测试成功，升级剩余服务器。
灰度发布是通过切换线上并存版本之间的路由权重，逐步从一个版本切换为另一个版本的过程。
三、 滚动发布 滚动发布是指每次只升级一个或多个服务，升级完成后加入生产环境，不断执行这个过程，直到集群中的全部旧版本升级新版本。
红色：正在更新的实例
蓝色：更新完成并加入集群的实例
绿色：正在运行的实例
特点 用户无感知，平滑过渡；
节约资源。
缺点 部署时间慢，取决于每阶段更新时间；
发布策略较复杂；
无法确定OK的环境，不易回滚。
部署过程 先升级1个副本，主要做部署验证；
每次升级副本，自动从LB上摘掉，升级成功后自动加入集群；
事先需要有自动更新策略，分为若干次，每次数量/百分比可配置；
回滚是发布的逆过程，先从LB摘掉新版本，再升级老版本，这个过程一般时间比较长；
自动化要求高。
小结 综上所述，三种方式均可以做到平滑式升级，在升级过程中服务仍然保持服务的连续性，升级对外界是无感知的。那生产上选择哪种部署方法最合适呢？这取决于哪种方法最适合你的业务和技术需求。如果你们运维自动化能力储备不够，肯定是越简单越好，建议蓝绿发布，如果业务对用户依赖很强，建议灰度发布。如果是K8S平台，滚动更新是现成的方案，建议先直接使用。
蓝绿发布：两套环境交替升级，旧版本保留一定时间便于回滚。
灰度发布：根据比例将老版本升级，例如80%用户访问是老版本，20%用户访问是新版本。
滚动发布：按批次停止老版本实例，启动新版本实例。</description>
    </item>
    
    <item>
      <title>运维工具系列---- 常见的服务器自动化工具</title>
      <link>https://kingjcy.github.io/post/linux/tool/ops-tool/</link>
      <pubDate>Wed, 17 Apr 2019 17:19:23 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/linux/tool/ops-tool/</guid>
      <description> Cobbler
 Cobbler是一个Linux的安装服务，它可以在网络环境下迅速安装。它可以将众多Linux任务关连在一起，这样在你安装或修改系统时，就可以不必在众多命令和应用程序之间切换了。
随着一系列简单的命令，可以配置网络安装PXE(Preboot Execute Environment)、重新安装、基于媒体的网络安装和虚拟化安装(支持Xen、qemu、KVM、和一些类型的VMware)。Cobbler使用一个叫做’koan’(和Cobbler交互)的程序来重新安装及虚拟化支持。
Cobbler是一个轻量级的应用程序(只有1.5万行Python代码)。它试图在小型和大型安装时都非常简单易用，而且容易工作、扩展和阅读。它避免成为”企业级”(像那么复杂)，但是它又拥有众多优秀的功能，非常适合在各种企业环境中使用，在重复性工作中节省大量的时间。
Cobbler可以选择性的帮助管理DHCP、DNS和yum包镜像基础设施，再者方面，它是一个更广义的自动化应用程序，而不仅仅只是处理配置。它还有一个轻量级的内置配置管理系统，以及整合与配置管理系统，像Puppet一样。Cobbler有一个命令行界面，一个网络界面，和许多用来访问配置的API。
 Puppet
 puppet是一种Linux、Unix平台的集中配置管理系统，使用ruby语言，可管理配置文件、用户、cron任务、软件包、系统服务等。puppet把这些系统实体称之为资源，puppet的设计目标是简化对这些资源的管理以及妥善处理资源间的依赖关系。
Puppet是一个C/S架构的配置管理工具，在中央服务器上安装puppet-server软件包（被称作Puppet master）。在需要管理的目标主机上安装puppet客户端软件（被称作Puppet Client）。当客户端连接上Puppet master后，定义在Puppet master上的配置文件会被编译，然后在客户端上运行。每个客户端默认每半个小时和服务器进行一次通信，确认配置信息的更新情况。如果有新的配置信息或者配置信息已经改变，配置将会被重新编译并发布到各客户端执行。也可以在服务器上主动触发一个配置信息的更新，强制各客户端进行配置。如果客户端的配置信息被改变了，它可以从服务器获得原始配置进行校正。
 FUNC
 func全称 Fedora Unified Network Controller ,主要用在Radhat, Fedora,OpenSuse,Centos系列系统上由一个server管理任意台服务器的工具,建立了Master-Slaves 主从SSL证书管控体系，可以将证书自动分发到所有受控服务.func直接发送远程命令或者远程获取数据,但是只适用于一些常用功能的模块的操作,实现其它功能需要自己写Python API,个人认为没有使用比较适当的”for do done”循环程序效果明确和方便.
 ansible
 ansible详解
 supervisord
 supervisord详解
 bmc
 </description>
    </item>
    
  </channel>
</rss>