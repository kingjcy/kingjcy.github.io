<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="关于算法的一些基础总结。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="计算机基础系列---- algorithm - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    计算机基础系列---- algorithm
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2014年04月16日 
                </div>
                <h1 class="post-title">计算机基础系列---- algorithm</h1>
            </header>

            <div class="post-content">
                <p>关于算法的一些基础总结。</p>

<h1 id="算法思想">算法思想</h1>

<p>思想很重要，如果看到需求，能够知道什么思想能够解决这个问题。一般问题的解决就是那么几种思想，需要重点把每种思想都掌握。</p>

<p>其实解决题目到最后就是看很清晰的看这个需要要用什么结构体，使用什么样的算法来解决这个问题，解决就是这个思路。工作中也是如此。</p>

<p>其实只有遍历和递归，一般都是人使用迭代，神使用递归，所以递归和迭代是解决问题的方法的基本单元，基本都是通过这两种方式解决的，本身确实是思想，但是是方法的思想，和解决问题的算法的思想。所有的问题都是通过迭代或者递归来解决的，但是可以有不同的算法思想，就像数据结构都是数组和链表表示的，但是还是有很多的其他数据结构。</p>

<p>这边简单提一下面试，面试的时候一般就是线性表的考察，树和图在写代码的时候就比较难了，所以要注重线性表的问题，要能把中等以上的题目都写出来，至于树和图只要知道概念和性质用途就行，而且在算法题中中等是门槛，必须写出来，难的有思想解决解析，复杂的数据结构也是这个思路，所以主要线性表的中等和简单问题的思路，要能完全写出来，也符合面试的有效时间内的考察。</p>

<h2 id="基本方法">基本方法</h2>

<ol>
<li>迭代</li>
</ol>

<p>就是我们常规思维，一步步循环走下去，当然有很多技巧或者规律来让我们走的快一点</p>

<ol>
<li>递归</li>
</ol>

<p>递归一般都是生成一颗递归树，一般都是递归回溯的遍历过程。</p>

<p>1.递归过程一般通过函数或子过程实现；</p>

<p>2.递归算法在函数或子过程的内部，直接或间接调用自己的算法</p>

<p>3.递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解</p>

<p>注意：必须有一个明确的递归结束条件；如果递归次数过多，容易造成栈溢出。</p>

<p>理解递归：递归调用过程中，不要直接一层层走下去，先把简单的第一层走完，哪怕是整个函数，你就当这个为一个表达式，先放在那，你就能很清晰的看到走到哪了</p>

<p>经典运用</p>

<ul>
<li><p>汉诺塔问题</p></li>

<li><p>阶乘问题</p></li>

<li><p>生成括号（递归往数组中加括号，需要生成做括号才能生成右括号，所以需要对括号进行计数left，right）</p></li>

<li><p>24点</p></li>
</ul>

<p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。</p>

<p>直接使用递归遍历，先任意取两个数字，获取其对应四种算法的结果，将其放入到新的数组中，然后再任意获取两个，依次类推，判断最后一位数的时候是否为24就可以。</p>

<h2 id="思想">思想</h2>

<p>一、枚举算法思想（暴力算法）</p>

<p>将问题的所有可能答案一一列举，根据判断条件判断此答案是否合适，一般用循环遍历迭代实现。</p>

<p>和回溯的区别就是回溯还有其他的可能，而穷举就是一条路走到黑。但是回溯其实也是暴力破解法，也是一种穷举的算法。</p>

<p>经典运用</p>

<ul>
<li><p>求平方根（x的平方根一定在0～x/2之间，然后进行遍历平方对比，可以求近似值a^2&lt;x&lt;(a+1)^2，更加像是数学，比如还有一个牛顿的公式y = ( y + x / y ) / 2 ）</p></li>

<li><p>查找一个字符串中最长的无重复字串（滑动窗口，重第一个字符串开始遍历，看新的字符在不在遍历的字符串中，如果在，则将左边的位置移动到这个重复字符在遍历字符串中的最后位置的下一个，记录最长的长度进行对比）</p></li>
</ul>

<p>这个暴力方法就是我们最常规的思维，可以不看相关的应用了。</p>

<p>二、贪心算法思想</p>

<p>贪心算法的原理比较简单，就是对问题求解的时候，每步都选择当前的最优解，然后已期望得到全局最优解。用局部最优解叠加出全局最优解。</p>

<p>贪心算法的适用场景是每次选择是没有状态的，也就是不会对后面的步骤产生影响。</p>

<p>局限：</p>

<p>不能保证最后的解是最优的；只能求满足某些约束条件的可行解范围。</p>

<p>经典应用</p>

<ul>
<li><p>跳跃游戏（重第一个点开始跳到最远的地方，每一步都是如此以期望达到终点，如果不行，则回退减少一步重试回溯）</p></li>

<li><p>跳跃游戏2（重第一步开始走，每一步都选择其中最大的一个值，这样可以走的更加远，算法实现居然可以使用迭代，神奇）</p></li>

<li><p>分配饼干（最小的饼干不能满足最小的孩子，也不能满足大孩子，如果能满足孩子，后面还有更大的饼干，肯定满足这个孩子，留给后面的）</p></li>
</ul>

<p>假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p>

<ul>
<li><p>不重叠的区间个数（按起点排序，遍历区间，如果不相交则继续移动，如果相交，则取结尾较小的那个，这样留给后面的那个空间选择就较大（贪心），改变其结尾值）</p></li>

<li><p>摇摆数列，摆动序列（贪心：我们只获取下一个摇摆的项进行状态操作，这样它就是一个摇摆数列，在差值一直为正（负）时，直接过滤，我们值保留最后一个，这样下一个一定是摇摆，可以将正负用状态来表示，进行switch来判断，（状态机），最后在摇摆的时候进行最大长度的增加）</p></li>

<li><p>移除k个数字（使用如果后一个数字比现在数字小，则删除这个数字的贪心思想）</p>

<p>贪心规律
从高位向低位遍历，如果对应的数字大于下一位数字，则把该位数字去掉，得到的数字最小。</p>

<p>去掉 K 个数字，需要从最高位遍历 k 次</p>

<p>注意
当所有数字都扫描完成后， k 仍然大于 0，该如何处理？ 如: num=12345, k=3
从尾部删除剩余 k 个数字
当数字中有 0 出现，该如何特殊处理？如: num=100200， k = 1
如果保留的数字串非空，则保留，否则不保留（比如 00200 无意义）。详情见代码注释
如何将最后结果存储为字符串并返回？
Go 中，可以使用 string(&lsquo;0&rsquo; + number) 的方式转化为字符</p></li>

<li><p>射击气球（区间排序，重第一个开始遍历选择击穿的区间，一直到第一个不能射中，这个第一个不能射中，需要获取区间的最小的end，再开启第二把射击，依次类推，贪心一次可以击穿最多）</p></li>

<li><p>最佳加油方法（在每个加油站都选择最大的加油量，然后在车油能行驶的历程中选择能加到油最多的加油站，这样加油最少次数，这个主要需要注意最后一个加油的情况，和一些加不到油的情况，最好还是要用最大堆来实现）</p></li>

<li><p>根据身高和序号重组队列(先排序，然后进行调整，统计前面的高的数量如何和第二位一样了，就讲这个数据插入到目前的位置)</p></li>

<li><p>买卖股票最大的收益</p></li>
</ul>

<p>三、试探算法（回溯法）</p>

<p>在试探算法中，放弃当前候选解，并继续寻找下一个候选解的过程称为回溯。一般都是递归后就是回溯，就是对当前这个值做还是不做处理的两种情况，所以一般用递归实现。
（为求得问题的正确解，会先委婉地试探某一种可能情况。在进行试探过程中，一旦发现原来选择的假设情况是不正确的，马上会自觉地退回一步重新选择，然后继续向前试探。反复进行，直到得到解或证明无解时才死心）</p>

<p>经典运用：</p>

<ul>
<li><p>跳跃游戏（尝试所有的可能，如果不行就回溯到开始重新来）</p></li>

<li><p>八皇后问题（递归回溯遍历）</p>

<p>皇后肯定是一行放一个，每一行放置就是递归，回溯就是确定位置对不对
在每一个递归中都是判断这个位置是否能放，所以要构造一个二维数组bool类型来判断
然后放置一个q，就将他们所有的不能放置的位置置为false
如果下一层不成功说明这个位置不能放置q，也置为false，
依次递归，将数据append到一个数组中去，获取所有的结果。</p></li>

<li><p>求子集（递归加入子集，是否取某个数字，这个是否取哪个，取决于是否把数据放到数组中去，递归的就是是否将数据放到数组中去，还可以用栈）</p></li>

<li><p>求子集2（先排序，递归加入子集，是否取某个数字，这个是否取哪个，取决于是否把数据放到数组中去，递归的就是是否将数据放到数组中去，然后在回溯的时候，在放置后的数据的时候需要把和当前元素重复的跳过，这样就不会先相同层级（个数）的相同数据重复选择）可以让同一层级，不出现相同的元素。但是却允许了不同层级之间的重复</p></li>

<li><p>组合数之和2（采用上面的方法，对每个数组进行求和对比，但是当数值大于target就不参加递归了（剪枝））</p></li>

<li><p>二进制矩阵中的最短路径（定义方向矩阵，访问矩阵，最短路径矩阵，最短是最先被访问的，然后按方向去遍历，返回最短路径矩阵节点）</p>

<p>（1）BFS的问题一般都会选用队列方式实现；
（2）代码模板如下：</p>

<p>void BFS()
{
    定义队列;
    定义备忘录，用于记录已经访问的位置；</p>

<pre><code>判断边界条件，是否能直接返回结果的。

将起始位置加入到队列中，同时更新备忘录。

while (队列不为空) {
    获取当前队列中的元素个数。
    for (元素个数) {
        取出一个位置节点。
        判断是否到达终点位置。
        获取它对应的下一个所有的节点。
        条件判断，过滤掉不符合条件的位置。
        新位置重新加入队列。
    }
}
</code></pre>

<p>}</p></li>
</ul>

<p>四、动态规划法</p>

<p>动态规划的核心思想是把原问题分解成子问题进行求解，也就是分治的思想。</p>

<p>关键词：递归（递归式）、表记录（已解决的子问题的答案）、根据子问题求解原问题的解（子问题不独立）、最优解（可选项）</p>

<p>步骤：</p>

<p>1.找出最优解的性质，刻画其结构特征；</p>

<p>2.递归地定义最优解；</p>

<p>3.以自底向上的方式计算出最优值；</p>

<p>4.根据计算最优值时得到的信息，构造一个最优解</p>

<p>只需求出最优值，步骤4可以省略；若需求出问题的一个最优解，则必须执行步骤4。</p>

<p>适用环境：</p>

<p>1.最优子结构。一个问题的最优解包含了其子问题的最优解。</p>

<p>2.重叠子问题。原问题的递归算法可以反复地解同样的子问题，而不是总是产生新的子问题</p>

<p>示例：0-1背包问题；矩阵链乘问题；最长公共子序列（LCS）；</p>

<ul>
<li>跳跃游戏（自顶向下，加上一个状态，不会走到0上的都是好节点，这样就能减少回溯）（自底向上，每一步都能有一个解，最后获取）</li>
</ul>

<p>五、递推算法思想</p>

<p>1.顺推法：从已知条件出发，逐步推算出要解决问题的方法。</p>

<p>2.逆推法：从已知结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。</p>

<p>经典运用：斐波那契数列（顺推法）、银行存款（逆推法）</p>

<p>六、分治算法思想</p>

<p>将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。只要求出子问题的解，就可得到原问题的解。分治思想一把都是用递归来实现</p>

<p>一般步骤：</p>

<p>1.分解，将要解决的问题划分成若干个规模较小的同类问题</p>

<p>2.求解，当子问题划分得足够小时，用较简单的方法解决</p>

<p>3.合并，按原问题的要求，将子问题的解逐层合并构成原问题的解</p>

<p>经典运用：大数相乘问题、比赛日程安排，归并排序；最大子段和问题</p>

<ul>
<li>逆序数</li>
</ul>

<p>七、模拟算法思想</p>

<p>对真实事物或者过程的虚拟。</p>

<p>经典运用：猜数字游戏、掷骰子问题，出栈顺序</p>

<p>十 分支界限法</p>

<p>关键字：解空间（广度优先、最小耗费优先）、界限函数（队列式、优先队列式）</p>

<p>步骤：</p>

<p>1.针对所给问题，定义问题的解空间。问题的解空间应至少包含问题的一个（最优）解</p>

<p>2.确定易于搜索的解空间结构。通常将解空间表示为树、图；解空间树的第i层到第i+1层边上的标号给出了变量的值；从树根到叶子的任一路径表示解空间的一个元素。</p>

<p>3.以广度优先或最小耗费优先的方式搜索整个解空间。每个活节点只有一次机会成为扩展节点，活节点一旦成为扩展节点，其余儿子节点被加入活节点表中。（以此方式递归搜索）</p>

<p>界限函数：分支界限法的核心。尽可能多、尽可能早地“杀掉”不可能产生最优解的活节点。好的界限函数可以大大减少问题的搜索空间，大大提高算法的效率。</p>

<p>1.队列式（FIFO）分支界限法。先进先出</p>

<p>2.优先队列式分支界限法。组织一个优先队列，按优先级选取。通常用最大堆来实现最大优先队列，最小堆来实现最小优先队列。</p>

<p>十一 概率算法</p>

<p>关键词：随机性选择、小概率错误（运行时间大幅减少）、不同解（对同一问题求解两次，可能得到完全不同的解，且所需时间、结果可能会有相当大的差别）</p>

<p>基本特征：</p>

<p>1.输入包括两部分。一，原问题的输入；二，供算法进行随机选择的随机数序列</p>

<p>2.运行过程中，包括一处或多处随机选择，根据随机值来决定算法的运行</p>

<p>3.结果不能保证一定是正确的，但可以限制出错率。</p>

<p>4.不同的运行过程中，对于相同的输入实例可以有不同的结果，执行时间也可能不同。</p>

<p>分类：</p>

<p>1.数值概率算法。常用于数值问题的求解。近似解，近似解的精度随计算时间的增加不断提高。</p>

<p>2.蒙特卡罗（Monte Carlo）算法。精确解，解未必是正确的，正确的概率依赖于算法所用的时间。一般情况下，无法有效地判定所得到的解是否肯定正确。</p>

<p>3.拉斯维加斯（LasVegas）算法。一旦找到解，一定是正确解。找到的概率随计算时间的增加而提高。对实例求解足够多次，使求解失效的概率任意小。</p>

<p>4.舍伍德（Sherwood）算法。总能求得问题的一个解，且所求得的解总是正确的。设法消除最坏情形与特定实例之间的关联性。多用于最快情况下的计算复杂度与其在平均情况下的计算复杂度差别较大。</p>

<p>十二 近似算法</p>

<p>关键词：近似解、解的容错界限（近似最优解与最优解之间相差的程度）、不存在多项式时间算法</p>

<p>基本思想：放弃求最优解，用近似最优解替代最优解。使算法简化，时间复杂度降低</p>

<p>衡量性能的标准：</p>

<p>1.算法的时间复杂度。时间复杂度必须是多项式阶的</p>

<p>2.解的近似程度。与近似算法本身、问题规模、不同的输入实例有关。</p>

<p>示例：NP问题、定点覆盖问题、TSP、子集和数问题、</p>

<p>以上算法思想分的细，有些算法思想其实可以合并一类</p>

<h1 id="时间复杂度和空间复杂度">时间复杂度和空间复杂度</h1>

<p>我们一般用“大O符号表示法”来表示时间复杂度：T(n) = O(f(n)),n是影响复杂度变化的因子，f(n)是复杂度具体的算法。</p>

<p>时间复杂度就是和算法运行的次数的最高项有关，和运行的次数有关比较好理解，比如运行数得清的几次就能结束的就是O(1),对于n越大运行次数越多的就是O(n),但是和最高项相关的不好理解，比如两个for循环n，其实就是运行的n^2次，这边的2就是最高项，对运行次数有着很大影响的，这边的时间复杂度就是O(n^2)</p>

<p>时间复杂度越简单，说明算法越好：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; 。。。</p>

<p>常见的时间复杂度</p>

<ul>
<li><p>常数阶O(1)</p>

<pre><code>int a = 1;
</code></pre></li>

<li><p>线性阶O(n)</p>

<pre><code>for(i=1; i&lt;=n; i++) {
   j = i;
   j++;
}
</code></pre></li>

<li><p>对数阶O(logN)</p>

<pre><code>int i = 1;
while(i &lt; n) {
    i = i * 2;
}
</code></pre></li>

<li><p>线性对数阶O(nlogN)</p>

<pre><code>for(m = 1; m &lt; n; m++) {
    i = 1;
    while(i &lt; n) {
        i = i * 2;
    }
}
</code></pre></li>

<li><p>平方阶O(n²)</p>

<pre><code>for(x=1; i &lt;= n; x++){
   for(i = 1; i &lt;= n; i++) {
       j = i;
       j++;
    }
}
</code></pre></li>

<li><p>立方阶O(n³)</p></li>

<li><p>K次方阶O(n^k)</p></li>

<li><p>指数阶(2^n)</p></li>
</ul>

<p>空间复杂度就是和算法占用了多少空间有关系，可以使用空间来换取时间，一般很少有计算这个。</p>

<p>常用</p>

<ul>
<li>空间复杂度 O(1)</li>
</ul>

<p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)。</p>

<ul>
<li><p>空间复杂度 O(n)</p>

<p>int[] m = new int[n]
for(i=1; i &lt;= n; ++i) {
   j = i;
   j++;
}</p></li>
</ul>

<p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，后面虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)。</p>

<h1 id="经典问题">经典问题</h1>

<ol>
<li>约瑟夫环</li>
</ol>

<p>设有编号为1，2，……，n的n(n&gt;0)个人围成一个圈，从第1个人开始报数，报到m时停止报数，报m的人出圈，再从他的下一个人起重新报数，报到m时停止报数，报m的出圈，……，如此下去，直到所有人全部出圈为止。当任意给定n和m后，设计算法求n个人出圈的次序</p>

<p>用循环链表实现</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef struct node
{
    int data;
    struct node *next;
}Node;
/**
 * @功能 约瑟夫环
 * @参数 total:总人数
 * @参数 from:第一个报数的人
 * @参数 count:出列者喊到的数
 * @作者 zheng
 * @更新 2013-12-5
 */
void JOSEPHUS(int total, int from, int count)
{
    Node *p1, *head;
    head = NULL;
    int i;
    // 建立循环链表
    for(i = 1; i &lt;= total; i++)
    {
        Node *newNode = (Node *)malloc(sizeof(Node));
        newNode-&gt;data = i;
        if(NULL == head)
        {
            head = newNode;
        }
        else
        {
            p1-&gt;next = newNode;
        }
        p1 = newNode;
    }
    p1-&gt;next = head;      // 尾节点连到头结点，使整个链表循环起来
    p1 = head;            // 使pcur指向头节点
    // 把当前指针pcur移动到第一个报数的人
    // 若从第一个人开始报数，这一段可要可不要
    for(i = 1; i &lt; from; i++)
    {
        p1 = p1-&gt;next;
    }
    Node *p2 = NULL;
    // 循环地删除队列中报到count的结点
    while(p1-&gt;next != p1)
    {
        for(i = 1; i &lt; count; i++)
        {
            p2 = p1;
            p1 = p1-&gt;next;
        }
        p2-&gt;next = p1-&gt;next;
        printf(&quot;Delete number: %d\n&quot;, p1-&gt;data);   // 打印所要删除结点的数据
        free(p1);                      // 删除结点，从内存释放该结点占用的内存空间
        p1 = p2-&gt;next;      // p1指针指向新的结点p2-&gt;next，即原先的p1-&gt;next
    }
    printf(&quot;The last one is No.%d\n&quot;, p1-&gt;data);
}
int main()
{
    int total, from, count;
    scanf(&quot;%d%d%d&quot;, &amp;total, &amp;from, &amp;count);
    JOSEPHUS(total, from, count);
    return 0;
}
运行结果：

13 1 3
Delete number: 3
Delete number: 6
Delete number: 9
Delete number: 12
Delete number: 2
Delete number: 7
Delete number: 11
Delete number: 4
Delete number: 10
Delete number: 5
Delete number: 1
Delete number: 8
The last one is No.13
</code></pre>

<ol>
<li>魔术师发牌问题</li>
</ol>

<p>一位魔术师掏出一叠扑克牌，魔术师取出其中13张黑桃，洗好后，把牌面朝下。
说：“我不看牌，只数一数就能知道每张牌是什么？”魔术师口中念一，将第一张牌翻过来看正好是A；
魔术师将黑桃A放到桌上，继续数手里的余牌，
第二次数1，2，将第一张牌放到这叠牌的下面，将第二张牌翻开，正好是黑桃2，也把它放在桌子上。
第三次数1，2，3，前面二张牌放到这叠牌的下面，取出第三张牌，正好是黑桃3，这样依次将13张牌翻出，全部都准确无误。
求解：魔术师手中牌的原始顺序是什么样子的？</p>

<p>使用数据结构是循环链表</p>

<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)
//13张牌
const len int=13
type Node struct {
    order int   //牌序号
    pNext *Node
}

type playingCard [len]string
//牌用数组存储
func (card *playingCard) newCard(){
    card[0]=&quot;A&quot;
    for i:=1;i&lt;10;i++ {
        card[i]=strconv.Itoa(i+1)
    }
    card[10]=&quot;L&quot;
    card[11]=&quot;Q&quot;
    card[12]=&quot;K&quot;
}
//建立循环链表
func createList()*Node {
    phead:=new(Node)
    phead.pNext=nil
    q:=phead
    for i:=1;i&lt;=len;i++ {
        pnew:=new(Node)
        pnew.order=-1
                q.pNext=pnew
        q=pnew
    }
    q.pNext=phead.pNext
    phead=nil
    return q
}
//清空链表
func cleanList(list *Node){
    p,q:=list.pNext,list.pNext
    for p!=list &amp;&amp; q!=nil{
        q=q.pNext
        p=nil
        p=q
    }
    list.pNext=list
}
//销毁链表
func descotry(list *Node){
    cleanList(list)
    list=nil
}
//发牌
func magic(list *Node) {
    count:=1
    p:=list.pNext
    p.order=0
    for count&lt;len {
        number:=0
        for number&lt;=count{
            p=p.pNext
            if p.order==-1 {
                number++
            }
        }
        p.order=count
        count++
    }
}
//打印牌
func traverse(list *Node,card playingCard){
    p:=list.pNext
    for  ;p!=list;p=p.pNext {
        card.Print(p.order)
        //fmt.Printf(&quot;%5d&quot;,p.order)
    }
    card.Print(p.order)
    //fmt.Printf(&quot;%5d&quot;,p.order)
}

func (card playingCard) Print(index int) {
    if index&gt;=0 &amp;&amp; index&lt;len {
        fmt.Printf(&quot;%5s&quot;,card[index])
    }else {
        fmt.Printf(&quot;%5s&quot;,&quot;空&quot;)
    }
}
func main() {
    var card playingCard
    card.newCard()
    //fmt.Println(card)
    list:=createList()
    defer descotry(list)
    magic(list)
    traverse(list,card)
}
</code></pre>

<p>3.汉诺塔</p>

<p>递归的典型思想</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

func hannuota(n int,A,B,C string){
    if n&lt;1 || n&gt;20 {
        return
    }
    if n==1{
        fmt.Printf(&quot;盘子%d从%s柱子移动到%s柱子\n&quot;,n,A,C)
    }else {
        hannuota(n-1,A,C,B)
        fmt.Printf(&quot;盘子%d从%s柱子移动到%s柱子\n&quot;,n,A,C)
        hannuota(n-1,B,A,C)
    }
}
func main() {
    a,b,c:=&quot;A&quot;,&quot;B&quot;,&quot;C&quot;
    var val int
    fmt.Println(&quot;请输入要移动的盘子数（1-20之间）：N=&quot;)
    fmt.Scanf(&quot;%d&quot;,&amp;val)
        hannuota(val,a,b,c)
}
</code></pre>

<p>4.八皇后</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

const Num int=8
var count int=1
var quees[Num][Num] int

func print(){
    fmt.Printf(&quot;第%d种解法:\n&quot;,count)
    for i:=0;i&lt;Num;i++ {
        for j:=0;j&lt;Num;j++ {
            if quees[i][j]==1 {
                fmt.Printf(&quot;%s &quot;,&quot;■&quot;)
            }else {
                fmt.Printf(&quot;%s &quot;,&quot;□&quot;)
            }
        }
        fmt.Println()
    }
}

func setQueen(row,col int) bool  {
    if row==0 {
        quees[row][col]=1
        return true
    }

    for i:=0;i&lt;Num;i++ {
        if quees[row][i]==1 {
            return false
        }
    }

    for i:=0;i&lt;Num;i++ {
        if quees[i][col]==1 {
            return false
        }
    }

    for i,j:=row,col;i&lt;Num &amp;&amp; j&lt;Num;i,j=i+1,j+1 {
        if quees[i][j]==1 {
            return false
        }
    }
    for i,j:=row,col;i&gt;=0 &amp;&amp; j&gt;=0;i,j=i-1,j-1 {
        if quees[i][j]==1 {
            return false
        }
    }
    for i,j:=row,col;i&lt;Num &amp;&amp; j&gt;=0;i,j=i+1,j-1 {
        if quees[i][j]==1 {
            return false
        }
    }
    for i,j:=row,col;i&gt;=0 &amp;&amp; j&lt;Num;i,j=i-1,j+1 {
        if quees[i][j]==1 {
            return false
        }
    }
    quees[row][col]=1
    return true
}

func solve(row int) {
    if row==Num {
        print()
        count++
        return
    }
    for i:=0;i&lt;Num;i++ {
        if setQueen(row,i) {
            solve(row+1)
        }
        quees[row][i]=0
    }
}

func main() {
    solve(0)
}
</code></pre>

<h1 id="常规算法">常规算法</h1>

<h2 id="查找">查找</h2>

<p>分类</p>

<p>　　1）静态查找和动态查找；</p>

<p>　　　　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</p>

<p>　　2）无序查找和有序查找。</p>

<p>　　　　无序查找：被查找数列有序无序均可；</p>

<p>　　　　有序查找：被查找数列必须为有序数列。</p>

<p>七大查找算法：顺序查找、二分查找、差值查找、斐波那契查找、 树表查找 (二叉树查找、平衡查找树之2-3查找树、平衡查找树之红黑树、B树和B+树)、分块查找、哈希查找、图查找 (广度优先查找、深度优先查找)</p>

<ol>
<li><p>循序迭代查找</p>

<p>查找结构：线性表（数组和链表），无序</p>

<p>就是我们最常用的迭代遍历，找到了就返回</p></li>

<li><p>二分查找</p>

<p>查找结构：有序的，非动态的数组</p>

<p>也是我们常说的折半查找，一般是获取中间数据，进行对比，需要查找的数据在左边一半还是在右边一半，依次类推，进行递归。</p>

<pre><code>func binarySearch(arr []int,  k int) int {
    left, right, mid := 1, len(arr), 0
    for {
        // mid向下取整
        mid = int(math.Floor(float64((left + right) / 2)))
        if arr[mid] &gt; k {
            // 如果当前元素大于k，那么把right指针移到mid - 1的位置
            right = mid - 1
        } else if arr[mid] &lt; k {
            // 如果当前元素小于k，那么把left指针移到mid + 1的位置
            left = mid + 1
        } else {
            // 否则就是相等了，退出循环
            break
        }
        // 判断如果left大于right，那么这个元素是不存在的。返回-1并且退出循环
        if left &gt; right {
            mid = -1
            break
        }
    }
    // 输入元素的下标
    return mid
}


func binarySearch2(sortedArray []int, lookingFor int) int {
    var low int = 0
    var high int = len(sortedArray) - 1
    for low &lt;= high {
        var mid int =low + (high - low)/2
        var midValue int = sortedArray[mid]
        if midValue == lookingFor {
            return mid
        } else if midValue &gt; lookingFor {
            high = mid -1
        } else {
            low = mid + 1
        }
    }
    return -1
}


func binarySearch3(arr []int, k int) int {
    low := 0
    high := len(arr) - 1
    for low &lt;= high {
        // 这种写法防止两数和导致的内存溢出
        mid := low + (high-low)&gt;&gt;1  // avg=(a+b)&gt;&gt;1://右移表示除2，左移表示乘2
        if k &lt; arr[mid] {
            high = mid - 1
        } else if k &gt; arr[mid] {
            low = mid + 1
        } else {
            return mid
        }
    }
    return -1
}



func binarySearch4(arr []int, k int) int {
    low := 0
    high := len(arr) - 1
    for low &lt;= high {
        /**
        利用位与（&amp;）提取出两个数相同的部分，利用异或（^）拿出两个数不同的部分的和，相同的部分加上不同部分的和除2即得到两个数的平均值
        异或： 相同得零，不同得1 == 男男等零，女女得零，男女得子
        avg = (a&amp;b)  + (a^b)&gt;&gt;1;
        或者
        avg = (a&amp;b)  + (a^b)/2;
         */
        mid := low &amp; high  + (low ^ high) &gt;&gt; 1
        if k &lt; arr[mid] {
            high = mid - 1
        } else if k &gt; arr[mid] {
            low = mid + 1
        } else {
            return mid
        }
    }
    return -1
}

第三、第四种方法逼格最高，第四种效率最快
</code></pre></li>

<li><p>差值查找</p>

<p>查找结构：有序的，非动态的数组</p>

<p>是在二分查找的基础上进行优化，不在取中间值，而是取我们查找的数据的比例，这样查找更快，但是比较适合数据比较均匀的，否则效果很差，其他一样。</p>

<pre><code>func insertSearch(arr []int, key int) int{
    low  := 0
    high := len(arr) - 1
    time := 0
    for low &lt; high {
        time += 1
        // 计算mid值是插值算法的核心代码 实际上就是
        mid := low + int((high - low) * (key - arr[low])/(arr[high] - arr[low]))
        if key &lt; arr[mid] {
            high = mid - 1
        }else if key &gt; arr[mid] {
            low = mid + 1
        }else {
            return mid
        }
    }
    return -1
}
</code></pre>

<p>还可以升级为斐波那契查找，就是将数据分为数量比例为0.618的两份进行查找。</p></li>

<li><p>哈希表</p></li>
</ol>

<p>说白了就是用一个二维数组来装原数组经过Hash运算后的值，如，第一维是 元素Hash后的值，第二维依次装着该 key在原数组中出现的索引号 &lt;因为原数组中的 元素可能会有相同的，所以Hash值也会一样，所以用了二维数组&gt;。在查找的时候可以先计算Hash然后用顺序查找在第一维中找到对应的Hash，然后在第二维中依次返回里面的内容&lt;也就是该key在原数组中的索引值&gt;；如果没找到对应Hash，则原数组没有包含该key</p>

<ol>
<li><p>树</p>

<p>树的查找主要在于树的构建，满足了特性，查找就变的简单。</p>

<ol>
<li>二叉排序树</li>
</ol>

<p>查找结构：树，必须满足二叉排序树的特点</p>

<p>就是所有的左节点都小于根节点，所有的右节点都大于根节点，这样中序遍历的适合就是一个有序数组。而且查找类似于二分查找。更快。</p>

<p>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后再用所查数据和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。</p>

<p>需要先构造一个二叉树，然后把数组的元素和索引放置树的对应位置，然后在从输的root逐个换个key做对比，取出key所在数组中的index</p>

<pre><code>/**
基本思路：先把数组构造出一颗二叉树的样纸，然后查找的时候在从root往下对比
 */
func BSTsearch(arr []int, key int) int{
    // 先在内存中构造 二叉树
    tree := new(Tree)
    for i, v := range arr {
        Insert(tree, v, i)
    }
    // 开始二叉树查找目标key
    return searchKey(tree.Root, key)
}

// 节点结构
type Node struct {
    Value, Index int  // 元素的值和在数组中的位置
    Left, Right *Node
}

// 树结构
type Tree struct {
    Root *Node
}

// 把数组的的元素插入树中
func Insert(tree *Tree, value, index int){
    if nil == tree.Root {
        tree.Root = newNode(value, index)
    }else {
        InsertNode(tree.Root, newNode(value, index))
    }
}

// 把新增的节点插入树的对应位置
func InsertNode(root, childNode *Node) {
    // 否则，先和根的值对比
    if childNode.Value &lt;= root.Value {
        // 如果小于等于跟的值，则插入到左子树
        if  nil == root.Left {
            root.Left = childNode
        }else {
            InsertNode(root.Left, childNode)
        }
    }else{
        // 否则，插入到右子树
        if nil == root.Right {
            root.Right = childNode
        }else {
            InsertNode(root.Right, childNode)
        }
    }
}

func newNode(value, index int) *Node {
    return &amp;Node{
        Value: value,
        Index: index,
    }
}
// 在构建好的二叉树中，从root开始往下查找对应的key 返回其在数组中的位置
func searchKey(root *Node, key int) int {
    if nil == root {
        return -1
    }
    if  key == root.Value {
        return root.Index
    }else if key &lt; root.Value {
        // 往左子树查找
        return searchKey(root.Left, key)
    }else {
        // 往右子树查找
        return searchKey(root.Right, key)
    }
}
</code></pre>

<ol>
<li>平衡二叉排序树（AVL树）</li>
</ol>

<p>在二叉排序树的基础上进行平衡，因为二叉排序树在一些极端情况，比如斜树，效率很差，而且这情况是可以转化为效率高的左右平衡的情况，
所以我们定义左右子树的度相差不能超过1的树叫平衡二叉排序树（AVL树），这样的树查找效率就得到来保证，如何平衡，就是在每次树插入时
判断一下度的差距（左-右），如果小于-1则左旋转，大于1则右旋转。</p>

<ol>
<li><p>多路树</p></li>

<li><p>红黑树</p></li>
</ol>

<p>实例</p>

<pre><code>const (
    RED   = true
    BLACK = false
)

// 节点
type RBNode struct {
    Color               bool // true == 红  false == 黑
    Parent, Left, Right *RBNode
    Value, Index        int
}

type RBTree struct {
    Root *RBNode
}

/*
* 对红黑树的节点(x)进行左旋转
*
* 左旋示意图(对节点 x 进行左旋)：
*      px                              px
*     /                               /
*    x                               y
*   /  \      --(左旋)-.           / \                #
*  lx   y                          x  ry
*     /   \                       /  \
*    ly   ry                     lx  ly
*
*
*/
func (t *RBTree) leftSpin(node *RBNode) {
    // 先提出自己的 右子
    y := node.Right

    // 自己的新右子 是前右子的左子
    node.Right = y.Left

    if nil != y.Left {
        y.Left.Parent = node
    }

    // 你以前的爹，就是我现在的爹
    y.Parent = node.Parent

    // 如果被旋转的节点是 之前树的根
    // 那么，新的跟就是 y 节点
    if nil == node.Parent {
        t.Root = y
    } else { // 被旋转的是普通节点时, 需要结合自身的父亲来确认自己之前是属于 左子还是右子
        if node.Parent.Left == node { // 被旋转节点之前是 左子时
            // 用 y 来作为之前 该节点父亲的 新左子
            node.Parent.Left = y
        } else { // 否则，是 右子
            node.Parent.Right = y
        }
    }

    // 将 node 设为 y 的左子
    y.Left = node
    // 将 y 设为 node 的新父亲
    node.Parent = y
}

/*
 * 对红黑树的节点(y)进行右旋转
 *
 * 右旋示意图(对节点 y 进行左旋)：
 *            py                               py
 *           /                                /
 *          y                                x
 *         /  \      --(右旋)-.            /  \                     #
 *        x   ry                           lx   y
 *       / \                                   / \                   #
 *      lx  rx                                rx  ry
 *
 */
func (t *RBTree) rightSpin(node *RBNode) {
    // 先提出自己的 左子
    x := node.Left
    node.Left = x.Right

    if nil != x.Left {
        x.Right.Parent = node
    }

    x.Parent = node.Parent

    // 如果被旋转的节点是 之前树的根
    // 那么，新的跟就是 x 节点
    if nil == node.Parent {
        t.Root = x
    } else {

        if node.Parent.Right == node {
            node.Parent.Right = x
        } else {
            node.Parent.Left = x
        }
    }

    x.Right = node

    node.Parent = x
}

func insertValue(tree *RBTree, val, index int) {
    node := &amp;RBNode{Value: val, Index: index, Color: BLACK}
    if nil == tree.Root {
        tree.Root = node
    }else{
        tree.insert(node)
    }
}

func (t *RBTree) insert(node *RBNode) {
    //int cmp;
    var tmpNode *RBNode
    root := t.Root

    // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。
    for nil != root {
        if node.Value &lt; root.Value {
            root = root.Left
        } else {
            root = root.Right
        }
        tmpNode = root
    }

    node.Parent = tmpNode
    if nil != tmpNode {

        if node.Value &lt; tmpNode.Value {
            tmpNode.Left = node
        } else {
            tmpNode.Right = node
        }
    } else {
        t.Root = node
    }

    // 2. 设置节点的颜色为红色
    node.Color = RED

    // 3. 将它重新修正为一颗二叉查找树
    t.adjustRBTree(node)
}

// 修正树
func (t *RBTree) adjustRBTree(node *RBNode) {
    var parent, gparent *RBNode // 父亲 和 祖父

    // 若“父节点存在，并且父节点的颜色是红色”
    for nil != node.Parent &amp;&amp; RED == node.Parent.Color {
        parent = node.Parent
        gparent = parent.Parent

        //若“父节点”是“祖父节点的左孩子”
        if parent == gparent.Left {
            // Case 1条件：叔叔节点是红色
            uncle := gparent.Right
            if nil != uncle &amp;&amp; RED == uncle.Color {
                uncle.Color = BLACK
                parent.Color = BLACK
                gparent.Color = RED
                node = gparent
                continue
            }

            // Case 2条件：叔叔是黑色，且当前节点是右孩子
            if node == parent.Right {
                var tmp *RBNode
                t.leftSpin(parent)
                tmp = parent
                parent = node
                node = tmp
            }

            // Case 3条件：叔叔是黑色，且当前节点是左孩子。
            parent.Color = BLACK
            gparent.Color = RED
            t.rightSpin(gparent)
        } else { //若“z的父节点”是“z的祖父节点的右孩子”
            // Case 1条件：叔叔节点是红色
            uncle := gparent.Left
            if nil != uncle &amp;&amp; RED == uncle.Color {
                uncle.Color = BLACK
                parent.Color = BLACK
                gparent.Color = RED
                node = gparent
                continue
            }

            // Case 2条件：叔叔是黑色，且当前节点是左孩子
            if node == parent.Left {
                var tmp *RBNode
                t.rightSpin(parent)
                tmp = parent
                parent = node
                node = tmp
            }

            // Case 3条件：叔叔是黑色，且当前节点是右孩子。
            parent.Color = BLACK
            gparent.Color = RED
            t.leftSpin(gparent)
        }
    }
    // 将根节点设为黑色
    t.Root.Color = BLACK
}

/**
红黑树查找
 */
func RedBlackTreeSearch(arr []int, key int) int{
    // 先构造树
    tree := new(RBTree)
    for i, v := range arr {
        insertValue(tree, v, i)
    }
    // 开始二叉树查找目标key
    return tree.serch(key)
}

func (t *RBTree) serch(key int) int {
    return serch(t.Root, key)
}
func serch(node *RBNode, key int) int {
    if nil == node {
        return -1
    }
    if key &lt; node.Value {
        return serch(node.Left, key)
    }else if key &gt; node.Value {
        return serch(node.Right, key)
    }else {
        return node.Index
    }
}
</code></pre></li>

<li><p>图查找</p></li>
</ol>

<p>深度优先查找和广度优先查找</p>

<ol>
<li><p>索引查找</p>

<ol>
<li>稠密索引
新建一个索引数组，在每个数据后加一个指针指向数据所在的位置，类似于一个哈希表，只实用于数据比较少的情况。</li>

<li><p>分块索引
新建一个索引表，存储一块数据的最大值和开始位置，每块数据是要进行排序的，但是块内的数据是不需要排序的，这样查找直接查到到哪一块。</p>

<p>是顺序查找的一种结合改进；</p>

<p>将n个数据元素&rdquo;按块有序&rdquo;划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须&rdquo;按块有序&rdquo;；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……
　　
算法流程：</p>

<pre><code>step1 ：先选取各块中的最大关键字构成一个索引表；
step2 ：查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。
</code></pre></li>

<li><p>倒排索引
用关键字来指向在哪些文件中存在，也就是我们的反向索引，和我们正常思想相反，正常的正向索引就是每个文件中包含哪些关键字，倒排索引更利于查找。</p></li>
</ol></li>

<li><p>快慢指针</p>

<p>一个指针走的快，一个走的慢，两个指针之间拥有一定的规律。比如</p>

<p>1、解决查找不知道大小的链表的中间数问题</p>

<pre><code>可以使用两个指针，一个一次走两位，一个指针一次走一位，两者之间就是两倍的关系，当快指针走到最后，慢指针刚好是获取中间
</code></pre>

<p>2、解决链表是否有环问题</p>

<pre><code>两个指针一个指针一步步移动，另一个指针则直接重头移动到第二个指针的位置，两者所使用的步数不同，就可以确认是有环的。
</code></pre></li>

<li><p>topK&ndash; 孤岛算法：</p></li>
</ol>

<p>TOP k就是从海量的数据中选取最大的k个元素或记录。</p>

<p>基本思想：就是维护一个具有k个元素的最小堆【小顶堆】。每当有新的元素加入时，判断它是否大于堆顶元素，如果大于，用该元素代替堆顶元素，并重新维护小顶堆，直到所有元素被处理完毕。</p>

<p>时间复杂度为O(N*logk)，基本达到线性复杂度。</p>

<p>适用场景：</p>

<pre><code>无序的，海量数据的
</code></pre>

<p>代码：</p>

<pre><code>func HeapSearchK (arr []int, topk int) {

    // 初始化原始最小堆
    smallHeapArr := buildSmallHeap(arr, topk)
    for i := topk; i &lt; len(arr); i ++ {
        // 如果当前原始比最小堆的根元素大，那么替换根，且重新调整最小堆
        if arr[i] &gt; smallHeapArr[0] {
            swapRoot(smallHeapArr, arr[i])
        }
    }
    // 最大的K个数
    fmt.Println(smallHeapArr)
}

//建立小顶堆 
func buildSmallHeap(arr []int,topk int) []int{
    smallHeapArr := arr[:topk]
    for i := topk&gt;&gt;1 - 1; i &gt;= 0; i-- {
        adjustSmallHeap(smallHeapArr, i, topk)
    }
    return smallHeapArr
}
// 调整最小堆
func adjustSmallHeap(arr []int, parent, length int) {
    i := parent
    for  {
        lchild := 2*parent + 1
        rchild := 2 *parent + 2
        if lchild &lt; length &amp;&amp; arr[lchild] &lt; arr[i] {
            i = lchild
        }
        // 右节点和根
        if rchild &lt; length &amp;&amp; arr[rchild] &lt; arr[i]{
            i = rchild
        }
        // 互换位置
        if parent != i {
            arr[i], arr[parent] = arr[parent], arr[i]
            parent = i
        }else {
            break
        }
    }
}

// 替换根部，且重新构造最小堆
func swapRoot(arr []int, root int) {
    arr[0] = root // 新的根
    // 重新调整堆
    adjustSmallHeap(arr, 0, len(arr))
}
</code></pre>

<h2 id="排序">排序</h2>

<p>排序算法是一种元算法，直接考的很少，但是思想还是有用的。</p>

<p>十大排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序</p>

<p>1.O(n^2)</p>

<p><strong>插入排序</strong></p>

<p>假设数据都已经排好，然后我用下一个数据向前面已经排好的队列中遍历插入。</p>

<pre><code>func insertionSort(arr []int) []int {
    for i := range arr {
        preIndex := i - 1
        current := arr[i]
        for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current {
            arr[preIndex+1] = arr[preIndex]
            preIndex -= 1
        }
        arr[preIndex+1] = current
    }
    return arr
}
</code></pre>

<p><strong>选择排序</strong></p>

<p>找到最小的，和第一个交换位置，然后找到剩下最小的，和第二个交换位置，依次类推。这个应该和冒泡是一样的思想，一个把最大的放在最后，一个把最小的放在最前。</p>

<pre><code>func selectSort(arr [6]int) {
    for i := 0; i &lt; len(arr)-1; i++ {
        min_index := i
        for j := i + 1; j &lt; len(arr); j++ {
            if arr[i] &gt; arr[j] {
                min_index = j
            }
            arr[i], arr[min_index] = arr[min_index], arr[i]
        }
    }
    fmt.Println(arr)
}
</code></pre>

<p><strong>希尔排序</strong></p>

<p>希尔是对插入排序的一种升级，将大的数组分成小的，来插入排序。</p>

<pre><code>/**
希尔排序：把切片分成n个batch，对每个batch进行插入排序；然后减小batch，再对每个batch进行插入排序；直到bathc等于1
*/
func shellSort(arr []int, batchSize int) {
    if batchSize &lt; 1 {
        return
    }
    // k : 每个batch中的元素所在batch的index， 介于[0, batchSize)
    for k := 0; k &lt; batchSize; k++ {
        // 用到了插入排序
        for j := 1; batchSize*j+k &lt; len(arr); j++ { // j: 用来获取每个batch所在的第k个元素，拥有多少个batch
            for n := j; n &gt; 0; n-- {
                pre := batchSize*(n-1) + k
                next := batchSize*n + k
                if arr[next] &lt; arr[pre] {
                    arr[next], arr[pre] = arr[pre], arr[next]
                }
            }

        }
    }
    shellSort(arr, batchSize/2)
}
</code></pre>

<p><strong>冒泡排序</strong></p>

<p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
针对所有的元素重复以上的步骤，除了最后一个；
重复步骤1~3，直到排序完成。</p>

<p>就是把最大的先拉出来，其实有一种递归的思想</p>

<pre><code>func bubbleSort(arr [6]int) {
    for i := 0; i &lt; len(arr)-1; i++ {
        for j := 0; j &lt; len(arr)-i-1; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    fmt.Println(arr)
}
</code></pre>

<p>2.O(nlogn)</p>

<p><strong>快排</strong></p>

<p>使用的是二分法，先选择第一个数据作为基准，然后遍历数据，大于基准的放到一个新的数组中，小于基准的放到一个数组中，依次类推，实现排序。
快排是在冒泡排序的基础上进行递归分治</p>

<pre><code>func quickSort(arr []int) []int {
    length := len(arr)
    if length &lt;= 1 {
        return arr
    }
    middle := arr[0]
    var left []int
    var right []int
    for i := 1; i &lt; length; i++ {
        if middle &lt; arr[i] {
            right = append(right, []int{arr[i]}...)
        } else {
            left = append(left, []int{arr[i]}...)
        }
    }
    middle_s := []int{middle}

    left = quickSort(left)
    right = quickSort(right)

    result := append(append(left, middle_s...), right...)

    return result
}
</code></pre>

<p><strong>归并排序</strong></p>

<p>// 归并排序：O(n*log(n))
// 建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用
// 先分治 -&gt; 再合并</p>

<pre><code>//合并
func Merge(arr []int, l, mid, r int) {
    // 分别复制左右子数组
    n1, n2 := mid-l+1, r-mid
    left, right := make([]int, n1), make([]int, n2)
    copy(left, arr[l:mid+1])
    copy(right, arr[mid+1:r+1])
    i, j := 0, 0
    k := l
    for ; i &lt; n1 &amp;&amp; j &lt; n2; k++ {
        if left[i] &lt;= right[j] {
            arr[k] = left[i]
            i++
        } else {
            arr[k] = right[j]
            j++
        }
    }
    for ; i &lt; n1; i++ {
        arr[k] = left[i]
        k++
    }
    for ; j &lt; n2; j++ {
        arr[k] = right[j]
        k++
    }
}

//分治
func MergeSort(arr []int, l, r int) {
    if l &lt; r {
        mid := (l + r - 1) / 2
        MergeSort(arr, l, mid)
        MergeSort(arr, mid+1, r)
        Merge(arr, l, mid, r)
    }
}
</code></pre>

<p><strong>堆排序</strong></p>

<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；顶点是最大值
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；顶点是最小值</p>

<pre><code>// 堆排序：O(n*log(n)) https://blog.csdn.net/code_beeps/article/details/91488526
// s[0]不用，实际元素从角标1开始
// 父节点元素大于子节点元素
// 左子节点角标为2*k
// 右子节点角标为2*k+1
// 父节点角标为k/2
func HeapSort(s []int) {
    N := len(s) - 1 //s[0]不用，实际元素数量和最后一个元素的角标都为N
    //构造堆
    //如果给两个已构造好的堆添加一个共同父节点，
    //将新添加的节点作一次下沉将构造一个新堆，
    //由于叶子节点都可看作一个构造好的堆，所以
    //可以从最后一个非叶子节点开始下沉，直至
    //根节点，最后一个非叶子节点是最后一个叶子
    //节点的父节点，角标为N/2
    for k := N / 2; k &gt;= 1; k-- {
        sink(s, k, N)
    }
    //下沉排序
    for N &gt; 1 {
        s[1], s[N] = s[N], s[1] //将大的放在数组后面，升序排序
        N--
        sink(s, 1, N)
    }
}

//下沉（由上至下的堆有序化）
func sink(s []int, k, N int) {
    for {
        i := 2 * k
        if i &gt; N { //保证该节点是非叶子节点
            break
        }
        if i &lt; N &amp;&amp; s[i+1] &gt; s[i] { //选择较大的子节点
            i++
        }
        if s[k] &gt;= s[i] { //没下沉到底就构造好堆了
            break
        }
        s[k], s[i] = s[i], s[k]
        k = i
    }
}











func heapSort(arr []int) []int {
    arrLen := len(arr)
    buildMaxHeap(arr, arrLen)
    for i := arrLen - 1; i &gt;= 0; i-- {
        swap(arr, 0, i)
        arrLen -= 1
        heapify(arr, 0, arrLen)
    }
    return arr
}

func buildMaxHeap(arr []int, arrLen int) {
    for i := arrLen / 2; i &gt;= 0; i-- {
        heapify(arr, i, arrLen)
    }
}

func heapify(arr []int, i, arrLen int) {
    left := 2*i + 1
    right := 2*i + 2
    largest := i
    if left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] {
        largest = left
    }
    if right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] {
        largest = right
    }
    if largest != i {
        swap(arr, i, largest)
        heapify(arr, largest, arrLen)
    }
}

func swap(arr []int, i, j int) {
    arr[i], arr[j] = arr[j], arr[i]
}
</code></pre>

<ol>
<li>O(n)</li>
</ol>

<p><strong>计数排序</strong></p>

<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>

<pre><code>func countingSort(arr []int, maxValue int) []int {
    bucketLen := maxValue + 1
    bucket := make([]int, bucketLen) // 初始为0的数组

    sortedIndex := 0
    length := len(arr)

    for i := 0; i &lt; length; i++ {
        bucket[arr[i]] += 1
    }

    for j := 0; j &lt; bucketLen; j++ {
        for bucket[j] &gt; 0 {
            arr[sortedIndex] = j
            sortedIndex += 1
            bucket[j] -= 1
        }
    }

    return arr
}
</code></pre>

<p><strong>桶排序</strong></p>

<pre><code>// 桶排序：O(n)，是计数排序的升级版，利用的函数的映射关系，这是一个典型的牺牲空间换取时间的排序
// 借助一个一维数组就可以解决这个问题
// 最大数值作为这个数组的长度,数组的下标key等于这元素的，value就+1也就是标记为1
func buckerSort(s []int) []int {
    arr := make([]int, 10)
    for _, v := range s {
        arr[v] += 1
    }
    sortList := make([]int, 0, len(s))
    for k, v := range arr {
        if v &gt; 0 {
            for i := 0; i &lt; v; i++ {
                sortList = append(sortList, k)
            }
        }
    }
    return sortList
}
</code></pre>

<p><strong>基数排序</strong></p>

<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>

<pre><code>// 基数排序
func BaseSort(data []int) []int {
    if len(data) &lt; 2 {
        return data
    }
    max := data[0]
    dataLen := len(data)
    for i := 1; i &lt; dataLen; i++ {
        if data[i] &gt; max {
            max = data[i]
        }
    }
    // 计算最大值的位数
    maxDigit := 0
    for max &gt; 0 {
        max = max/10
        maxDigit++
    }
    // 定义每一轮的除数，1,10,100...
    divisor := 1;
    // 定义了10个桶，为了防止每一位都一样所以将每个桶的长度设为最大,与原数组大小相同
    bucket := [10][20]int{{0}}
    // 统计每个桶中实际存放的元素个数
    count := [10]int{0}
    // 获取元素中对应位上的数字，即装入那个桶
    var digit int
    // 经过maxDigit+1次装通操作，排序完成
    for i := 1; i &lt;= maxDigit; i++ {
        for j := 0; j &lt; dataLen; j++ {
            tmp := data[j]
            digit = (tmp / divisor) % 10
            bucket[digit][count[digit]] = tmp
            count[digit]++
        }
        // 被排序数组的下标
        k := 0
        // 从0到9号桶按照顺序取出
        for b := 0; b &lt; 10; b++ {
            if count[b] == 0 {
                continue
            }
            for c := 0; c &lt; count[b]; c++ {
                data[k] = bucket[b][c]
                k++
            }
            count[b] = 0
        }
        divisor = divisor * 10
    }
    return data
}
</code></pre>

<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>

<pre><code>基数排序：根据键值的每位数字来分配桶；
计数排序：每个桶只存储单一键值；
桶排序：每个桶存储一定范围的数值；
</code></pre>

<p><strong>语言应用</strong></p>

<p>golang的sort包</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/computerbase/algorithm/algotithm/">https://kingjcy.github.io/post/computerbase/algorithm/algotithm/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/algorithm/">
                            <i class="fa fa-tags"></i>
                            algorithm
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/worklife/leetmeetcode/">Leetmeetcode 练习</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年11月05日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/computerbase/datastruct/datastruct/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/story/sunnyoftwopeople/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#算法思想">算法思想</a>
<ul>
<li><a href="#基本方法">基本方法</a></li>
<li><a href="#思想">思想</a></li>
</ul></li>
<li><a href="#时间复杂度和空间复杂度">时间复杂度和空间复杂度</a></li>
<li><a href="#经典问题">经典问题</a></li>
<li><a href="#常规算法">常规算法</a>
<ul>
<li><a href="#查找">查找</a></li>
<li><a href="#排序">排序</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

