<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="关于数据结构的一些基础总结。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="计算机基础系列---- Datastruct - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    计算机基础系列---- Datastruct
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2014年04月16日 
                </div>
                <h1 class="post-title">计算机基础系列---- Datastruct</h1>
            </header>

            <div class="post-content">
                <p>关于数据结构的一些基础总结。</p>

<h1 id="总结">总结</h1>

<p><a href="https://github.com/azl397985856/leetcode">https://github.com/azl397985856/leetcode</a></p>

<h1 id="数据结构">数据结构</h1>

<p>按物理结构分为顺序结构和链式结构，在计算机上只有这两种存储方式。</p>

<p>按逻辑结构进行分为我们常说的散点集合，线性数据结构，树状数据结构和网状数据结构。这个是我们常规使用的方式，其实数据结构就是那几种。</p>

<h2 id="散点集合">散点集合</h2>

<p>就是正常的set集合</p>

<h2 id="线性数据结构">线性数据结构</h2>

<h3 id="线性表">线性表</h3>

<ol>
<li>数组</li>
</ol>

<p>数组其实是一段连续的内存，通过唯一索引下标（由于地址也是连续的，所以下标根据地址循序来就行，不需要存）来获取对应内存的值。</p>

<p>数组可以说是最基本的数据结构，可以实现很多的复杂的数据结构，比如，队列，栈，树，图等，只不过有些数据结构使用数组会造成很多的资源空间的浪费。选择使用了链式来实现，在计算机中就是这两种基本结构。</p>

<ul>
<li><p>代码表示</p>

<pre><code>[]int
</code></pre></li>

<li><p>经典应用</p>

<pre><code>两数之和（暴力遍历，找到相加相等返回index，还可以使用map）
</code></pre></li>

<li><p>golang中数组array和slice的实现</p>

<p>数组就是和这个是一样的，一段连续的内存，连续的地址来实现来数组的存储，但是Go语言的数组又不同于C语言或者其他语言的数组，C语言的数组变量是指向数组第一个元素的指针；而Go语言的数组是一个值，Go语言中的数组是值类型，一个数组变量就表示着整个数组，意味着Go语言的数组在传递的时候，传递的是原数组的拷贝。</p>

<p>slice就是一个指向数组的指针。</p></li>
</ul>

<p><strong>稀疏数组</strong></p>

<p>稀疏数组就是我们在使用数组来存储数据结构的时候，数组中有很多的空间是浪费的，比如一个二维数组中只存储来几个数字，我们可以将有数据的的位置的坐标和数值用我们正常的数组来存储，这样可以节省很多的空间，这个数组就是稀疏数组，其实这也是压缩的一种方式。</p>

<ul>
<li><p>实现即应用，用于存储压缩数据（定义一个结构体存储数据的位置和值，然后存放到数组中去）</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

type ValNode struct {
    row int
    col int
    val int
}

func main() {
    //一、先创建一个原始数组
    var chessMap [11][11]int
    chessMap[1][2] = 1 //黑子
    chessMap[2][3] = 2 //蓝子

    //输出原始数组
    for _, v := range chessMap {
        for _, v2 := range v {
            fmt.Printf(&quot;%d\t&quot;, v2)
        }
        fmt.Println()
    }

    //二、转成稀疏数组
    //1、遍历chessMap，如果发现有一个元素的值不为0，创建一个node结构体
    //2、将其放入到对应的切片中即可
    var sparseArr []ValNode
    //标准的一个稀疏数组应该还有一个记录元素的二维数组的规模（行和列，默认值）
    //创建一个ValNode值节点
    valNode := ValNode{
        row: 11,
        col: 11,
        val: 0,
    }
    sparseArr = append(sparseArr, valNode)
    //遍历
    for i, v := range chessMap {
        for j, v2 := range v {
            if v2 != 0 {
                //创建一个ValNode值节点
                valNode := ValNode{
                    row: i,
                    col: j,
                    val: v2,
                }
                sparseArr = append(sparseArr, valNode)
            }
        }
    }
    //输出稀疏数组
    fmt.Println(&quot;当前的稀疏数组是：&quot;)
    for i, valNode := range sparseArr {
        fmt.Printf(&quot;%d: %d %d %d\n&quot;, i, valNode.row, valNode.col, valNode.val)
    }
    //三、恢复原始的数组
    //1、这里使用稀疏数组恢复
    //2、先创建一个原始数组
    var chessMap2 [11][11]int
    //遍历稀疏数组(文件的每一行)
    for i, valNode := range sparseArr {
        if i != 0 { //跳过第一行的数据
            chessMap2[valNode.row][valNode.col] = valNode.val
        }
    }
    //输出chessMap2
    fmt.Println(&quot;恢复后的原始数据：&quot;)
    for _, v := range chessMap2 {
        for _, v2 := range v {
            fmt.Printf(&quot;%d\t&quot;, v2)
        }
        fmt.Println()
    }
}



1、将这个稀疏数组，存盘  
2、打开这个文件，恢复原始数组
 

package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
)

type nodeval struct {
    row int
    col int
    val interface{}
}

//文件读取转成原始数据
func ReadData(filename string) {
    file, err := os.OpenFile(filename, os.O_RDONLY, 0666)
    if err != nil {
        log.Fatalf(&quot;%s&quot;, err)
    }
    defer file.Close()
    bfrd := bufio.NewReader(file)
    var index = 0
    var arr [][]int
    for {
        line, err := bfrd.ReadBytes('\n')
        if err != nil {
            break
        }
        index++
        temp := strings.Split(string(line), &quot; &quot;)
        row, _ := strconv.Atoi(temp[0])
        col, _ := strconv.Atoi(temp[1])
        value, _ := strconv.Atoi(temp[2])
        if index == 1 {
            for i := 0; i &lt; row; i++ {
                var arr_temp []int
                for j := 0; j &lt; col; j++ {
                    arr_temp = append(arr_temp, value)
                }
                arr = append(arr, arr_temp)
            }
        }
        if index != 1 {
            arr[row][col] = value
        }
    }
    // 打印数据
    fmt.Println(&quot;从磁盘读取后的数据&quot;)
    for _, v := range arr {
        for _, v1 := range v {
            fmt.Printf(&quot;%d\t&quot;, v1)
        }
        fmt.Println()
    }
}

func main() {

    var chessmap [11][11]int
    chessmap[1][2] = 1
    chessmap[2][3] = 2

    // 看看原始数据
    for _, v := range chessmap {
        for _, v1 := range v {
            fmt.Printf(&quot;%d\t&quot;, v1)
        }
        fmt.Println()
    }

    // 转成稀疏数据
    var sparseArr []nodeval
    // 数据规模
    sparseArr = append(sparseArr, nodeval{
        row: 11,
        col: 11,
        val: 0,
    })
    //稀疏数组
    for row, val := range chessmap {
        for col, val1 := range val {
            if val1 != 0 {
                sparseArr = append(sparseArr, nodeval{
                    row: row,
                    col: col,
                    val: val1,
                })
            }
        }
    }
    // 稀疏数组存盘
    filepath := &quot;c:/test.txt&quot;
    file, err := os.OpenFile(filepath, os.O_WRONLY|os.O_CREATE, 0666)
    if err != nil {
        fmt.Printf(&quot;open file err=%v\n&quot;, err)
    }
    defer file.Close()
    writer := bufio.NewWriter(file)
    for _, node := range sparseArr {
        str := fmt.Sprintf(&quot;%d %d %d \n&quot;, node.row, node.col, node.val)
        writer.WriteString(str)
    }
    writer.Flush()

    // 稀疏数据从磁盘读取转换成原始数据
    ReadData(filepath)
}
</code></pre></li>
</ul>

<p><strong>稀疏矩阵</strong></p>

<p>其实就是上面转化的矩阵，在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。</p>

<ul>
<li><p>代码</p>

<p>其实就是一个二维数组</p></li>

<li><p>经典应用</p>

<p>稀疏矩阵的一个典型应用就是稀疏数组，用于数据的压缩存储。在上面已经实现。</p></li>
</ul>

<p><strong>对称矩阵</strong></p>

<p>对称矩阵（Symmetric Matrices）是指以主对角线为对称轴，各元素对应相等的矩阵。 在线性代数中，对称矩阵是一个方形矩阵，其转置矩阵和自身相等</p>

<p>1.对称矩阵是一个方阵，即就是行和列长度相等
2.对称矩阵中的所有元素都是相互对称的，即就是矩阵的下三角和上三角是对称的</p>

<p><strong>常规矩阵</strong></p>

<p>常规矩阵就是一个矩阵，矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合</p>

<ul>
<li><p>经典应用</p>

<p>矩阵转置（矩阵反转）（矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。所以只要获取一列重下往上的数据，放到对应的行中就可以，依次类推）</p>

<p>矩阵旋转（90度，就是先转置，在左右反转，就是进行对应位置值的互换）</p>

<p>矩阵螺旋输出（模拟路径，当需要边缘或在之前走过的点的时候，方向就顺时针旋转一下。定义方向指针和四个方向的走过的数据）</p></li>
</ul>

<ol>
<li>链表</li>
</ol>

<p>其实链表也是一种基本的数据结构，因为在计算机中只有两种存储方式，所以这两种数据可以说是数据结构的基本单位，可以实现很多的复杂的数据结构，比如，队列，栈，树，图等，其实大多数都是使用链表来实现的。</p>

<p><strong>单链表</strong></p>

<p>头指针：链表中的第一个结点的存储位置。</p>

<pre><code>头结点：

头结点是加在单链表之前附设的一个头结点。
头结点的数据域一般不存储任何信息，也可以存放一些关于线性表的长度的附加信息。
头结点的指针域存放指向第一个结点的指针(即第一个结点的存储位置)。
头结点不一定是链表的必要元素。

头指针：
头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。
头指针具有标识作用，所以常用头指针冠以链表的名字(指针变量的名字)。
无论链表是否为空，头指针均不为空。
头指针是链表的必要元素。
</code></pre>

<p>线性表中最后一个结点的指针域为空(NULL)。</p>

<ul>
<li><p>代码</p>

<pre><code>//数据
type Object interface{}

//节点
type Node struct {
    data Object
    next *Node
}

//初始化一个链表就是新建一个头节点，链表的主要操作还是增删改查。
var head Node = Node{Data: nil, next: nil}

//我们还可以建立一个链表的结构体来实现
type List struct{
    mutex *sync.RWMutex
    Size uint
    Head *Node
    Tail *Node
}

//初始化就是
func (list *List) Init() {
    (*list).size = 0    // 此时链表是空的
    (*list).head = nil  // 没有车头
    (*list).tail = nil  // 没有车尾
}
</code></pre></li>

<li><p>经典应用</p>

<pre><code>两数相加（两个数用链表表示，按位相加，主要是下一位的判断，和最后情况的判断）
链表反转(新定义两个指针进行遍历改变真正的指向)
链表部分反转（找到反转的位置，保留一个不反转的节点和反转的头节点，然后就是定义两个指针来反转，最后连接）
寻找链表相交点（长的先走，然后一样长的一起走，看能不能找到一样的值，还可以用快慢指针，两个链表连接）
链表合并（遍历两个链表，将较小的数字插入到新链表中）
链表分区（双指针法，把大于x的值放入到一个链表中，小于x的值放到一个链表中，都是按着原来的顺序，然后把两张表相连接）
复杂链表的深度拷贝（深拷贝就是新建一个一摸一样的数据，互不影响，两种思路，1。迭代，复制一个节点，然后复制random指向的点，依次遍历，如果这个点是random指向的点就不用复制了，改变指向就可以2。先根据next遍历，复制所有节点，并用map把对应的地址和值记录下来，然后再遍历一般改变random的指向，直接map匹配就好）
</code></pre></li>
</ul>

<p><strong>双向链表</strong></p>

<p>在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>

<ul>
<li><p>代码表示</p>

<pre><code>// 节点数据
type DoubleObject interface{}

// 双链表节点
type DoubleNode struct {
    Data DoubleObject
    Prev *DoubleNode
    Next *DoubleNode
}

//初始化依然是建立一个head节点
var head Node = Node{Data: nil, Prev: nil，Next: nil,}

// 双链表
type DoubleList struct{
    mutex *sync.RWMutex
    Size uint
    Head *DoubleNode
    Tail *DoubleNode
}

//初始化和单链表也是一致的
</code></pre></li>

<li><p>经典应用</p>

<p>居然没有实在的题目，主要看增删改查吧
二叉搜索树转换双向循环链表(中序遍历二叉搜索树是从小到大的循序，在每个节点的改变指针的指向，左指针表示双链表向前指，右指针表示双链表向后指)</p></li>

<li><p>标准库list的实现</p>

<p>就是定义好了如上的结构体，实现了双向链表，写好了增删改查的api</p></li>
</ul>

<p><strong>静态链表</strong></p>

<p>静态链表就是不使用指针，而使用下标来实现单链表。</p>

<p>用数组描述的链表叫做静态链表。C语言中，让数组的元素都是由两个数据域组成，data和cur。数组的每个下标都对应着一个data和一个cur。数据域data，用来存放数据元素，也就是要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数据中的下标，把cur叫游标。另外，数组的第一个和最后一个元素作为特殊元素处理，不存数据。数组的第一个元素，即下标为0的元素的cur存放备用链表（未被使用的数组元素）第一个结点的下标，而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点的作用。</p>

<p>在高级语言的今天，基本上不实用了。</p>

<p>代码</p>

<pre><code>//静态链表节点
type Node struct{
    data string
    cursor int
}
</code></pre>

<p>基本不实用了，了解一下就好</p>

<p><strong>循环链表</strong></p>

<p>将单链表中终端结点的指针端由空指针改为指向头结点，就是整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。</p>

<p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是判断p-&gt;nex不等于头结点，则循环未结束。不在需要head节点</p>

<p>为了用O(1)的时间由链表指针访问到最后一个结点，可以采用这样的方法：不使用头指针（head），而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点都很方便了。即终端结点用尾指针rear指示，而头结点就是rear-&gt;next，开始结点就是rear-&gt;next-&gt;next。</p>

<p>双向链表也可以有循环链表，即对于某一结点p，它的后继的前驱是它自己，它的前驱的后继还是它自己：p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next。</p>

<ul>
<li>代码实现</li>
</ul>

<p>其实循环链表的的单还是双的结构体都是正常的一样的，只不过最后操作的时候需要形成一个循环，就是指向头指针，至于初始化，可以指向自己，可以不指向自己。</p>

<pre><code>单链
    //数据
    type Object interface{}

    //节点
    type CNode struct {
        data Object
        next *CNode
    }

    //正常初始化
    var head CNode = Node{Data: nil, next: nil}

    //定一个结构体，这种属于正常使用，会带链表的大小
    type CList struct {
        size uint64    // 车厢数量
        head *CNode    // 车头
    }

    //初始化
    func (cList *CList) Init() {
        lst := *cList
        lst.size = 0    // 没车厢
        lst.head = nil  // 没车头
    }


双链

    //结点
    type Node struct {
        Data ElemType
        Pre  *Node
        Next *Node
    }

    //链表
    type List struct {
        First *Node
        Last  *Node
        Size  int
    }

    //工厂函数
    func CreateList() *List {
        s := new(Node)
        s.Next, s.Pre = s, s
        return &amp;List{s, s, 0}
    }
</code></pre>

<ul>
<li><p>经典应用</p>

<p>判断链表中是否有环（两个指针，一个一步步遍历，一个每次重头开始遍历，出现步数不一样的时候就存在环，还有链表的遍历）</p></li>

<li><p>ring库的实现</p>

<p>就是一个双向循环链表的实现，封装了很多的API</p></li>
</ul>

<ol>
<li>栈</li>
</ol>

<p>栈是数据按照后进先出 LIFO(Last-In-First-Out) 原则组成的集合。添加和移除元素都是在栈顶进行，类比书堆，不能在栈底增删元素。</p>

<p>其实栈就是一种特殊的线性表，只不过遵守着特殊的规则，可以使用数组和链表来实现。</p>

<p><strong>链表实现方式</strong></p>

<p>在golang中只有标准库list，所以可以省去了链表的定义和创建模块。</p>

<ul>
<li><p>代码</p>

<pre><code>//栈
type Stack struct {
    list *list.List
    lock *sync.RWMutex
}

//初始化
func NewStack() *Stack {
    list := list.New()
    l := &amp;sync.RWMutex{}
    return &amp;Stack{list, l}
}
</code></pre></li>

<li><p>实例</p>

<pre><code>package main

import (
    &quot;container/list&quot;
    &quot;sync&quot;
)

type Stack struct {
    list *list.List
    lock *sync.RWMutex
}

func NewStack() *Stack {
    list := list.New()
    l := &amp;sync.RWMutex{}
    return &amp;Stack{list, l}
}

func (stack *Stack) Push(value interface{}) {
    stack.lock.Lock()
    defer stack.lock.Unlock()
    stack.list.PushBack(value)
}

func (stack *Stack) Pop() interface{} {
    stack.lock.Lock()
    defer stack.lock.Unlock()
    e := stack.list.Back()
    if e != nil {
        stack.list.Remove(e)
        return e.Value
    }
    return nil
}

func (stack *Stack) Peak() interface{} {
    e := stack.list.Back()
    if e != nil {
        return e.Value
    }

    return nil
}

func (stack *Stack) Len() int {
    return stack.list.Len()
}

func (stack *Stack) Empty() bool {
    return stack.list.Len() == 0
}
</code></pre></li>

<li><p>实例简化</p>

<pre><code>import &quot;container/list&quot;

// 初始化
queue := list.New()
stack := list.New()

// 入队 入栈
queue.PushBack(123)
stack.PushBack(123)

// 出队 出栈 返回的数据是结构类型 Value 需要断言成相应的类型
num1 = queue.Front()
queue.Remove(num1)

num2 = queue.Back()
stack.Remove(num2)
</code></pre></li>

<li><p>原生实现</p>

<pre><code>package main

import (
    &quot;sync&quot;
)

type (
    Stack struct {
        top    *node
        length int
        lock   *sync.RWMutex
    }
    node struct {
        value interface{}
        prev  *node
    }
)

// Create a new stack
func NewStack() *Stack {
    return &amp;Stack{nil, 0, &amp;sync.RWMutex{}}
}

// Return the number of items in the stack
func (this *Stack) Len() int {
    return this.length
}

// View the top item on the stack
func (this *Stack) Peek() interface{} {
    if this.length == 0 {
        return nil
    }
    return this.top.value
}

// Pop the top item of the stack and return it
func (this *Stack) Pop() interface{} {
    this.lock.Lock()
    defer this.lock.Unlock()
    if this.length == 0 {
        return nil
    }
    n := this.top
    this.top = n.prev
    this.length--
    return n.value
}

// Push a value onto the top of the stack
func (this *Stack) Push(value interface{}) {
    this.lock.Lock()
    defer this.lock.Unlock()
    n := &amp;node{value, this.top}
    this.top = n
    this.length++
}
</code></pre></li>
</ul>

<p><strong>数组实现方式</strong></p>

<p>在实际项目中不要这么使用，这么做会带来内存泄漏的风险。那么这个场景用来干啥呢，刷刷 leetcode 题还是蛮方便的。一般来说会用链表来实现队列和栈，当然 golang 内置的 container/list 库提供了双向链表的数据结构。我们用这个也是很方便的。</p>

<ul>
<li><p>代码</p>

<pre><code>type ItemStack struct {
    items []Item
    lock  sync.RWMutex
}

// New creates a new ItemStack
func NewStack() *ItemStack {
    s := &amp;ItemStack{}
    s.items = []Item{}
    return s
}
</code></pre></li>

<li><p>实例</p>

<pre><code>package stack

import (
    &quot;github.com/cheekybits/genny/generic&quot;
    &quot;sync&quot;
)

type Item generic.Type

type ItemStack struct {
    items []Item
    lock  sync.RWMutex
}

// 创建栈
func (s *ItemStack) New() *ItemStack {
    s.items = []Item{}
    return s
}

// 入栈
func (s *ItemStack) Push(t Item) {
    s.lock.Lock()
    s.items = append(s.items, t)
    s.lock.Unlock()
}

// 出栈
func (s *ItemStack) Pop() *Item {
    s.lock.Lock()
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1 ]
    s.lock.Unlock()
    return &amp;item
}
</code></pre></li>

<li><p>经典应用</p>

<pre><code>用队列实现栈（栈和队列都是用list实现的，本身提供了这些功能，就简单了，这个主要是一个思想，满足队列的特性，需要将最上面的值放到队头，栈实现队列也是一个原理，将队头放在栈顶）
栈是否是合法的出栈顺序（模拟入栈出栈，按序列匹配出栈，看是否能得到这个序列，可以用list库，但是没有ide的时候可能使用slice更加好写一点）
获取最小值（单独用一个栈来存储这个最小值，必须要是栈，因为在弹出的时候，可能弹出最小值，需要知道下一个最小值）
计算器（中缀表达式转后缀表达式计算，转换有规则，计算有规则）
</code></pre></li>
</ul>

<ol>
<li>队列</li>
</ol>

<p>队列是数据按照先进先出 FIFO(First-In-First-Out) 原则组成的集合，类比排队，在队列任一端添加元素，从对应的另一端删除元素。</p>

<p>其实队列也是一种特殊的线性表，数据结构和栈是一样的，只不过遵守着不同的特殊的规则，可以使用数组和链表来实现。</p>

<p><strong>链表实现方式</strong></p>

<p>这个也可以直接使用标准库的list来实现，减去了链表的定义和创建</p>

<ul>
<li><p>代码</p>

<pre><code>// Queue 队列信息
type Queue struct{
    list *list.List
    lock *sync.RWMutex
}

// Init 队列初始化
func (q *Queue)Init()  {
    list := list.New()
    l := &amp;sync.RWMutex{}
    return &amp;Queue{list, l}
}
</code></pre></li>

<li><p>经典应用</p></li>
</ul>

<p><strong>数组实现方式</strong></p>

<ul>
<li><p>代码</p>

<pre><code>type ItemQueue struct {
    items []Item
    lock  sync.RWMutex
}
</code></pre></li>

<li><p>实例</p>

<pre><code>package queue

import (
    &quot;github.com/cheekybits/genny/generic&quot;
    &quot;sync&quot;
)

type Item generic.Type

type ItemQueue struct {
    items []Item
    lock  sync.RWMutex
}

// 创建队列
func (q *ItemQueue) New() *ItemQueue {
    q.items = []Item{}
    return q
}

// 如队列
func (q *ItemQueue) Enqueue(t Item) {
    q.lock.Lock()
    q.items = append(q.items, t)
    q.lock.Unlock()
}

// 出队列
func (q *ItemQueue) Dequeue() *Item {
    q.lock.Lock()
    item := q.items[0]
    q.items = q.items[1:len(q.items)]
    q.lock.Unlock()
    return &amp;item
}

// 获取队列的第一个元素，不移除
func (q *ItemQueue) Front() *Item {
    q.lock.Lock()
    item := q.items[0]
    q.lock.Unlock()
    return &amp;item
}

// 判空
func (q *ItemQueue) IsEmpty() bool {
    return len(q.items) == 0
}

// 获取队列的长度
func (q *ItemQueue) Size() int {
    return len(q.items)
}
</code></pre></li>

<li><p>channel的实现</p></li>
</ul>

<p>我们一般都不需要自己去创建队列了，大部分都是使用封装好的通信机制channel</p>

<p>channel是使用循环链表做缓存，中间有两个队列，分别是接受和发送，满了就会阻塞</p>

<ul>
<li><p>经典应用</p>

<p>用栈实现队列，和用队列实现栈是一个思想</p></li>
</ul>

<p><strong>循环队列</strong></p>

<p>循环队列其实也就是循环表，只不过我们有这么一个概念，了解一下。</p>

<ul>
<li><p>channel的实现</p>

<p>channel带缓存的其实也是一个循环队列。</p></li>

<li><p>经典应用</p></li>
</ul>

<p>设计一个循环队列</p>

<pre><code>//  622
type MyCircularQueue struct {
    data  []int
    front int
    rear  int
    cap   int
}

/** Initialize your data structure here. Set the size of the queue to be k. */
func Constructor(k int) MyCircularQueue {
    return MyCircularQueue{
        data:  make([]int, k + 1),
        front: 0,
        rear:  0,
        cap:   k + 1,
    }
}

/** Insert an element into the circular queue. Return true if the operation is successful. */
func (mcq *MyCircularQueue) EnQueue(value int) bool {
    if mcq.IsFull() {
        return false
    }
    mcq.data[mcq.rear] = value
    mcq.rear = (mcq.rear + 1) % mcq.cap
    return true
}

/** Delete an element from the circular queue. Return true if the operation is successful. */
func (mcq *MyCircularQueue) DeQueue() bool {
    if mcq.IsEmpty() {
        return false
    }
    mcq.front = (mcq.front + 1) % mcq.cap
    return true
}

/** Get the front item from the queue. */
func (mcq *MyCircularQueue) Front() int {
    if !mcq.IsEmpty() {
        return mcq.data[mcq.front]
    }
    return -1
}

/** Get the last item from the queue. */
func (mcq *MyCircularQueue) Rear() int {
    if mcq.IsEmpty() {
        return -1
    }
    mod := (mcq.rear - 1) % mcq.cap
    if mod == -1 {
        mod = mcq.cap - 1
    }
    return mcq.data[mod]
}

/** Checks whether the circular queue is empty or not. */
func (mcq *MyCircularQueue) IsEmpty() bool {
    return mcq.front == mcq.rear
}

/** Checks whether the circular queue is full or not. */
func (mcq *MyCircularQueue) IsFull() bool {
    return (mcq.rear+1)%mcq.cap == mcq.front
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * obj := Constructor(k);
 * param_1 := obj.EnQueue(value);
 * param_2 := obj.DeQueue();
 * param_3 := obj.Front();
 * param_4 := obj.Rear();
 * param_5 := obj.IsEmpty();
 * param_6 := obj.IsFull();
 */
</code></pre>

<ol>
<li>字符串</li>
</ol>

<p>字符串其实就是[]string,字符串在这边单独列出来，主要是使用上比较广泛，比较经典的就是字符串匹配问题</p>

<p><strong>BF算法</strong></p>

<p>就是我们的暴力匹配方法，循环遍历，也是我们的常规思维，第一个匹配上再匹配第二个，匹配不上在向后移动</p>

<pre><code>func IndexFind(s, sep string) int {
    for i := 0; i &lt; len(s); i++ {
        if s[i] == sep[0] {
            is := true
            j := 0
            for ; j &lt; len(sep); j++ {
                if sep[j] != s[i+j] {
                    is = false
                    break
                }
            }
            if is {
                return i
            }
        }
    }
    return -1
}
</code></pre>

<p><strong>KMP算法</strong></p>

<p>就是减少回溯，在我们匹配不上的时候知道下一步去哪边匹配，而不是一步一步的去匹配，主要是如何移位的问题，要么全移动，要么移动匹配位</p>

<p>KMP算法的主要原理如下:</p>

<p>s为目标文本, 长度为m</p>

<p>p为搜索词,长度为n</p>

<p>假设p[i]与s[x]匹配失败,那么p[i-1]与s[x-1]是匹配成功的, 则试图找到一个索引 j, 使得p[0:j] = p<a href="p[0:j] 包含p[j]">i-j-1:i-1</a>，其实就是构建前缀数组（计算字符串f每一个位置的字符串的前缀和后缀公共部分的最大长度，不包括字符串本身，否则最大长度始终是字符串本身）</p>

<p>如果有则s[x]继续与p[j+1]进行比较, 相当于搜索词移动i-j-1位（移动位置=已匹配的字符数 - 对应的部分匹配值）</p>

<p>无则s[x]与p[0]比较. (具体代码实现时无可以表示为-1, 这样+1 后正好为0) 相当于搜索词移动i位</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

func GetNextValueArray(sub []byte) (next []int) {
    var (
        length        int = len(sub)
        middle        int
        compare_left  int
        compare_right int
        match_count   int
    )

    next = make([]int, length)
    next[0] = 0
    next[1] = 0

    for i := 2; i &lt; length; i++ {
        middle = i / 2
        match_count = 0

        if i%2 == 0 {
            for j := 0; j &lt; middle; j++ {
                compare_left = 0
                compare_right = i - 1 - j
                for compare_left &lt;= j {
                    if sub[compare_left] != sub[compare_right] {
                        break
                    }
                    compare_left++
                    compare_right++
                }
                if compare_left == j+1 {
                    match_count++
                }
            }
            next[i] = match_count

        } else {
            for j := 0; j &lt;= middle; j++ {
                compare_left = 0
                compare_right = i - 1 - j
                for compare_left &lt;= j {
                    if sub[compare_left] != sub[compare_right] {
                        break
                    }
                    compare_left++
                    compare_right++
                }
                if compare_left == j+1 {
                    match_count++
                }
            }
            next[i] = match_count
        }
    }

    return next
}

func ReviseNextValueArray(next []int) []int {
    var length int = len(next)
    for i := 2; i &lt; length; i++ {
        if next[i] == next[next[i]] {
            next[i] = next[next[i]]
        }
    }

    return next
}

//在content中的start-end之间寻找sub子串
//成功返回匹配成功的起始下标，匹配失败则返回-1
func KMP(content []byte, start_index int, end_index int, sub []byte) (index int) {
    var (
        next       []int = ReviseNextValueArray(GetNextValueArray(sub))
        sub_index  int   = 0
        sub_length int   = len(sub)
    )
    for i := start_index; i &lt;= end_index; i++ {
        if content[i] == sub[sub_index] {
            match_start := i
            for j := sub_index; j &lt;= sub_length; j++ {
                if j == sub_length {
                    return match_start - sub_index
                }
                if i &gt;= end_index || content[i] != sub[j] {
                    sub_index = next[j]
                    break
                }
                i++
            }
        }
    }

    return -1
}

func main() {
    content := []byte(&quot;why every programming language use the hello world as the first test???&quot;)
    sub := []byte(&quot;hello world&quot;)
    fmt.Println(KMP(content, 0, len(content)-1, sub))
}
</code></pre>

<ul>
<li>string库的实现</li>
</ul>

<p>string的contain函数使用了rk算法。</p>

<p>string查找使用了BF和RK算法，根据长度来决定使用什么算法</p>

<p>shortStringLen 大小根据机器来决定</p>

<pre><code>var shortStringLen int
func init() {
    if cpu.X86.HasAVX2 {
        shortStringLen = 63
    } else {
        shortStringLen = 31
    }
}
</code></pre>

<p>rk算法在hash的时候使用了E进制，还有这个数16777619</p>

<p><strong>Rabin-Karp算法</strong></p>

<p>假设匹配文本的长度为M,目标文本的长度为N</p>

<ol>
<li>计算匹配文本的hash值</li>
<li>计算目标字符串中每个长度为M的子串的hash值（需要计算N-M+1次）</li>
<li>比较hash值, 如果hash值不同，字符串必然不匹配，如果hash值相同，还需要使用朴素算法（BF）再次判断</li>
</ol>

<ul>
<li>经典应用</li>
</ul>

<p>还有一些其他的算法，可以了解一下。</p>

<pre><code>BF：暴力搜索算法

RK：基于字符串hash ID的算法

KMP：最经典的的算法，基于“双配序列”规则

Horspool：基于坏字符规则的算法，BM的简化版

Sunday：基于坏字符规则的算法，Horspool的进化版

BM：BM算法，基于好后缀和坏字符规则
</code></pre>

<ul>
<li><p>最长不重复字符串</p>

<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。（滑动窗口在左边发现这个最新字符时，就将左边移动到这个index继续遍历，并且比较这个重复的字符串的长度，获取最大的不重复字符串）</p></li>
</ul>

<h2 id="树状数据结构">树状数据结构</h2>

<ol>
<li>树</li>
</ol>

<p>它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。</p>

<pre><code>    ①每个节点有零个或多个子节点；
    ②没有父节点的节点称为根节点；
    ③每一个非根节点有且只有一个父节点；
    ④除了根节点外，每个子节点可以分为多个不相交的子树；
</code></pre>

<p><strong>二叉树</strong></p>

<p>每个节点最多含有两个子树的树称为二叉树。</p>

<ul>
<li><p>代码表示</p>

<pre><code>//节点
type Node struct {
    Val int
    Left *Node
    Right *Node
}

//初始化
var root tree.Node
root = tree.Node{Value: 3}
root.Left = &amp;tree.Node{}
root.Right = &amp;tree.Node{5, nil, nil}
root.Right.Left = new(tree.Node)
root.Left.Right = tree.CreateNode(2)
root.Right.Left.SetValue(4)
</code></pre></li>

<li><p>遍历</p></li>
</ul>

<p>1、深度优先遍历（DFS）</p>

<ul>
<li><p>前序&ndash;根左右</p></li>

<li><p>中序&ndash;左根右</p></li>

<li><p>后序&ndash;左右根</p></li>
</ul>

<p>2、广度优先遍历（BFS）</p>

<ul>
<li><p>层序&ndash;按层</p></li>

<li><p>实例</p></li>
</ul>

<p>上面的方式一般都是一起实现的，可以直接重实例中看出来</p>

<pre><code>package tree

import (
    &quot;fmt&quot;
)

type TreeNode struct {
    ID    int
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func PreOrder(root *TreeNode) {
    if root != nil {
        fmt.Printf(&quot;%d &quot;, root.Val)
        PreOrder(root.Left)
        PreOrder(root.Right)
    }
}

func InOrder(root *TreeNode) {
    if root != nil {
        InOrder(root.Left)
        fmt.Printf(&quot;%d &quot;, root.Val)
        InOrder(root.Right)
    }
}

func PostOrder(root *TreeNode) {
    if root != nil {
        PostOrder(root.Left)
        PostOrder(root.Right)
        fmt.Printf(&quot;%d &quot;, root.Val)
    }
}


package main

import (
    &quot;fmt&quot;
    &quot;go_code/data_structure/tree&quot;
)

func main() {

    node7 := &amp;tree.TreeNode{
        ID:    7,
        Val:   7,
        Left:  nil,
        Right: nil,
    }
    node6 := &amp;tree.TreeNode{
        ID:    6,
        Val:   6,
        Left:  nil,
        Right: nil,
    }
    node5 := &amp;tree.TreeNode{
        ID:    5,
        Val:   5,
        Left:  nil,
        Right: nil,
    }
    node4 := &amp;tree.TreeNode{
        ID:    4,
        Val:   4,
        Left:  nil,
        Right: nil,
    }
    node3 := &amp;tree.TreeNode{
        ID:    3,
        Val:   3,
        Left:  node6,
        Right: node7,
    }
    node2 := &amp;tree.TreeNode{
        ID:    2,
        Val:   2,
        Left:  node4,
        Right: node5,
    }

    node1 := &amp;tree.TreeNode{
        ID:    1,
        Val:   1,
        Left:  node2,
        Right: node3,
    }

    fmt.Println(&quot;先序遍历&quot;)
    tree.PreOrder(node1)
    fmt.Println()
    fmt.Println(&quot;中序遍历&quot;)
    tree.InOrder(node1)
    fmt.Println()
    fmt.Println(&quot;后序遍历&quot;)
    tree.PostOrder(node1)
}
</code></pre>

<ul>
<li><p>经典应用</p>

<pre><code>路径之和2（前序遍历求和对比）
最近公共祖先（如果pq同时位于左边，或者右边，则第一个找到的就是公共祖先，如果分别位于左右子数，那么他们的根就是公共祖先，对于子数依然成立）

    最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

侧面观察二叉树（层序遍历求第一个或者最后一个节点）
</code></pre></li>

<li><p>完全二叉树和满二叉树</p>

<p>满二叉树&mdash;深度为K则结点个数2^k-1
完全二叉树&mdash;重根开始编号，层序可以按顺序的获取所有的值，完全二叉树可以说是为了堆而存在的</p>

<p>其实计算机中只有两种存储方式，一个顺序一个是链式，所以树是可以使用数组来存储的，当然这样会浪费很多的空间，所以一般都是使用链式来存储的，但是如果是完全二叉树，使用数组存储就比较好来，不浪费。</p></li>

<li><p>堆</p>

<p>最大堆：根结点的键值是所有堆结点键值中最大者，且每个结点的值都比其孩子的值大。</p>

<p>最小堆：根结点的键值是所有堆结点键值中最小者，且每个结点的值都比其孩子的值小。</p>

<p>构建最大堆，最小堆，也就是堆的初始化，首先重倒数第二层进行遍历，它的子节点2k+1，2k+2如果比根节点大，就进行交换，当然交换后如果子节点由树还是需要进行对比交换，直到满足堆的特性，由底想上，最后最大的就在顶上，</p></li>

<li><p>经典应用</p>

<pre><code>寻找最大k个数（构建k大小的堆）
寻找中位数（构建一个最大堆一个最小堆）
</code></pre></li>
</ul>

<p>1、线索二叉树</p>

<p>就是在二叉树中有很多的节点是空的，我们是不是能把他利用起来，作为指向前驱后继，这样能完善树的不知道前驱的缺陷，很大程度的提高了查询的效率。但是这种只有在中序的情况才能进行线索化，主要是因为左根右的结构可以允许在相隔的节点上有空间进行操作。</p>

<p>结点结构中增加两个标志域LTag和RTag。LTag=0时，lchild域指示结点的左孩子，LTag=1时，lchild域指示结点的前驱；RTag=0时，rchild域指示结点的右孩子，RTag=1时，rchild域指示结点的后继。</p>

<p>这样定义的好处是既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。便于查找。</p>

<ul>
<li><p>代码</p>

<pre><code> //二叉树的二叉线索存储表示
 typedef BiThrNode struct{
    TElemType       data,
    lchild,rchild   BiThrNode, /* 左右孩子指针 */
    LTag,RTag       int; /* 左右标志 */定义
 }

//这个不是初始化，而是对树进行中序遍历线索化
</code></pre></li>

<li><p>经典应用</p></li>
</ul>

<p>2、哈夫曼树（最优二叉树）</p>

<p>主要用于压缩，在每个连接之间加一个权重，可以减少遍历的次数。从而提高查询的效率。</p>

<p>树的带权路径长度：所有叶子结点的带权路径长度之和，记为WPL。这个小，反应的是查询的效率高</p>

<ul>
<li><p>代码</p>

<pre><code>//节点
type BNode struct {
    key string
    value float64
    ltree, rtree *BNode
}

//这种树不存在初始化，是对已经有的节点进行构造哈夫曼树，构造规则，先获取最小的两个点作为子节点，对应的和就是父节点，然后再取出最小的一个点和这个和进行比较，小就作为左节点和这个和最和一个新的树，反之则作为右节点，这样构造的就是一个哈夫曼树，也是最优二叉树。
我们用实例来直接看
</code></pre>

<ul>
<li><p>实例</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;errors&quot;
    &quot;os&quot;
)

type BNode struct {
    key string
    value float64
    ltree, rtree *BNode
}

func getMinNodePos(treeList []*BNode) (pos int, err error) {
    if len(treeList) == 0 {
        return -1, errors.New(&quot;treeList length is 0&quot;)
    }
    pos = -1
    for i, _ := range treeList {
        if pos &lt; 0 {
            pos = i
            continue
        }
        if treeList[pos].value &gt; treeList[i].value {
            pos = i
        }
    }

    return pos, nil
}

func get2MinNodes(treeList []*BNode) (node1, node2 *BNode, newlist []*BNode) {
    if len(treeList) &lt; 2 {
    }
    pos, err := getMinNodePos(treeList)
    if nil != err {
        return nil, nil, treeList
    }
    node1 = treeList[pos]
    newlist = append(treeList[:pos], treeList[pos + 1 :]...)

    pos, err = getMinNodePos(newlist)
    if nil != err {
        return nil, nil, treeList
    }
    node2 = newlist[pos]
    newlist = append(newlist[:pos], newlist[pos + 1 :]...)

    return node1, node2, newlist
}

func makeHuffmanTree(treeList []*BNode) (tree *BNode, err error) {
    if len(treeList) &lt; 1 {
        return nil, errors.New(&quot;Error : treeList length is 0&quot;)
    }
    if len(treeList) == 1 {
        return treeList[0], nil
    }
    lnode, rnode, newlist := get2MinNodes(treeList)

    newNode := new(BNode)
    newNode.ltree = lnode
    newNode.rtree = rnode

    newNode.value = newNode.ltree.value + newNode.rtree.value
    newNode.key = newNode.ltree.key + newNode.rtree.key;

    newlist = append(newlist, newNode)

    return makeHuffmanTree(newlist)
}

func main() {
    keyList   := []byte    {'A',  'B', 'C',  'D',  'E', 'F',  'G',  'H'}
    valueList := []float64 {0.12, 0.4, 0.29, 0.90, 0.1, 1.1, 1.23, 0.01}

    treeList := []*BNode   {}
    for i, x := range keyList {
        n := BNode{key:string(x), value:valueList[i]}
        treeList = append(treeList, &amp;n)
    }

    tree, err := makeHuffmanTree(treeList)
    if nil != err {
        fmt.Println(err.Error())
    }

    //TODO you can make it yourself
    //showTree(tree)
}
</code></pre></li>
</ul></li>

<li><p>经典应用</p></li>
</ul>

<p><strong>哈夫曼编码</strong></p>

<p>哈夫曼编码是可变字长编码(VLC)的一种，Huffman于1952年提出的编码方法， 该方法完全依据字符出现概率来构造异字头的平均长度最短的码字， 有时称之为最佳编码，一般就叫做Huffman编码</p>

<p>3.排序二叉树（二叉排序树，二叉搜索树，二叉查找树）</p>

<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>

<p>和正常的树一样，就是在构建的时候需要满足这个规则</p>

<ul>
<li>实例</li>
</ul>

<p>排序后进行查找就比较简单了</p>

<pre><code>package main

import &quot;fmt&quot;

type BST struct {
    left *BST
    value int
    right *BST
}

//查找元素
func (t *BST) Search(value int) bool {
    if t == nil {
        return false
    }
    compare := value - t.value
    if compare &lt; 0 {
        return t.left.Search(value)
    }else if compare &gt; 0 {
        return t.right.Search(value)
    }else {
        return true
    }
}

//添加元素
func (t *BST) Insert(value int) *BST {
    if t ==nil {
        newNode := BST{nil,value,nil}
        return &amp;newNode
    }
    if value &lt; t.value {
        t.left = t.left.Insert(value)
    }else{
        t.right = t.right.Insert(value)
    }
    return t
}
/*删除元素
*1、如果被删除结点只有一个子结点，就直接将A的子结点连至A的父结点上，并将A删除
*2、如果被删除结点有两个子结点，将该结点右子数内的最小结点取代A。
*/
func (t *BST) Delete(value int) *BST {
    if t ==nil {
        return t
    }
    compare := value - t.value
    if compare &lt; 0 {
        t.left = t.left.Delete(value)
    }else if compare &gt; 0{
        t.right = t.right.Delete(value)
    }else { //找到结点,删除结点
        if t.left != nil &amp;&amp; t.right != nil {
            t.value = t.right.getMin()
            t.right = t.right.Delete(t.value)
        } else if t.left !=nil {
            t = t.left
        }else {
            t = t.right
        }
    }
    return t
}

//按顺序获得树中元素
func (t *BST) getAll() []int {
    values := []int{}
    return addValues(values,t)
}

//将一个节点加入切片中
func addValues(values []int,t *BST) []int {
    if t != nil {
        values = addValues(values,t.left)
        values = append(values,t.value)
        values = addValues(values,t.right)
    }
    return values
}

//查找子树最小值
func (t *BST) getMin() int {
    if t == nil {
        return -1
    }
    if t.left == nil {
        return t.value
    } else {
        return t.left.getMin()
    }
}

//查找子树最大值
func (t *BST) getMax() int {
    if t == nil {
        return -1
    }
    if t.right == nil {
        return t.value
    } else {
        return t.right.getMax()
    }
}

//查找最小结点
func (t *BST) getMinNode() *BST {
    if t == nil {
        return nil
    }else {
        for t.left != nil {
            t = t.left
        }
    }
    return t
}

//查找最大结点
func (t *BST) getMaxNode() *BST {
    if t == nil {
        return nil
    }else {
        for t.right != nil {
            t = t.right
        }
    }
    return t
}


func main() {
    bsTree := BST{nil,22,nil}
    bsTree.Insert(22)
    bsTree.Insert(12)
    bsTree.Insert(122)
    bsTree.Insert(62)
    bsTree.Insert(72)
    bsTree.Insert(25)
    bsTree.Insert(32)
    bsTree.Insert(42)
    fmt.Println(bsTree.getAll())

    fmt.Println(bsTree.Search(22))
    fmt.Println(bsTree.Search(20))

    fmt.Println(bsTree.getMin())
    fmt.Println(bsTree.getMinNode().value)

    fmt.Println(bsTree.getMax())
    fmt.Println(bsTree.getMaxNode().value)

    bsTree.Delete(22)
    fmt.Println(bsTree.getAll())

}
</code></pre>

<ul>
<li>经典应用</li>
</ul>

<p>4.AVL树（二叉平衡树）</p>

<p>带有平衡条件的二叉查找树。
平衡条件：其每个节点的左子树和右子树的高度最多相差 1 的二叉查找树。（空树的高度为 -1）。
当插入时有可能会破坏平衡条件，我们通过旋转（rotation）来进行修正。</p>

<ul>
<li>实例</li>
</ul>

<p>这个我们通过实例来说明</p>

<pre><code>package main

import &quot;fmt&quot;

type AVL struct {
    value int      //值
    height int     //深度
    left *AVL      //左子树
    right *AVL     //右子树
}

//查找元素
func (t *AVL) Search(value int) bool {
    if t == nil {
        return false
    }
    compare := value - t.value
    if compare &lt; 0 {
        return t.left.Search(value)
    }else if compare &gt; 0 {
        return t.right.Search(value)
    }else {
        return true
    }
}



func (t *AVL) leftRotate() *AVL {  //左旋转
    headNode := t.right
    t.right = headNode.left
    headNode.left = t
    //更新结点高度
    t.height = max(t.left.getHeight(),t.right.getHeight()) + 1
    headNode.height = max(headNode.left.getHeight(),headNode.right.getHeight()) + 1
    return headNode
}

func (t *AVL) rightRotate() *AVL {  //右旋转
    headNode := t.left
    t.left = headNode.right
    headNode.right = t
    //更新结点高度
    t.height = max(t.left.getHeight(),t.right.getHeight()) +1
    headNode.height = max(headNode.left.getHeight(),headNode.right.getHeight()) + 1
    return headNode
}

func (t *AVL) rightThenLeftRotate() *AVL {  //右旋转,之后左旋转
    //以失衡点右结点先右旋转
    sonHeadNode := t.right.rightRotate()
    t.right = sonHeadNode
    //再以失衡点左旋转
    return t.leftRotate()
}

func (t *AVL) LeftThenRightRotate() *AVL {  //左旋转,之后右旋转
    //以失衡点左结点先左旋转
    sonHeadNode := t.left.leftRotate()
    t.left = sonHeadNode
    //再以失衡点左旋转
    return t.rightRotate()
}

func (t *AVL) adjust() *AVL {
    if t.right.getHeight() - t.left.getHeight() == 2 {
        if t.right.right.getHeight() &gt; t.right.left.getHeight() {
            t = t.leftRotate()
        }else {
            t = t.rightThenLeftRotate()
        }
    }else if t.left.getHeight() - t.right.getHeight() == 2 {
        if t.left.left.getHeight() &gt; t.left.right.getHeight() {
            t = t.rightRotate()
        } else {
            t = t.LeftThenRightRotate()
        }
    }
    return t
}

//添加元素
func (t *AVL) Insert(value int) *AVL {
    if t == nil {
        newNode := AVL{value,1,nil,nil}
        return &amp;newNode
    }
    if value &lt; t.value {
        t.left = t.left.Insert(value)
        t = t.adjust()
    }else if value &gt; t.value{
        t.right = t.right.Insert(value)
        t = t.adjust()
    }else {
        fmt.Println(&quot;the node exit&quot;)
    }
    t.height = max(t.left.getHeight(),t.right.getHeight()) + 1
    return t
}


/*删除元素
*1、如果被删除结点只有一个子结点，就直接将A的子结点连至A的父结点上，并将A删除
*2、如果被删除结点有两个子结点，将该结点右子数内的最小结点取代A。
*3、查看是否平衡,该调整调整
*/
func (t *AVL) Delete(value int) *AVL {
    if t ==nil {
        return t
    }
    compare := value - t.value
    if compare &lt; 0 {
        t.left = t.left.Delete(value)
    }else if compare &gt; 0{
        t.right = t.right.Delete(value)
    }else { //找到结点,删除结点（）
        if t.left != nil &amp;&amp; t.right != nil {
            t.value = t.right.getMin()
            t.right = t.right.Delete(t.value)
        } else if t.left !=nil {
            t = t.left
        }else {//只有一个右孩子或没孩子
            t = t.right
        }
    }
    if t != nil {
        t.height = max(t.left.getHeight(),t.right.getHeight()) + 1
        t = t.adjust()
    }
    return t
}

//按顺序获得树中元素
func (t *AVL) getAll() []int {
    values := []int{}
    return addValues(values,t)
}

//将一个节点加入切片中
func addValues(values []int,t *AVL) []int {
    if t != nil {
        values = addValues(values,t.left)
        values = append(values,t.value)
        fmt.Println(t.value,t.height)
        values = addValues(values,t.right)
    }
    return values
}

//查找子树最小值
func (t *AVL) getMin() int {
    if t == nil {
        return -1
    }
    if t.left == nil {
        return t.value
    } else {
        return t.left.getMin()
    }
}

//查找子树最大值
func (t *AVL) getMax() int {
    if t == nil {
        return -1
    }
    if t.right == nil {
        return t.value
    } else {
        return t.right.getMax()
    }
}

//查找最小结点
func (t *AVL) getMinNode() *AVL {
    if t == nil {
        return nil
    }else {
        for t.left != nil {
            t = t.left
        }
    }
    return t
}

//查找最大结点
func (t *AVL) getMaxNode() *AVL {
    if t == nil {
        return nil
    }else {
        for t.right != nil {
            t = t.right
        }
    }
    return t
}

//得到树高
func (t *AVL) getHeight() int {
    if t == nil {
        return 0
    }
    return t.height
}

func max(a int,b int) int{
    if a &gt; b {
        return a
    }else {
        return b
    }
}


func main() {
    bsTree := AVL{100,1,nil,nil}
    newTree := bsTree.Insert(60)
    newTree = bsTree.Insert(120)
    newTree = bsTree.Insert(110)
    newTree = bsTree.Insert(130)
    newTree = bsTree.Insert(105)
    fmt.Println(newTree.getAll())

    newTree.Delete(110)
    fmt.Println(newTree.getAll())

}
</code></pre>

<p>7.红黑树</p>

<p>红黑树是一种基于二叉查找树的数据结构，是一种自平衡的二叉搜索树，它包含了二叉搜索树的特性，同时具备以下性质：</p>

<p>1、所有节点的颜色不是红色就是黑色。
2、根节点是黑色。
3、每个叶子节点都是黑色的空节点(nil)。
4、每个红色节点的两个子节点都是黑色。(从每个叶子到根节点的所有路径上不能有两个连续的红色节点)
5、从任一节点到其叶子节点的所有路径上都包含相同数目的黑节点。</p>

<ul>
<li><p>代码</p>

<pre><code>const (
    // RED 红树设为true
    RED bool = true
    // BLACK 黑树设为false
    BLACK bool = false
)

// RBNode 红黑树
type RBNode struct {
    value               int64
    color               bool
    left, right, parent *RBNode
}

type RBTree struct {
    root *RBNode
}
</code></pre></li>
</ul>

<p>节点的插入：
【首先】将红黑树当作一颗二叉查找树，将节点插入；【然后】将节点着色为红色；【最后】通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。</p>

<p><strong>B树</strong></p>

<p>5.B树</p>

<p>B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。
一颗m阶的B树定义如下：
1、每个结点最多有m-1个关键字。
2、根结点最少可以只有1个关键字。
3、非根结点至少有Math.ceil(m/2)-1个关键字。
4、每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
5、所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</p>

<p>条件：
a、根节点至少有2个子节点
b、每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m
c、每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m
d、所有的叶子结点都位于同一层
e、每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划</p>

<p>6,B+树</p>

<p>条件：
a、有k个子结点的结点必然有k个关键字
b、非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中
c、树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录</p>

<p>典型应用场景：Mysql数据库的索引类型 - B+索引</p>

<p><strong>常规树和森林</strong></p>

<p>主要还是将常规树和森林转化为二叉树来进程操作。</p>

<h2 id="网状数据结构">网状数据结构</h2>

<p>1。图</p>

<p>图就是网状数据结构，有顶点和边组成，可以是有向图和无向图。</p>

<p>图的存储结构</p>

<p>邻接矩阵-也就是一个二维数组记录这顶点与顶点之间的连接数据，还有一个数组记录着顶点数据</p>

<p>邻接表，我认为就是一张哈希表，有数组和链表组成，数组记录着顶点，链表记录这连接的顶点</p>

<ul>
<li><p>代码</p>

<pre><code>type Node struct {
    value int
}

type Graph struct {
    nodes []*Node          // 节点集
    edges map[Node][]*Node // 邻接表表示的无向图
    lock  sync.RWMutex     // 保证线程安全
}
</code></pre></li>

<li><p>实例</p>

<pre><code>// 增加节点
func (g *Graph) AddNode(n *Node) {
    g.lock.Lock()
    defer g.lock.Unlock()
    g.nodes = append(g.nodes, n)
}

// 增加边
func (g *Graph) AddEdge(u, v *Node) {
    g.lock.Lock()
    defer g.lock.Unlock()
    // 首次建立图
    if g.edges == nil {
        g.edges = make(map[Node][]*Node)
    }
    g.edges[*u] = append(g.edges[*u], v) // 建立 u-&gt;v 的边
    g.edges[*v] = append(g.edges[*v], u) // 由于是无向图，同时存在 v-&gt;u 的边
}

// 输出图
func (g *Graph) String() {
    g.lock.RLock()
    defer g.lock.RUnlock()
    str := &quot;&quot;
    for _, iNode := range g.nodes {
        str += iNode.String() + &quot; -&gt; &quot;
        nexts := g.edges[*iNode]
        for _, next := range nexts {
            str += next.String() + &quot; &quot;
        }
        str += &quot;\n&quot;
    }
    fmt.Println(str)
}

// 输出节点
func (n *Node) String() string {
    return fmt.Sprintf(&quot;%v&quot;, n.value)
}
</code></pre></li>

<li><p>遍历</p></li>
</ul>

<p>图的遍历主要就是这两种遍历思想，深度优先搜索使用递归方式，需要栈结构辅助实现。广度优先搜索需要使用队列结构辅助实现。</p>

<p>图的存储结构-十字链表和邻接多重表</p>

<p>了解一下，前者对有向图进行了优化，后者对无向图进行了优化。</p>

<ul>
<li><p>经典应用</p>

<p>课程安排</p></li>
</ul>

<h1 id="附录">附录</h1>

<p>部分代码实现</p>

<p>1.用栈实现计算器</p>

<p>计算后缀表达式的代码实现</p>

<pre><code>func calculate(postfix string) int {
    stack := stack.ItemStack{}
    fixLen := len(postfix)
    for i := 0; i &lt; fixLen; i++ {
        nextChar := string(postfix[i])
        // 数字：直接压栈
        if unicode.IsDigit(rune(postfix[i])) {
            stack.Push(nextChar)
        } else {
            // 操作符：取出两个数字计算值，再将结果压栈
            num1, _ := strconv.Atoi(stack.Pop())
            num2, _ := strconv.Atoi(stack.Pop())
            switch nextChar {
            case &quot;+&quot;:
                stack.Push(strconv.Itoa(num1 + num2))
            case &quot;-&quot;:
                stack.Push(strconv.Itoa(num1 - num2))
            case &quot;*&quot;:
                stack.Push(strconv.Itoa(num1 * num2))
            case &quot;/&quot;:
                stack.Push(strconv.Itoa(num1 / num2))
            }
        }
    }
    result, _ := strconv.Atoi(stack.Top())
    return result
}
</code></pre>

<p>现在只需知道如何将中缀转为后缀，再利用栈计算即可。</p>

<p>中缀表达式转后缀表达式</p>

<ul>
<li><p>从左到右逐个字符遍历中缀表达式，输出的字符序列即是后缀表达式：</p>

<ul>
<li>遇到数字直接输出</li>
<li>遇到运算符则判断：

<ul>
<li>栈顶运算符优先级更低则入栈，更高或相等则直接输出</li>
<li>栈为空、栈顶是 ( 直接入栈</li>
<li>运算符是 ) 则将栈顶运算符全部弹出，直到遇见 )</li>
</ul></li>
<li>中缀表达式遍历完毕，运算符栈不为空则全部弹出，依次追加到输出</li>
</ul></li>
</ul>

<p>转换的代码实现</p>

<pre><code>// 中缀表达式转后缀表达式
func infix2ToPostfix(exp string) string {
    stack := stack.ItemStack{}
    postfix := &quot;&quot;
    expLen := len(exp)

    // 遍历整个表达式
    for i := 0; i &lt; expLen; i++ {
        char := string(exp[i])
        switch char {
        case &quot; &quot;:
            continue
        case &quot;(&quot;:
            // 左括号直接入栈
            stack.Push(&quot;(&quot;)
        case &quot;)&quot;:
            // 右括号则弹出元素直到遇到左括号
            for !stack.IsEmpty() {
                preChar := stack.Top()
                if preChar == &quot;(&quot; {
                    stack.Pop() // 弹出 &quot;(&quot;
                    break
                }
                postfix += preChar
                stack.Pop()
            }

            // 数字则直接输出
        case &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;:
            j := i
            digit := &quot;&quot;
            for ; j &lt; expLen &amp;&amp; unicode.IsDigit(rune(exp[j])); j++ {
                digit += string(exp[j])
            }
            postfix += digit
            i = j - 1 // i 向前跨越一个整数，由于执行了一步多余的 j++，需要减 1

        default:
            // 操作符：遇到高优先级的运算符，不断弹出，直到遇见更低优先级运算符
            for !stack.IsEmpty() {
                top := stack.Top()
                if top == &quot;(&quot; || isLower(top, char) {
                    break
                }
                postfix += top
                stack.Pop()
            }
            // 低优先级的运算符入栈
            stack.Push(char)
        }
    }

    // 栈不空则全部输出
    for !stack.IsEmpty() {
        postfix += stack.Pop()
    }

    return postfix
}

// 比较运算符栈栈顶 top 和新运算符 newTop 的优先级高低
func isLower(top string, newTop string) bool {
    // 注意 a + b + c 的后缀表达式是 ab + c +，不是 abc + +
    switch top {
    case &quot;+&quot;, &quot;-&quot;:
        if newTop == &quot;*&quot; || newTop == &quot;/&quot; {
            return true
        }
    case &quot;(&quot;:
        return true
    }
    return false
}
</code></pre>

<p>几乎所有的语言都会有数组和哈希表这两种集合元素，有的语言将数组实现成列表，有的语言将哈希表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。</p>

<ol>
<li>线性表</li>
</ol>

<p>数组</p>

<p>内存分为了堆内存和栈内存，当初始化数组时，堆内存分配相应大小的连续的内存块，并将第一个内存块的地址放入栈内存中存储。这样读取数据的时候取第0个就是首地址的内存中的数据，第1个就是首地址+1的内存块中数据。其余删除与写入操作与读取类似。</p>

<p>当定义一个数组a时，编译器根据指定的元素个数和元素的类型分配确定大小（元素类型大小×元素个数）的一块内存，并把这块内存的名字命名为 a，名字 a 一旦与这块内存匹配就不能再改变。其中，a[0]、a[1]、a[2]、a[3] 与 a[4] 都为 a 的元素，但并非元素的名字（数组的每一个元素都是没有名字的）。</p>

<p><img src="/media/datastruct/array.jpeg" alt="" /></p>

<p>在 32 位系统中，由于 int 类型的数据占 4 字节单元，因此该数组 a 在内存中共占据连续的 4×5=20 字节单元，依次保存 a[0]、a[1]、a[2]、a[3] 与 a[4] 共 5 个元素。如果这里假设元素 a[0] 的地址是 10000，则元素 a[1] 的地址是 10000+1×4=10004; 元素 a[2] 的地址是 10000+2×4=10008; 元素 a[3] 的地址是 10000+3×4=10012; 元素 a[4] 的地址是 10000+4×4=10016。</p>

<p>由此可见，数组的存储具有如下特点：</p>

<pre><code>索引从 0 开始。
数组在内存中占据连续的字节单元。
数组占据的字节单元数等于数组元素个数乘以该数组所属数据类型的数据占据的字节单元数（元素个数乘以元素类型大小）。
数组元素按顺序连续存放。
</code></pre>

<p>顺序表</p>

<p>链表</p>

<p>静态链表</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;
)
//静态链表节点
type Node struct{
    data string
    cursor int
}

const maxSize int=10
//初始化链表
func initList(size int)([]Node){
    if size&lt;3 {
        log.Fatal(&quot;size参数错误&quot;)
        return nil
    }
    list:=make([]Node,size)
    for i:=0;i&lt;size-2;i++ {
        list[i].cursor=i+1
    }
    list[size-2].cursor=0
    list[size-1].cursor=0
    return list
}
//显示链表结构
func traverse(list []Node){
    for _,v:=range list {
        fmt.Printf(&quot;%5d&quot;,v.cursor)
    }
    fmt.Println()
    for _,v:=range list {
        fmt.Printf(&quot;%5s&quot;,v.data)
    }
    fmt.Println()
    for i,_:=range list {
        fmt.Printf(&quot;%5d&quot;,i)
    }
    fmt.Println()
}
//回收链表到备用链表
func destroyList(list []Node){
    if list[maxSize-1].cursor==0 {
        return
    }
    j:=list[maxSize-1].cursor
    list[maxSize-1].cursor=0
    i:=list[0].cursor
    list[0].cursor=j
    if j&gt;0 {
        j=list[j].cursor
    }
    list[j].cursor=i
}
//判断是否为空
func isempty(list []Node) bool {
    if list[maxSize-1].cursor==0 {
        return true
    }
    return false
}
//链表长度
func length(list []Node) int {
    i,j:=0,list[maxSize-1].cursor
    for j&gt;0 {
        j=list[j].cursor
        i++
    }
    return i
}
//获取指定位置的节点数据
func getElement(list []Node,index int)string {
    if index&lt;1 || index&gt;maxSize-2 {
        log.Fatal(&quot;index out of range&quot;)
        return &quot;&quot;
    }
    i:=list[maxSize-1].cursor
    j:=1
    for i&gt;0 &amp;&amp; j&lt;index {
        j++
        i=list[i].cursor
    }
    if j!=index {
        return &quot;&quot;
    }
    return list[i].data
}
//获取数据元素的位置
func locateElem(list []Node,data string) int {
    locate:=0
    i:=list[maxSize-1].cursor
    for i&gt;0 {
        locate++
        if list[i].data==data {
            return locate
        }
        i=list[i].cursor
    }
    return locate
}
//获取元素的前驱节点
func priorElem(list []Node,data string) string {
    if isempty(list){
        return &quot;&quot;
    }
    i:=list[maxSize-1].cursor
    var j int
    for i&gt;0 {
        j=list[i].cursor
        if list[j].data==data{
            return list[i].data
        }
        i=j
    }
    return &quot;&quot;
}
//获取元素的后驱节点
func nextElem(list []Node,data string) string {
    if isempty(list) {
        return &quot;&quot;
    }
    i:=list[maxSize-1].cursor
    var j int
    for i&gt;0 {
        j=list[i].cursor
        if list[i].data==data {
            return list[j].data
        }
        i=j
    }
    return &quot;&quot;
}
//分配节点
func malloc(list []Node) int {
    i:=list[0].cursor
    if i==0 {
        os.Exit(0)
    }
    list[0].cursor=list[i].cursor
    return i
}
//回收节点
func free(list []Node,index int){
    list[index].cursor=list[0].cursor
    list[0].cursor=index
}
//插入节点
func insertLIst(list []Node,index int,data string) {
    if index&lt;1 || index&gt;length(list) {
        os.Exit(0)
    }
    i:=list[maxSize-1].cursor
    j:=1
    for i&gt;0 &amp;&amp; j&lt;index-1 {
                j++
        i=list[i].cursor
    }
    tmp:=list[i].cursor
    cur:=malloc(list)
    list[cur].data=data
    list[cur].cursor=tmp
    list[i].cursor=cur
}
//删除节点
func deleteList(list []Node,index int)string{
    if index&lt;1 || index&gt;length(list) {
        return &quot;删除参数错误&quot;
    }
    i:=list[maxSize-1].cursor
    j:=1
    for i&gt;0 &amp;&amp; j&lt;index-1 {
        j++
        i=list[i].cursor
    }
    tmp:=list[i].cursor
    list[i].cursor=list[tmp].cursor
    val:=list[tmp].data
    free(list,tmp)
    return val
}
//遍历链表
func traveList(list []Node){
    if list[maxSize-1].cursor==0 {
        return
    }
    i:=list[maxSize-1].cursor
    j:=1
    for i&gt;0 {
        fmt.Printf(&quot;第%d个节点为：%s\n&quot;,j,list[i].data)
        i=list[i].cursor
        j++
    }
}

func main() {
    var list []Node
    list=initList(maxSize)
    list[1].data=&quot;A&quot;
    list[9].cursor=1
    list[2].data=&quot;C&quot;
    list[2].cursor=0
    list[0].cursor=3
    //traverse(list)
        insertLIst(list,2,&quot;B&quot;)
    traveList(list)
    reval:=deleteList(list,1)
    fmt.Println(&quot;删除的节点为：&quot;,reval)
    traveList(list)

}
</code></pre>

<p>循环链表</p>

<p>约瑟夫环</p>

<p>约瑟夫环（Josephus）问题是由古罗马的史学家约瑟夫（Josephus）提出的，他参加并记录了公元66—70年犹太人反抗罗马的起义。约瑟夫作为一个将军，设法守住了裘达伯特城达47天之久，在城市沦陷之后，他和40名死硬的将士在附近的一个洞穴中避难。在那里，这些叛乱者表决说“要投降毋宁死”。于是，约瑟夫建议每个人轮流杀死他旁边的人，而这个顺序是由抽签决定的。约瑟夫有预谋地抓到了最后一签，并且，作为洞穴中的两个幸存者之一，他说服了他原先的牺牲品一起投降了罗马。
约瑟夫环问题的具体描述是：设有编号为1，2，……，n的n(n&gt;0)个人围成一个圈，从第1个人开始报数，报到m时停止报数，报m的人出圈，再从他的下一个人起重新报数，报到m时停止报数，报m的出圈，……，如此下去，直到所有人全部出圈为止。当任意给定n和m后，设计算法求n个人出圈的次序。</p>

<p>解法一：用循环链表实现
#include<stdio.h>
#include<stdlib.h>
typedef struct node
{
    int data;
    struct node *next;
}Node;
/**
 * @功能 约瑟夫环
 * @参数 total:总人数
 * @参数 from:第一个报数的人
 * @参数 count:出列者喊到的数
 * @作者 zheng
 * @更新 2013-12-5
 */
void JOSEPHUS(int total, int from, int count)
{
    Node *p1, *head;
    head = NULL;
    int i;
    // 建立循环链表
    for(i = 1; i &lt;= total; i++)
    {
        Node *newNode = (Node *)malloc(sizeof(Node));
        newNode-&gt;data = i;
        if(NULL == head)
        {
            head = newNode;
        }
        else
        {
            p1-&gt;next = newNode;
        }
        p1 = newNode;
    }
    p1-&gt;next = head;      // 尾节点连到头结点，使整个链表循环起来
    p1 = head;            // 使pcur指向头节点
    // 把当前指针pcur移动到第一个报数的人
    // 若从第一个人开始报数，这一段可要可不要
    for(i = 1; i &lt; from; i++)
    {
        p1 = p1-&gt;next;
    }
    Node *p2 = NULL;
    // 循环地删除队列中报到count的结点
    while(p1-&gt;next != p1)
    {
        for(i = 1; i &lt; count; i++)
        {
            p2 = p1;
            p1 = p1-&gt;next;
        }
        p2-&gt;next = p1-&gt;next;
        printf(&ldquo;Delete number: %d\n&rdquo;, p1-&gt;data);   // 打印所要删除结点的数据
        free(p1);                      // 删除结点，从内存释放该结点占用的内存空间
        p1 = p2-&gt;next;      // p1指针指向新的结点p2-&gt;next，即原先的p1-&gt;next
    }
    printf(&ldquo;The last one is No.%d\n&rdquo;, p1-&gt;data);
}
int main()
{
    int total, from, count;
    scanf(&ldquo;%d%d%d&rdquo;, &amp;total, &amp;from, &amp;count);
    JOSEPHUS(total, from, count);
    return 0;
}
运行结果：</p>

<p>13 1 3
Delete number: 3
Delete number: 6
Delete number: 9
Delete number: 12
Delete number: 2
Delete number: 7
Delete number: 11
Delete number: 4
Delete number: 10
Delete number: 5
Delete number: 1
Delete number: 8
The last one is No.13
解法二：数组实现
思路：设数组a有n个变量，每个变量中初始放的标识数是1，表示这个人在队列里，若出列标识数就变为0。
现在计数器从1开始向后数，每报一个数即把累加器加1。这里累加器表示报数人数。累列到m时，报数的人要出列，标识数要变为0。下一个人从1开始重新报数。
报到最后一个人后，从第一个人开始继续报数。</p>

<p>#include<stdio.h>
#include<memory.h>
int main()
{
    int n, m;
    scanf(&ldquo;%d%d&rdquo;, &amp;n, &amp;m);
    int flag[n + 1];    // 在队列里标记为1，出列标记为0
    memset(flag, 0, sizeof(flag));  //把数组每个元素置0，在memory.h中声明
    int i = 0;
    int outCnt = 0;     //  记录出列的人数
    int numoff = 0;     //  报数
    // 默认都标记为1
    for(i = 1; i &lt;= n; i++)
    {
        flag[i] = 1;
    }
    while(outCnt &lt; n - 1)
    {
        for(i = 1; i &lt;= n; i++ )
        {
            if (1 == flag[i])
            {
                numoff++;
                if(numoff == m)
                {
                    printf(&ldquo;Dequeue：%d\n&rdquo;, i);
                    outCnt++;
                    flag[i] = 0;    // 已出列的人标记为0
                    numoff = 0;     // 从头开始报数
                }
            }
        }
    }
    for(i = 1; i &lt;= n; i++)
    {
        if(1 == flag[i])
        {
            printf(&ldquo;The last one is: %d\n&rdquo;, i);
        }
    }
    return 0;
}
运行结果：</p>

<p>13 3
Dequeue：3
Dequeue：6
Dequeue：9
Dequeue：12
Dequeue：2
Dequeue：7
Dequeue：11
Dequeue：4
Dequeue：10
Dequeue：5
Dequeue：1
Dequeue：8
The last one is: 13
解法三：用数学公式求解
上面编写的解约瑟夫环的程序模拟了整个报数的过程，因为N和M都比较小，程序运行时间还可以接受，很快就可以出计算结果。可是，当参与的总人数N及出列值M非常大时，其运算速度就慢下来。例如，当N的值有上百万，M的值为几万时，到最后虽然只剩2个人，也需要循环几万次（由M的数量决定）才能确定2个人中下一个出列的序号。显然，在这个程序的执行过程中，很多步骤都是进行重复无用的循环。
那么，能不能设计出更有效率的程序呢？
办法当然有。其中，在约瑟夫环中，只是需要求出最后的一个出列者最初的序号，而不必要去模拟整个报数的过程。因此，为了追求效率，可以考虑从数学角度进行推算，找出规律然后再编写程序即可。</p>

<p>为了讨论方便，先根据原意将问题用数学语言进行描述。
问题：将编号为0～（N–1）这N个人进行圆形排列，按顺时针从0开始报数，报到M–1的人退出圆形队列，剩下的人继续从0开始报数，不断重复。求最后出列者最初在圆形队列中的编号。</p>

<p>下面首先列出0~(N-1)这N个人的原始编号如下：
0  1  2  3  …  N-3  N-2  N-1</p>

<p>根据前面曾经推导的过程可知，第一个出列人的编号一定是(M–1)%N。例如，在13个人中，若报到3的人出列，则第一个出列人的编号一定是(3–1)%13=2，注意这里的编号是从0开始的，因此编号2实际对应以1为起点中的编号3。根据前面的描述，m的前一个元素(M–1)已经出列，则出列1人后的列表如下：
0  1  2  3  …  M-3  M-2  ○  M  M+1  M+2  …  N-3  N-2  N-1
注意，上面的圆圈表示被删除的数。</p>

<p>根据规则，当有人出列之后，下一个位置的人又从0开始报数，则以上列表可调整为以下形式（即以M位置开始，N–1之后再接上0、1、2……，形成环状）：
M  M+1  M+2  …  N-2  N-1  0  1  …  M-3  M-2</p>

<p>按上面排列的顺序从0开始重新编号，可得到下面的对应关系：
M    M+1 M+2 …   N-2 N-1 0   1   …   M-3 M-2
0    1   2   …   N-(M+2) N-(M+1) N-M N-(M-1) …   N-3 N-2
这里，假设上一行的数为x，下一行的数为y，则对应关系为:</p>

<p>y = (x - M + N) % N           公式【1】
或者</p>

<p>x = (y + M) % N                公式【2】
通过上表的转换，将出列1人后的数据重新组织成了0～（N–2）共N–1个人的列表，继续求N–1个参与人员，按报数到M–1即出列，求解最后一个出列者最初在圆形队列中的编号。</p>

<p>看出什么规律没有？通过一次处理，将问题的规模缩小了。即对于N个人报数的问题，可以分解为先求解（N–1）个人报数的子问题；而对于（N–1）个人报数的子问题，又可分解为先求[(N-1)-1]个人报数的子问题，……。</p>

<p>问题中的规模最小时是什么情况？就是只有1个人时（N=1），报数到（M–1）的人出列，这时最后出列的是谁？当然只有编号为0这个人。因此，可设有以下函数：</p>

<p>F(1) = 0
那么，当N=2，报数到（M–1）的人出列，最后出列的人是谁？应该是只有一个人报数时得到的最后出列的序号加上M，因为报到M-1的人已出列，只有2个人，则另一个出列的就是最后出列者，利用公式【2】，可表示为以下形式：</p>

<p>F(2) = [F(1) + M] % N = [F(1) + M] % 2
比如，N=2, M=3时，有F(2) = [F(1) + M]%N = (0 + 3)%2 = 1</p>

<p>根据上面的推导过程，可以很容易推导出，当N=3时的公式：</p>

<p>F(3) = [F(2) + M] % N = [F(2) + M] % 3
于是，咱们可以得到递推公式：</p>

<p>F(1) = 0
F(N) = [F(N - 1) + M] % N      (N&gt;1)
有了此递推公式，可使用递归方法来设计程序：</p>

<p>#include <iostream>
using namespace std;
int josephus(int n, int m)
{
    if(1 == n)
    {
        return 0;
    }
    return (josephus(n - 1, m) + m) % n;
}
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    cout &lt;&lt; &ldquo;最后出列的人的编号为（从0开始编号）：&rdquo; &lt;&lt; josephus(n, m) &lt;&lt; endl;
    return 0;
}
运行结果：</p>

<p>13 3
最后出列的人的编号为（从0开始编号）：12
使用递归函数会占用计算机较多的内存，当递归层次太深时可能导致程序不能执行，比如64层的汉诺塔需要计算很长的时间。
因此，这里可以将程序直接编写为以下的递推形式：</p>

<p>#include <iostream>
using namespace std;
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    int out = 0;
    for(int i = 2; i &lt;= n; i++)
    {
        out = (out + m) % i;
    }
    cout &lt;&lt; &ldquo;最后出列的人的编号为（从0开始编号）：&rdquo; &lt;&lt; out &lt;&lt; endl;
    return 0;
}</p>

<ol>
<li>hash</li>
</ol>

<p>哈希表是一种数据结构，但是它并没有准确的结构类型，我觉得可以说是一种概念，类似于数组，只不过它的索引是key，是要单独存储的，然后根据key通过hash函数可以直接访问存储结构地址。但是会发送索引相同的情况，这个时候解决这种冲突的方法决定了最终的数据结构。</p>

<ul>
<li>拉链法</li>
</ul>

<p>拉链是指将数组指向一个链表，链表有对应的key-value且属于同一索引组成，然后再根据key匹配到对应的值。通过一个哈希函数将key转换为数组下标，真正的key-value是存储在该数组对应的链表里。</p>

<p>这也就是我们常说的hashmap，使用了数组和链表的结合，结构如下</p>

<p><img src="/media/datastruct/hashtable.png" alt="" /></p>

<p>代码结构</p>

<pre><code>//链表结构里数据的数据类型 键值对
type KV struct {
    Key string
    Value string
}


//链表结构
type LinkNode struct {
    //节点数据
    Data KV
    //下一个节点
    NextNode *LinkNode
}

type HashMap struct {
    //HashMap木桶
    Buckets [BucketCount]*LinkNode
}
</code></pre>

<ul>
<li>开放寻址法</li>
</ul>

<p>线性探测：将key-value存放在数组中，发现没有数据，就在这个地址存储，发现有数据，则把同一索引的顺延往下存放。</p>

<p>这个单纯的使用数组进行实现。</p>

<p>代码结构</p>

<pre><code>//链表结构里数据的数据类型 键值对
type KV struct {
    Key string
    Value string
}


type Hasharray struct {
    Buckets []KV
}
</code></pre>

<p>哈希函数：time33</p>

<p>数据较少的时候可以用直接定址，用一个线性函数完成映射，空间复杂度高一点
一般用除余法，选择一个较大的素数。一般最好是接近或者等于哈希表的长度。
数字选择法，在key过大的时候。</p>

<ol>
<li>树：树是一种递归定义的数据结构</li>
</ol>

<p>树是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。</p>

<p>①每个节点有零个或多个子节点；
②没有父节点的节点称为根节点；
③每一个非根节点有且只有一个父节点；
④除了根节点外，每个子节点可以分为多个不相交的子树；</p>

<p>基本概念：
结点的度（Degree）：一个结点拥有的子树数目称为该结点的度。
树的度：一棵树中最大的结点度数。
结点的层次（Level）：从根结点开始定义根为第一层，它的孩子为第二层，依此类推。
深度（高度）（Depth）：树中结点最大层次的值。</p>

<p>二叉树：
满二叉树&mdash;深度为K则结点个数2^k-1
完全二叉树&mdash;重根开始编号，按顺序的</p>

<p>存储：虽然是数的形式，但是在内存中还是两种存储结构
顺序存储：将数据自上向下，自左向右依次存储在一个连续的内存中；
链表存储：一般用这个存储方式
链表经典结构体
typedef struct Node
{
    int data；
    struct Node *left，*right;
}Node；</p>

<p>遍历：
先序：根左右
中序：左根右
后序：左右根</p>

<p>二叉排序树/二叉查找树&mdash;左小右大（BST）&mdash;右边的总是大于左边的</p>

<p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
（3）左、右子树也分别为二叉排序树</p>

<p>&mdash;-一个无序序列可以通过构造一棵二叉排序树后利用中序遍历变成一个有序序列</p>

<p>前继节点：某个节点的前继节点，是指比该节点小的所有节点中的最大的一个节点。
后继节点：某个节点的后继节点，是指比该节点大的所有节点中的最小的一个节点。</p>

<p>优化：
1、平衡二叉树/AVL树(BBST)&mdash;&mdash;-在二叉排序树的基础上左右子树的深度之差的绝对值不超过1，大大降低了复杂度（这个方案很好的解决了二叉查找树退化成链表（O（n））的问题&ndash;这个就是二叉查找树的问题），但是在旋转时比较消耗性能，然后可以考虑更高效的红黑树&mdash;O（lgn）</p>

<p>typedef struct Balanced_Binary_Tree<br />
 {<br />
     Elemtype e;<br />
     int bf;  //平衡因子
     struct Balanced_Binary_Tree *child[2];<br />
 }*AVL;</p>

<p>2、红黑树（R-B tree）&mdash;&ndash;自平衡二叉树，在平衡二叉树的基础上每个节点又增加了一个颜色的属性，节点的颜色只能是红色或黑色</p>

<p>（1）根节点只能是黑色；
（2）红黑树中所有的叶子节点后面再接上左右两个空节点，这样可以保持算法的一致性，而且所有的空节点都是黑色；
（3）其他的节点要么是红色，要么是黑色，红色节点的父节点和左右孩子节点都是黑色，及黑红相间；
（4）在任何一棵子树中，从根节点向下走到空节点的路径上所经过的黑节点的数目相同，从而保证了是一个平衡二叉树。</p>

<p>3、线索二叉树（Threaded Binary Tree）&mdash;-在没用的的指针空间加上索引吧
4、Huffman树
5、B-树
6、B+树
7、字典树是一种以树形结构保存大量字符串。以便于字符串的统计和查找，经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。
（1）根节点为空；
（2）除根节点外，每个节点包含一个字符；
（3）从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
（4）每个字符串在建立字典树的过程中都要加上一个区分的结束符，避免某个短字符串正好是某个长字符串的前缀而淹没。</p>

<p>实例</p>

<p>本篇文章使用golang来实现树的遍历</p>

<p>树的定义
package tree</p>

<p>type Node struct {
    Val int
    Left *Node
    Right *Node
}
深度优先遍历
深度优先遍历需要优先使用栈</p>

<p>栈的定义
type Stack struct {
    list *list.List
}</p>

<p>func NewStack() *Stack {
    list := list.New()
    return &amp;Stack{list}
}</p>

<p>func (stack *Stack) Push(value interface{}) {
    stack.list.PushBack(value)
}</p>

<p>func (stack *Stack) Pop() interface{} {
    if e := stack.list.Back(); e!= nil {
        stack.list.Remove(e)
        return e.Value
    }</p>

<pre><code>return nil
</code></pre>

<p>}</p>

<p>func (stack *Stack) Len() int {
    return stack.list.Len()
}</p>

<p>func (stack *Stack) Empty() bool {
    return stack.Len() == 0
}
前序遍历
为Stack结构体添加前序遍历的方法，前序遍历的思路是通过栈，将右子树先行压栈，然后左子树压栈</p>

<p>func (root *Node) PreTravesal() {
    if root == nil {
        return
    }</p>

<pre><code>s := stack.NewStack()
s.push(root)

for !s.Empty() {
    cur := s.Pop().(*Node)
    fmt.Println(cur.Val)

    if cur.Right != nil {
        s.Push(cur.Right)
    }
    if cur.Left != nil {
        s.Push(cur.Left)
    }
}
</code></pre>

<p>}
中序遍历
func (root *Node) InTravesal() {
    if root == nil {
        return
    }</p>

<pre><code>s := stack.NewStack()
cur := root
for {
    for cur != nil {
        s.Push(cur)
        cur = cur.Left
    }

    if s.Empty() {
        break
    }

    cur = s.Pop().(*Node)
    fmt.Println(cur.Val)
    cur = cur.right
}
</code></pre>

<p>}
后序遍历
func (root *Node) PostTravesal() {
    if root == nil {
        return
    }</p>

<pre><code>s := stack.NewStack()
out := stack.NewStack()
s.Push(root)

for !s.Empty() {
    cur := s.Pop().(*Node)
    out.Push(cur)

    if cur.Left != nil {
        s.Push(cur.Left)
    }

    if cur.Right != nil {
        s.Push(cur.Right)
    }
}

for !out.Empty() {
    cur := out.Pop().(*Node)
    fmt.Println(cur.Val)
}
</code></pre>

<p>}
广度优先遍历
广度优先遍历需要使用到队列</p>

<p>实现队列
使用切片实现队列</p>

<p>package queue</p>

<p>import (
    &ldquo;fmt&rdquo;
)</p>

<p>type Queue interface {
    Offer(e interface{})
    Poll() interface{}
    Clear() bool
    Size() int
    IsEmpty() bool
}</p>

<p>type LinkedList struct {
    elements []interface{}
}</p>

<p>func New() *LinkedList {
    return &amp;LinkedList{}
}</p>

<p>func (queue *LinkedList) Offer(e interface{}) {
    queue.elements = append(queue.elements, e)
}</p>

<p>func (queue *LinkedList) Poll() interface{} {
    if queue.IsEmpty() {
        fmt.Println(&ldquo;Poll error : queue is Empty&rdquo;)
        return nil
    }</p>

<pre><code>firstElement := queue.elements[0]
queue.elements = queue.elements[1:]
return firstElement
</code></pre>

<p>}</p>

<p>func (queue *LinkedList) Size() int {
    return len(queue.elements)
}</p>

<p>func (queue *LinkedList) IsEmpty() bool {
    return len(queue.elements) == 0
}</p>

<p>func (queue *LinkedList) Clear() bool  {
    if queue.IsEmpty() {
        fmt.Println(&ldquo;queue is Empty!&rdquo;)
        return false
    }
    for i := 0; i &lt; queue.Size(); i++ {
        queue.elements[i] = nil
    }
    queue.elements = nil
    return true
}</p>

<p>层序遍历
func (root *Node) LevelTravesal() {
    if root == nil {
        return
    }</p>

<pre><code>linkedList := queue.New()
linkedList.Offer(root)

for !linkedList.IsEmpty()  {
    cur := linkedList.Poll().(*Node)
    fmt.Println(cur.Val)

    if cur.Left != nil {
        linkedList.Offer(cur.Left)
    }

    if cur.Right != nil {
        linkedList.Offer(cur.Right)
    }
}
</code></pre>

<p>}</p>

<p>哈夫曼树</p>

<p>哈夫曼树与哈夫曼编码
术语：</p>

<p>i)路径和路径长度</p>

<p>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。 路径中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p>

<p>ii)结点的权及带权路径长度</p>

<p>若对树中的每个结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。 结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p>

<p>iii)树的带权路径长度</p>

<p>树的带权路径长度：所有叶子结点的带权路径长度之和，记为WPL。</p>

<p>先了解一下哈夫曼树，之后再构造一棵哈夫曼树，最后分析下哈夫曼树的原理。</p>

<p>1)哈夫曼树
哈夫曼树是这样定义的：给定n个带权值的节点，作为叶子节点，构造一颗二叉树，使树的带权路径长度达到最小，这时候的二叉树就是哈夫曼树，也叫最优二叉树。</p>

<p>哈夫曼树具有如下性质：</p>

<p>1)带权路径长度最短</p>

<p>2)权值较大的结点离根较近</p>

<p>2)构造哈夫曼树
构造哈夫曼树的步骤如下：</p>

<p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p>

<p>1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；</p>

<p>2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树， 且新树的根结点权值为其左、右子树根结点权值之和</p>

<p>3)从森林中删除选取的两棵树，并将新树加入森林</p>

<p>4)重复2)、3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树</p>

<p>根据如上规则，可以按部就班的写出代码，Go 语言的描述如下：</p>

<p>按 Ctrl+C 复制代码
package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;errors&rdquo;
    &ldquo;os&rdquo;
)</p>

<p>type BNode struct {
    key string
    value float64
    ltree, rtree *BNode
}</p>

<p>func getMinNodePos(treeList []*BNode) (pos int, err error) {
    if len(treeList) == 0 {
        return -1, errors.New(&ldquo;treeList length is 0&rdquo;)
    }
    pos = -1
    for i, _ := range treeList {
        if pos &lt; 0 {
            pos = i
            continue
        }
        if treeList[pos].value &gt; treeList[i].value {
            pos = i
        }
    }</p>

<pre><code>return pos, nil
</code></pre>

<p>}</p>

<p>func get2MinNodes(treeList []*BNode) (node1, node2 *BNode, newlist []*BNode) {
    if len(treeList) &lt; 2 {
    }
    pos, err := getMinNodePos(treeList)
    if nil != err {
        return nil, nil, treeList
    }
    node1 = treeList[pos]
    newlist = append(treeList[:pos], treeList[pos + 1 :]&hellip;)</p>

<pre><code>pos, err = getMinNodePos(newlist)
if nil != err {
    return nil, nil, treeList
}
node2 = newlist[pos]
newlist = append(newlist[:pos], newlist[pos + 1 :]...)

return node1, node2, newlist
</code></pre>

<p>}</p>

<p>func makeHuffmanTree(treeList []*BNode) (tree *BNode, err error) {
    if len(treeList) &lt; 1 {
        return nil, errors.New(&ldquo;Error : treeList length is 0&rdquo;)
    }
    if len(treeList) == 1 {
        return treeList[0], nil
    }
    lnode, rnode, newlist := get2MinNodes(treeList)</p>

<pre><code>newNode := new(BNode)
newNode.ltree = lnode
newNode.rtree = rnode

newNode.value = newNode.ltree.value + newNode.rtree.value
newNode.key = newNode.ltree.key + newNode.rtree.key;

newlist = append(newlist, newNode)

return makeHuffmanTree(newlist)
</code></pre>

<p>}</p>

<p>func main() {
    keyList   := []byte    {&lsquo;A&rsquo;,  &lsquo;B&rsquo;, &lsquo;C&rsquo;,  &rsquo;D&rsquo;,  &lsquo;E&rsquo;, &lsquo;F&rsquo;,  &lsquo;G&rsquo;,  &lsquo;H&rsquo;}
    valueList := []float64 {0.12, 0.4, 0.29, 0.90, 0.1, 1.1, 1.23, 0.01}</p>

<pre><code>treeList := []*BNode   {}
for i, x := range keyList {
    n := BNode{key:string(x), value:valueList[i]}
    treeList = append(treeList, &amp;n)
}

tree, err := makeHuffmanTree(treeList)
if nil != err {
    fmt.Println(err.Error())
}

//TODO you can make it yourself
//showTree(tree)
</code></pre>

<p>}
按 Ctrl+C 复制代码
得到的哈夫曼树如下：</p>

<p>其中的橙色结点都是数据中的权值结点。</p>

<p>计算一下这棵树的带权路径长度:</p>

<p>WPL=0.9x2 + 0.4x3 + 0.01x6 + 0.01x6 + 0.1x6 + 0.12x5 + 0.29x4 + 1.1x2 + 1.23x2 = 10.08</p>

<p>计算好了，但是这个带权路径是最小的吗？下面就看一下理论依据。</p>

<p>3)哈夫曼树的证明
设有t片叶子，权值分别为W1,W2,W3,&hellip;,Wt。 定义二叉树的权值为W(T)=∑Wi*L(vi),其中Vi是带权为Wi的叶子， L(vi)是叶子Vi的路径长度，接下来我们就求W(T)的最小值。</p>

<p>1）权值最小的叶子节点距离树根节点的距离不比其它叶子节点到树根结点的距离近</p>

<p>不失一般性，我们不妨设W1≤W2≤W3≤&hellip;≤Wt，并且W1和W2的叶子是兄弟。 先随意给出一棵符合条件的二叉树，再逐步把它调整到最佳。 设S是非叶子结点中路径最长的一点，假设S的儿子不是V1和V2,而是其他的Vx和Vy， 那么L(Vx)≥L(V1),L(Vx)≥L(V2)，L(Vy)≥L(V1), L(Vy)≥L(V1),注意到Vx,Vy≥V1,V2， 所以我们交换Vx和V1,Vy和V2,固定其他的量不变，则我们得到的二叉树的权值差为 [V1L(Vx)+ V2L(Vy)+ VxL(V1)+ VyL(V2)]- [V1L(V1)+ V2L(V2)+ VxL(Vx)+ VyL(Vy)]=(V1- Vx)(L(Vx)- L(V1))+(V2-Vy)(L(Vy)-L(V2))≤0，所以调整后权值减小了。 故S的儿子必定为v1和v2。</p>

<p>2)哈夫曼树是最优的</p>

<p>设Tx是带权W1,W2,W3,&hellip;,Wt的二叉树，在Tx中用一片叶子代替W1，W2这两片树叶和它们的双亲组成的子树，并对它赋权值为W1+W2，设Tx&rsquo;表示带权W1+W2，W3，W4，&hellip;,Wt的二叉树，则显然有W(Tx)=W(Tx&rsquo;)+W1+W2，所以若Tx是最优树，则Tx&rsquo;也是最优树，所以逐步往下调整可以把带有t个权的最优树简化到t-1个，再从t-1个简化到t-2个，&hellip;,最后降到带有2个权的最优树</p>

<p>4)哈夫曼编码
哈夫曼编码是可变字长编码(VLC)的一种，Huffman于1952年提出的编码方法， 该方法完全依据字符出现概率来构造异字头的平均长度最短的码字， 有时称之为最佳编码，一般就叫做Huffman编码。</p>

<p>1951年，哈夫曼和他在MIT信息论的同学需要选择是完成学期报告还是期末考试。 导师Robert M. Fano给他们的学期报告的题目是，寻找最有效的二进制编码。 由于无法证明哪个已有编码是最有效的，哈夫曼放弃对已有编码的研究， 转向新的探索，最终发现了基于有序频率二叉树编码的想法， 并很快证明了这个方法是最有效的。由于这个算法，学生终于青出于蓝， 超过了他那曾经和信息论创立者香农共同研究过类似编码的导师。 哈夫曼使用自底向上的方法构建二叉树， 避免了次优算法Shannon-Fano编码的最大弊端──自顶向下构建树。</p>

<p>1952年，David A. Huffman在麻省理工攻读博士时发表了《一种构建极小多余编码的方法》 （A Method for the Construction of Minimum-Redundancy Codes）一文， 它一般就叫做Huffman编码。</p>

<p>Huffman在1952年根据香农（Shannon）在1948年和范若（Fano） 在1949年阐述的这种编码思想提出了一种不定长编码的方法， 也称霍夫曼（Huffman）编码。霍夫曼编码的基本方法是先对图像数据扫描一遍， 计算出各种像素出现的概率，按概率的大小指定不同长度的唯一码字， 由此得到一张该图像的霍夫曼码表。编码后的图像数据记录的是每个像素的码字， 而码字与实际像素值的对应关系记录在码表中。</p>

<p>哈夫曼树就是为生成哈夫曼编码而构造的。哈夫曼编码的目的在于获得平均长度最短的码字， 所以下面我么以一个简单的例子来演示一下， 通过哈夫曼编码前后数据占用空间对比，来说明一下哈夫曼编码的应用。</p>

<p>4.1)编码
这里有一片英文文章《If I Were a Boy Again》，我们首先统计其中英文字符和标点符号出现的频率。(按照字符在字母表中的顺序排序)</p>

<p>字符  频数  比例
换行  36  2.236
空格  271 16.832
&ldquo;   4   0.248
,   21  1.304
.   15  0.932
;   2   0.124
F   1   0.062
I   23  1.429
L   1   0.062
N   1   0.062
T   1   0.062
W   1   0.062
a   98  6.087
b   23  1.429
c   31  1.925
d   38  2.360
e   143 8.882
f   36  2.236
g   25  1.553
h   43  2.671
i   80  4.969
k   11  0.683
l   69  4.286
m   31  1.925
n   89  5.528
o   109 6.770
p   20  1.242
q   1   0.062
r   80  4.969
s   67  4.161
t   105 6.522
u   45  2.795
v   16  0.994
w   34  2.112
y   39  2.422
接下来构造一棵哈夫曼树：</p>

<p>我们依然使用本文最开始使用的代码进行哈夫曼树的构造。 以每个字符为叶子节点，字符出现的次数为权值，构造哈夫曼树。</p>

<p>构造出的哈夫曼树图片有点儿大，这个页面放不下，有兴趣的同学到这里看看。</p>

<p>获取叶节点的哈夫曼编码的Go语言代码如下：</p>

<p>复制代码
//叶子结点的哈夫曼编码存储在map m里面
func getHuffmanCode(m map[string]string, tree *BNode){
    if nil == tree {
        return
    }</p>

<pre><code>showHuffmanCode(m, tree, &quot;&quot;)
</code></pre>

<p>}</p>

<p>func showHuffmanCode(m map[string]string, node *BNode, e string) {
    if nil == node {
        return
    }
    //左右子结点均为nil，则说明此结点为叶子节点
    if nil == node.ltree &amp;&amp; nil == node.rtree {
        m[node.key] = e
    }</p>

<pre><code>//递归获取左子树上叶子结点的哈夫曼编码
showHuffmanCode(m, node.ltree, e + &quot;0&quot;)

//递归获取右子树上叶子结点的哈夫曼编码
showHuffmanCode(m, node.rtree, e + &quot;1&quot;)
</code></pre>

<p>}
复制代码
根据哈夫曼树得出的每个叶子节点的哈夫曼编码如下(按照频数排序)：</p>

<p>字符  频数  哈夫曼编码
W   1   10110011110
F   1   10110011111
L   1   1011001001
N   1   1011001000
q   1   1011001010
;   2   1011001110
&ldquo;   4   101100110
k   11  1011000
.   15  1110000
v   16  1110001
p   20  010100
,   21  010101
I   23  011110
b   23  011111
g   25  101101
m   31  101111
c   31  101110
w   34  111001
换行  36  111111
f   36  111110
d   38  00100
y   39  00101
h   43  01011
u   45  01110
s   67  11101
l   69  11110
r   80  0100
i   80  0011
n   89  0110
a   98  1000
t   105 1001
o   109 1010
e   143 000
空格  271 110
这里频数就是权值，可以看到，权值越小的距离根结点越远，编码长度也就越大。</p>

<p>比如W在整篇文章中只出现了一次，频数是1，权重很小，而它的编码是10110011110，很大吧。</p>

<p>编码替换</p>

<p>下一步开始进行数据压缩，就是根据上表，把文章中出现的所有字符替换成对应的哈夫曼编码。 不是以字符串形式的&rdquo;010101&rdquo;，而是二进制形式的&rdquo;010101&rdquo;，就是bit位操作， 不过这里为了简便，就省略了bit操作的步骤，而是以01字符串来表示二进制的01 bit流。。</p>

<p>进行内容替换的Go语言代码如下：</p>

<p>复制代码
func HuffmanCode(m map[string]string, tree *BNode, strContent string) string {
    if nil == tree{
        return &ldquo;&rdquo;
    }
    strEncode := &ldquo;&rdquo;
    for _, v := range strContent {
        strEncode += m[string(v)]
    }</p>

<pre><code>return strEncode
</code></pre>

<p>}
复制代码
下面是一些统计数据：</p>

<p>原文章内容：1610字节</p>

<p>压缩后长度：886字节（885.375）</p>

<p>压缩率：54.99％</p>

<p>当然，这只是内容的数据部分，我们还需要存储刚刚生成的&rdquo;字符-编码&rdquo;对照表， 所以综合的压缩率不会这么大。当前的程序是基础的使用哈夫曼编码进行数据压缩的方法， 还可以在基础的方法之上进行改进，压缩率会更大。</p>

<p>4.2)解码
解码是编码的逆过程。读取加密的数据流，当接到一个bit的时候， 将当前的bit数组去和&rdquo;字符-编码&rdquo;表中的编码进行比较，如果匹配成功， 则将其替换成编码对应的字符，当前bit数组清空，继续读取字节流并记录。</p>

<p>下面是一个段解码的代码片段：</p>

<p>复制代码
func HuffmanDecode(mapTable map[string]string, str string) {
    //把&rdquo;字符-编码&rdquo;的map反转一下，变成&rdquo;编码-字符&rdquo;的map，便于查找比对。
    mapRTable := make(map[string]string)</p>

<pre><code>for k, v := range mapTable {
    mapRTable[v] = k
}

var strCode string
getWord := func (b byte) (strWord string, r bool){
    strCode += string(b)
    strWord = mapRTable[strCode]
    if &quot;&quot; == strWord {
        return &quot;&quot;, false
    }
    strCode = &quot;&quot;
    return strWord, true
}

strDecode := &quot;&quot;
for _, v := range []byte(str) {
    //每读取一个bit位都要进行一次搜索，目前效率有点儿低哈~.~
    if strWord, b := getWord(v); b {
        //如果匹配成功，则把匹配到的字符追加到结尾
        strDecode += strWord
    }
}

fmt.Printf(&quot;decode : [%s]\n&quot;, strDecode)
</code></pre>

<p>}</p>

<p>红黑树结构的建立
2.1 节点结构
       节点有红黑两色，我们先定义2个常量。布尔型足够：</p>

<p>const (
    // RED 红树设为true
    RED bool = true
    // BLACK 黑树设为false
    BLACK bool = false
)
       然后是节点结构，包括树共有的特性：节点的值，指向父节点、左右儿子节点的3个指针；还有红黑树特有的：颜色。下面是树的结构：</p>

<p>// RBNode 红黑树
type RBNode struct {
    value               int64
    color               bool
    left, right, parent *RBNode
}
       还有一些查找父节点，兄弟节点的方法，很简单，就不细说了。</p>

<p>// getGrandParent() 获取父级节点的父级节点
func (rbnode *RBNode) getGrandParent() *RBNode {&lsquo;代码略……&rsquo;}</p>

<p>// getSibling() 获取兄弟节点
func (rbnode *RBNode) getSibling() *RBNode {&lsquo;代码略……&rsquo;}</p>

<p>// GetUncle() 父节点的兄弟节点
func (rbnode *RBNode) getUncle() *RBNode {&lsquo;代码略……&rsquo;}
2.2 树的结构
       树的结构只包含一个根节点Root，还有很多方法，等介绍插入删除时再细说，代码结构如下:</p>

<p>type RBTree struct {
    root *RBNode
}
2.3 树的旋转
       节点的结构里面有个方法很重要，是整个红黑树的一个核心功能，那就是树的旋转。添加和删除过程中都多次应用到了树的旋转。下面就讲一下旋转的细节。对旋转比较熟的就可以直接看下一部分了。
       先定义旋转常量：</p>

<p>const (
    // 左旋
    LEFTROTATE bool = true
    // 右旋
    RIGHTROTATE bool = false
)
       树的旋转包括左旋和右旋，下面图解说明</p>

<p>左旋</p>

<pre><code>   左旋：以P为轴心左旋，N原来的父节点P作为N节点的左孩子，原N节点的左孩子变为P节点的右孩子，左旋就完成了。
</code></pre>

<p>右旋
       右旋：与左旋类似，只是把N节点的右孩子变为了P节点的左孩子。</p>

<p>需几点注意：</p>

<p>节点左旋必须有右孩子，右旋必须有左孩子。
如果N经过旋转变成了根节点，一定要记得将RBTree结构体中的根节点指针root指向N，这是容易出错的地方。
旋转代码如下：</p>

<p>// rotate() true左旋/false右旋
// 若有根节点变动则返回根节点
func (rbnode *RBNode) rotate(isRotateLeft bool) (*RBNode, error) {
    var root *RBNode
    if rbnode == nil {
        return root, nil
    }
    if !isRotateLeft &amp;&amp; rbnode.left == nil {
        return root, errors.New(&ldquo;右旋左节点不能为空&rdquo;)
    } else if isRotateLeft &amp;&amp; rbnode.right == nil {
        return root, errors.New(&ldquo;左旋右节点不能为空&rdquo;)
    }</p>

<pre><code>parent := rbnode.parent
var isleft bool
if parent != nil {
    isleft = parent.left == rbnode
}
if isRotateLeft {
    grandson := rbnode.right.left
    rbnode.right.left = rbnode
    rbnode.parent = rbnode.right
    rbnode.right = grandson
} else {
    grandson := rbnode.left.right
    rbnode.left.right = rbnode
    rbnode.parent = rbnode.left
    rbnode.left = grandson
}
// 判断是否换了根节点
if parent == nil {
    rbnode.parent.parent = nil
    root = rbnode.parent
} else {
    if isleft {
        parent.left = rbnode.parent
    } else {
        parent.right = rbnode.parent
    }
    rbnode.parent.parent = parent
}
return root, nil
</code></pre>

<p>}
3. 节点的插入
       插入相对来说简单一些，首先是一个查找树的插入，然后是分治法进行树的变化以符合红黑树特征</p>

<p>3.1 数据的插入
       二叉查找树的插入方式，没啥好说的，直接上代码：</p>

<p>func (rbtree *RBTree) insertNode(pnode *RBNode, data int64) {
    if pnode.value &gt;= data {
        // 插入数据不大于父节点，插入左节点
        if pnode.left != nil {
            rbtree.insertNode(pnode.left, data)
        } else {
            tmpnode := NewRBNode(data)
            tmpnode.parent = pnode
            pnode.left = tmpnode
            rbtree.insertCheck(tmpnode)
        }
    } else {
        // 插入数据大于父节点，插入右节点
        if pnode.right != nil {
            rbtree.insertNode(pnode.right, data)
        } else {
            tmpnode := NewRBNode(data)
            tmpnode.parent = pnode
            pnode.right = tmpnode
            // 插入验证
            rbtree.insertCheck(tmpnode)
        }
    }
}
3.2 插入时树结构的检查及变化
       检查分几种情况，下面依次说明：
       1. 要检查的节点没有父节点，意为此节点为root，则设置此节点的颜色为黑色（一开始提到过，插入时的节点初始时都是红色），直接返回，若不是根节点，则进行情况2的检查。
       2. 如果添加节点的父节点是黑色，那就省事儿多了。插入的是红色，不影响黑色数量，且由于父节点是黑色，不会出现父子节点都是红色的情况。性质4、5都不受影响。
       3. 若添加点的父节点也是红色，那就得考虑考虑了，这里应用了分治法，包括添加的节点N，N的父节点P，N的叔父节点U，N的祖父节点G。</p>

<p>叔父节点的判断
       下一步就是根据U节点的颜色进入不同流程，G左边的节点中有相邻的2个红色节点，肯定有一个要变成黑色，相应右边也要有变成黑色的点。这样，如果U是红色，则可直接变成黑色；若本身就是黑色，那就得用旋转的方法寻找平衡了，下面先说U节点是红色的情况。
       a) 若U为红色，则P与U都直接变成黑色，这样这部分每条路线上都多了一个黑色节点，需再减去一个以达到外部的平衡，然后把G改为红色。这样又会出现一个问题，那就是G的父节点的颜色未知，如果也是红色，那就又不符合规则了。又出现了要检查的内容。我们直接把这个问题扔给上一级，让上一级去解决，直到解决完成，即用递归的方式处理（N或P是左孩子还是右孩子没有关系，这里为了方便，只写出一个）。
改变颜色</p>

<pre><code>   b) 若U为黑色，则进入旋转平衡阶段。
</code></pre>

<p>3.3 插入节点时的树的旋转情况
       内容比较多，就拿出来单说了。这里是红黑树插入的重要步骤。树的旋转需注意把根节点的情况考虑进去，我们先写左旋和右旋的方法，实现如下：</p>

<p>func (rbtree *RBTree) rotateLeft(node *RBNode) {
    if tmproot, err := node.rotate(LEFTROTATE); err == nil {
        if tmproot != nil {
            rbtree.root = tmproot
        }
    } else {
        log.Printf(err.Error())
    }
}
以上是左旋的实现，右旋类似，不再赘述。</p>

<p>下面是旋转平衡的几种情况：</p>

<p>N是P的左（右）孩子，P同样是G的左（右）孩子，则只需以G为轴进行左（右）旋，然后把P改为黑色，G改为红色。左右黑色节点数目不变，且不影响外部的规则。
旋转
N是P的右（左）孩子，而P是G的左（右）孩子
       我们需以P为轴左旋（右边那种情况为右旋）。这时我们会发现树现在变成了1的情况，再用1的逻辑去处理就行了，同样这种旋转方式不会影响每个路径上的黑色节点数目，且结果顶点处的节点为黑色，不破坏外部的数据。
旋转
       这样，插入的情况便都考虑到了，下面是实现代码：</p>

<p>func (rbtree *RBTree) insertNode(pnode *RBNode, data int64) {
    if pnode.value &gt;= data {
        // 插入数据不大于父节点，插入左节点
        if pnode.left != nil {
            rbtree.insertNode(pnode.left, data)
        } else {
            tmpnode := NewRBNode(data)
            tmpnode.parent = pnode
            pnode.left = tmpnode
            rbtree.insertCheck(tmpnode)
        }
    } else {
        // 插入数据大于父节点，插入右节点
        if pnode.right != nil {
            rbtree.insertNode(pnode.right, data)
        } else {
            tmpnode := NewRBNode(data)
            tmpnode.parent = pnode
            pnode.right = tmpnode
            rbtree.insertCheck(tmpnode)
        }
    }
}
func (rbtree *RBTree) insertCheck(node *RBNode) {
    if node.parent == nil {
        // 检查1：若插入节点没有父节点，则该节点为root
        rbtree.root = node
        // 设置根节点为black
        rbtree.root.color = BLACK
        return
    }</p>

<pre><code>// 父节点是黑色的话直接添加，红色则进行处理
if node.parent.color == RED {
    if node.getUncle() != nil &amp;&amp; node.getUncle().color == RED {
        // 父节点及叔父节点都是红色，则转为黑色
        node.parent.color = BLACK
        node.getUncle().color = BLACK
        // 祖父节点改成红色
        node.getGrandParent().color = RED
        // 递归处理
        rbtree.insertCheck(node.getGrandParent())
    } else {
        // 父节点红色，父节点的兄弟节点不存在或为黑色
        isleft := node == node.parent.left
        isparentleft := node.parent == node.getGrandParent().left
        if !isleft &amp;&amp; isparentleft {
            rbtree.rotateLeft(node.parent)
            rbtree.rotateRight(node.parent)

            node.color = BLACK
            node.left.color = RED
            node.right.color = RED
        } else if isleft &amp;&amp; !isparentleft {
            rbtree.rotateRight(node.parent)
            rbtree.rotateLeft(node.parent)

            node.color = BLACK
            node.left.color = RED
            node.right.color = RED
        } else if isleft &amp;&amp; isparentleft {
            node.parent.color = BLACK
            node.getGrandParent().color = RED
            rbtree.rotateRight(node.getGrandParent())
        } else if !isleft &amp;&amp; !isparentleft {
            node.parent.color = BLACK
            node.getGrandParent().color = RED
            rbtree.rotateLeft(node.getGrandParent())
        }
    }
}
</code></pre>

<p>}
4. 节点的删除
4.1 删除节点的转换
删除主要有3种情况</p>

<p>要删除的节点N没有子节点，可直接删除，然后验证平衡性
要删除的节点N有一个子节点S，则需将S的父节点设为N的父节点P，如果N是P的左儿子节点，就把P的左子节点设成S，右边同理。
要删除的节点N有2个儿子S1和S2，这样直接删除会麻烦很多。我们利用一下排序二叉树的性质，进行一下转换。过程如下：
       a) 选择右子树中的节点作替换（左右无所谓，道理是一样的，我们以替换右子树中的节点为例）
       b) 找到节点N右子树中最靠左边的非空节点M（不一定是叶子节点），将M的值复制到N，然后把要删除的节点改为M，则转换成了删除节点中包含有一个子节点（或没有子节点）的问题，例如下图中我们如果要删除5，则寻找节点7的最左侧的非空节点6，将6复制到5的位置，然后排序树仍然成立（原来的6要删除了，不考虑在内）
删除2个节点的转换成删除1个
4.2 删除含单个子节点的节点
       删除含单个子节点的节点也包括删除没有子节点的节点。如果要删除的节点没有子节点，为了转换方便，我们需在没有子节点的节点上加上一个临时节点，颜色为黑色，作为左孩子还是右孩子都可以。新加的节点虽然暂时破环了平衡，但是不影响旋转等操作（下面处理过程中能看出来）。最后记得删除即可。
       删除含单个子节点的节点也包括几种情况：</p>

<p>删除的是根节点，且节点没有子节点，则直接删除，root置空。
删除的是根节点，且节点只有一个子节点，直接删除，将根节点指向子节点，并设置颜色为黑色
删除的是非根节点，又分几种情况
       a) 要删除的节点是红色，则它的父节点与子节点（如果有的话）都是黑色，直接把子节点或空节点替换要删除节点的位置即可，不会影响黑节点的平衡
删除节点</p>

<pre><code>   b) 要删除的是黑色节点，但它的子节点存在且是红色，我们要做到只是用子节点替换它，然后改变子节点为黑色，使黑色平衡
</code></pre>

<p>删除节点</p>

<pre><code>   c) 要删除的是黑色节点且子节点也是黑色，这就需要检验平衡了，检查替换后的孩子节点，下面一节会说明
</code></pre>

<p>4.3 删除时树结构的检查及变化
       由上一节我们能了解到需要检查平衡的是要删除的节点与它的子节点N都是黑色的情况，很大程度上简化了树的检查。
       我们把替换后的节点用N表示，N是黑色。N的兄弟节点为了不和子节点弄混，我们用B表示。B的2个儿子分别用S1和S2表示。N的父节点称为P。
       下面是几种情况:</p>

<p>N是根节点，直接设成黑色，退出。（存在递归的情况，这个必须有）
B是红色。由性质4和5，及N及N的原始父亲都是黑色可判断，如果B是红色，则它的父亲P是黑色，它的2个子树都是存在的且都是黑色（这点在逻辑过程中判断是否为空很重要）。
       我们以N节点是P节点的左孩子为例，需要以P为轴左旋。把B作为最顶层，颜色设为黑色。P的颜色设为红色。这个单元上所有路径上的黑色节点数量不变。这里需注意，N节点的兄弟节点变成了S1。由于N的路径上还少一个黑色节点（已删除的父节点），整体平衡尚未成功，我们仍需努力，还有内部的解决办法，接着往下走。
B为红色时
P为黑色，B和它的2个子节点都是黑色（若子节点为空也算是黑色，由于golang的指针没有cpp那么神奇，这里需在逻辑中写明），为了维护单元内的平衡，我们需把B节点设为红色，这样内部黑色节点是平衡的，不过单元整体少了一个黑色节点。自己解决不了那就扔给上一层去解决吧，不在其位不谋其政。这里有个递归需注意。
BP及儿子为黑色
如果P是红色，B和它的2个子节点（或空节点）都是黑色，我们只需把P设成黑色，B设成红色即可，还记得情形1中的那种情况吗？这样就补全丢失的黑色了
P是红色
如果B是黑色，S1是红色，S2是黑色（N是P的左孩子的情况下）。则需以B为轴进行右旋，让B的左子树指针变空（为了统一到第6种情况处理），这时N的路径还还少一个黑色节点
S1是红色
大部分情况都考虑的差不多了，还有一种情况就是B节点为黑色，B节点的右孩子为红色（5形成的这种情况）。这时需要以P为轴进行左旋，然后交换P与B的颜色，即P为黑色，B未知。S2变为黑色。这样使单元内恢复平衡，且整个树的各个路径与删除前一致</p>

<p>S2是红色
       树的删除分析就结束了，下面是实现代码：</p>

<p>// 删除对外方法
func (rbtree *RBTree) Delete(data int64) {
    rbtree.delete_child(rbtree.root, data)
}</p>

<p>// 删除节点
func (rbtree *RBTree) delete_child(n *RBNode, data int64) bool {
    if data &lt; n.value {
        if n.left == nil {
            return false
        }
        return rbtree.delete_child(n.left, data)
    }
    if data &gt; n.value {
        if n.right == nil {
            return false
        }
        return rbtree.delete_child(n.right, data)
    }</p>

<pre><code>if n.right == nil || n.left == nil {
    // 两个都为空或其中一个为空，转为删除一个子树节点的问题
    rbtree.delete_one(n)
    return true
}

//两个都不为空，转换成删除只含有一个子节点节点的问题
mostLeftChild := n.right.getLeftMostChild()
tmpval := n.value
n.value = mostLeftChild.value
mostLeftChild.value = tmpval

rbtree.delete_one(mostLeftChild)

return true
</code></pre>

<p>}</p>

<p>// 删除只有一个子节点的节点
func (rbtree *RBTree) delete_one(n *RBNode) {
    var child *RBNode
    isadded := false
    if n.left == nil {
        child = n.right
    } else {
        child = n.left
    }</p>

<pre><code>if n.parent == nil &amp;&amp; n.left == nil &amp;&amp; n.right == nil {
    n = nil
    rbtree.root = n
    return
}
if n.parent == nil {
    n = nil
    child.parent = nil
    rbtree.root = child
    rbtree.root.color = BLACK
    return
}

if n.color == RED {
    if n == n.parent.left {
        n.parent.left = child

    } else {
        n.parent.right = child
    }
    if child != nil {
        child.parent = n.parent
    }
    n = nil
    return
}

if child != nil &amp;&amp; child.color == RED &amp;&amp; n.color == BLACK {
    if n == n.parent.left {
        n.parent.left = child

    } else {
        n.parent.right = child
    }
    child.parent = n.parent
    child.color = BLACK
    n = nil
    return
}

// 如果没有孩子节点，则添加一个临时孩子节点
if child == nil {
    child = NewRBNode(0)
    child.parent = n
    isadded = true
}

if n.parent.left == n {
    n.parent.left = child
} else {
    n.parent.right = child
}

child.parent = n.parent

if n.color == BLACK {
    if !isadded &amp;&amp; child.color == RED {
        child.color = BLACK
    } else {
        rbtree.deleteCheck(child)
    }
}

// 如果孩子节点是后来加的，需删除
if isadded {
    if child.parent.left == child {
        child.parent.left = nil
    } else {
        child.parent.right = nil
    }
    child = nil
}
n = nil
</code></pre>

<p>}</p>

<p>// deleteCheck() 删除验证
func (rbtree *RBTree) deleteCheck(n *RBNode) {
    if n.parent == nil {
        n.color = BLACK
        return
    }
    if n.getSibling().color == RED {
        n.parent.color = RED
        n.getSibling().color = BLACK
        if n == n.parent.left {
            rbtree.rotateLeft(n.parent)
        } else {
            rbtree.rotateRight(n.parent)
        }
    }
    //注意：这里n的兄弟节点发生了变化，不再是原来的兄弟节点
    is_parent_red := n.parent.color
    is_sib_red := n.getSibling().color
    is_sib_left_red := BLACK
    is_sib_right_red := BLACK
    if n.getSibling().left != nil {
        is_sib_left_red = n.getSibling().left.color
    }
    if n.getSibling().right != nil {
        is_sib_right_red = n.getSibling().right.color
    }
    if !is_parent_red &amp;&amp; !is_sib_red &amp;&amp; !is_sib_left_red &amp;&amp; !is_sib_right_red {
        n.getSibling().color = RED
        rbtree.deleteCheck(n.parent)
        return
    }
    if is_parent_red &amp;&amp; !is_sib_red &amp;&amp; !is_sib_left_red &amp;&amp; !is_sib_right_red {
        n.getSibling().color = RED
        n.parent.color = BLACK
        return
    }
    if n.getSibling().color == BLACK {
        if n.parent.left == n &amp;&amp; is_sib_left_red &amp;&amp; !is_sib_right_red {
            n.getSibling().color = RED
            n.getSibling().left.color = BLACK
            rbtree.rotateRight(n.getSibling())
        } else if n.parent.right == n &amp;&amp; !is_sib_left_red &amp;&amp; is_sib_right_red {
            n.getSibling().color = RED
            n.getSibling().right.color = BLACK
            rbtree.rotateLeft(n.getSibling())
        }
    }
    n.getSibling().color = n.parent.color
    n.parent.color = BLACK
    if n.parent.left == n {
        n.getSibling().right.color = BLACK
        rbtree.rotateLeft(n.parent)
    } else {
        n.getSibling().left.color = BLACK
        rbtree.rotateRight(n.parent)
    }
}</p>

<p>2.倒排索引</p>

<p>理解正向索引和反向索引，也就是我们说的倒排索引</p>

<p>正向索引，将文件包含哪些词作为存储，到文件中去寻找一些词，需要先找到文件，然后再看有没有这些词</p>

<p>反向索引，将包含这些词的文件作为一个存储，找到这个词就知道哪些文件包含这些词了。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/computerbase/datastruct/datastruct/">https://kingjcy.github.io/post/computerbase/datastruct/datastruct/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/datastruct/">
                            <i class="fa fa-tags"></i>
                            Datastruct
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/about/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/computerbase/algorithm/algotithm/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#总结">总结</a></li>
<li><a href="#数据结构">数据结构</a>
<ul>
<li><a href="#散点集合">散点集合</a></li>
<li><a href="#线性数据结构">线性数据结构</a>
<ul>
<li><a href="#线性表">线性表</a></li>
</ul></li>
<li><a href="#树状数据结构">树状数据结构</a></li>
<li><a href="#网状数据结构">网状数据结构</a></li>
</ul></li>
<li><a href="#附录">附录</a></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

