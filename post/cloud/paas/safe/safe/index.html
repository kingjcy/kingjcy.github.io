<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="在基于k8s做应用开发的时候，都是使用admin来使用k8s，基本不用去关注授权的问题。但是，当我们将k8s作为PaaS平台的容器编排引擎，并引入多租户时，就涉及到权限管理相关的问题了，paas平台的安全都是基于k8s的安全机制来实现的。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="云计算安全系列---- 安全 - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    云计算安全系列---- 安全
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
			<li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/categories/">归档</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="https://kingjcy.github.io/"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2020年05月04日 
                </div>
                <h1 class="post-title">云计算安全系列---- 安全</h1>
            </header>

            <div class="post-content">
                <p>在基于k8s做应用开发的时候，都是使用admin来使用k8s，基本不用去关注授权的问题。但是，当我们将k8s作为PaaS平台的容器编排引擎，并引入多租户时，就涉及到权限管理相关的问题了，paas平台的安全都是基于k8s的安全机制来实现的。</p>

<p>Kubernetes中的隔离主要包括这几种：</p>

<ul>
<li>网络隔离：需要使用网络插件，比如flannel, calico。</li>
<li>资源隔离：kubernetes原生支持资源隔离，pod就是资源隔离和调度的最小单位，同时使用namespace限制用户空间和资源限额。</li>
<li>身份隔离：使用RBAC-基于角色的访问控制，多租户的身份认证和权限控制。</li>
</ul>

<p>那么k8s的安全机制有哪些？首先我们先来了解一些概念。</p>

<h1 id="基础概念">基础概念</h1>

<h2 id="用户">用户</h2>

<p>Kubernetes 中有两种用户:</p>

<pre><code>一种是内置“用户”：ServiceAccount，用于集群内的资源的一种身份,便于认证授权操作，我们叫做系统服务用户。
一种就是我们这种操作集群的人，实际操作 &quot;kubectl&quot; 命令的人,我们直接叫用户。
</code></pre>

<h3 id="service-account">Service Account</h3>

<p>Service Account概念的引入是基于这样的使用场景：运行在pod里的进程需要调用Kubernetes API以及非Kubernetes API的其它服务。这时候pod就需要一个身份做认证授权。所以Service Account它并不是给kubernetes集群的用户使用的，而是给pod里面的进程使用的，它为pod提供必要的身份认证。</p>

<pre><code>kubectl get sa --all-namespaces

NAMESPACE     NAME          SECRETS   AGE
default       build-robot   1         1d
default       default       1         32d
default       kube-dns      1         31d
kube-public   default       1         32d
kube-system   dashboard     1         31d
kube-system   default       1         32d
kube-system   heapster      1         30d
kube-system   kube-dns      1         31d
</code></pre>

<p>如果kubernetes开启了ServiceAccount（–admission_control=…,ServiceAccount,… ）那么会在每个namespace下面都会创建一个默认的default的sa，可见sa是namespace级别的。其中最重要的就是secrets，它是每个sa下面都会拥有的一个加密的token。</p>

<pre><code>kubectl get sa  default  -o yaml

apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: 2017-05-02T06:39:12Z
  name: default
  namespace: default
  resourceVersion: &quot;175&quot;
  selfLink: /api/v1/namespaces/default/serviceaccounts/default
  uid: 0de23575-2f02-11e7-98d0-5254c4628ad9
secrets:
- name: default-token-rsf8r
</code></pre>

<p>当用户再该namespace下创建pod的时候都会默认使用这个sa，kubernetes会把默认的sa挂载到容器内。</p>

<p>看一下这个secret</p>

<pre><code>kubectl get secret default-token-rsf8r -o yaml
apiVersion: v1
data:
  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUR2akNDQXFhZ0F3SUJBZ0lVZlpvZDJtSzNsa3JiMzR3NDhhUmtOc0pVVDJjd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1pURUxNQWtHQTFVRUJoTUNRMDR4RURBT0JnTlZCQWdUQjBKbGFVcHBibWN4RURBT0JnTlZCQWNUQjBKbAphVXBwYm1jeEREQUtCZ05WQkFvVEEyczRjekVQTUEwR0ExVUVDeE1HVTNsemRHVnRNUk13RVFZRFZRUURFd3ByCmRXSmxjbTVsZEdWek1CNFhEVEUzTURVd01qQTNNekF3TUZvWERUSXlNRFV3TVRBM016QXdNRm93WlRFTE1Ba0cKQTFVRUJoTUNRMDR4RURBT0JnTlZCQWdUQjBKbGFVcHBibWN4RURBT0JnTlZCQWNUQjBKbGFVcHBibWN4RERBSwpCZ05WQkFvVEEyczRjekVQTUEwR0ExVUVDeE1HVTNsemRHVnRNUk13RVFZRFZRUURFd3ByZFdKbGNtNWxkR1Z6Ck1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBc2E5Zk1HVGd2MGl0YnlZcHoycXkKOThKWktXdWdFL0VPbXRYS2ExT0Y3ekUxSFh1cDFOVG8rNkhvUEFuR3hhVzg4Q0s0TENrbWhNSGFLdUxnT3IvVApOMGphdnc5YWlPeVdYR1hXUUxVN3U0aVhoaDV6a2N4bmZxRW9JOW9JV2dMTzVEL3hBL0tnZzRQZDRMeFdqMkFQCk4rcVdxQ2crU3BrdkpIQUZWL3IyTk1BbEIzNHBrK0t5djVQMDJSQmd6Y2xTeSs5OUxDWnlIQ1VocGl0TFFabHoKdUNmeGtBeUNoWFcxMWNKdVFtaDM4aFVKa0dhUW9OVDVSNmtoRTArenJDVjVkWnNVMVZuR0FydWxaWXpJY3kregpkeUZpYWYyaitITyt5blg4RUNySzR1TUF3Nk4zN1pnNjRHZVRtbk5EWmVDTTlPelk5czBOVzc1dHU5bHJPZTVqCnZRSURBUUFCbzJZd1pEQU9CZ05WSFE4QkFmOEVCQU1DQVFZd0VnWURWUjBUQVFIL0JBZ3dCZ0VCL3dJQkFqQWQKQmdOVkhRNEVGZ1FVK2RqMThRUkZyMWhKMVhGb1VyYUVVRnpEeVRBd0h3WURWUjBqQkJnd0ZvQVUrZGoxOFFSRgpyMWhKMVhGb1VyYUVVRnpEeVRBd0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dFQkFBazQ4ODZBa0Fpa3VBVWRiOWU1CitldkVXVVFFaTIyTmc4REhmVTVSbXppU2ZhVllFQ1FuTlBUREprMmYvTm1Kb3RUVWxRZS9Ec3BkNEk1TFova1IKMGI2b1VoZkdmTkVOOXVObkkvZEgzOFBjUTNDaWtVeHhaeFRYTytaaldxcGNHZTRLNzZtaWd2ZWhQR2Z1VUNzQwp0UmZkZDM2YkhnRjN4MzRCWnc5MStDQ2VKQzBSWmNjVENqcHFHUEZFQlM3akJUVUlRVjNodnZycWJMV0hNeTJuCnFIck94UFI1eFkrRU5SQ0xzVWNSdk9icUhBK1g0c1BTdzBwMWpROXNtK1lWNG1ybW9Gd1RyS09kK2FqTVhzVXkKL3ZRYkRzNld4RWkxZ2ZvR3BxZFN6U1k0MS9IWHovMjZWNlFWazJBajdQd0FYZmszYk1wWHdDamRXRG4xODhNbQpXSHM9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
  namespace: ZGVmYXVsdA==
  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnBjM01pT2lKcmRXSmxjbTVsZEdWekwzTmxjblpwWTJWaFkyTnZkVzUwSWl3aWEzVmlaWEp1WlhSbGN5NXBieTl6WlhKMmFXTmxZV05qYjNWdWRDOXVZVzFsYzNCaFkyVWlPaUprWldaaGRXeDBJaXdpYTNWaVpYSnVaWFJsY3k1cGJ5OXpaWEoyYVdObFlXTmpiM1Z1ZEM5elpXTnlaWFF1Ym1GdFpTSTZJbVJsWm1GMWJIUXRkRzlyWlc0dGNuTm1PSElpTENKcmRXSmxjbTVsZEdWekxtbHZMM05sY25acFkyVmhZMk52ZFc1MEwzTmxjblpwWTJVdFlXTmpiM1Z1ZEM1dVlXMWxJam9pWkdWbVlYVnNkQ0lzSW10MVltVnlibVYwWlhNdWFXOHZjMlZ5ZG1salpXRmpZMjkxYm5RdmMyVnlkbWxqWlMxaFkyTnZkVzUwTG5WcFpDSTZJakJrWlRJek5UYzFMVEptTURJdE1URmxOeTA1T0dRd0xUVXlOVFJqTkRZeU9HRmtPU0lzSW5OMVlpSTZJbk41YzNSbGJUcHpaWEoyYVdObFlXTmpiM1Z1ZERwa1pXWmhkV3gwT21SbFptRjFiSFFpZlEuSmxuamM0Y0xNYkZrRlJVQjIyWGtFN2t4bTJ1dS1aQm9sUTh4VEdDNmdLOTdSZTVOMzBuY2V0SWJsanVOVWFlaDhtMDk2R19nMHE3cmRvWm5XMTV2OFBVXzNyM1hWWlBNc1lxbGRpZlNJbWtReXFqeEphVlBka3Izam5GWVBkVWNaTmk3MFF3cWtEdm5sMXB4SFRNZTZkTVNPTlExbUVoMHZSbHBhRTdjVWtTVlg5blRzaFVJVTVXWE9wRUxwdTVjVjBHV3ZGeDRDSzR6Umt3clNMdlV5X2d5UGZwLWdYVFZQWU80NkJKSWZtaVhlZGhVaW9nempPN285eGxDbUxQVkhyNkFIZGViNExiTVA1dkJ2MlBSZ2RrMW9keTR0VEdxLVRGU3M2VkNoMTZ4dk5IdTRtRVN5TjZmcXVObzJwYUFOelY4b251aTJuaU4yNTU1TzN4SFdR
kind: Secret
metadata:
  annotations:
    kubernetes.io/service-account.name: default
    kubernetes.io/service-account.uid: 0de23575-2f02-11e7-98d0-5254c4628ad9
  creationTimestamp: 2017-05-02T06:42:07Z
  name: default-token-rsf8r
  namespace: default
  resourceVersion: &quot;12551&quot;
  selfLink: /api/v1/namespaces/default/secrets/default-token-rsf8r
  uid: 75c0a236-2f02-11e7-98d0-5254c4628ad9
type: kubernetes.io/service-account-token
</code></pre>

<p>上面的内容是经过base64加密过后的，我们直接进入容器内</p>

<pre><code>~ # ls -l  /var/run/secrets/kubernetes.io/serviceaccount/
total 0
lrwxrwxrwx    1 root     root            13 May  4 23:57 ca.crt -&gt; ..data/ca.crt
lrwxrwxrwx    1 root     root            16 May  4 23:57 namespace -&gt; ..data/namespace
lrwxrwxrwx    1 root     root            12 May  4 23:57 token -&gt; ..data/token
</code></pre>

<p>可以看到已将ca.crt 、namespace和token放到容器内了，那么这个容器就可以通过https的请求访问apiserver了，这就是所有的pod都能走apiserver的原因。</p>

<p>service account是namespace作用域，而User是全cluster唯一。service account会对应一个虚拟User，User名为system:serviceaccount:${namespace}:${sa_name}，比如在default namespace的test service account，则对应的虚拟User为system:serviceaccount:default:test。</p>

<h3 id="用户-1">用户</h3>

<p>可以理解成实际操作 &ldquo;kubectl&rdquo; 命令的人，区别于 pod 等资源概念的实际操作的k8s集群的运维人员或者用户，也就是我们的平常的用户。</p>

<h3 id="kubernetes没有用户以及用户组">Kubernetes没有用户以及用户组</h3>

<p>Kubernetes并没有提供用户管理和身份认证功能，除了Service Account外，所有的用户信息都依赖外部的用户管理系统来存储，因此通过api-serever根本无法列出User和Group。这符合UNIX设计哲学的，即Do One Thing and Do It Well。Kubernetes只专注于做应用编排，其他的功能则提供接口集成，我们使用的CNI，CSI，CRI都是这个思想。</p>

<p>这样做的好处也显而易见，用户账户信息与Kubernetes集群松耦合，便于集成企业已有的身份认证系统，如AD、LADP、Keycloak等。</p>

<p>我们在写rolebingding的时候，Subjects需要填User或者Group，我们一般使用sa，也可以使用外部身份认证系统。</p>

<h2 id="多租户">多租户</h2>

<p>1、租户</p>

<ul>
<li>租户主要是&rdquo;租&rdquo;，讲究的是是你租用的一个资源，就属于你私有的，和用户是两个概念。</li>
</ul>

<p>比如你使用阿里云的存储服务，阿里是“租”给你它的存储设备，你是它的租户，别人不会看见你存储的数据，就像你租的房子别人不能翻查一样。当然同时你也是阿里云网站的用户。</p>

<p>2、多租户的目的？</p>

<ul>
<li>隔离。</li>
</ul>

<p>3、k8s多租户的实现</p>

<ul>
<li>一般可以将租户及其 Kubernetes 资源分隔到单独的命名空间中。然后，您可以使用策略来强制执行租户隔离。通常按命名空间划分，可用于限制 API 访问、资源使用以及允许容器执行的操作。</li>
</ul>

<p>4、多租户使用场景:企业内部共享集群的多租户</p>

<p>我们可以通过命名空间对不同部门或团队进行资源的逻辑隔离，同时定义以下几种角色的业务人员：</p>

<ul>
<li>集群管理员(cluster admin)

<ul>
<li>具有集群的管理能力（扩缩容、添加节点等操作）</li>
<li>负责为租户管理员创建和分配命名空间</li>
<li>负责各类策略（RAM/RBAC/networkpolicy/quota…）的 CRUD</li>
</ul></li>
<li>租户管理员(namespace admin)

<ul>
<li>至少具有集群的 RAM 只读权限</li>
<li>管理租户内相关人员的 RBAC 配置</li>
</ul></li>
<li>租户内用户(namespace user)

<ul>
<li>在租户对应命名空间内使用权限范围内的 k8s 资源</li>
</ul></li>
</ul>

<p><img src="/media/cloud/k8s/tenant" alt="" /></p>

<h2 id="安全机制">安全机制</h2>

<p>APIServer提供了3A机制：认证机制（Authentication）、授权机制（Authorization）以及准入控制机制（Admission Controllers）。</p>

<h3 id="认证机制-authentication">认证机制（Authentication）</h3>

<p>k8s 中的认证机制，是在用户访问 APIServer 的第一步。这一步往往只检测请求头或客户端证书，通俗的讲这一步就是验证用户名密码的。所以也就是我们正常使用的认证方式，比如token，basic等。</p>

<p>认证支持好几种方式:</p>

<ul>
<li>客户端证书</li>
<li>Bearer Tokens

<ul>
<li>Service Account Token</li>
<li>BootStrap Token</li>
<li>Static Token</li>
</ul></li>
<li>HTTP Basic Auth</li>
<li>Authenticating Proxy</li>
</ul>

<h4 id="1-客户端证书">1、客户端证书</h4>

<p>x509认证是默认开启的认证方式，api-server启动时会指定ca证书以及ca私钥，只要是通过ca签发的客户端x509证书，则可认为是可信的客户端。所以带着签发的客户端证书是可以通过https的安全验证的。</p>

<p>签发客户端证书有两种方式，一种是基于CA根证书签发证书，另一个种是发起CSR(Certificate Signing Requests)请求。</p>

<blockquote>
<p>使用CA根证书签发客户端证书</p>
</blockquote>

<p>使用CA根证书需要CA的私钥，假设要创建一个int32bit用户，所属的组为int32bit，使用openssl签发证书:</p>

<pre><code>openssl genrsa -out int32bit.key 2048 # 生成私钥
openssl req -new -key int32bit.key -out int32bit.csr -subj &quot;/CN=int32bit/O=int32bit&quot; # 发起CSR请求
openssl x509 -req -in int32bit.csr -CA $CA_LOCATION/ca.crt -CAkey $CA_LOCATION/ca.key -CAcreateserial -out int32bit.crt -days 365 # 基于CSR文件签发x509证书
</code></pre>

<p>其中CA_LOCATION为api server的CA证书路径，使用kubeadm部署一般为/etc/kubernetes/pki/。</p>

<p>最后生成config文件:</p>

<pre><code>kubectl config set-credentials int32bit \
  --client-certificate=int32bit.crt \
  --client-key=int32bit.key \
  --embed-certs=true \
  --kubeconfig=&quot;int32bit@int32bit-kubernetes.config.config&quot;
</code></pre>

<p>注意使用&ndash;embed-certs参数，这样才会把证书内容填充到kubeconfig文件，否则仅填充证书路径。</p>

<blockquote>
<p>通过CSR签发证书</p>
</blockquote>

<p>前面通过CA签发证书需要有CA的私钥，其实Kubernetes可以直接发起CSR请求。</p>

<p>首先创建一个CSR请求，CN为test-csr，O为int32bit，即User为test-csr，Group为int32bbit。</p>

<pre><code>openssl req -new -newkey rsa:4096 \
  -nodes -keyout test-csr.key \
  -out test-csr.csr -subj &quot;/CN=test-csr/O=int32bit&quot;
</code></pre>

<p>声明一个CSR Resource:</p>

<pre><code>apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: test-csr
spec:
  groups:
  - int32bit
  request: ... # 这里填test-csr.csr内容并转化为base64
  usages:
  - client auth
</code></pre>

<p>创建该资源:</p>

<pre><code># kubectl apply -f test-csr.yaml
certificatesigningrequest.certificates.k8s.io/test-csr created
# kubectl get csr
NAME       AGE   REQUESTOR          CONDITION
test-csr   4s    kubernetes-admin   Pending
</code></pre>

<p>此时CSR的状态为Pending，通过kubectl certificate approve命令签发证书:</p>

<pre><code># kubectl certificate approve test-csr
certificatesigningrequest.certificates.k8s.io/test-csr approved
# kubectl get csr
NAME       AGE   REQUESTOR          CONDITION
test-csr   2m    kubernetes-admin   Approved,Issued
</code></pre>

<p>此时CSR显示已经完成签发，可以读取证书内容:</p>

<pre><code># kubectl get csr test-csr -o jsonpath='{.status.certificate}' | base64 -d
-----BEGIN CERTIFICATE-----
MIIEDTCCAvWgAwIBAgIUB9dVsj34xnQ8m5KUQwpdblWapNcwDQYJKoZIhvcNAQEL
...
yvfz8hcwrhQc6APpmZcBnil7iyzia3tnztQjoyaZ0cjC
-----END CERTIFICATE-----
</code></pre>

<p>查看证书部分摘要信息:</p>

<pre><code># kubectl get csr test-csr -o jsonpath='{.status.certificate}' \
  | base64 -d \
  | openssl x509  -noout  \
  -subject  -issuer
subject=O = int32bit, CN = test-csr
issuer=CN = kubernetes
</code></pre>

<p>配置kubeconfig使用证书认证的方式和前面的一样。</p>

<blockquote>
<p>总结</p>
</blockquote>

<p>可见，客户端向k8s提交带有用户名、用户组等信息的CSR，然后管理员在k8s上为该客户签发证书。当然也可以基于ca私钥的基础上直接使用openssl签发证书，用户名和密码都是隐藏在证书中的，以后，用户使用该证书去访问k8s，api-server就能够辨识出用户。结合RBAC的配置，如果该用户或者用户组通过rolebinding绑定了role，那么该用户就拥有该role对对应资源的操作权限。</p>

<p>我们搭建k8s过程中签发的CA证书就是一个客户端证书，是一个拥有集群管理员权限的证书。</p>

<p>使用x509证书相对静态密码来说显然会更安全，只要证书不泄露，可以认为是无懈可击的。但是虽然颁发证书容易，目前却没有很好的方案注销证书。</p>

<p>所以使用x509证书认证适用于Kubernetes内部组件之间认证，普通用户认证并不推荐通过证书的形式进行认证。</p>

<blockquote>
<p>身份识别</p>
</blockquote>

<p>上面说了，用户信息是隐藏在证书中的，我们来看一下，正常我们可以重kubectl的kubeconfig中获取用户的证书内容，一般是一个base64加密的内容</p>

<pre><code>// admin-client-certificate.txt
LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM4akNDQWRxZ0F3SUJBZ0lJZjJkVlJqbThFTFF3RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2EzVmlaWEp1WlhSbGN6QWVGdzB4T0RBMU1UUXdPREUzTVROYUZ3MHhPVEExTVRRd09ERTNNVGRhTURReApGekFWQmdOVkJBb1REbk41YzNSbGJUcHRZWE4wWlhKek1Sa3dGd1lEVlFRREV4QnJkV0psY201bGRHVnpMV0ZrCmJXbHVNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXhCbjNqZHc4MGIxR2ZiNnMKdzJOcnFwTG90TVQ0bnlBZjJIaHFNclhqbk8rd25hSzFBSVRPdy8yMm1EajByd0l1SndkUUlqNS9CYUY2M3BQRQoxcFUwdmhJUFZLNG42Skk0ZG1Nem8vbFIzalpwR2VaVzF6ZFhhQ292dzljN2NsYmlIby9tRkc0eHF5dFZMZlg0Ci9TOG1GcDJBOVFjaWVKR0lvNVMwQlIzRlpsVTFQTTdEUmJMRFZWcTFQZHlOWTJHZnNiR3JIbEdnWHZXQUtDZC8KSDc5Z0FxVm9UWGpTSVdDVll1WWNvTHZkdlZYUVNJaVlscFhGUDFqQlFMdmNVN3ZycXRiMTJSbXJ4bnBrVzRwbApkR0VPWDJzTG1mWVo1VGlGcGtSd3oyR3hzbVd5UmJ0Nk91SVNKRkk2UlowcitSbjR5TURLUHJZbEVuZ0RWYzVLClBaNXptd0lEQVFBQm95Y3dKVEFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUgKQXdJd0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dFQkFFWk5UdlR6Mk9nekNVZHZNRmJyaFBzcCttRDJ2UGpNUkN4aQozQmtBMTB2SUNPU2ZkeW1NbjhhdzBJYktZejJnUWJYcVVmcXpRbVFmYTNpZitRWUJrQis3N3pmc3Y5YW00RVAvCmU2VGc1MnRxVjJQN3MyZUY3dE5BZTIwR3lWNnlGbFExUVVXNS9NNE0rSk1sVitCVWJsOXlFeVFsRU51Y0tmK3UKVFB5S0tUVXR6dlVZcjVFM0VKa3Q4NEVRSU52dzJuUjJqTnZlWjFYV09saVVyS2ZqSEh0ZnZPL241NlVTdUk0dwp1MkxUbElDUmNqNGcrWldsSWplTUZrR3lQYkp5SkFRNjVQMnNHclptMWtsR0dIM216d081Q1AxeVpXdm9VampQCmp6U2pNQ0lhSy9mUjhlUkFKNnExdFQ2YkcyNkwrbmprS0NRRFdLcGpBV09hcHVST2Niaz0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=
</code></pre>

<p>然后针对该文件数据做base64解码，得到client certificate文件：</p>

<pre><code>cat admin-client-certificate.txt | base64 -d &gt; admin-client.crt

# cat admin-client.crt

-----BEGIN CERTIFICATE-----
MIIC8jCCAdqgAwIBAgIIf2dVRjm8ELQwDQYJKoZIhvcNAQELBQAwFTETMBEGA1UE
AxMKa3ViZXJuZXRlczAeFw0xODA1MTQwODE3MTNaFw0xOTA1MTQwODE3MTdaMDQx
FzAVBgNVBAoTDnN5c3RlbTptYXN0ZXJzMRkwFwYDVQQDExBrdWJlcm5ldGVzLWFk
bWluMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxBn3jdw80b1Gfb6s
w2NrqpLotMT4nyAf2HhqMrXjnO+wnaK1AITOw/22mDj0rwIuJwdQIj5/BaF63pPE
1pU0vhIPVK4n6JI4dmMzo/lR3jZpGeZW1zdXaCovw9c7clbiHo/mFG4xqytVLfX4
/S8mFp2A9QcieJGIo5S0BR3FZlU1PM7DRbLDVVq1PdyNY2GfsbGrHlGgXvWAKCd/
H79gAqVoTXjSIWCVYuYcoLvdvVXQSIiYlpXFP1jBQLvcU7vrqtb12RmrxnpkW4pl
dGEOX2sLmfYZ5TiFpkRwz2GxsmWyRbt6OuISJFI6RZ0r+Rn4yMDKPrYlEngDVc5K
PZ5zmwIDAQABoycwJTAOBgNVHQ8BAf8EBAMCBaAwEwYDVR0lBAwwCgYIKwYBBQUH
AwIwDQYJKoZIhvcNAQELBQADggEBAEZNTvTz2OgzCUdvMFbrhPsp+mD2vPjMRCxi
3BkA10vICOSfdymMn8aw0IbKYz2gQbXqUfqzQmQfa3if+QYBkB+77zfsv9am4EP/
e6Tg52tqV2P7s2eF7tNAe20GyV6yFlQ1QUW5/M4M+JMlV+BUbl9yEyQlENucKf+u
TPyKKTUtzvUYr5E3EJkt84EQINvw2nR2jNveZ1XWOliUrKfjHHtfvO/n56USuI4w
u2LTlICRcj4g+ZWlIjeMFkGyPbJyJAQ65P2sGrZm1klGGH3mzwO5CP1yZWvoUjjP
jzSjMCIaK/fR8eRAJ6q1tT6bG26L+njkKCQDWKpjAWOapuROcbk=
-----END CERTIFICATE-----
</code></pre>

<p>查看证书内容：</p>

<pre><code># openssl x509 -in ./admin-client.crt -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 9180400125522743476 (0x7f67554639bc10b4)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=kubernetes
        Validity
            Not Before: May 14 08:17:13 2018 GMT
            Not After : May 14 08:17:17 2019 GMT
        Subject: O=system:masters, CN=kubernetes-admin
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)

   ... ...
</code></pre>

<p>从证书输出的信息中，我们看到了下面这行：</p>

<pre><code>Subject: O=system:masters, CN=kubernetes-admin
</code></pre>

<p>k8s apiserver对kubectl的请求进行client certificate验证，验证通过后kube-apiserver会得到：group = system:masters的http上下文信息，并传给后续的authorizers。</p>

<h4 id="2-bearer-token">2、bearer token</h4>

<blockquote>
<p>Service Account Token</p>
</blockquote>

<p>service account是使用Bearer Token认证的，不过和前面的Token不一样的是service account是基于JWT(JSON Web Token)认证机制，JWT原理和x509证书认证其实有点类似，都是通过CA根证书进行签名和校验，只是格式不一样而已，JWT由三个部分组成，每个部分由.分割，三个部分依次如下:</p>

<ul>
<li>Header（头部）: Token的元数据，如alg表示签名算法，typ表示令牌类型，一般为JWT，kid表示Token ID等。</li>
<li>Payload（负载): 实际存放的用户凭证数据，如iss表示签发人，sub签发对象，exp过期时间等。</li>
<li>Signature（签名）：基于alg指定的算法生成的数字签名，为了避免被篡改和伪造。</li>
</ul>

<p>为了便于HTTP传输，JWT Token在传递过程中会转成Base64URL编码，其中Base64URL相对我们常用的Base64编码不同的是<code>=被省略、+替换成-，/替换成_</code>，这么做的原因是因为这些字符在URL里面有特殊含义。</p>

<p>可以用如下脚本实现Kubernetes Service Account的Token解码:</p>

<pre><code>#!/bin/bash

# base64url解码
decode_base64_url() {
  LEN=$((${#1} % 4))
  RESULT=&quot;$1&quot;
  if [ $LEN -eq 2 ]; then
    RESULT+='=='
  elif [ $LEN -eq 3 ]; then
    RESULT+='='
  fi
  echo &quot;$RESULT&quot; | tr '_-' '/+' | base64 -d
}

# 解码JWT
decode_jwt()
{
  JWT_RAW=$1
  for line in $(echo &quot;$JWT_RAW&quot; | awk -F '.' '{print $1,$2}'); do
    RESULT=$(decode_base64_url &quot;$line&quot;)
    echo &quot;$RESULT&quot; | python -m json.tool
  done
}

# 获取k8s sa token
get_k8s_sa_token()
{
  NAME=$1
  TOKEN_NAME=$(kubectl get sa &quot;$NAME&quot; -o jsonpath='{.secrets[0].name}')
  kubectl get secret &quot;${TOKEN_NAME}&quot; -o jsonpath='{.data.token}' | base64 -d
}

main()
{
  NAME=$1
  if [[ -z $NAME ]]; then
    echo &quot;Usage: $0 &lt;secret_name&gt;&quot;
    exit 1
  fi
  TOKEN=$(get_k8s_sa_token &quot;$NAME&quot;)
  decode_jwt &quot;$TOKEN&quot;
}

main &quot;$@&quot;
</code></pre>

<p>从解码的数据可见，JWT Token的颁发机构为kubernetes/serviceaccount,颁发对象为SA对应的虚拟用户system:serviceaccount:default:test，除此之外还存储着其他的SA信息，如SA name、namespace、uuid等。这里需要注意的是我们发现JWT Token中没有exp字段，即意味着只要这个SA存在，这个Token就是永久有效的。</p>

<p>通过如下方式配置kubeconfig:</p>

<pre><code>TOKEN_NAME=$(kubectl get serviceaccounts ${SA_NAME} -n ${namespace} -o jsonpath={.secrets[0].name})
TOKEN=$(kubectl get secret &quot;${TOKEN_NAME}&quot; -n ${namespace} -o jsonpath={.data.token} | base64 -d)
kubectl config set-credentials &quot;${USERNAME}&quot; --token=&quot;$TOKEN&quot;
</code></pre>

<p>为了验证test-sa，在刚刚创建的int32bit-rolebinding的subjects增加了ServiceAccount test-sa。和预期一样，test-sa能够读取pod列表但没有删除pod权限。</p>

<p>service account除了可以用于集群外认证外，其还有一个最大的特点是可以通过Pod.spec.serviceAccountName把token attach到Pod中。在 Pod的Spec 中指明 ServiceAccount ，service account本来是系统服务使用的账户，当我们创建service account时，它会自带一个secret，这个secret就是token。我们通过这个token就能来访问 ApiServer，访问系统资源。</p>

<p>此时Kubernetes会自动把SA的Token通过volume的形式挂载到/run/secrets/kubernetes.io/serviceaccount目录上，从而Pod可以读取token调用Kubernetes API.</p>

<p>到这里为止，service account可能是Kubernetes目前最完美的认证方案了，既能支持集群外的客户端认证，又支持集群内的Pod关联授权。</p>

<p>但事实上，service account并不是设计用来给普通user认证的，默认enabled，通常被 pod 所使用,是给集群内部服务使用的，目前虽然token是永久有效的。</p>

<blockquote>
<p>Bootstrap Tokens</p>
</blockquote>

<p>bootstrap token则是由Kubernetes动态生成的，通过Secret形式存储，并且具有一定的生命周期，一旦过期就会失效。不像静态token，只要启动参数不变，token就不会变化。</p>

<p>我们使用kubeadm会生成一个token:</p>

<pre><code># kubeadm token list
TOKEN                     TTL       EXPIRES                USAGES                   DESCRIPTION   EXTRA GROUPS
bpjp71.6ckt2g3o3hso3gn4   23h       2019-12-15T11:58:13Z   authentication,signing   &lt;none&gt;        system:bootstrappers:kubeadm:default-node-token
</code></pre>

<p>Token有两个部分组成，由.分割，前面部分为Token ID bpjp71，后面部分为Token Secret 6ckt2g3o3hso3gn4。Token默认TTL为一天，对应的group为system:bootstrappers:kubeadm:default-node-token，对应User为system:bootstrap:${Token ID}。</p>

<p>kubeadm创建一个Token会对应在Kubernetes的kube-system namespace创建一个secret，secret名为bootstrap-token-${TOKEN_ID}，这里为bootstrap-token-bpjp71。</p>

<pre><code># kubectl get secret bootstrap-token-bpjp71 -n kube-system -o yaml --export
apiVersion: v1
data:
  auth-extra-groups: c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=
  expiration: MjAxOS0xMi0xNVQxMTo1ODoxM1o=
  token-id: YnBqcDcx
  token-secret: NmNrdDJnM28zaHNvM2duNA==
  usage-bootstrap-authentication: dHJ1ZQ==
  usage-bootstrap-signing: dHJ1ZQ==
kind: Secret
metadata:
  name: bootstrap-token-bpjp71
type: bootstrap.kubernetes.io/token
</code></pre>

<p>此时可以通过如下命令生成config:</p>

<pre><code>kubectl config set-credentials bootstrap \
  --user bootstrap \
  --token bpjp71.6ckt2g3o3hso3gn4
</code></pre>

<p>为了验证boostrap token，我们把用户添加到int32bit-role中，注意对应的虚拟User名。</p>

<pre><code># kubectl  describe  rolebindings int32bit-rolebinding
Name:         int32bit-rolebinding
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Role:
  Kind:  Role
  Name:  int32bit-role
Subjects:
  Kind   Name                     Namespace
  ----   ----                     ---------
  Group  int32bit
  User   system:bootstrap:bpjp71
</code></pre>

<p>这种token主要用于临时授权使用，比如kubeadm初始化集群时会生成一个bootstrap token，这个token具有创建certificatesigningrequests权限，从而新Node能够发起CSR请求，请求客户端证书。</p>

<blockquote>
<p>Static Token</p>
</blockquote>

<p>静态token认证和静态密码原理几乎完全一样，唯一不同的是静态token通过token-auth-file指定token文件，文件内容也是和静态密码一样，认证时头部格式为Authorization: Bearer ${Token}，</p>

<p>因此其优点和缺点也和静态密码完全一样，这里不再赘述。</p>

<h4 id="3-http-basic-auth">3、HTTP Basic Auth</h4>

<p>静态密码是最简单的认证方式，只需要在api-server启动时指定使用的密码本路径即可:</p>

<pre><code>--basic-auth-file=/etc/static_secret/passwd

Static Password File: 以参数 --basic-auth-file=&lt;SOMEFILE&gt; 指明 basic auth file 的位置。
这个 basic auth file 以 csv 文件的形式存在，里面至少包含三个信息：password、username、uid（user id）、group（一些k8s常用的系统角色），比如NoMoreSecret,int32bit-1,1000,&quot;int32bit&quot; ，此时定义了一个用户int32bit-1，静态密码为NoMoreSecret，所属Group为intt32bit。
</code></pre>

<p>使用http请求认证的时候，认证头部为Basic base64encode(${username}:${password})。</p>

<p>通过静态密码的唯一优势是简单，其缺点也是非常明显:</p>

<ul>
<li>静态密码是明文，非常不安全，还有可能被暴力破解。</li>
<li>非常不灵活，增加或者删除用户，必须手动修改静态密码文件并重启所有的api-server服务。</li>
</ul>

<p>这种方式在实际场景中很少被使用，不建议生产环境使用。</p>

<h4 id="集成外部认证系统">集成外部认证系统</h4>

<p>Kubernetes最强大的功能是支持集成第三方Id Provider（IdP），主流的如AD、LADP以及OpenStack Keystone等，毕竟专业的人做专业的事。</p>

<!--
>通过OpenID Connect集成keycloak认证系统


当前支持OpenID Connect的产品有很多，如:

    Keycloak
    UAA
    Dex
    OpenUnison

1、keycloak配置

由于Kubernetes要求必须是https，测试环境需要签发自己的CA，参考为Kubernetes 搭建支持 OpenId Connect 的身份认证系统:

    #!/bin/bash
    mkdir -p ssl
    cat << EOF > ssl/ca.cnf
    [req]
    req_extensions = v3_req
    distinguished_name = req_distinguished_name

    [req_distinguished_name]

    [ v3_req ]
    basicConstraints = CA:TRUE
    EOF
    cat << EOF > ssl/req.cnf
    [req]
    req_extensions = v3_req
    distinguished_name = req_distinguished_name

    [req_distinguished_name]

    [ v3_req ]
    basicConstraints = CA:FALSE
    keyUsage = nonRepudiation, digitalSignature, keyEncipherment
    subjectAltName = @alt_names

    [alt_names]
    IP.1 = 192.168.193.172
    EOF

    openssl genrsa -out ssl/ca-key.pem 2048
    openssl req -x509 -new -nodes -key ssl/ca-key.pem -days 365 -out ssl/ca.pem -subj "/CN=keycloak-ca" -extensions v3_req -config ssl/ca.cnf

    openssl genrsa -out ssl/keycloak.pem 2048
    openssl req -new -key ssl/keycloak.pem -out ssl/keycloak-csr.pem -subj "/CN=keycloak" -config ssl/req.cnf
    openssl x509 -req -in ssl/keycloak-csr.pem -CA ssl/ca.pem -CAkey ssl/ca-key.pem -CAcreateserial -out ssl/keycloak.crt -days 365 -extensions v3_req -extfile ssl/req.cnf

    # 生成 keystore 并导入 keypair
    openssl pkcs12 -export -out ssl/keycloak.p12 -inkey ssl/keycloak.pem -in ssl/keycloak.crt -certfile ssl/ca.pem
    keytool -importkeystore -deststorepass 'noMoreSecret' -destkeystore ssl/keycloak.jks -srckeystore ssl/keycloak.p12 -srcstoretype PKCS12

由于没有配置固定域名，因此添加了alt_names并指定IP。

最后复制ssl/keycloak.p12到如下两个路径:

    cp ssl/keycloak.p12 keycloak-8.0.1/standalone/configuration/keycloak.jks
    cp ssl/keycloak.p12 /etc/kubernetes/pki/

2、keycloak认证信息配置

登录keycloak管理页面创建一个realm以及client，名称都为int32bit-kubernetes。其中realm类似namespace概念，实现了多租户模型，client对应一个认证主体，所有使用keycloak认证的都需要创建一个对应的client。


每个client会对应有一个secret，这二者关系就是access key和access secret关系:


接下来通过Web管理页面执行如下操作：

    在Roles中创建两个role分别为int32bit-kubernetes-cluster-admin、int32bit-kubernetes-readonly。
    在Users中创建两个用户k8s-admin、k8s-readonlly。
    k8s-admin关联int32bit-kubernetes-cluster-admin role，k8s-readonlly关联int32bit-kubernetes-readonly role。

注: 管理员可以在User的Credentials面板中设置用户密码。

通过curl检查是否可认证获取token:

    curl -sSLk \
      -d "client_id=int32bit-kubernetes" \
      -d "client_secret=700eeab2-2f85-45a1-9904-297a0be4d4fd" \
      -d "response_type=code token" \
      -d "grant_type=password" \
      -d "username=k8s-admin" \
      -d "password=noMoreSecret" \
      -d "scope=openid" \
      https://192.168.193.172:8443/auth/realms/int32bit-kubernetes/protocol/openid-connect/token

其中返回的id_token，在后面Kubernetes对接中非常重要，它也是一个JWT Token，解码后的内容如下:

    {
      "alg": "RS256",
      "typ": "JWT",
      "kid": "95WIuxaLj99XHhmytuQm4POZztFxYCaw3Pd-KyBGVVQ"
    }
    {
      "jti": "39b94185-045a-4cee-b025-d0e0909d6bfd",
      "exp": 1576466962,
      "nbf": 0,
      "iat": 1576466662,
      "iss": "https://192.168.193.172:8443/auth/realms/int32bit-kubernetes",
      "aud": "int32bit-kubernetes",
      "sub": "95374c54-c47f-42a5-9bb2-2e0e417a9ff2",
      "typ": "ID",
      "azp": "int32bit-kubernetes",
      "auth_time": 0,
      "session_state": "0eafa8ba-6536-4f6a-989f-177e19e4882a",
      "acr": "1",
      "email_verified": false,
      "preferred_username": "k8s-admin"
    }

我们发现id_token默认没有groups信息，为了支持Kubernetes的Group认证，需要在client中添加mappers字段groups。


这里之所以映射User Realm Role，而不是Group MemberShip，是因为Group会在id_token中添加前缀/，如/test-group1,/test-group2，这个暂时没想到怎么处理，或许有更好的办法。

再次生成token_id就会有groups信息了:

    {
      "jti": "39b94185-045a-4cee-b025-d0e0909d6bfd",
      "exp": 1576466962,
      "nbf": 0,
      "iat": 1576466662,
      "iss": "https://192.168.193.172:8443/auth/realms/int32bit-kubernetes",
      "aud": "int32bit-kubernetes",
      "sub": "95374c54-c47f-42a5-9bb2-2e0e417a9ff2",
      "typ": "ID",
      "azp": "int32bit-kubernetes",
      "auth_time": 0,
      "session_state": "0eafa8ba-6536-4f6a-989f-177e19e4882a",
      "acr": "1",
      "email_verified": false,
      "groups": [
        "int32bit-kubernetes-cluster-admin"
      ],
      "preferred_username": "k8s-admin"
    }

3、Kubernetes集成keycloak认证

在api-server中增加如下命令行启动参数:

    - --oidc-issuer-url=https://192.168.193.172:8443/auth/realms/int32bit-kubernetes
    - --oidc-client-id=int32bit-kubernetes
    - --oidc-username-claim=preferred_username
    - --oidc-username-prefix=-
    - --oidc-groups-claim=groups
    - --oidc-ca-file=/etc/kubernetes/pki/keycloak.crt

参数解析

    --oidc-issuer-url路径需要具体到realm，这里为int32bit-kubernetes；
    --oidc-client-id对应client id，前面我们已经创建。
    --oidc-username-claim、--oidc-groups-claim告诉Kubernetes如何从id_token中读取username和groups，根据前面解码后的id_token，我们不难选择。
    --oidc-username-prefix告诉Kubernetes针对这个odic的用户需要添加什么前缀，如果集群同时有多个认证系统，建议添加个前缀加以区分，如指定前缀为odic:，则Kubernetes对应的User为odic: preferred_username。
    --oidc-ca-file指定keycloak的根证书，因为不是权威证书，不指定则不会信任该证书。

前面创建了两个用户，与Role的关联关系如下:

    k8s-admin: int32bit-kubernetes-cluster-admin
    k8s-readonly: int32bit-kubernetes-readonly

相对应的在Kubernetes创建两个clusterrolebinging:

cluster-admin:

    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      annotations:
        rbac.authorization.kubernetes.io/autoupdate: "true"
      labels:
        kubernetes.io/bootstrapping: rbac-defaults
      name: cluster-admin
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: cluster-admin
    subjects:
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: system:masters
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: int32bit-kubernetes-cluster-admin
    cluster-readonly:

    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      annotations:
        rbac.authorization.kubernetes.io/autoupdate: "true"
      labels:
        kubernetes.io/bootstrapping: rbac-defaults
      name: cluster-readonly
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: view
    subjects:
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: int32bit-kubernetes-readonly

4、使用OpenId Connect认证

生成config文件:

    kubectl config set-credentials oidc \
       --auth-provider=oidc \
       --auth-provider-arg=idp-issuer-url=https://192.168.193.172:8443/auth/realms/int32bit-kubernetes \
       --auth-provider-arg=client-id=int32bit-kubernetes \
       --auth-provider-arg=client-secret=700eeab2-2f85-45a1-9904-297a0be4d4fd

为了便于登录，下载kube-login插件:

    kubectl krew install oidc-login

此时可以直接通过如下命令进行登录:

    kubectl oidc-login --username username --password password

如果是图形界面，不指定参数直接使用kubectl oidc-login可自动打开浏览器进行登录校验。


可见使用k8s-admin具有所有权限，而k8s-readonly只有list的权限。

>通过webhook集成OpenStack Keystone

webhook和odic一样也是集成外部认证系统的一种方式，当client发起api-server请求时会触发webhook服务TokenReview调用，webhook会检查用户的凭证信息，如果是合法则返回authenticated": true等信息。api-server会等待webhook服务返回，如果返回的authenticated结果为true，则表明认证成功，否则拒绝访问。

1、OpenStack Keystone配置

为了后续测试，我们在Keystone创建如下资源:

    #!/bin/bash
    openstack project create int32bit-kubernetes
    USERS_AND_ROLES=(k8s-admin k8s-viewer)
    for i in "${USERS_AND_ROLES[@]}"; do
      openstack user create --project int32bit-kubernetes --password noMoreSecret "$i"
      openstack role create "$i"
      openstack role add --user "$i" --project int32bit-kubernetes "$i"
    done

其中k8s-admin user关联k8s-admin role，k8s-viewer user关联k8s-viewer role，我们根据不同role角色设置不同的权限：

    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: k8s-auth-policy
      namespace: kube-system
    data:
      policies: |
        [
          {
            "resource": {
              "verbs": ["get", "list", "watch"],
              "resources": ["*"],
              "version": "*",
              "namespace": "default"
            },
            "match": [
              {
                "type": "role",
                "values": ["k8s-viewer", "k8s-admin"]
              },
              {
                "type": "project",
                "values": ["int32bit-kubernetes"]
              }
            ]
          },
          {
            "resource": {
              "verbs": ["create", "update", "delete"],
              "resources": ["*"],
              "version": "*",
              "namespace": "default"
            },
            "match": [
              {
                "type": "role",
                "values": ["k8s-admin"]
              },
              {
                "type": "project",
                "values": ["int32bit-kubernetes"]
              }
            ]
          }
        ]

如上policy配置中，k8s-viewer只允许读namesapce default的资源，而k8s-admin允许create、update以及delete等所有权限。

创建如上configmap:

    kubectl apply -f keystone-auth.yaml

2、配置k8s-keystone-auth webhook插件

安装和配置k8s-keystone-auth可参考官方文档k8s-keystone-auth

安装完后验证webhook认证结果:

    #!/bin/bash
    keystone_auth_service_addr=$(kubectl get svc keystone-auth -o jsonpath={.spec.clusterIP})
    token=$(openstack token issue -f shell | awk -F '=' '/^id=.*/{print $2}' | tr -d '"')
    cat <<EOF | curl -ks -XPOST -d @- https://${keystone_auth_service_addr}:8443/webhook | python -mjson.tool
    {
      "apiVersion": "authentication.k8s.io/v1beta1",
      "kind": "TokenReview",
      "metadata": {
        "creationTimestamp": null
      },
      "spec": {
        "token": "$token"
      }
    }
    EOF

输出如果authenticated": true则说明认证成功。

当然也可以验证webhook的授权，如验证k8s-viewer是否具有list pods权限:

    keystone_auth_service_addr=$(kubectl get svc keystone-auth -o jsonpath={.spec.clusterIP})
    cat <<EOF | curl -ks -XPOST -d @- https://${keystone_auth_service_addr}:8443/webhook | python -mjson.tool
    {
      "apiVersion": "authorization.k8s.io/v1beta1",
      "kind": "SubjectAccessReview",
      "spec": {
        "resourceAttributes": {
          "namespace": "default",
          "verb": "list",
          "group": "",
          "resource": "pods"
        },
        "user": "k8s-viewer",
        "group": ["423d41d3a02f4b77b4a9bbfbc3a1b3c6"],
        "extra": {
            "alpha.kubernetes.io/identity/project/id": ["7c266ba4f14d4a64bda0b6b562f2cd60"],
            "alpha.kubernetes.io/identity/project/name": ["int32bit-kubernetes"],
            "alpha.kubernetes.io/identity/roles": ["k8s-viewer"]
        }
      }
    }
    EOF

如果输出"allowed": true，则说明具有list pods权限。

3、配置Kubernetes使用keystone webhook

按照官方文档，创建webhook conf文件:

    keystone_auth_service_addr=$(kubectl get svc keystone-auth -o jsonpath={.spec.clusterIP})
    cat <<EOF > /etc/kubernetes/pki/webhookconfig.yaml
    ---
    apiVersion: v1
    kind: Config
    preferences: {}
    clusters:
      - cluster:
          insecure-skip-tls-verify: true
          server: https://${keystone_auth_service_addr}:8443/webhook
        name: webhook
    users:
      - name: webhook
    contexts:
      - context:
          cluster: webhook
          user: webhook
        name: webhook
    current-context: webhook
    EOF

修改api-server配置文件:

    sed -i '/image:/ i \ \ \ \ - --authentication-token-webhook-config-file=/etc/kubernetes/pki/webhookconfig.yaml' /etc/kubernetes/manifests/kube-apiserver.yaml
    sed -i '/image:/ i \ \ \ \ - --authorization-webhook-config-file=/etc/kubernetes/pki/webhookconfig.yaml' /etc/kubernetes/manifests/kube-apiserver.yaml
    sed -i "/authorization-mode/c \ \ \ \ - --authorization-mode=Node,Webhook,RBAC" /etc/kubernetes/manifests/kube-apiserver.yaml

如上开启了基于Webhook授权功能，如果仅使用Keystone认证而不使用Keystone授权，可以不开启。

4、使用Keystone认证

下载webhook插件，用于请求认证时获取keystone token：

    curl -sSL https://api.nz-por-1.catalystcloud.io:8443/v1/AUTH_b23a5e41d1af4c20974bf58b4dff8e5a/lingxian-public/client-keystone-auth -o ~/keystone/client-keystone-auth
    chmod +x ~/keystone/client-keystone-auth

通过如下脚本生成kubeconfig文件:

    #!/bin/bash
    kubectl config set-cluster "int32bit-kubernetes" \
      --certificate-authority="/etc/kubernetes/pki/ca.crt" \
      --server https://192.168.193.172:6443 \
      --embed-certs=true \
      --kubeconfig=keystone@int32bit-kubernetes.config

    kubectl config set-credentials keystone \
      --kubeconfig keystone@int32bit-kubernetes.config
    sed -i '/user: {}/ d' keystone@int32bit-kubernetes.config
    cat <<EOF >> keystone@int32bit-kubernetes.config
      user:
        exec:
          command: "/root/keystone/client-keystone-auth"
          apiVersion: "client.authentication.k8s.io/v1beta1"
    EOF
    kubectl config set-context \
      --cluster=int32bit-kubernetes \
      --user=keystone keystone@int32bit-kubernetes \
      --namespace=default --kubeconfig keystone@int32bit-kubernetes.config
    cp keystone@int32bit-kubernetes.config \
      ~/users-credentials/credentials/

配置完后就可以通过Keystone实现认证了。

    # cat k8s_viewere_openrc
    export OS_DOMAIN_NAME=Default
    export OS_USERNAME=k8s-viewer
    export OS_PASSWORD=noMoreSecret
    export OS_PROJECT_NAME=int32bit-kubernetes
    export OS_USER_DOMAIN_NAME=Default
    export OS_PROJECT_DOMAIN_NAME=Default
    export OS_AUTH_URL=http://192.168.193.77:5000/v3
    export OS_IDENTITY_API_VERSION=3
    # source k8s_viewere_openrc
    # kubectl get pod nginx-7cfc94d94-w8tpl
    NAME                    READY   STATUS    RESTARTS   AGE
    nginx-7cfc94d94-w8tpl   1/1     Running   0          13d
    # kubectl delete pod nginx-7cfc94d94-w8tpl
    Error from server (Forbidden): pods "nginx-7cfc94d94-w8tpl" is forbidden: User "k8s-viewer" cannot delete resource "pods" in API group "" in the namespace "default"
    可见k8s-viewer用户可以查看pod但没有删除pod的权限。

    # cat k8s_admin_openrc
    export OS_DOMAIN_NAME=Default
    export OS_USERNAME=k8s-admin
    export OS_PASSWORD=noMoreSecret
    export OS_PROJECT_NAME=int32bit-kubernetes
    export OS_USER_DOMAIN_NAME=Default
    export OS_PROJECT_DOMAIN_NAME=Default
    export OS_AUTH_URL=http://192.168.193.77:5000/v3
    export OS_IDENTITY_API_VERSION=3
    # source  k8s_admin_openrc
    # kubectl get pod nginx-7cfc94d94-w8tpl
    NAME                    READY   STATUS    RESTARTS   AGE
    nginx-7cfc94d94-w8tpl   1/1     Running   0          13d
    # kubectl delete pod nginx-7cfc94d94-w8tpl
    pod "nginx-7cfc94d94-w8tpl" deleted
    k8s-admin用户既可以查看pod，也可以删除pod。

我们可以通过kubectl-access_matrix插件查看权限矩阵:


进一步说明k8s-admin用户具有default namespace的所有权限，而k8s-viewer只具有可读权限。

如果企业已经部署OpenStack，Kubernetes运行在OpenStack平台之上，或者通过Magnum部署，集成Keystone实现Kubernetes认证和授权非常方便，很好地把Kubernetes的认证和授权与OpenStack的认证授权统一管理整合在一块。

>使用外部认证系统的优势

对比前面的认证方式，使用OpenID Connect认证以及基于Webhook的认证方式优势显而易见:

    安全。基于JWT Token交换认证，JWT具有数字签名，可避免伪造。并且相对Service Account JWT，OpenID Connect认证的JWT具有有效期。
    灵活。身份认证和集群本身是松耦合的，通过IDP配置账户信息不需要Kubernetes干预。
    认证功能丰富。可使用企业身份系统的MFA、SSO等功能实现更完善更安全的认证策略。




-->

<h4 id="总结">总结</h4>

<p>1、静态密码和静态token认证策略的优点是非常简单，缺点是非常不安全和不灵活，不推荐使用。</p>

<p>2、x509证书认证本身的安全性保障没有问题，最大的问题是不支持证书回收，意味着一旦证书颁发出去就很难在回收过来。这种认证策略适合集群内部组件之间的认证通信。</p>

<p>3、bootstrap token适合需要临时授权的场景，如集群初始化。</p>

<p>4、service account基于JWT认证，JWT包含的字段比较简单，没有有效期和aud字段，存在安全隐患，不适用于普通用户认证，适用于集群内的Pod向api-server认证，如kube-proxy和flannel需要调用api-server监控service和pod的状态变化。</p>

<p>5、OpenID Connect(oidc)以及webhook可集成企业已有的身份认证系统，如AD、LDAP，其特点是安全、灵活、功能全面，并且身份认证与Kubernetes集群解耦合，非常适用于普通用户的认证，推荐使用。</p>

<h3 id="授权机制-authorization">授权机制（Authorization）</h3>

<p>当用户通过认证后，k8s 的授权机制将对用户的行为等进行授权检查。换句话说，就是对这个请求本身，是否对某资源、某 namespace、某操作有权限限制。</p>

<p>若要开启某种模式，需要在 APIServer 启动时，设置参数 &ndash;authorization-mode=RBAC。授权机制目前有 4 种模式：RBAC、ABAC、Node、Webhook。</p>

<p>比如我们在自定义CRD开发的时候，就需要使用到RBAC对新对象进行授权，才能使用。</p>

<h4 id="1-rbac">1、RBAC</h4>

<p>基于角色的权限访问控制，就是对某个用户赋予某个角色，而这个角色通常决定了对哪些资源拥有怎样的权限。</p>

<p>最基本的概念</p>

<ul>
<li>Role：角色，它其实是一组规则，定义了一组对 Kubernetes API 对象的操作权限。</li>
<li>Subject：被作用者，既可以是“人”，也可以是“机器”，也可以是你在 Kubernetes 里定义的“用户”。</li>
<li>RoleBinding：定义了“被作用者”和“角色”的绑定关系。</li>
</ul>

<p>而这三个概念，其实就是整个 RBAC 体系的核心所在。</p>

<p>首先需要用户，所以我们正常创建sa，然后给他授权</p>

<p>1、创建sa</p>

<p>创建一个 ServiceAccount 很简单，只需要指定其所在 namespace 和 name 即可。</p>

<pre><code>apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: hdls
  name: hdls-sa
</code></pre>

<p>2、定义角色</p>

<p>RBAC 中最重要的概念就是 Role 和 RoleBinding。</p>

<ul>
<li>Role 定义了一组对 Kubernetes API 对象的操作权限。</li>
<li>RoleBinding 则定义的是具体的 ServiceAccount 和 Role 的对应关系。</li>
</ul>

<p>实例</p>

<pre><code>kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: hdls
  name: hdls-role
rules:
- apiGroups: [&quot;&quot;]
  resources: [&quot;pods&quot;]
  verbs: [&quot;get&quot;, &quot;list&quot;]
</code></pre>

<ul>
<li>namespace： 在这里仅限于逻辑上的“隔离”，并不会提供任何实际的隔离或者多租户能力；</li>
<li>rules：定义的是权限规则，允许“被作用者”，对 hdls 下面的 Pod 对象，进行 GET 和 LIST 操作；

<ul>
<li>apiGroups：为 &ldquo;&rdquo; 代表 core API Group；</li>
<li>resources：指的是资源类型</li>
<li>verbs： 指的是具体的操作，当前 Kubernetes（v1.11）里能够对 API 对象进行的所有操作有 &ldquo;get&rdquo;, &ldquo;list&rdquo;, &ldquo;watch&rdquo;, &ldquo;create&rdquo;, &ldquo;update&rdquo;, &ldquo;patch&rdquo;, &ldquo;delete&rdquo;。</li>
</ul></li>
</ul>

<p>3、绑定角色</p>

<p>RoleBinding 则定义的是具体的 ServiceAccount 和 Role 的对应关系。</p>

<pre><code>kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: hdls-rolebinding
  namespace: hdls
subjects:
- kind: ServiceAccount
  name: hdls-sa
  apiGroup: &quot;&quot;
roleRef:
  kind: Role
  name: hdls-role
  apiGroup: &quot;&quot;
</code></pre>

<ul>
<li>这个 RoleBinding 对象里定义了一个 subjects 字段，即“被作用者”。它的类型是 ServiceAccount，就是上面创建的 sa。这个 subjects 还可以是 User 和 Group，User 是指 k8s 里的用户，而 Group 是指 ServiceAccounts。</li>
<li>roleRef 字段是用来直接通过名字，引用我们前面定义的 Role 对象（hdls-role），从而定义了 Subject 和 Role 之间的绑定关系。</li>
</ul>

<p>Role 和 RoleBinding 对象都是 Namespaced 对象，它们只对自己的 Namespace 内的资源有效。</p>

<p>而某个 Role 需要对于非 Namespaced 对象（比如：Node），或者想要作用于所有的 Namespace 的时候，我们需要使用 ClusterRole 和 ClusterRoleBinding 去做授权。</p>

<p>这两个 API 对象的用法跟 Role 和 RoleBinding 完全一样。只不过，它们的定义里，没有了 Namespace 字段。</p>

<p>Kubernetes 已经内置了很多个为系统保留的 ClusterRole，它们的名字都以 system: 开头。一般来说，这些系统级别的 ClusterRole，是绑定给 Kubernetes 系统组件对应的 ServiceAccount 使用的。</p>

<p>Kubernetes 还提供了四个内置的 ClusterRole 来供用户直接使用：</p>

<ul>
<li>cluster-admin：整个集群的最高权限。如果在 ClusterRoleBinding 中使用，意味着在这个集群中的所有 namespace 中的所有资源都拥有最高权限。</li>
<li>admin：管理员权限。如果在 RoleBinding 中使用，意味着在某个 namespace 中，对大部分资源拥有读写权限，包括创建 Role 和 RoleBinding 的权限，但没有对资源 quota 和 namespace 本身的写权限。</li>
<li>edit：写权限。在某个 namespace 中，拥有对大部分资源的读写权限，但没有对 Role 和 RoleBinding 的读写权限。</li>
<li>view：读权限。在某个 namespace 中，仅拥有对大部分资源的读权限，没有对 Role 和 RoleBinding 的读权限，也没有对 seccrets 的读权限。</li>
</ul>

<h4 id="2-abac">2、ABAC</h4>

<p>基于属性的权限访问控制。若要开启该模式，需要在 APIServer 启动时，开启 &ndash;authorization-policy-file=<code>&lt;SOME_FILENAME&gt;</code> 和 &ndash;authorization-mode=ABAC 两个参数。</p>

<p>json 对象的格式来定义权限</p>

<p>与 Yaml 文件一致，必须描述的属性有 apiVersion、kind、spec，而 spec 里描述了具体的用户、资源和行为。看个例子：</p>

<pre><code>{&quot;apiVersion&quot;: &quot;abac.authorization.kubernetes.io/v1beta1&quot;, &quot;kind&quot;: &quot;Policy&quot;, &quot;spec&quot;: {&quot;user&quot;: &quot;bob&quot;, &quot;namespace&quot;: &quot;projectCaribou&quot;, &quot;resource&quot;: &quot;pods&quot;, &quot;readonly&quot;: true}}
</code></pre>

<p>这就描述了用户 bob 只有在 namespace projectCaribou 下对 pod 的读权限。</p>

<h4 id="3-node">3、Node</h4>

<p>Node 授权机制是一种特殊的模式，是 kubelet 发起的请求授权。开启该模式，需要开启参数 &ndash;authorization-mode=Node。</p>

<p>通过启动 &ndash;enable-admission-plugins=&hellip;,NodeRestriction,&hellip;，来限制 kubelet 访问 node，endpoint、pod、service以及secret、configmap、PV 和 PVC 等相关的资源。</p>

<h4 id="4-webhook">4、Webhook</h4>

<p>Webhook 模式是一种 HTTP 回调模式，是一种通过 HTTP POST 方式实现的简单事件通知。该模式需要 APIServer 配置参数 –authorization-webhook-config-file=<code>&lt;SOME_FILENAME&gt;</code>，HTTP 配置文件的格式跟 kubeconfig 的格式类似。</p>

<h3 id="准入控制-admission-controllers">准入控制（Admission Controllers）</h3>

<p>在一个请求通过了认证机制和授权认证后，需要经过最后一层筛查，即准入控制。这个准入控制模块的代码通常在 APIServer 中，并被编译到二进制文件中被执行。这一层安全检查的意义在于，检查该请求是否达到系统的门槛，即是否满足系统的默认设置，并添加默认参数。</p>

<p>准入控制以插件的形式存在
开启的方式为：</p>

<pre><code>kube-apiserver --enable-admission-plugins=NamespaceLifecycle,LimitRanger ...
</code></pre>

<p>关闭的方式为：</p>

<pre><code>kube-apiserver --disable-admission-plugins=PodNodeSelector,AlwaysDeny ...
</code></pre>

<p>常用的准入控制插件有：</p>

<pre><code>AlwaysAdmit：允许所有请求通过，被官方反对，因为没有实际意义；
AlwaysPullImages：将每个 pod 的 image pull policy 改为 always，在多租户的集群被使用；
AlwaysDeny：禁止所有请求通过，被官方反对，因为没有实际意义；
DefaultStorageClass：为每个 PersistentVolumeClaim 创建默认的 PV；
DefaultTolerationSeconds：如果 pod 对污点 node.kubernetes.io/not-ready:NoExecute 和 node.alpha.kubernetes.io/unreachable:NoExecute 没有容忍，为其创建默认的 5 分钟容忍 notready:NoExecute 和unreachable:NoExecute；
LimitRanger：确保每个请求都没有超过其 namespace 下的 LimitRange，如果在 Deployment 中使用了 LimitRange 对象，该准入控制插件必须开启；
NamespaceAutoProvision：检查请求中对应的 namespace 是否存在，若不存在自动创建；
NamespaceExists：检查请求中对应的 namespace 是否存在，若不存在拒绝该请求；
NamespaceLifecycle：保证被删除的 namespace 中不会创建新的资源；
NodeRestriction：不允许 kubelet 修改 Node 和 Pod 对象；
PodNodeSelector：通过读取 namespace 的注解和全局配置，来控制某 namespace 下哪些 label 选择器可被使用；
PodPreset：满足预先设置的标准的 pod 不允许被创建；
Priority：通过 priorityClassName 来决定优先级；
ResourceQuota：保证 namespace 下的资源配额；
ServiceAccount：保证 ServiceAccount 的自动创建，如果用到 ServiceAccount，建议开启；
</code></pre>

<h2 id="dynamic-admission-controllers">dynamic Admission Controllers</h2>

<p>TODO</p>

<h1 id="使用模式">使用模式</h1>

<p>目前最常见的使用姿势</p>

<ul>
<li>某一个服务或业务方要接入进来使用</li>
<li>给他们创建一个 SA，再在 rbac 中创建关联的 role(分配权限)，把这个 SA 丢给他们</li>
</ul>

<p>因为我们不太可能去做云服务平台，对外提供给个人用户，内部服务和业务团队，通过 SA 接入已经足够</p>

<p>这个 SA 创建后，只拥有读取 pod 的权限，也可以限制为只拥有某个 namespace 下的 pod 的权限，你要接入其他用户，再建一个 SA。</p>

<p>kubectl 可以通过 SA 配置访问到 apiserver，我们可以参考kubectl的方式去调用相关的API，这个其实就是云平台做的东西。</p>

<h2 id="内部使用sa">内部使用sa</h2>

<p><strong>创建一个 SA，只拥有读取 pod 的权限，然后通过 kubectl config 的配置去使用这个 SA 访问 apiserver</strong></p>

<p>1、创建sa</p>

<pre><code>MacBook-Pro:exercise chunyinjiang$ cat sa.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: jcy
  name: jcy-sa
MacBook-Pro:exercise chunyinjiang$ kubectl get sa -n jcy
NAME      SECRETS   AGE
default   1         39h
jcy-sa    1         39h
</code></pre>

<p>2、创建role</p>

<pre><code>MacBook-Pro:exercise chunyinjiang$ cat role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
    namespace: jcy
    name: jcy-role
rules:
- apiGroups: [&quot;&quot;]
  resources: [&quot;pods&quot;]
  verbs: [&quot;get&quot;, &quot;list&quot;]
MacBook-Pro:exercise chunyinjiang$ kubectl get role -n jcy
NAME       CREATED AT
jcy-role   2020-06-10T11:29:37Z
</code></pre>

<p>3、创建rolebinding</p>

<pre><code>MacBook-Pro:exercise chunyinjiang$ cat rolebinding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jcy-rolebinding
  namespace: jcy
subjects:
- kind: ServiceAccount
  name: jcy-sa
  apiGroup: &quot;&quot;
roleRef:
  kind: Role
  name: jcy-role
  apiGroup: &quot;&quot;

MacBook-Pro:exercise chunyinjiang$ kubectl get rolebinding -n jcy
NAME              ROLE            AGE
jcy-rolebinding   Role/jcy-role   38h
</code></pre>

<p>4、kubeconfig配置sa</p>

<pre><code>TOKEN_NAME=$(kubectl get serviceaccounts jcy-sa -o jsonpath={.secrets[0].name})
MacBook-Pro:exercise chunyinjiang$ echo $TOKEN_NAME
jcy-sa-token-f5lsr

TOKEN=$(kubectl get secret &quot;${TOKEN_NAME}&quot; -n jcy -o jsonpath={.data.token} | base64 -d)
MacBook-Pro:exercise chunyinjiang$ echo $TOKEN
eyJhbGciOiJSUzI1NiIsImtpZCI6Ilgwa2JRbE5kbFU1UXhRSkZBa0lQX1l4V0VrVkZZbTJVX3hFRS1CbnlRejQifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJqY3kiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlY3JldC5uYW1lIjoiamN5LXNhLXRva2VuLWY1bHNyIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImpjeS1zYSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImFkMjg0NzAxLTFiMWUtNGFkOC1hZWE3LTI5YzgxNDljNDJmOCIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpqY3k6amN5LXNhIn0.DeHgbaW5nDDakGxdV448_BOwrSI_Ez2mI8Ii-aztcZMVYJvo2_tWafAWAGm8s3VROcRxgPH8YroCKnllQBL_odJw55ZWhow_KBfOdAh3yKYbF9rNy2BLCV_n_T_qJdSm6M1eXD4_49dhPr3WqEhB5oDqZCXVpa7D0WExtorkiSctYmzfTFcRz2O8fnGExnhtz05p3HnqjyqpbiZQnP1qx6jJd1zlu4T3zgmmx4BLsqSHNVBhsW4Zhz-RmpO91vYzWQDYK6Mp9Yo97rtZofRy2J-6PJ8eI3RslsueWI_JBRPj8MAV-BwolOwXCgoH5ewGyPUveBPVF7Hqok-e_WaNpQ


kubectl config set-credentials system:serviceaccount:jcy:jcy-sa --token=&quot;$TOKEN&quot;
User &quot;system:serviceaccount:jcy:jcy-sa&quot; set.

kubectl config set-context jcy-context --cluster=minikube --namespace=jcy --user=system:serviceaccount:jcy:jcy-sa

kubectl config use-context jcy-context
</code></pre>

<p>5、验证是否生效，以及是否只有读 pod 的权限</p>

<pre><code>MacBook-Pro:exercise chunyinjiang$ kubectl get pods
No resources found in jcy namespace.
MacBook-Pro:exercise chunyinjiang$ kubectl get pods -n default
Error from server (Forbidden): pods is forbidden: User &quot;system:serviceaccount:jcy:jcy-sa&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;default&quot;
MacBook-Pro:exercise chunyinjiang$ kubectl create ns jay
Error from server (Forbidden): namespaces is forbidden: User &quot;system:serviceaccount:jcy:jcy-sa&quot; cannot create resource &quot;namespaces&quot; in API group &quot;&quot; at the cluster scope
MacBook-Pro:exercise chunyinjiang$ kubectl get sa -n jcy
Error from server (Forbidden): serviceaccounts is forbidden: User &quot;system:serviceaccount:jcy:jcy-sa&quot; cannot list resource &quot;serviceaccounts&quot; in API group &quot;&quot; in the namespace &quot;jcy&quot;
</code></pre>

<h2 id="多租户的实现">多租户的实现</h2>

<p>多租户也是基于sa+rbac的基础上实现的，首先用户信息需要单独的系统进行存储，这个可以接入外部的已经成熟的系统，也可以自己开发，然后每一个真实的用户对应一个sa，这个时候sa就是正在的用户，每个sa在rbac的基础对namespace角色操作进行关联，完成对应用户的权限管理。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="https://kingjcy.github.io/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/cloud/paas/safe/safe/">https://kingjcy.github.io/post/cloud/paas/safe/safe/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/paas/">
                            <i class="fa fa-tags"></i>
                            paas
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/safe/">
                            <i class="fa fa-tags"></i>
                            safe
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/k8s/">
                            <i class="fa fa-tags"></i>
                            k8s
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/cloudnative/">
                            <i class="fa fa-tags"></i>
                            cloudnative
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/cloud/paas/base/kubernetes/k8s-store/">云计算K8s组件系列（八）---- 存储</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2021年08月03日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/docker/docker-image/">云计算容器系列---- Docker image 优化</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2021年07月31日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/kubernetes/k8s-autoscaler/">云计算K8s系列---- K8s autoscaler</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2021年02月04日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/kubernetes/k8s-kruise/">云计算K8s系列---- kruise</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2021年01月17日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/kubernetes/k8s-network-cni/">云计算K8s系列---- 网络CNI</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2021年01月17日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/kubernetes/k8s-controller/">云计算K8s系列---- K8s controller</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年11月24日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/kubernetes/k8s-apiserver/">云计算K8s组件系列（一）---- K8s apiserver 详解</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年10月24日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/kubernetes/k8s-kubelet/">云计算K8s组件系列（四）---- K8s kubelet 详解</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年10月20日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/docker/docker-network/">云计算容器系列---- Docker network</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年10月14日)</span></li><li id="li-rels"><a href="/post/cloud/paas/base/kubernetes/k8s-proxy/">云计算K8s组件系列（五）---- K8s proxy 详解</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年10月13日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/architecture/count/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/cloud/paas/base/docker/docker-principle/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#基础概念">基础概念</a>
<ul>
<li><a href="#用户">用户</a>
<ul>
<li><a href="#service-account">Service Account</a></li>
<li><a href="#用户-1">用户</a></li>
<li><a href="#kubernetes没有用户以及用户组">Kubernetes没有用户以及用户组</a></li>
</ul></li>
<li><a href="#多租户">多租户</a></li>
<li><a href="#安全机制">安全机制</a>
<ul>
<li><a href="#认证机制-authentication">认证机制（Authentication）</a>
<ul>
<li><a href="#1-客户端证书">1、客户端证书</a></li>
<li><a href="#2-bearer-token">2、bearer token</a></li>
<li><a href="#3-http-basic-auth">3、HTTP Basic Auth</a></li>
<li><a href="#集成外部认证系统">集成外部认证系统</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
<li><a href="#授权机制-authorization">授权机制（Authorization）</a>
<ul>
<li><a href="#1-rbac">1、RBAC</a></li>
<li><a href="#2-abac">2、ABAC</a></li>
<li><a href="#3-node">3、Node</a></li>
<li><a href="#4-webhook">4、Webhook</a></li>
</ul></li>
<li><a href="#准入控制-admission-controllers">准入控制（Admission Controllers）</a></li>
</ul></li>
<li><a href="#dynamic-admission-controllers">dynamic Admission Controllers</a></li>
</ul></li>
<li><a href="#使用模式">使用模式</a>
<ul>
<li><a href="#内部使用sa">内部使用sa</a></li>
<li><a href="#多租户的实现">多租户的实现</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2021  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

