<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="java是重c／c&#43;&#43;发展过来的，丢弃了一些复杂的难以理解的特性，如指针，java语言是面向对象的： Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）操作符重载、多继承、自动的强制类型转换。
java是编译成字节码文件，不是可执行文件，最后是需要解释器来解释运行的。
Java 基础语法
大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。
Java标识符 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始
Java修饰符 像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符： 访问控制修饰符 : default, public , protected, private
默认的，也称为 default，在同一包内可见，不使用任何修饰符。 私有的，以 private 修饰符指定，在同一类内可见。 共有的，以 public 修饰符指定，对所有类可见。 受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。  访问控制和继承
请注意以下方法继承的规则：
父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。  非访问控制修饰符 : static,final, abstract, strictfp
static 修饰符，用来创建类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。修饰抽象类或者方法，类似于虚函数修饰符 synchronized 和 volatile 修饰符，主要用于线程的编程。  Java关键字 abstract 抽象方法，抽象类的修饰符 assert 断言条件是否满足 boolean 布尔数据类型 break 跳出循环或者label代码段 byte 8-bit 有符号数据类型 case switch语句的一个条件 catch 和try搭配捕捉异常信息 char 16-bit Unicode字符数据类型 class 定义类 const 未使用 continue 不执行循环体剩余部分 default switch语句中的默认分支 do 循环语句，循环体至少会执行一次 double 64-bit双精度浮点数 else if条件不成立时执行的分支 enum 枚举类型 extends 表示一个类是另一个类的子类 final 表示一个值在初始化之后就不能再改变了 表示方法不能被重写，或者一个类不能有子类 finally 为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。 float 32-bit单精度浮点数 for for循环语句 goto 未使用 if 条件语句 implements 表示一个类实现了接口 import 导入类 instanceof 测试一个对象是否是某个类的实例 int 32位整型数 interface 接口，一种抽象的类型，仅有方法和常量的定义 long 64位整型数 native 表示方法用非java代码实现 new 分配新的类实例 package 一系列相关类组成一个包 private 表示私有字段，或者方法等，只能从类内部访问 protected 表示字段只能通过类或者其子类访问 子类或者在同一个包内的其他类 public 表示共有属性或者方法 return 方法返回值 short 16位数字 static 表示在类级别定义，所有实例共享的 strictfp 浮点数比较使用严格的规则 super 表示基类 switch 选择语句 synchronized 表示同一时间只能由一个线程访问的代码块 this 表示调用当前实例 或者调用另一个构造函数 throw 抛出异常 throws 定义方法可能抛出的异常 transient 修饰不要序列化的字段 try 表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码 void 标记方法不返回任何值 volatile 标记字段可能会被多个线程同时访问，而不做同步 while while循环">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Java - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Java
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2015年04月03日 
                </div>
                <h1 class="post-title">Java</h1>
            </header>

            <div class="post-content">
                <p>java是重c／c++发展过来的，丢弃了一些复杂的难以理解的特性，如指针，java语言是面向对象的：
Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）操作符重载、多继承、自动的强制类型转换。</p>

<p>java是编译成字节码文件，不是可执行文件，最后是需要解释器来解释运行的。</p>

<p>Java 基础语法</p>

<p>大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。
类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。
方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。
主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。</p>

<p>Java标识符
Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。
所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始</p>

<p>Java修饰符
像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：
访问控制修饰符 : default, public , protected, private</p>

<pre><code>默认的，也称为 default，在同一包内可见，不使用任何修饰符。
私有的，以 private 修饰符指定，在同一类内可见。
共有的，以 public 修饰符指定，对所有类可见。
受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。
</code></pre>

<p>访问控制和继承</p>

<p>请注意以下方法继承的规则：</p>

<pre><code>父类中声明为 public 的方法在子类中也必须为 public。
父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
父类中声明为 private 的方法，不能够被继承。
</code></pre>

<p>非访问控制修饰符 : static,final, abstract, strictfp</p>

<pre><code>static 修饰符，用来创建类方法和类变量。
final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
abstract 修饰符，用来创建抽象类和抽象方法。修饰抽象类或者方法，类似于虚函数修饰符
synchronized 和 volatile 修饰符，主要用于线程的编程。
</code></pre>

<p>Java关键字
abstract    抽象方法，抽象类的修饰符
assert  断言条件是否满足
boolean 布尔数据类型
break   跳出循环或者label代码段
byte    8-bit 有符号数据类型
case    switch语句的一个条件
catch   和try搭配捕捉异常信息
char    16-bit Unicode字符数据类型
class   定义类
const   未使用
continue    不执行循环体剩余部分
default switch语句中的默认分支
do  循环语句，循环体至少会执行一次
double  64-bit双精度浮点数
else    if条件不成立时执行的分支
enum    枚举类型
extends 表示一个类是另一个类的子类
final   表示一个值在初始化之后就不能再改变了
表示方法不能被重写，或者一个类不能有子类
finally 为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。
float   32-bit单精度浮点数
for for循环语句
goto    未使用
if  条件语句
implements  表示一个类实现了接口
import  导入类
instanceof  测试一个对象是否是某个类的实例
int 32位整型数
interface   接口，一种抽象的类型，仅有方法和常量的定义
long    64位整型数
native  表示方法用非java代码实现
new 分配新的类实例
package 一系列相关类组成一个包
private 表示私有字段，或者方法等，只能从类内部访问
protected   表示字段只能通过类或者其子类访问
子类或者在同一个包内的其他类
public  表示共有属性或者方法
return  方法返回值
short   16位数字
static  表示在类级别定义，所有实例共享的
strictfp    浮点数比较使用严格的规则
super   表示基类
switch  选择语句
synchronized    表示同一时间只能由一个线程访问的代码块
this    表示调用当前实例
或者调用另一个构造函数
throw   抛出异常
throws  定义方法可能抛出的异常
transient   修饰不要序列化的字段
try 表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码
void    标记方法不返回任何值
volatile    标记字段可能会被多个线程同时访问，而不做同步
while   while循环</p>

<p>Java注释
类似于C/C++，Java也支持单行以及多行注释。注释中的字符将被Java编译器忽略。</p>

<p>接口
在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。
接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>

<p>java对象和类</p>

<p>Java中的类</p>

<pre><code>public class Variable{      ---类
    static int allClicks=0;    // 类变量

    String str=&quot;hello world&quot;;  // 实例变量，成员变量

    public void method(){       ---类方法

        int i =0;  // 局部变量

    }
}
</code></pre>

<p>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</p>

<p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p>

<p>创建对象</p>

<pre><code>public class Puppy{
   public Puppy(String name){
      //这个构造器仅有一个参数：name
      System.out.println(&quot;小狗的名字是 : &quot; + name ); 
   }
   public static void main(String []args){
      // 下面的语句将创建一个Puppy对象
      Puppy myPuppy = new Puppy( &quot;tommy&quot; );
   }
}
</code></pre>

<p>访问实例变量和方法</p>

<pre><code>/* 实例化对象 */
ObjectReference = new Constructor();
/* 访问其中的变量 */
ObjectReference.variableName;
/* 访问类中的方法 */
ObjectReference.MethodName();
</code></pre>

<p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>

<ol>
<li>一个源文件中只能有一个public类</li>
<li>一个源文件可以有多个非public类</li>
<li>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li>
<li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li>
<li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ol>

<p>Import语句</p>

<p>下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类</p>

<pre><code>import java.io.*;
</code></pre>

<p>Java 基本数据类型</p>

<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>

<ol>
<li><p>byte：</p>

<p>byte 数据类型是8位、有符号的，以二进制补码表示的整数；
最小值是 -128（-2^7）；
最大值是 127（2^7-1）；
默认值是 0；
byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
例子：byte a = 100，byte b = -50。</p></li>
</ol>

<p>short：</p>

<pre><code>short 数据类型是 16 位、有符号的以二进制补码表示的整数
最小值是 -32768（-2^15）；
最大值是 32767（2^15 - 1）；
Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
默认值是 0；
例子：short s = 1000，short r = -20000。
</code></pre>

<p>int：</p>

<pre><code>int 数据类型是32位、有符号的以二进制补码表示的整数；
最小值是 -2,147,483,648（-2^31）；
最大值是 2,147,483,647（2^31 - 1）；
一般地整型变量默认为 int 类型；
默认值是 0 ；
例子：int a = 100000, int b = -200000。
</code></pre>

<p>long：</p>

<pre><code>long 数据类型是 64 位、有符号的以二进制补码表示的整数；
最小值是 -9,223,372,036,854,775,808（-2^63）；
最大值是 9,223,372,036,854,775,807（2^63 -1）；
这种类型主要使用在需要比较大整数的系统上；
默认值是 0L；
例子： long a = 100000L，Long b = -200000L。
&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。
</code></pre>

<p>float：</p>

<pre><code>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
float 在储存大型浮点数组的时候可节省内存空间；
默认值是 0.0f；
浮点数不能用来表示精确的值，如货币；
例子：float f1 = 234.5f。
</code></pre>

<p>double：</p>

<pre><code>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；
浮点数的默认类型为double类型；
double类型同样不能表示精确的值，如货币；
默认值是 0.0d；
例子：double d1 = 123.4。
</code></pre>

<p>boolean：</p>

<pre><code>boolean数据类型表示一位的信息；
只有两个取值：true 和 false；
这种类型只作为一种标志来记录 true/false 情况；
默认值是 false；
例子：boolean one = true。
</code></pre>

<p>char：</p>

<pre><code>char类型是一个单一的 16 位 Unicode 字符；
最小值是 \u0000（即为0）；
最大值是 \uffff（即为65,535）；
char 数据类型可以储存任何字符；
例子：char letter = 'A';。
</code></pre>

<p>引用类型</p>

<p>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。</p>

<p>Java常量</p>

<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p>

<pre><code>final double PI = 3.1415927;
</code></pre>

<p>虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>

<p>java常用特殊字符和c一样</p>

<pre><code>\n  换行 (0x0a)
\r  回车 (0x0d)
</code></pre>

<p>自动类型转换</p>

<p>数据类型转换必须满足如下规则：</p>

<ol>
<li>不能对boolean类型进行类型转换。</li>
<li>不能把对象类型转换成不相关类的对象。</li>
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
<li>转换过程中可能导致溢出或损失精度，</li>
</ol>

<p>强制类型转换</p>

<pre><code>byte b = (byte)i1;//强制类型转换为byte
</code></pre>

<p>Java 变量类型</p>

<p>在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p>

<pre><code>type identifier [ = value][, identifier [= value] ...] ;
</code></pre>

<p>格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。</p>

<p>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p>

<pre><code>int a, b, c;         // 声明三个int型整数：a、 b、c
int d = 3, e = 4, f = 5; // 声明三个整数并赋予初值
byte z = 22;         // 声明并初始化 z
String s = &quot;runoob&quot;;  // 声明并初始化字符串 s
double pi = 3.14159; // 声明了双精度浮点型变量 pi
char x = 'x';        // 声明变量 x 的值是字符 'x'。
</code></pre>

<p>java运算符</p>

<p>基本运算符和c++是一样的。</p>

<p>instanceof 运算符</p>

<p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>

<pre><code>String name = &quot;James&quot;;
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
</code></pre>

<p>如果被比较的对象兼容于右侧类型,该运算符仍然返回true。</p>

<p>java语句</p>

<p>基本上顺序循环条件都和c++一样。</p>

<p>for循环中多了一个下面的使用方式</p>

<p>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。
表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</p>

<pre><code>Test.java 文件代码：
public class Test {
   public static void main(String args[]){
      int [] numbers = {10, 20, 30, 40, 50};

      for(int x : numbers ){
         System.out.print( x );
         System.out.print(&quot;,&quot;);
      }
      System.out.print(&quot;\n&quot;);
      String [] names ={&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;};
      for( String name : names ) {
         System.out.print( name );
         System.out.print(&quot;,&quot;);
      }
   }
}
</code></pre>

<p>java提供了number，math，character，string，StringBuffer，StringBuilder的类，是一种装箱的过程，将对应的类对象转化为支持的数据类型是一种拆箱的过程。</p>

<p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>

<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>

<p>数组在每一个语言中都占有很重要的位置。java中和c++中基本差不多，提倡以下声明方式</p>

<pre><code>double[] myList;
</code></pre>

<p>当然也兼容c++的声明方式</p>

<pre><code>double myList[];
</code></pre>

<p>创建数组</p>

<pre><code>arrayRefVar = new dataType[arraySize];
</code></pre>

<p>在java中对数组的处理提出了一种foreach的使用方式，类似于go中的range，就是for循环的另外一种用法。同时java也提供了arrays类。</p>

<p>Java 日期时间
java.util 包提供了 Date 类来封装当前的日期和时间。</p>

<p>获取当前日期时间
Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示：</p>

<pre><code>import java.util.Date;

public class DateDemo {
   public static void main(String args[]) {
       // 初始化 Date 对象
       Date date = new Date();

       // 使用 toString() 函数显示日期时间
       System.out.println(date.toString());
   }
}
</code></pre>

<p>java方法就是和c++中的函数一样</p>

<p>特殊函数：</p>

<p>finalize() 方法</p>

<p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>

<p>你可以使用 finalize() 来确保一个对象打开的文件被关闭了。在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p>

<p>finalize() 一般格式是：</p>

<pre><code>protected void finalize()
{
   // 在这里终结代码
}
</code></pre>

<p>关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。</p>

<p>当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。</p>

<p>Java 流(Stream)、文件(File)和IO</p>

<p>Java 的控制台输入由 System.in 完成。
为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。
下面是创建 BufferedReader 的基本语法：
BufferedReader br = new BufferedReader(new
                      InputStreamReader(System.in));
BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p>

<p>控制台的输出由 print( ) 和 println() 完成。还可以使用write（）。</p>

<p>文件主要两个类</p>

<p>FileInputStream 该流用于从文件读取数据，它的对象可以用关键字 new 来创建。</p>

<pre><code>InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);
</code></pre>

<p>FileOutputStream 该类用来创建一个文件并向文件中写数据。</p>

<pre><code>import java.io.*;

public class fileStreamTest{
  public static void main(String args[]){
    try{
      byte bWrite [] = {11,21,3,40,5};
      OutputStream os = new FileOutputStream(&quot;test.txt&quot;);
      for(int x=0; x &lt; bWrite.length ; x++){
      os.write( bWrite[x] ); // writes the bytes
    }
    os.close();

    InputStream is = new FileInputStream(&quot;test.txt&quot;);
    int size = is.available();

    for(int i=0; i&lt; size; i++){
      System.out.print((char)is.read() + &quot;  &quot;);
    }
      is.close();
    }catch(IOException e){
      System.out.print(&quot;Exception&quot;);
    }  
  }
}
</code></pre>

<p>还有一些关于文件和I/O的类，我们也需要知道：
File Class(类)
FileReader Class(类)
FileWriter Class(类)</p>

<p>Java中的目录</p>

<p>File类中有两个方法可以用来创建文件夹：
mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。
mkdirs()方法创建一个文件夹和它的所有父文件夹。</p>

<pre><code>import java.io.File;

public class CreateDir {
  public static void main(String args[]) {
    String dirname = &quot;/tmp/user/java/bin&quot;;
    File d = new File(dirname);
    // 现在创建目录
    d.mkdirs();
  }
}
</code></pre>

<p>Java Scanner 类</p>

<p>Scanner 类来获取用户的输入。通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据</p>

<pre><code>import java.util.Scanner; 

public class ScannerDemo {  
    public static void main(String[] args) {  
        Scanner scan = new Scanner(System.in); 
    // 从键盘接收数据  

    //next方式接收字符串
        System.out.println(&quot;next方式接收：&quot;);
        // 判断是否还有输入
        if(scan.hasNext()){   
          String str1 = scan.next();
          System.out.println(&quot;输入的数据为：&quot;+str1);  
        }  

    }  
}
</code></pre>

<p>如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取：</p>

<pre><code>import java.util.Scanner;  

public class ScannerDemo {  
    public static void main(String[] args) {  
        Scanner scan = new Scanner(System.in);  
    // 从键盘接收数据  
        int i = 0 ;  
        float f = 0.0f ;  
        System.out.print(&quot;输入整数：&quot;);  
        if(scan.hasNextInt()){                 
      // 判断输入的是否是整数  
            i = scan.nextInt() ;                
      // 接收整数  
            System.out.println(&quot;整数数据：&quot; + i) ;  
        }else{                                 
      // 输入错误的信息  
            System.out.println(&quot;输入的不是整数！&quot;) ;  
        }  
        System.out.print(&quot;输入小数：&quot;);  
        if(scan.hasNextFloat()){              
      // 判断输入的是否是小数  
            f = scan.nextFloat() ;             
      // 接收小数  
            System.out.println(&quot;小数数据：&quot; + f) ;  
        }else{                                
      // 输入错误的信息  
            System.out.println(&quot;输入的不是小数！&quot;) ;  
        }  
    }  
}
</code></pre>

<p>java异常处理</p>

<p>所有的异常类是从 java.lang.Exception 类继承的子类。
Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p>

<p>捕获异常
使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。
try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p>

<pre><code>try
{
   // 程序代码
}catch(ExceptionName e1)
{
   //Catch 块
}
</code></pre>

<p>throws/throw 关键字：
如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p>

<p>finally关键字
finally 关键字用来创建在 try 代码块后面执行的代码块。
无论是否发生异常，finally 代码块中的代码总会被执行。
在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p>

<p>声明自定义异常
在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。
所有异常都必须是 Throwable 的子类。
如果希望写一个检查性异常类，则需要继承 Exception 类。
如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。
可以像下面这样定义自己的异常类：
class MyException extends Exception{
}</p>

<p>继承关键字
继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。</p>

<p>extends</p>

<p>类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>

<p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>

<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。
this关键字：指向自己的引用。</p>

<p>final 关键字声明类可以把类定义为不能继承的，即最终类；</p>

<p>重写(Override)
重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>

<p>重载(Overload)
重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>

<p>多态存在的三个必要条件
继承
重写
父类引用指向子类对象</p>

<p>多态的实现方式
方式一：重写：
这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。
方式二：接口
1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。
2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。
方式三：抽象类和抽象方法</p>

<p>抽象类
在Java语言中使用abstract class来定义抽象类。</p>

<p>抽象方法
如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。
Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。
抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。
当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。
多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>

<p>封装的优点
1. 良好的封装能够减少耦合。
2. 类内部的结构可以自由修改。
3. 可以对成员变量进行更精确的控制。
4. 隐藏信息，实现细节。</p>

<p>Java 接口
接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>

<p>Java 包(package)
为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。
包的作用
1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p>

<p>创建包
创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。
包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。
如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p>

<p>import 关键字
为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 &ldquo;import&rdquo; 语句可完成此功能。</p>

<p>Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：
枚举（Enumeration）
位集合（BitSet）
向量（Vector）
栈（Stack）
字典（Dictionary）
哈希表（Hashtable）
属性（Properties）
以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)，包括map，list等等</p>

<p>泛型方法类似于模版。</p>

<p>Java 序列化
Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。
将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p>

<p>类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含序列化和反序列化对象的方法。</p>

<p>java.net 包中提供了两种常见的网络协议的支持：
TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。
UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。</p>

<p>创建一个线程
Java 提供了三种创建线程的方法：
通过实现 Runnable 接口；
通过继承 Thread 类本身；
通过 Callable 和 Future 创建线程。</p>

<p>java文件是以.java为后缀结尾的。
编译后形成的不是可执行文件，是一个字节码文件，以.class结尾，需要jvm才能运行。
也可以直接通过 javac filename 命令完成编译，通过 java classname 命令来运行程序。由此可见javac是编译器，编译后形成的不是可执行文件，是一个字节码文件，以.class结尾，需要jvm才能运行，所以需要java是执行器，如果想偷看jar包内部结构,你可以运行 jar tvf 命令:</p>

<p>jar tvf springboot-practice-1.0.0-SNAPSHOT.jar
运行jar包用</p>

<p>jar -jar    jar包</p>

<p>Java 中主类名应该和要保存的 Java 文件名相同
在Java中，仅仅通过类来定义变量不会分配内存空间，必须使用new关键字来完成内存空间的分配。
如果你希望使用Java包中的类，就必须先使用import语句导入。
要生成包必须先声明package&mdash;-</p>

<p>大体上和c/c++差不多</p>

<p>因此人们常说的Java X=Java SE X=JDK1.X，都是一回事。</p>

<p>eclipse的使用：
已有的项目是用import导入</p>

<p>java开发要求线上环境要和本地一致，才能开发，本地开发好上传，一样的构建</p>

<p>java关键字</p>

<p>abstract    抽象，用于创建抽象类，抽象类是没有用的，必须通过重写来实现
continue    for new switch
assert***   声称
default goto*   package
synchronized    同步
boolean do  if  private this
break   double<br />
implements  实现
protected   throw
byte    else    import  public  throws
case    enum****<br />
instanceof  运算符
return<br />
transient   临时，短暂的
catch   extends int short   try
char</p>

<p>interface   static  void
class<br />
finally 最后
long<br />
strictfp**<br />
volatile    易变的
const*  float<br />
native  本地
super   用于继承时调用父类被隐藏或者覆盖的成员
while</p>

<p>接口 类似于抽象类，但是在接口里，方法是没有方法体的，都是抽象方法。但是在抽象类中，只要有抽象方法的类就是抽象类，也就是可以有方法体的。</p>

<p>接口是用来处理C++中多继承的情况的。java中是没有多继承的，只有单继承</p>

<p>import static java.lang.System.*;</p>

<p>public class Demo{
  public static void main(String[] args) {
      SataHdd sh1=new SeagateHdd(); //初始化希捷硬盘
      SataHdd sh2=new SamsungHdd(); //初始化三星硬盘
  }
}</p>

<p>//串行硬盘接口
interface SataHdd{
    //连接线的数量
    public static final int CONNECT_LINE=4;
    //写数据
    public void writeData(String data);
    //读数据
    public String readData();
}</p>

<p>// 维修硬盘接口
interface fixHdd{
    // 维修地址
    String address = &ldquo;北京市海淀区&rdquo;;
    // 开始维修
    boolean doFix();
}</p>

<p>//希捷硬盘
class SeagateHdd implements SataHdd, fixHdd{
    //希捷硬盘读取数据
    public String readData(){
        return &ldquo;数据&rdquo;;
    }
    //希捷硬盘写入数据
    public void writeData(String data) {
        out.println(&ldquo;写入成功&rdquo;);
    }
    // 维修希捷硬盘
    public boolean doFix(){
        return true;
    }
}
//三星硬盘
class SamsungHdd implements SataHdd{
    //三星硬盘读取数据
    public String readData(){
        return &ldquo;数据&rdquo;;
    }
    //三星硬盘写入数据
    public void writeData(String data){
        out.println(&ldquo;写入成功&rdquo;);
    }
}
//某劣质硬盘，不能写数据
abstract class XXHdd implements SataHdd{
    //硬盘读取数据
    public String readData() {
        return &ldquo;数据&rdquo;;
    }
}</p>

<p>继承  extends</p>

<p>Java中是单继承，可以对父类方法进行重写，重写的注解@Override</p>

<p>Java中的重载也是更具参数的类型和个数进行的。</p>

<p>Java集合类中包含了list，set，map以及对应的其操作，其创建依赖与实现类。当然迭代器依旧重要，其提供的hasnext（），next（）方法十分常用</p>

<p>Java错误处理
try-catch-finally这个是个特色</p>

<p>Java中的输出输入流以及文件流都是和c++差不多的</p>

<p>Jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等
　　War文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对jar文件进行封装，并把它作为小型服务程序（servlet）来访问。
　　Ear文件（扩展名为.Ear,Enterprise Application Archive）包含全部企业应用程序。在这种情形下，一个企业应用程序被定义为多个jar文件、资源、类和Web应用程序的集合。</p>

<p>import导入的是类</p>

<p>jstack可以生成JVM当前时间点的线程快照。线程快照就是当前JVM内每一条线程正在执行的方法堆栈的集合。使用jstack可以打印出Thread Dump是非常有用的诊断Java应用问题的工具1. 查找内存泄露，常见的是程序里load大量的数据到缓存；
2. 发现死锁线程；</p>

<p>Java的堆栈信息从下往上看，最下面的是最外层调用的</p>

<p>Thread Dump分析
通过前面1.4部分的方法，获取Thread Dump信息后，对其进行分析；
3.1 首先介绍一下Thread Dump信息的各个部分
头部信息：
时间，jvm信息
2011-11-02 19:05:06<br />
Full thread dump Java HotSpot&trade; Server VM (16.3-b01 mixed mode):</p>

<p>线程info信息块：
1. &ldquo;Timer-0&rdquo; daemon prio=10tid=0xac190c00 nid=0xaef in Object.wait() [0xae77d000]
2.  java.lang.Thread.State: TIMED_WAITING (on object monitor)
3.  atjava.lang.Object.wait(Native Method)
4.  -waiting on <0xb3885f60> (a java.util.TaskQueue)     ###继续wait
5.  atjava.util.TimerThread.mainLoop(Timer.java:509)
6.  -locked <0xb3885f60> (a java.util.TaskQueue)         ###已经locked
7.  atjava.util.TimerThread.run(Timer.java:462)
* 线程名称：Timer-0
* 线程类型：daemon
* 优先级: 10，默认是5
* jvm线程id：tid=0xac190c00，jvm内部线程的唯一标识（通过java.lang.Thread.getId()获取，通常用自增方式实现。）
* 对应系统线程id（NativeThread ID）：nid=0xaef，和top命令查看的线程pid对应，不过一个是10进制，一个是16进制。（通过命令：top -H -p pid，可以查看该进程的所有线程信息）
* 线程状态：in Object.wait().
* 起始栈地址：[0xae77d000]
* Java thread statck trace：是上面2-7行的信息。到目前为止这是最重要的数据，Java stack trace提供了大部分信息来精确定位问题根源。</p>

<p>对于thread dump信息，主要关注的是线程的状态和其执行堆栈。现在针对这两个重点部分进行讲解：
1）Java thread statck trace详解：
堆栈信息应该逆向解读：程序先执行的是第7行，然后是第6行，依次类推。
- locked <0xb3885f60> (a java.util.ArrayList)
- waiting on <0xb3885f60> (a java.util.ArrayList)
也就是说对象先上锁，锁住对象0xb3885f60，然后释放该对象锁，进入waiting状态。
为啥会出现这样的情况呢？看看下面的java代码示例，就会明白：
synchronized(obj) {<br />
       &hellip;&hellip;&hellip;<br />
       obj.wait();<br />
       &hellip;&hellip;&hellip;<br />
}<br />
在堆栈的第一行信息中，进一步标明了线程在代码级的状态，例如：
java.lang.Thread.State: TIMED_WAITING (parking)
解释如下：
|blocked|
This thread tried to enter asynchronized block, but the lock was taken by another thread. This thread isblocked until the lock gets released.
|blocked (on thin lock)|
This is the same state asblocked, but the lock in question is a thin lock.
|waiting|
This thread calledObject.wait() on an object. The thread will remain there until some otherthread sends a notification to that object.
|sleeping|
This thread calledjava.lang.Thread.sleep().
|parked|
This thread calledjava.util.concurrent.locks.LockSupport.park().
|suspended|
The thread&rsquo;s execution wassuspended by java.lang.Thread.suspend() or a JVMTI agent call.</p>

<p>2) 线程状态详解：
Runnable
<em>The thread is either running or ready to run when it gets its CPU turn.</em></p>

<p>Wait on condition
<em>The thread is either sleeping or waiting to be notified by another thread.</em>
    该状态出现在线程等待某个条件的发生或者sleep。具体是什么原因，可以结合 stacktrace来分析。最常见的情况是线程在等待网络的读写，比如当网络数据没有准备好读时，线程处于这种等待状态，而一旦有数据准备好读之后，线程会重新激活，读取并处理数据。在Java引入 New IO之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在 New IO里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。
    如果发现有大量的线程都处在 Wait on condition，从线程 stack看， 正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。所以要结合系统的一些性能观察工具来综合分析，比如 netstat统计单位时间的发送包的数目，看是否很明显超过了所在网络带宽的限制；观察cpu的利用率，看系统态的CPU时间是否明显大于用户态的CPU时间；如果程序运行在 Solaris 10平台上，可以用dtrace工具看系统调用的情况，如果观察到 read/write的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。另外一种出现 Wait on condition的常见情况是该线程在 sleep，等待 sleep的时间到了，将被唤醒。</p>

<p>Waiting for Monitor Entry and in Object.wait()
<em>The thread is waiting to getthe lock for an object (some other thread may be holding the lock). Thishappens if two or more threads try to execute synchronized code. Note that thelock is always for an object and not for individual methods.</em>
    在多线程的 JAVA程序中，实现线程之间的同步，就要说说 Monitor。 Monitor是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “ActiveThread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态是 “Waiting for monitorentry”，而在 “Wait Set”中等待的线程状态是“in Object.wait()”。
   先看 “Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set”队列。对应的 code就像：
synchronized(obj) {
    &hellip;&hellip;&hellip;
}
这时有两种可能性：
    该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码。
    该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。
    在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。
临界区的设置，是为了保证其内部的代码执行的原子性和完整性。但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。
    再看“Wait Set”里面的线程。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll()，“Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()。
一般，Cpu很忙时，则关注runnable的线程，Cpu很闲时，则关注waiting for monitor entry的线程。</p>

<p>3.2 JVM线程介绍
在Thread Dump中，有一些 JVM内部的后台线程，来执行譬如垃圾回收，或者低内存的检测等等任务，这些线程往往在 JVM初始化的时候就存在，如下所示：
HotSpot VM Thread
被HotSpot VM管理的内部线程为了完成内部本地操作，一般来说不需要担心它们，除非CPU很高。
&ldquo;VM Periodic Task Thread&rdquo; prio=10tid=0xad909400 nid=0xaed waiting on condition</p>

<p>HotSpot GC Thread
当使用HotSpot parallel GC，HotSpot VM默认创建一定数目的GC thread。
&ldquo;GC task thread#0 (ParallelGC)&ldquo;prio=10 tid=0xf690b400 nid=0xade runnable
&ldquo;GC task thread#1 (ParallelGC)&ldquo;prio=10 tid=0xf690cc00 nid=0xadf runnable
&ldquo;GC task thread#2 (ParallelGC)&ldquo;prio=10 tid=0xf690e000 nid=0xae0 runnable
⋯⋯
当面对过多GC，内存泄露等问题时，这些是关键的数据。使用native id，可以将从OS/Java进程观测到的高CPU与这些线程关联起来。</p>

<p>JNI global references count
JNI global reference是基本的对象引用，从本地代码到被Java GC管理的Java对象的引用。其角色是阻止仍然被本地代码使用的对象集合，但在Java代码中没有引用。在探测JNI相关内存泄露时，关注JNI references很重要。如果你的程序直接使用JNI或使用第三方工具，如检测工具，检测本地内存泄露。
JNI global references: 832</p>

<p>Java Heap utilization view
从jdk1.6开始在thread dump快照底部，可以找到崩溃点的内存空间利用情况:YongGen,OldGen和PermGen。目前我测试的系统导出的thread dump，还未见到这一部分内容（sun jdk1.6）。以下例子，摘自他人文章：
Heap<br />
 PSYoungGen      total 466944K, used 178734K [0xffffffff45c00000, 0xffffffff70800000, 0xffffffff70800000)<br />
  eden space 233472K, 76% used [0xffffffff45c00000,0xffffffff50ab7c50,0xffffffff54000000)<br />
  from space 233472K, 0% used [0xffffffff62400000,0xffffffff62400000,0xffffffff70800000)<br />
  to   space 233472K, 0% used [0xffffffff54000000,0xffffffff54000000,0xffffffff62400000)<br />
 PSOldGen        total 1400832K, used 1400831K [0xfffffffef0400000, 0xffffffff45c00000, 0xffffffff45c00000)<br />
  object space 1400832K, 99% used [0xfffffffef0400000,0xffffffff45bfffb8,0xffffffff45c00000)<br />
 PSPermGen       total 262144K, used 248475K [0xfffffffed0400000, 0xfffffffee0400000, 0xfffffffef0400000)<br />
  object space 262144K, 94% used [0xfffffffed0400000,0xfffffffedf6a6f08,0xfffffffee0400000)</p>

<p>还有一些其他的线程（如下），不一一介绍了，有兴趣，可查看文章最后的附件信息。
&ldquo;Low Memory Detector&rdquo; daemon prio=10tid=0xad907400 nid=0xaec runnable [0x00000000]
&ldquo;CompilerThread1&rdquo; daemon prio=10tid=0xad905400 nid=0xaeb waiting on condition [0x00000000]
&ldquo;CompilerThread0&rdquo; daemon prio=10tid=0xad903c00 nid=0xaea waiting on condition [0x00000000]
&ldquo;Signal Dispatcher&rdquo; daemon prio=10tid=0xad902400 nid=0xae9 runnable [0x00000000]
&ldquo;Finalizer&rdquo; daemon prio=10tid=0xf69eec00 nid=0xae8 in Object.wait() [0xaf17d000]
&ldquo;Reference Handler&rdquo; daemon prio=10tid=0xf69ed800 nid=0xae7 in Object.wait() [0xae1e7000]
&ldquo;VM Thread&rdquo; prio=10 tid=0xf69e9800nid=0xae6 runnable</p>

<p>java注解</p>

<p>1.JDK本身自带的，比如以下的注解
@Override:重写一个方法
@Deprecated：标示某个方法是过时的
@Suppvisewarnings：忽略注解的提示
2.第三方的注解，比如Spring中的注解
3.自定义注解</p>

<p>使用@interface定义（不理解？我们是不是用class这个关键字定义类呢？）
成员的类型是受限制的，合法的类型只包含以下的几类：
基本类型如int ,String 等
Class,Annotation,Enumeration等
成员必须以无参无异常的方式进行声明
如果只有一个成员需要写成value</p>

<p>元注解，是给注解的注解，包含有以下的四个
1. @Target:标明该注解的使用范围，包含以下的几个范围：</p>

<ul>
<li>构造方法声明：constructor</li>
<li>字段声明：Field</li>
<li>局部变量声明：Local_variable</li>
<li>方法声明：Method</li>
<li>包声明：Method</li>
<li>参数声明：parameter</li>
<li>类接口：type</li>
<li>@Retention：注解的生命周期,包含有以下的几类</li>
</ul>

<ol>
<li>只在源码显示，编译后丢失</li>
<li>编译时会记录到Class中，运行时丢失</li>
<li>运行时存在，可以通过反射获取到</li>

<li><p>@Inherited :此为标识符，标识该注解是否可以被继承</p>

<p>注意：只有Target中含有Type，即类类型的时候才会起作用。</p></li>

<li><p>@Documented：此为标识符，标识该类是否出现在Javadoc中</p></li>
</ol>

<p>举例自定义注解</p>

<p>@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitName {
    String value() default &ldquo;&rdquo;;
}</p>

<p>@FruitName(&ldquo;Apple&rdquo;)
 private String appleName;</p>

<p>J2ee是一种规范，struts、hibernate、spring这三个框架是有名的框架，struts是一个mvc框架，spring是一个全面框架，hibernate是一个专门针对数据库的框架。</p>

<p>java框架spring</p>

<p>就是有一个类似于c++中自己开发框架，只是比较全面，包含多个模块，和c++中的那些有名的库一样的功能，统一应用。该框架的主要优势是其良好的设计和分层架构，软件开发人员可以只选择Spring提供的某项技术，例如AOP，而不需要使用它提供的其它技术。同时，Spring还提供了和其他开源软件的无缝结合，为J2EE应用程序开发提供了集成的框架。</p>

<p>spring mvc</p>

<p>Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts，但Spring的MVC框架使用IoC对控制逻辑和业务对象提供了完全的分离。所以就是一个mvc框架。</p>

<p>第一步：发起请求到前端控制器(DispatcherServlet)
第二步：前端控制器请求HandlerMapping查找 Handler
         可以根据xml配置、注解进行查找
第三步：处理器映射器HandlerMapping向前端控制器返回Handler
第四步：前端控制器调用处理器适配器去执行Handler
第五步：处理器适配器去执行Handler
第六步：Handler执行完成给适配器返回ModelAndView
第七步：处理器适配器向前端控制器返回ModelAndView
         ModelAndView是springmvc框架的一个底层对象，包括Model和view
第八步：前端控制器请求视图解析器去进行视图解析
         根据逻辑视图名解析成真正的视图(jsp)
第九步：视图解析器向前端控制器返回View
第十步：前端控制器进行视图渲染
         视图渲染将模型数据(在ModelAndView对象中)填充到request域
第十一步：前端控制器向用户响应结果</p>

<p>组件：
1、前端控制器DispatcherServlet（不需要程序员开发）
作用接收请求，响应结果，相当于转发器，中央处理器。
有了DispatcherServlet减少了其它组件之间的耦合度。</p>

<p>2、处理器映射器HandlerMapping(不需要程序员开发)
作用：根据请求的url查找Handler，对应对需要配置xml文件</p>

<p>3、处理器适配器HandlerAdapter
作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler</p>

<p>4、处理器Handler(需要程序员开发)
注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</p>

<p>5、视图解析器View resolver(不需要程序员开发)
作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）</p>

<p>6、视图View(需要程序员开发jsp)
View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf&hellip;）</p>

<p>Spring boot是spring的升级简化开发版本，就是已经约定好了默认配置。不需要再像spring那样自己配置很多配置，快速启动的，有两个重要的东西</p>

<p>1.@EnableAutoConfiguration 用于自动配置。简单的说，它会根据你的pom配置（实际上应该是根据具体的依赖）来判断这是一个什么应用，并创建相应的环境。</p>

<p>2.SpringApplication 则是用于从main方法启动Spring应用的类。由于我们使用了 spring-boot-starter-parent POM，所以可以使用 mvn spring-boot:run来启动项目（根路径）。打包就用正常的jar执行：java -jar target/myproject-0.0.1-SNAPSHOT.jar  ，这个类SpringApplication提供了run和一些其他的函数，类似于beego，是一种mvc开发</p>

<p>Spring Boot 不单单从 application.properties 获取配置，所以我们可以在程序中多种设置配置属性。按照以下列表的优先级排列：
1.命令行参数
2.java:comp/env 里的 JNDI 属性
3.JVM 系统属性
4.操作系统环境变量
5.RandomValuePropertySource 属性类生成的 random.* 属性
6.应用以外的 application.properties（或 yml）文件
7.打包在应用内的 application.properties（或 yml）文件
8.在应用 @Configuration 配置类中，用 @PropertySource 注解声明的属性文件
9.SpringApplication.setDefaultProperties 声明的默认属性</p>

<p>Spring boot简化spring的关键之处
自动配置:针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置。
起步依赖:告诉Spring Boot需要什么功能，它就能引入需要的库。
命令行界面:这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。
Actuator:让你能够深入运行中的Spring Boot应用程序，一探究竟</p>

<p>Spring 最初利用“工厂模式”（DI依赖注入）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。所以一般都是两者结合使用</p>

<p>突然发现spring与mybatis整合之后可以只写个接口而不实现，spring默认会帮我们实现，然后觉得非常神奇，将需要的sql写到对应的xml文件中</p>

<p>java内置库
rt.jar是JAVA基础类库，基础数据类型等io.lang.  比如里面有String类Long类等等。
dt.jar是关于运行环境的类库<br />
swing界面工具，
tools.jar是工具类库 编译工具javac</p>

<p>spring</p>

<p>DI，AOP，模版</p>

<pre><code>DI（依赖注入）：Ioc（反向控制）：实现必须依赖抽象，而不是抽象依赖实现
AOP（面向切面，就是把切面抽象为接口，然后用上面的调用方式）：面向服务，实现不同服务的解耦，通过api进行通信
</code></pre>

<p>AOP像OOP一样，只是一种编程范式，AOP并没有规定说，实现AOP协议的代码，要用什么方式去实现。</p>

<p>第一种方式，我可以采用代理模式，</p>

<p>什么是代理模式，就是我再生成一个代理类，去代理UserController的saveUser()方法</p>

<pre><code>面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。      但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。    也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。       一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。      AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。
</code></pre>

<p>spring Cloud</p>

<p>就是一个spring实现微服务的工具箱，提供了注册中心，服务发现等功能，可以将AOP架构转化为微服务架构</p>

<p>java线程</p>

<p>1、扩展java.lang.Thread类。</p>

<p>此类中有个run()方法，应该注意其用法：
public void run()
如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</p>

<p>Thread 的子类应该重写该方法。
2、实现java.lang.Runnable接口。</p>

<p>实际上是创建了thread对象，通过构造方法，也实现了Runnable与thread类的关联，然后就可以调用thread对象的方法了</p>

<p>void run()
使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run 方法。</p>

<p>方法 run 的常规协定是，它可能执行任何所需的操作。</p>

<p>二、实例化线程</p>

<p>1、如果是扩展java.lang.Thread类的线程，则直接new即可。</p>

<p>2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：
Thread(Runnable target)
Thread(Runnable target, String name)
Thread(ThreadGroup group, Runnable target)
Thread(ThreadGroup group, Runnable target, String name)
Thread(ThreadGroup group, Runnable target, String name, long stackSize)</p>

<p>三、启动线程</p>

<p>在线程的Thread对象上调用start()方法，而不是run()或者别的方法。</p>

<p>在调用start()方法之前：线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。</p>

<p>在调用start()方法之后：发生了一系列复杂的事情
启动新的执行线程（具有新的调用栈）；
该线程从新状态转移到可运行状态；
当该线程获得机会执行时，其目标run()方法将运行。</p>

<p>这些应该是封装好线程池的基础</p>

<p>这边有一个线程的状态，可以用thread的getstate（）获得</p>

<p>Java中的线程的生命周期大体可分为5种状态。</p>

<ol>
<li>新建(NEW)：新创建了一个线程对象。</li>

<li><p>可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p></li>

<li><p>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p></li>

<li><p>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：
(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p></li>

<li><p>死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生</p></li>
</ol>

<p>Java并发编程：线程池的使用</p>

<p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p>

<p>在ThreadPoolExecutor类中提供了四个构造方法：
public class ThreadPoolExecutor extends AbstractExecutorService {
    &hellip;..
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue<Runnable> workQueue);</p>

<pre><code>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);

public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);

public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
    BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
...
</code></pre>

<p>}</p>

<p>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；
keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：
复制代码
TimeUnit.DAYS;               //天
TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟
TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒
TimeUnit.MICROSECONDS;      //微妙
TimeUnit.NANOSECONDS;       //纳秒
复制代码
workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：
ArrayBlockingQueue;
LinkedBlockingQueue;
SynchronousQueue;
　　ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>

<p>threadFactory：线程工厂，主要用来创建线程；
handler：表示当拒绝处理任务时的策略，有以下四种取值：
ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p>

<p>ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。</p>

<p>　　Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；</p>

<p>　　然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；</p>

<p>　　抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；</p>

<p>　　然后ThreadPoolExecutor继承了类AbstractExecutorService。</p>

<p>　　在ThreadPoolExecutor类中有几个非常重要的方法</p>

<p>execute()
submit()
shutdown()
shutdownNow()
 　　execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p>

<p>　　submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</p>

<p>　　shutdown()和shutdownNow()是用来关闭线程池的。</p>

<p>1.线程池状态</p>

<p>　　在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：</p>

<p>volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
 　　runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；</p>

<p>　　下面的几个static final变量表示runState可能的几个取值。</p>

<p>　　当创建线程池后，初始时，线程池处于RUNNING状态；</p>

<p>　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p>

<p>　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p>

<p>　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p>

<p>.线程池中的线程初始化</p>

<p>　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p>

<p>　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>

<p>prestartCoreThread()：初始化一个核心线程；
prestartAllCoreThreads()：初始化所有核心线程</p>

<p>不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p>

<p>Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池
Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池
 　　下面是这三个静态方法的具体实现;</p>

<p>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
　　从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p>

<p>　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p>

<p>　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p>

<p>　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>

<p>newScheduledThreadPool() ：
     作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池</p>

<p>　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</p>

<p>　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p>

<p>阻塞队列&ndash;LinkedBlockingQueue</p>

<p>常用方法如下：
add(anObject)：
把anObject添加到BlockingQueue里，添加成功返回true，如果BlockingQueue空间已满则抛出异常。
offer(anObject)：
表示如果可能的话，将anObject加到BlockingQueue里，即如果BlockingQueue可以容纳，则返回true，否则返回false。
put(anObject)：
把anObject加到BlockingQueue里，如果BlockingQueue没有空间，则调用此方法的线程被阻断直到BlockingQueue里有空间再继续。
poll(time)：
获取并移除此队列的头，若不能立即取出，则可以等time参数规定的时间，取不到时返回null。
take()：
获取BlockingQueue里排在首位的对象，若BlockingQueue为空，阻断进入等待状态直到BlockingQueue有新的对象被加入为止。
clear()：
从队列彻底移除所有元素。
remove()方法直接删除队头的元素
peek()方法直接取出队头的元素，并不删除</p>

<p>servlet就是你写在容器（如tomcat）里的动态资源，远程客户端点击或者一个url请求会封装成一个http请求，到你的服务端后由容器解析http请求，并封装为java servlet请求和响应，最后放进servlet的service方法根据请求作出服务。
web服务器习惯处理静态页面，所以需要一个程序来帮忙处理动态请求(如当前时间)。</p>

<p>arraylist 动态数组</p>

<p>1）不初始化起容量  ArrayList al = new ArrayList();//默认容量为0，当数组容量满时数组会自动一当前数组容量的2倍扩容</p>

<p>2)初始化容量ArrayList al = new ArrayList(3);//初始容量为3</p>

<p>3）以一个集合或数组初始化ArrayList al = new ArrayList(a);//a为集合或数组</p>

<p>四、添加元素</p>

<p>添加元素用其自带的方法add(object value);</p>

<p>ArrayList al = new ArrayList();</p>

<p>al.add(&ldquo;a&rdquo;);</p>

<p>Insert(int index,object value)方法也可以用来将元素插入到索引处，不过其有一定的限制性,必须在数组长度以内插入数组</p>

<p>InsertRange(int index,ICollection c)方法同Insert()一样</p>

<p>五、删除元素</p>

<p>al.Remove(object obj);//移除数组中的obj元素</p>

<p>al.RemoveAt(int index);//移除索引为index的数字元素</p>

<p>al.RemoveRange(int indext,int count);//移除从索引index开始，移除count个元素</p>

<p>六、查找元素</p>

<p>查找元素有Contains（）、IndexOf（）、LastIndexOf（）3中方法</p>

<p>al.Contains(object obj);//查找数组中是否有obj元素，存在返回true；</p>

<p>IndexOf（）有两个重载方法 起用法如下：</p>

<p>1）、al.IndexOf(object obj);//从0开始查找obj元素，只第一个obj元素，并返回起在数组中的位置,如果不存在，返回-1；</p>

<p>2）、al.IndexOf(object obj，int startIndex); //从startIndex开始查找obj元素，只第一个obj元素，并返回起在数组中的位置，</p>

<p>3）、al.IndexOf(object obj，int startIndex，int count); 从startIndex开始想后查找count个元素，如果存在obj元素，则返回其在数组中的位置</p>

<p>al.LastIndexOf()方法与IndexOf（）用法相同，它也有两个重载，其不同的是，LastIndexOf（obj）是查找要obj最后出现的位置</p>

<p>七、ArrayList的遍历</p>

<p>1、Count属性可以获取ArrayList数组的长度，可以用for遍历数组</p>

<pre><code>                           for (int i = 0; i &lt; al.Count;i++ )



                          {



                                       Console.Write(&quot;{0}\t&quot;,al[i]);



                          }
</code></pre>

<p>2、用foreach遍历</p>

<p>foreach(object o in al)</p>

<pre><code>                      {



                              Console.Write(&quot;{0}\t&quot;, o);



                        }
</code></pre>

<p>内部实现
在java.util.zip中</p>

<p>java.util 中的集合类包含 Java 中某些最常用的类。 最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。</p>

<p>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。 从概念上而言，您可以将 List 看作是具有数值键的 Map。 而实际上，除了 List 和 Map 都在定义 java.util 中外，两者并没有直接的联系。</p>

<p>list</p>

<p>List:元素是有序的(怎么存的就怎么取出来，顺序不会乱)，元素可以重复（角标1上有个3，角标2上也可以有个3）因为该集合体系有索引，</p>

<p>ArrayList：底层的数据结构使用的是数组结构（数组长度是可变的百分之五十延长）（特点是查询很快，但增删较慢）线程不同步</p>

<p>LinkedList：底层的数据结构是链表结构（特点是查询较慢，增删较快）
Vector：底层是数组数据结构 线程同步（数组长度是可变的百分之百延长）（无论查询还是增删都很慢，被ArrayList替代了）</p>

<p>map</p>

<p>equals(Object o)    比较指定对象与此 Map 的等价性
hashCode()  返回此 Map 的哈希码
clear() 从 Map 中删除所有映射
remove(Object key)  从 Map 中删除键和关联的值
put(Object key, Object value)   将指定值与指定键相关联
putAll(Map t)   将指定 Map 中的所有映射复制到此 map</p>

<p>遍历put和putall</p>

<p>使用 putAll() 通常也并不比使用大量的 put() 调用更有效率，但 putAll() 的存在一点也不稀奇。 这是因为，putAll() 除了迭代 put() 所执行的将每个键值对添加到 Map 的算法以外，还需要迭代所传递的 Map 的元素。 但应注意，putAll() 在添加所有元素之前可以正确调整 Map 的大小，因此如果您未亲自调整 Map 的大小（我们将对此进行简单介绍），则 putAll() 可能比预期的更有效。</p>

<p>Java 自带了各种 Map 类。 这些 Map 类可归为三种类型：</p>

<p>通用 Map，用于在应用程序中管理映射，通常在 java.util 程序包中实现
HashMap
Hashtable
Properties
LinkedHashMap
IdentityHashMap
TreeMap
WeakHashMap
ConcurrentHashMap
专用 Map，您通常不必亲自创建此类 Map，而是通过某些其他类对其进行访问
java.util.jar.Attributes
javax.print.attribute.standard.PrinterStateReasons
java.security.Provider
java.awt.RenderingHints
javax.swing.UIDefaults
一个用于帮助实现您自己的 Map 类的抽象类
AbstractMap</p>

<p>OOM为out of memory的简称，称之为内存溢出。</p>

<p>程序中常见的打印有如下几类：</p>

<p>一：</p>

<p>如图：</p>

<p>Java应用程序在启动时会指定所需要的内存大小，其主要被分割成两个不同的部分，分别为Head space(堆空间-Xmx指定)和Permegen(永久代-XX:MaxPermSize指定)，</p>

<p>通常来说，造成如上图异常的基本上程序代码问题而造成的内存泄露。这种异常，通过dump+EMA可以轻松定位。（EMA虽功能强大，但对机器性能内存要求极高）</p>

<p>二：</p>

<p>Java.lang.OutOfMemeoryError:GC overhead limit exceeded</p>

<p>如上异常，即程序在垃圾回收上花费了98%的时间，却收集不回2%的空间，通常这样的异常伴随着CPU的冲高。定位方法同上。</p>

<p>三：</p>

<p>Java.lang.OutOfMemoryError: PermGen space（JAVA8引入了Metaspace区域）</p>

<p>永久代内存被耗尽，永久代的作用是存储每个类的信息，如类加载器引用、运行池常量池、字段数据、方法数据、方法代码、方法字节码等。基本可以推断PermGen占用大小取决于被加载的数量以及类的大小。定位方法同上。</p>

<p>还有很多OOM异常，甚至会触发操作系统的OOM killer去杀掉其它进程。</p>

<p>四：</p>

<p>本节主要讨论下面一种OOM，如图</p>

<p>产生这种异常的原因是由于系统在不停地创建大量的线程，且不进行释放。系统的内存是有限的，分配给JAVA应用的程序也是有限的，系统自身能允许创建的最大线程数计算规则：</p>

<p>(MaxProcessMemory-JVMMemory-ReservedOsMemory)/ThreadStackSize</p>

<p>其中</p>

<p>MaxProcessMemory：指的是一个进程的最大内存</p>

<p>JVMMemory ：JVM内存</p>

<p>ReservedOsMemory：保留的操作系统内存</p>

<p>ThreadStackSize：线程栈的大小</p>

<p>从公式中可以得出结论，系统可创建线程数量与分配给JVM内存大小成反比。</p>

<p>传统上大家认识中的jboss ，现在分成四大版本企业版,命名为： Jboss EAP， 文档非常全且细致，同时用来做社区版的参考。社区full profile版： wildfly， 支持Java EE 8标准， Micro Profile标准。社区servlet版： wildfly servlet， 对标就是tomcat, 体积小巧，但比tomcat先进强大。微服务版： wildlfy swarm， 对标的是spring boot.总体上， wildfly8之前， web是基于tomcat的。 在wildfly8之后web处理基于全新研发的undertow; 基于jboss modules ,jboss msc实现了模块化，简单好用。</p>

<p>jmx</p>

<p>JMX的全称为Java Management Extensions. 顾名思义，是管理Java的一种扩展。这种机制可以方便的管理、监控正在运行中的Java程序。常用于管理线程，内存，日志Level，服务重启，系统环境等。</p>

<h1 id="java锁">java锁</h1>

<ol>
<li>公平锁/非公平锁</li>
</ol>

<p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p>

<p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p>

<p>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p>

<p>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p>

<ol>
<li>可重入锁</li>
</ol>

<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。</p>

<p>对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。</p>

<p>对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p>

<pre><code>synchronized void setA() throws Exception{
    Thread.sleep(1000);
    setB();
}
synchronized void setB() throws Exception{
    Thread.sleep(1000);
}
</code></pre>

<p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p>

<ol>
<li>独享锁/共享锁</li>
</ol>

<p>独享锁是指该锁一次只能被一个线程所持有。</p>

<p>共享锁是指该锁可被多个线程所持有。</p>

<p>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。</p>

<p>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</p>

<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>

<p>对于Synchronized而言，当然是独享锁。</p>

<ol>
<li>互斥锁/读写锁</li>
</ol>

<p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p>

<p>互斥锁在Java中的具体实现就是ReentrantLock</p>

<p>读写锁在Java中的具体实现就是ReadWriteLock</p>

<ol>
<li>乐观锁/悲观锁</li>
</ol>

<p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p>

<p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p>

<p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p>

<p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p>

<p>悲观锁在Java中的使用，就是利用各种锁。</p>

<p>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p>

<ol>
<li>分段锁</li>
</ol>

<p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p>

<p>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。</p>

<p>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p>

<p>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</p>

<p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>

<ol>
<li>偏向锁/轻量级锁/重量级锁</li>
</ol>

<p>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p>

<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>

<p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>

<p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p>

<ol>
<li>自旋锁</li>
</ol>

<p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>

<p>java中的锁的定义和描述还是比较全面的，其他语言中也有对应的锁，但是只是直接使用了，并没有这么定义，可以对比使用实现，所以需要了解其概念，便于交流使用。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/language/java/java/">https://kingjcy.github.io/post/language/java/java/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/language/">
                            <i class="fa fa-tags"></i>
                            language
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/java/">
                            <i class="fa fa-tags"></i>
                            java
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/language/language/">Language</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年03月26日)</span></li><li id="li-rels"><a href="/post/golang/go/">golang使用系列---- go基本使用积累</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年03月23日)</span></li><li id="li-rels"><a href="/post/language/python/">Python</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2015年04月08日)</span></li><li id="li-rels"><a href="/post/tool/markdown/">markdown的基本使用</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2014年11月24日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/language/python/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/linux/c&#43;&#43;/signal/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#java锁">java锁</a></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

