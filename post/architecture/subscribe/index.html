<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="实例：可靠消息通知系统。
可靠消息通知系统实际上是一个非常常见的系统。最常用的一个例子就是数据库的master slave 模式。master里面的事件要非常可靠的通知到slave，中间不能有任何的丢失。还有一种比如交易系统中，我们会调用银行或者交易所的接口，银行在交易成功后会给我们一个通知，这个通知的消息必须可靠的被通知到目标，不能有任何的丢失。在我们的系统中，行情数据的复制也是不能有任何数据丢失的情景，为了保证A 服务器 和 B服务器有相同的行情，在从A服务器的消息要被B服务器准确的接收。当然，你也可以做一个聊天系统，这个聊天系统不会丢失任何消息。
那么如何实现这个系统呢，首先，为了保证不在内存中丢失消息，那么消息必须写盘，并且为了检测消息是否丢失，必须给消息编号。消息写盘也可以用我们开发的事务日志系统，如果消息非常的大量，那么还需要批量提交模式（Group Commit）。大部分情况下，消息丢失不是因为服务器崩溃，而且网络意外中断，这些中断往往时间很短，在1分钟以内，所以，有必要在内存中缓存部分的消息，如果网络中断，客户端再次请求时，发送当时的消息序号，这样就可以补全网络中断丢失的数据。如果时间太长了，内存中的数据不够补了，那么首先要从消息源数据库中下载历史消息，然后再接受实时的消息。整体的思路就是这样的，在这里，我们就看看我们的消息通知系统的实时广播部分的设计。
 消息广播基本流程： 订阅 –&gt; 广播：  首先客户端向服务器说明，我要订阅哪些消息，比如，master slave 中，我只要写消息就好了，读消息就不需要了。然后，再向服务器请求数据，服务器广播数据给我们。注意，我们这里把订阅 和 广播分成两个部分，两个请求，那么怎么知道这两个请求是同一个人发出的呢？或者，怎么关联起来呢？这里，我用了一个session的概念，订阅的时候，把订阅的消息类型保存到session，广播的时候，从session中读取消息类型，然后发送对应的数据。
这部分的代码如下：
var bmu sync.Mutex var defaultBroadcast = make(map[int64]*Broadcast) var ErrNotRingItemer = errors.New(&quot;ErrNotRingItemer&quot;) //基本上可以保证有1个小时的数据 const btickSize = 3600 * 4 //可以传递任意的数据 func GetBroadcast(name int64, n int) (*Broadcast, error) { bmu.Lock() defer bmu.Unlock() b, ok := defaultBroadcast[name] if ok { return b, nil } b , err := NewBroadcast(name, n) if err !">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Subscribe - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Subscribe
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年03月11日 
                </div>
                <h1 class="post-title">Subscribe</h1>
            </header>

            <div class="post-content">
                <p>实例：可靠消息通知系统。</p>

<p>可靠消息通知系统实际上是一个非常常见的系统。最常用的一个例子就是数据库的master slave 模式。master里面的事件要非常可靠的通知到slave，中间不能有任何的丢失。还有一种比如交易系统中，我们会调用银行或者交易所的接口，银行在交易成功后会给我们一个通知，这个通知的消息必须可靠的被通知到目标，不能有任何的丢失。在我们的系统中，行情数据的复制也是不能有任何数据丢失的情景，为了保证A 服务器 和 B服务器有相同的行情，在从A服务器的消息要被B服务器准确的接收。当然，你也可以做一个聊天系统，这个聊天系统不会丢失任何消息。</p>

<p>那么如何实现这个系统呢，首先，为了保证不在内存中丢失消息，那么消息必须写盘，并且为了检测消息是否丢失，必须给消息编号。消息写盘也可以用我们开发的事务日志系统，如果消息非常的大量，那么还需要批量提交模式（Group Commit）。大部分情况下，消息丢失不是因为服务器崩溃，而且网络意外中断，这些中断往往时间很短，在1分钟以内，所以，有必要在内存中缓存部分的消息，如果网络中断，客户端再次请求时，发送当时的消息序号，这样就可以补全网络中断丢失的数据。如果时间太长了，内存中的数据不够补了，那么首先要从消息源数据库中下载历史消息，然后再接受实时的消息。整体的思路就是这样的，在这里，我们就看看我们的消息通知系统的实时广播部分的设计。</p>

<ol>
<li>消息广播基本流程： 订阅 –&gt; 广播：</li>
</ol>

<p>首先客户端向服务器说明，我要订阅哪些消息，比如，master slave 中，我只要写消息就好了，读消息就不需要了。然后，再向服务器请求数据，服务器广播数据给我们。注意，我们这里把订阅 和 广播分成两个部分，两个请求，那么怎么知道这两个请求是同一个人发出的呢？或者，怎么关联起来呢？这里，我用了一个session的概念，订阅的时候，把订阅的消息类型保存到session，广播的时候，从session中读取消息类型，然后发送对应的数据。</p>

<p>这部分的代码如下：</p>

<pre><code>var bmu sync.Mutex
var defaultBroadcast = make(map[int64]*Broadcast)
var ErrNotRingItemer = errors.New(&quot;ErrNotRingItemer&quot;)
//基本上可以保证有1个小时的数据
const btickSize = 3600 * 4
//可以传递任意的数据

func GetBroadcast(name int64, n int) (*Broadcast, error) {
    bmu.Lock()
     defer bmu.Unlock()
     b, ok := defaultBroadcast[name]
     if ok {
         return b, nil
     }
     b , err := NewBroadcast(name, n)
     if err != nil {
         return nil, err
     }
     defaultBroadcast[name] = b
     return b, nil
 }

 type Broadcast struct {
     mu sync.RWMutex
     targets map[int64]*Subscribe
     ringbuffer *algo.RingBuffer
     name int64
 }

 func NewBroadcast(name int64, n int) (*Broadcast, error) {
     b := &amp;Broadcast{}
     b.targets = make(map[int64]*Subscribe)
     b.ringbuffer = algo.NewRingBuffer(n, nil)
     b.name = name
     return b, nil
 }

 func (b *Broadcast) GetName() int64 {
     return b.name
 }

 func (b *Broadcast) Sub(id int64, req *Subscribe) {
     b.mu.Lock()
     defer b.mu.Unlock()
     b.targets[id] = req
 }

 func (b *Broadcast) Unsub(id int64) {
     b.mu.Lock()
     defer b.mu.Unlock()
     delete(b.targets, id)
 }

 //是否在buffer内部
 func (b *Broadcast) InBuffer(start int64, end int64) (bool, error) {
     return b.ringbuffer.InBuffer(start, end)
 }

 func (b *Broadcast) Query(start int64, end int64, ty int64) (algo.Iterator, error) {
     find := &amp;algo.RingFind{start, end, ty}
     return b.ringbuffer.Find(find, true) //模糊查找，不是精确匹配
 }

 //如果要提供查询功能，那么就要缓存数据，一般采用ringbuffer
 //data要满足下面的条件：
 //1. 存在一个递增着的ID
 //2. 实现BufferItemer接口
 func (b *Broadcast) Push(item algo.RingItemer) error {
     b.mu.RLock()
     defer b.mu.RUnlock()
     item2, err := b.ringbuffer.Push(item)
     if err != nil {
         return err
     }
     for _, v := range b.targets {
         //过滤不想发送的
         if (v.Check(b.name, item2.Type)) {
             v.Send(item)
         }
     }
     return nil
 }

 func (b *Broadcast) Find(find *algo.RingFind) (algo.Iterator, error) {
     return b.ringbuffer.Find(find, true)
 }

 type Subscribe struct {
     mu sync.Mutex
     ch chan interface{}
     tys map[int64]int64
 }

 func NewSubscribe(n int) (*Subscribe) {
     s := &amp;Subscribe{}
     s.ch = make(chan interface{}, n)
     s.tys = make(map[int64]int64)
     return s
 }

 func (s *Subscribe) Add(bname int64, ty int64) {
     s.mu.Lock()
     defer s.mu.Unlock()
     s.tys[bname] = ty
 }

 func (s *Subscribe) Check(bname int64, dataty int64) bool {
     s.mu.Lock()
     defer s.mu.Unlock()
     ty, ok := s.tys[bname]
     if !ok { //没有订阅
         return false
     }
     if ty == algo.AnyType || dataty == ty {
         return true
     }
     return false
 }

 func (s *Subscribe) Read(buf []interface{}) (int) {
     var i = 1
     buf[0] = &lt;-s.ch
     for {
         if i == len(buf) {
             return i
         }
         select {
         case data := &lt;-s.ch:
             buf[i] = data
             i++
         default:
             return i
         }
     }
     panic(&quot;nerver reach&quot;)
 }

 func (s *Subscribe) Send(data interface{}) {
      select {
      case s.ch &lt;- data :
      default:
          //清除旧的数据
          s.Clear()
          //发送结束标志位
          s.ch &lt;- nil
      }
 }

 func (s *Subscribe) Clear() {
     for {
         select {
         case &lt;-s.ch:
         default:
             return
         }
     }
 }
</code></pre>

<p>这里，有个数据结构叫做RingBuffer, 是一个环状的buffer，非常适合做缓存固定数目的数据，用于广播。广播是用管道来传输数据的，管道的性能实际上已经非常的高，不需要什么无锁队列之类的。在这里也给管道加上buffer使得，消息意外的扰动，不会使得带宽不够用而立马堵塞。</p>

<p>接受消息：</p>

<p>在用户登录后，如果有权限，那么就可以作为消息源客户端，消息源的代码如下：</p>

<pre><code>func pushTick(w *asyn.ResponseWriter, r *asyn.Request) {
    event := r.GetBody().(*response.OrderBookEvent)
    b, _ := GetBroadcast(event.InstrumentId, btickSize)
    b.Push(event)
    asyn.Log().Println(event)
    asyn.OKHandle(w, r)
}
</code></pre>

<p>第2行： 从请求中获取 消息事件。</p>

<p>第3行： event.InstrumentId 是消息的类型，btickSzie 是缓存的数据数目。</p>

<p>第6行： 向客户端发送OK，确认消息发送成功。</p>

<p>每个消息是否发送成功，都有确认。这样，客户端就知道上次消息发送到哪里了。</p>

<p>订阅：</p>

<pre><code>func subscribe(w *asyn.ResponseWriter, r *asyn.Request) {
    instId := r.GetBody().(int64)
    log.Println(&quot;sub&quot;, instId)
    b, err := GetBroadcast(instId, btickSize)
    if err != nil {
        r.SetErr(err)
        asyn.ErrorHandle(w, r)
        return
    }
    //订阅的size
    //get and set 要成为一个原子操作
    session := r.GetSession()
    session.Get3(&quot;subscribe&quot;, func (data interface{}) interface{} {
        if data == nil {
            data = NewSubscribe(4096)
        }
        sub := data.(*Subscribe)
        //广播, 类型
        id := int64(uintptr(unsafe.Pointer(session)))
        sub.Add(instId, algo.AnyType)
        b.Sub(id, sub)
        session.OnDelete(func () {
            b.Unsub(id)
        })
        return sub
    })
    asyn.OKHandle(w, r)
}
</code></pre>

<p>第2行：获取消息的类型，通过这个类型，可以找到对应的广播对象。</p>

<p>第12-30行：这是一个线程安全的session操作，具体看一下session.Get3 的实现就知道了：</p>

<pre><code>func (s *Session) Get3(name string, callback func (interface{}) interface{}) interface{} {
    s.mu.Lock()
    defer s.mu.Unlock()
    data, err := s.get(name)
    if err != nil {
        data = nil
    }
    data = callback(data)
    s.set(name, data)
    return data
}
</code></pre>

<p>s.get 获取session的数据，如果没有session数据，那么为nil。简单的说，这里的意思是：如果session “subscribe” 如果还没有设置，那么就新建一个对象，如果已经设置了，那么读取这个对象，并且，这个操作是线程安全的。</p>

<p>这里还添加了一个session撤销时候的操作。</p>

<p>广播：</p>

<pre><code>//读取广播数据
func read(w *asyn.ResponseWriter, r *asyn.Request) {
session := r.GetSession()
//从session 中获取subscribe 对象
sub := session.Get3(&quot;subscribe&quot;, func (data interface{}) interface{} {
if data == nil {
data = NewSubscribe(4096)
}
return data
}).(*Subscribe)
depth := r.GetBody().(int)
log.Println(&quot;get subscribe&quot;)
resp := w.Resp
if depth == 0 {
resp.MsgType = &quot;ticks&quot;
} else {
resp.MsgType = &quot;ticks1&quot;
}
buf := make([]interface{}, 1024)
dg := make([]*response.OrderBookEvent, 1024)
tick1 := make([]*base.TickGo, 1024)
for {
n := sub.Read(buf)
for i := 0; i &lt; n; i++ {
if buf[i] == nil {
//close by broadcast
r.SetErr(errors.New(&quot;501&quot;))
asyn.ErrorHandle(w, r)
return
}
if depth == 0 {
dg[i] = buf[i].(*response.OrderBookEvent)
} else {
tick1[i] = buf[i].(*response.OrderBookEvent).ToTickGo()
}
}
var err error
if depth == 0 {
err = w.WriteResponse(resp, dg[:n])
} else {
err = w.WriteResponse(resp, tick1[:n])
}
if err != nil {
r.SetErr(err)
asyn.ErrorHandle(w, r)
return
}
}
}
</code></pre>

<p>read 有个depth参数，这是行情的深度。股票期货里面都有后这个概念。传说中的几档行情。</p>

<p>第26行：这里有个close。一般来说，是因为网络拥堵 或者 异常，无法发送数据了。</p>

<p>还有一点要注意，这里的行情是批量发送的。sub.Read 尽可能多的读取数据，减少网络io的次数。</p>

<p>当然，服务器框架本身提供了心跳机制，对消息广播系统，实时性是非常重要的，即时的检查出网络异常，才能保证实时性。</p>

<p>以上是对我们的异步消息服务器框架的一个简单的介绍。设计这框架，非常重要的两个理念：</p>

<p>模块化的设计，一个功能，就对应一个函数。</p>

<p>模块之间的通讯采用session，而对于比较复杂的通讯，可以自己建立一个线程安全的数据结构，比如这里的Broadcast 和 Subscribe</p>

            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/architecture/subscribe/">https://kingjcy.github.io/post/architecture/subscribe/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags//">
                            <i class="fa fa-tags"></i>
                            
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/go-unsafe/">Go Unsafe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-text/">Go Text</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-plugin/">Go Plugin</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-mine/">Go Mine</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-internal/">Go Internal</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-index/">Go Index</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-image/">Go Image</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-html/">Go Html</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-hash/">Go Hash</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-go/">Go Go</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/architecture/microservices/go-micro/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/middleware/network/application-netprotocol/webserver/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

