<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="微服务其实就是服务化的一种概念，由过去单体架构演变成分布式系统的一个产物。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="架构系列---- 架构的演进 - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    架构系列---- 架构的演进
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2018年03月05日 
                </div>
                <h1 class="post-title">架构系列---- 架构的演进</h1>
            </header>

            <div class="post-content">
                <p>微服务其实就是服务化的一种概念，由过去单体架构演变成分布式系统的一个产物。</p>

<h1 id="微服务架构演变由来">微服务架构演变由来</h1>

<p><img src="/media/architecture/microservices/architecture-change" alt="" /></p>

<blockquote>
<h2 id="单体架构">单体架构</h2>
</blockquote>

<p>以前使用 Laravel 做 web 项目时，是根据 MVC 去划分目录结构的，即 Controller 层处理业务逻辑，Model 层处理数据库的 CURD，View 层处理数据渲染与页面交互。以及 MVP、MVVM 都是将整个项目的代码是集中在一个代码库中，进行业务处理。这种单一聚合代码的方式在前期实现业务的速度很快，但在后期会暴露很多问题：</p>

<pre><code>开发与维护困难：随着业务复杂度的增加，代码的耦合度往往会变高，多个模块相互耦合后不易横向扩展
效率和可靠性低：过大的代码量将降低响应速度，应用潜在的安全问题也会累积
</code></pre>

<p>单体架构最终走向了单体地狱，比如</p>

<pre><code>1、代码全量编译成一个实例，因为一个模块的问题可能会导致全量的模块不能使用
2、问题难以地位，比如有一个死循环，会导致cpu占用100%，还会影响机器上其他的应用的使用，同时，很难知道是哪个模块出问题
3、代码量大，可能编译启动就需要很长时间，到最后就不可维护了，而且线上出问题就没办法处理了，因为重启都需要很长的时间
</code></pre>

<p>在这个时候我们使用的组织架构就是最简单的</p>

<pre><code>前台-后台
</code></pre>

<blockquote>
<h2 id="垂直拆分的垂直架构">垂直拆分的垂直架构</h2>
</blockquote>

<p>单体架构的瓶颈太严重了，变的越来越臃肿，每次开发业务，都要将全部功能进行回归，于是就讲业务进行拆分成不同的进程，通过报文进行相互调用，最后还是公用数据库，但是很快各种瓶颈有出现了。</p>

<p>在这个时候我们使用的组织架构还是最简单的架构</p>

<pre><code>前台-后台
</code></pre>

<p>由最初的mvc的api的调用，变成了http的调用模式。</p>

<blockquote>
<h2 id="第一代微服务-服务化">第一代微服务&mdash;服务化</h2>
</blockquote>

<p>所以现在传统的mvc架构带来的单体问题已经十分严重了，基本上已经不再使用了，提倡微服务的思想。</p>

<p>微服务是一种思想，其实就是开发分布式系统，将模块服务化。</p>

<p>微服务落地目前存在的主要困难有如下几方面：</p>

<pre><code> 单体应用拆分为分布式系统后，进程间的通讯机制和故障处理措施变的更加复杂。
 系统微服务化后，一个看似简单的功能，内部可能需要调用多个服务并操作多个数据库实现，服务调用的分布式事务问题变的非常突出。
 微服务数量众多，其测试、部署、监控等都变的更加困难。
</code></pre>

<p>随着RPC框架的成熟，第一个问题已经逐渐得到解决。例如springcloud可以非常好的支持restful调用，dubbo可以支持多种通讯协议。</p>

<p>对于第三个问题，随着docker、devops技术的发展以及各公有云paas平台自动化运维工具的推出，微服务的测试、部署与运维会变得越来越容易。</p>

<p>而对于第二个问题，现在还没有通用方案很好的解决微服务产生的事务问题。分布式事务已经成为微服务落地最大的阻碍，也是最具挑战性的一个技术难题,目前<a href="/posts/distributed/distributed-event/">主要解决方案</a>。</p>

<h4 id="第一代微服务框架">第一代微服务框架</h4>

<p>微服务是一种软件架构，它将一个大且聚合的业务项目拆解为多个小且独立的业务模块，模块即服务，各服务间使用高效的协议（protobuf、JSON 等）相互调用即是 RPC。这种拆分代码库的方式有以下特点：</p>

<pre><code>1. 每个服务应作为小规模的、独立的业务模块在运行，类似 Unix 的 Do one thing and do it well，这就是微服务参考了unix的设计哲学，包括独立开发，自动化测试（细致的错误检查和处理）和（分布式）部署，不影响其他服务。同时也加快了开发交付周期，降低代码耦合度导致的沟通成本。

2. 从依赖库到依赖服务，增加了开发者选择的自由（语言，框架，库），提高了复用效率，只要符合服务 API 契约，开发人员可以自由选择开发技术。这就意味着开发人员可以采用新技术编写或重构服务，由于服务相对较小，所以这并不会对整体应用造成太大影响。
</code></pre>

<p>可见微服务也是分布式系统，但是微服务注重的注册中心，和服务发现，可以实现简单的扩缩容的方式，这也是微服务的一大重大特点。也就是服务治理，其实后面出现的各大框架也是着重解决这个问题。</p>

<p>当然微服务架构的也有很多缺点：</p>

<pre><code>微服务强调了服务大小，但实际上这并没有一个统一的标准：业务逻辑应该按照什么规则划分为微服务，这本身就是一个经验工程。有些开发者主张 10-100 行代码就应该建立一个微服务。虽然建立小型服务是微服务架构崇尚的，但要记住，微服务是达到目的的手段，而不是目标。微服务的目标是充分分解应用程序，以促进敏捷开发和持续集成部署。

微服务的分布式特点带来的复杂性：开发人员需要基于 RPC 或者消息实现微服务之间的调用和通信，而这就使得服务之间的发现、服务调用链的跟踪和质量问题变得的相当棘手。微服务的精髓之一就是服务之间传递的是可序列化消息，而不是对象和引用，这个思想是和 DCOM 及 EJB 完全相反的。只有数据，不包含逻辑；这个设计的好处不用我多说也很好理解，参考 CSP

分区的数据库体系和分布式事务：更新多个业务实体的业务交易相当普遍，不同服务可能拥有不同的数据库。CAP 原理的约束，使得我们不得不放弃传统的强一致性，而转而追求最终一致性，这个对开发人员来说是一个挑战。

测试挑战：传统的单体WEB应用只需测试单一的 REST API 即可，而对微服务进行测试，需要启动它依赖的所有其他服务。这种复杂性不可低估。

跨多个服务的更改：比如在传统单体应用中，若有 A、B、C 三个服务需要更改，A 依赖 B，B 依赖 C。我们只需更改相应的模块，然后一次性部署即可。但是在微服务架构中，我们需要仔细规划和协调每个服务的变更部署。我们需要先更新 C，然后更新 B，最后更新 A。

部署复杂：微服务由不同的大量服务构成。每种服务可能拥有自己的配置、应用实例数量以及基础服务地址。这里就需要不同的配置、部署、扩展和监控组件。此外，我们还需要服务发现机制，以便服务可以发现与其通信的其他服务的地址。因此，成功部署微服务应用需要开发人员有更好地部署策略和高度自动化的水平。
</code></pre>

<p>总的来说（问题和挑战）：API Gateway、服务间调用、服务发现、服务容错、服务部署、数据调用。其实大部分也是我们一开始的说的微服务落地的三大难题。</p>

<p>不过，现在很多微服务的框架（比如 Spring Cloud、Dubbo）已经很好的解决了上面的问题。</p>

<blockquote>
<p>Spring Cloud</p>
</blockquote>

<p>Spring Cloud为开发者提供了快速构建分布式系统的通用模型的工具（包括配置管理、服务发现、熔断器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态等）</p>

<p>其实主要解决了部署的问题，他就是一个很好的部署工具，目前也开始拥抱docker了。</p>

<blockquote>
<p>Dubbo</p>
</blockquote>

<p>Dubbo是一个阿里巴巴开源出来的一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p>

<p>其实主要解决的服务间通信的问题。</p>

<blockquote>
<p>分布式事务</p>
</blockquote>

<p>还是要解决具体的业务。目前<a href="/posts/distributed/distributed-event/">主要解决方案</a>。</p>

<p>在这个时候组织架构就发生了很大的变化</p>

<h4 id="soa">SOA</h4>

<p>SOA是什么？SOA全英文是Service-Oriented Architecture，中文意思是面向服务架构，是一种思想，一种方法论，一种分布式的服务架构。</p>

<p><img src="/media/architecture/microservices/20180305.jpg" alt="" /></p>

<p>通过一个系统我们看一下架构的演变过程（由统一到分布式）：</p>

<p>当我们的项目比较小时，我们只有一个系统，并且把他们写到一起，放在一个服务器上，但是随着平台越来越大，数据量越来越大，我们不得不通过分库，把多个模块的数据库分别放在对应得服务器上，每个模块调用自己的子系统即可。</p>

<p><img src="/media/architecture/microservices/ac1" alt="" /></p>

<blockquote>
<p>ESB</p>
</blockquote>

<p>随着我们系统的进一步复杂度的提示，我们不得不进一步对系统的性能进行提升，我们将多个模块分成多个子系统，多个子系统直接互相调用（因为SOA一般用于大型项目，比较复杂，所以一般总系统不会再集成，会拆分多个，分别做成服务，相互调用）。当我们的电商UI进行一个下订单的任务时，多个服务直接互相调用，系统通过数据总线(java的ESB，其实也就是我们所说的网关)，分别调用对于的子系统即可。</p>

<pre><code> 企业数据总线：企业数据总线不是对多个子模块的集成，他在这里充当数据通道的作用，数据总线不关心业务，数据总线根据给的地址和协议去调服务，上端不关心服务在哪里是什么，只找数据总线。

 数据总线是起到调度服务的作用，数据总线不是集成服务，数据总线更新一个调度框架，每个服务需要根据约定向数据总线注册服务，那么如何注册那？其实数据总线就像一个字典结构，

 数据总线里面一个key对于一个value，key指的是服务名，value则是服务的调度方式，还有一点需要说明的是，数据总线只是指路人，服务是不经过数据总线的，如上图的黄色线的路径。

 数据总线通过域名解析实现:一个域名绑定多台服务器，ajax也可以，dns也可以，解析域名嘛。

 其实数据总线还有一些高级应用，比如心跳检测，实现负载均衡等等，就不细说了，目前应用数据总线的有阿里的dubbo,还有zookeeper。
</code></pre>

<p><img src="/media/architecture/microservices/ac2.png" alt="" /></p>

<p>可见组织架构</p>

<pre><code>前台---ESB---后台
</code></pre>

<p>随着企业发展到一定程度，需要规范化管理的时候，我们上了ERP系统，要通过供应链建设B2C业务的时候，我们上了SRM系统，仓储管理到一定规模我们上WMS，物流管理我们上TMS……整个公司各个系统功能有重叠，有交叉，内部协同成了重大问题。</p>

<p>这就好像我们一直在打是局部信息化战争，头痛医头脚痛医脚，需要解决什么样的问题，就上什么样的系统，最终就形成了所谓烟囱式的系统架构。</p>

<p>导致整个架构重复造轮子，跨系统管理也给运营人员造成了不必要的时间精力浪费。整个系统管理冗杂又造成资源浪费，这时候就需要将原有的系统规范化、一体化，通过数据总线进去进行深度的整合，打通各个信息孤岛，形成前后贯通的信息化建设。</p>

<p>我们把这个时代称之为ESB数据孤岛时代。</p>

<p><img src="/media/architecture/electroniccommerce/esb.jpg" alt="" /></p>

<p>大部分情况下基本上都是够用，虽然ESB很重，核心很难改变，不够灵活，但是随着发展，出现了更加灵活的方式。</p>

<h4 id="中台">中台</h4>

<pre><code>前台---中台---后台
</code></pre>

<p>而到了大中台时代，中台的核心价值是在于，在对企业业务有了柔性支撑和贯通的前提下，再形成协同与智慧的运营体系。</p>

<p>一般企业架构分成了三个层次：前台、中台、后台。中台又分成三大块，业务中台、数据中台和技术中台。</p>

<p><img src="/media/architecture/electroniccommerce/middle" alt="" /></p>

<pre><code>技术中台支撑企业业务发展，通过打通企业内异构系统，支持业务中台；

业务中台围绕公司业务运营进行服务，将获取的多维度数据传递给数据中台，由数据中台分析反馈给业务中台，以优化业务运营。同时数据中台通过BI智能分析，帮助企业管理者更好的做决策分析。三者是相辅相成，相互协作的。
业务中台其实就是把原有的前端的会员中心、营销中心、商品中心，后端的供应链中心、采配中心等重点模块放在业务中台模块，以后前端不管对接多少个第三方，线上线下增加多少家门店，都能进行统一会员、统一商品编码、统一供应链整合，整个系统一体化。真正做到用技术支持业务，通过业务收集大量数据进行决策，统一高效的进行管理。

数据中台：一般指以数据采集、数据集成、数据治理，指标体系和数据仓库统一建设等数据管理活动为典型特征的中台。
</code></pre>

<h1 id="大中台">大中台</h1>

<p>其实中台严格意义上来说，不是一种架构，也不是一种系统，而是一种战略。</p>

<p>当前最需要建设的中台有两种：</p>

<pre><code>狭义的业务中台：一般指在线业务为典型特征的中台。在OLDI（Online Data-Intensive）时代，越来越多的企业的核心业务都是在线业务，因此把在线业务中台简称为业务中台。
数据中台：一般指以数据采集、数据集成、数据治理，指标体系和数据仓库统一建设等数据管理活动为典型特征的中台。
</code></pre>

<p>对业务中台来说，比较符合的场景主要有：</p>

<pre><code>业务系统研发团队至少大几十人（含外包的），需求多变化快，系统又涉及多个领域（比如做ERP、电商的），业务逻辑比较复杂。
这时业务中台可以把系统和业务领域划分清楚，提高研发效率。做相似行业的外包项目为主，业务规模也做的比较大的（一年有两位数的项目）。
这时业务中台可以提升软件复用，降低定制化成本，提高研发效率。如果每个项目都完全不一样，那中台也救不了你。
</code></pre>

<p>支持业务中台的技术体系，包括微服务、DevOps、云原生和分布式事务等。</p>

<p>将需求设计成微服务架构，然后每个服务使用各种技术栈来开发业务，比如golang的技术栈的高并发的特性来开发web服务等，然后将一些统一的模块进行统一的接入和输出，使用devops的开发模式，在业务中还是需要解决分布式事务等问题。</p>

<p>比如在网易，是网易轻舟微服务平台，提供微服务应用全生命周期的完整支持，包括下一代微服务Service Mesh支持、经典微服务框架NSF、包括CI/CD的DevOps、分布式事务框架GXTS、APM、API网关、GoAPI全自动化测试以及容器应用管理服务等。</p>

<p>对数据中台来说，比较符合的场景：</p>

<pre><code>数据产品比较多，每天要看数据如果没数据就不知道怎么工作的运营人员比较多的业务。
比如电商就是典型。尤其是数据产品和运营人员还在多个团队。
用数据的姿势比较复杂，问题比较多，比如经常出现指标不一致、数据出错、想要的数据不知道哪里有等问题。
</code></pre>

<p>支持数据中台的技术体系，包括指标管理、数据服务、元数据管理、数仓开发与管理、数据安全管理、数据资产管理、大数据计算引擎、数据集成/同步/交换引擎等，</p>

<p>其实数据中台就是将数据进行处理，不同数据资源，统一的输出标准，中间用到大部分就是数据引擎，比如kafka队列，sprak，flink等流式引擎，hadoop，hbase和hive等大数据引擎。</p>

<p>比如在网易，是以网易猛犸为核心的网易全链路数据中台解决方案。</p>

<blockquote>
<h2 id="下一代微服务-去中心化">下一代微服务&ndash;去中心化</h2>
</blockquote>

<h4 id="service-mesh">Service Mesh</h4>

<p>随着注册中心的出现，任何调用都走网关，网关的瓶颈有到来，于是出现了下一代的微服务架构service mesh，主要落地的项目就是istio，主要是去中心化的设计</p>

<p>Istio 作为用于微服务服务聚合层管理的新锐项目，是 Google、IBM、Lyft（海外共享出行公司、Uber劲敌） 首个共同联合开源的项目，提供了统一的连接，安全，管理和监控微服务的方案</p>

<p>go-micro是基于Go语言实现的插件化RPC微服务框架，与go-kit，kite等微服务框架相比，它具有易上手、部署简单、工具插件化等优点。</p>

<p>go-micro框架提供了服务发现、负载均衡、同步传输、异步通信以及事件驱动等机制，它尝试去简化分布式系统间的通信，让我们可以专注于自身业务逻辑的开发。所以对于新手而言，go-micro是个不错的微服务实践的开始。</p>

<p>在云原生模型里，一个应用可以由数百个服务组成，每个服务可能有数千个实例，而每个实例可能会持续地发生变化。这种情况下，服务间通信不仅异常复杂，而且也是运行时行为的基础。管理好服务间通信对于保证端到端的性能和可靠性来说是无疑是非常重要的。种种复杂局面便催生了服务间通信层的出现，这个层既不会与应用程序的代码耦合，又能捕捉到底层环境高度动态的特点，让业务开发者只关注自己的业务代码，并将应用云化后带来的诸多问题以不侵入业务代码的方式提供给开发者。</p>

<p>这个服务间通信层就是 Service Mesh，它可以提供安全、快速、可靠的服务间通讯（service-to-service）。</p>

<p>Service Mesh，可以将它比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交给 Service Mesh 就可以了。</p>

<p>微服务的各种框架也有一些。但这些框架大多是编程语言层面来解决的，需要用户的业务代码中集成框架的类库，语言的选择也受限。这种方案很难作为单独的产品或者服务给用户使用，升级更新也受限于应用本身的更新与迭代。直到 Service Mesh 的概念的提出。Service Mesh 貌似也没有比较契合的翻译（有的译做服务齿合层，有的翻译做服务网格），这个概念就是试图在网络层抽象出一层，来统一接管一些微服务治理的功能。这样就可以做到跨语言，无侵入，独立升级。其中前一段时间 Google，IBM，Lyft 联合开源的 istio 就是这样一个工具，先看下它的功能简介：</p>

<pre><code>智能路由以及负载均衡
跨语言以及平台
全范围（Fleet-wide）策略执行
深度监控和报告
</code></pre>

<p>主要做了什么</p>

<pre><code>可视化 其实本质上微服务治理的许多技术点都包含可视化要求，比如监控和链路追踪，比如服务依赖
弹性（Resiliency 或者应该叫柔性，因为弹性很容易想到 scale） 就是网络层可以不那么生硬，比如超时控制，重试策略，错误注入，熔断，延迟注入都属于这个范围。
效率（Efficiency） 网络层可以帮应用层多做一些事情，提升效率。比如卸载 TLS，协议转换兼容
流量控制 比如根据一定规则分发流量到不同的 Service 后端，但对调用方来说是透明的。
安全保护 在网络层对流量加密/解密，增加安全认证机制，而对应用透明。
</code></pre>

<p>目前流行的 Service Mesh 开源软件有 Linkerd、Envoy 和 Istio，而最近 Buoyant（开源 Linkerd 的公司）又发布了基于 Kubernetes 的 Service Mesh 开源项目 Conduit。</p>

<p>Service Mesh 开源项目简介：</p>

<pre><code>Linkerd（https://github.com/linkerd/linkerd）：第一代 Service Mesh，2016 年 1 月 15 日首发布，业界第一个 Service Mesh 项目，由 Buoyant 创业小公司开发（前 Twitter 工程师），2017 年 7 月 11 日，宣布和 Istio 集成，成为 Istio 的数据面板。
Envoy（https://github.com/envoyproxy/envoy）：第一代 Service Mesh，2016 年 9 月 13 日首发布，由 Matt Klein 个人开发（Lyft 工程师），之后默默发展，版本较稳定。
Istio（https://github.com/istio/istio）：第二代 Service Mesh，2017 年 5 月 24 日首发布，由 Google、IBM 和 Lyft 联合开发，只支持 Kubernetes 平台，2017 年 11 月 30 日发布 0.3 版本，开始支持非 Kubernetes 平台，之后稳定的开发和发布。
Conduit（https://github.com/runconduit/conduit）：第二代 Service Mesh，2017 年 12 月 5 日首发布，由 Buoyant 公司开发（借鉴 Istio 整体架构，部分进行了优化），对抗 Istio 压力山大，也期待 Buoyant 公司的毅力。
nginMesh（https://github.com/nginmesh/nginmesh）：2017 年 9 月首发布，由 Nginx 开发，定位是作为 Istio 的服务代理，也就是替代 Envoy，思路跟 Linkerd 之前和 Istio 集成很相似，极度低调，GitHub 上的 star 也只有不到 100。
Kong（https://github.com/Kong/kong）：比 nginMesh 更加低调，默默发展中。
</code></pre>

<p>关于微服务和服务网格的区别，我的一些理解：</p>

<pre><code>1、service mesh主要是解决了微服务框架中三大难题之一的服务间通信的问题，类似于上一代服务架构dubbo的作用，是在容器docker和k8s的原生基础上实现的服务间通信的方案，所以比java系的dubbo方案更加友好。
2、service mesh在上一代的SOA架构上做了升级，设计的是去中性化的通信架构，解决的网关或者总线的瓶颈问题。
</code></pre>

<p>[istio]()(todo)</p>

<h4 id="k8s和微服务">k8s和微服务</h4>

<p>k8s在docker的基础上实现了管理，促使了下一代的微服务得以落地，主要解决了微服务三大难题的部署问题。类似于springcloud，但是目前也可以拥抱k8s了，可见k8s是一种趋势。</p>

<p><img src="/media/architecture/microservices/k8s-ecology" alt="" /></p>

<p>随着docker、容器的日渐成熟，容器编排的问题就凸显出来，大量的容器怎么去管理，怎么调度，怎么启停都成了迫切需要解决的问题。有需求就有人去解决，ApacheMesos、kubernetes、docker swarm陆续登场，大有三足鼎立之势，而随着各自的发展，到了2017年下半年，google的亲儿子kubernetes的呼声越来越高，社区也更加活跃、成熟。2017年底，docker swarm和ApacheMesos陆续宣称支持kubernetes，预示着容器编排大战的结束，kubernetes已然成为容器编排领域的事实标准。</p>

<p>服务编排框架的成熟，使得容器的管理越来越方便、高效，容器带来的好处也随之凸显：提升资源利用率节省成本、更高效的持续集成，持续交付、解放运维、快速扩缩容，应对突发流量&hellip;</p>

<p>服务编排框架的成熟也让微服务的概念得以落地，同时也催生了java界微服务化的方案，像SpringBoot，SpringCloud。然而服务编排一定是对微服务的编排吗？也就是我们容器里运行的一定是微服务吗？不是的，我们可以运行任何服务，我们现有的业务可以不做任何改造就运行到容器中，让kubernetes去管理、调度。至于微服务呢，只是有了kubernetes，让微服务变得容易管理了。让我们有条件把服务拆分的足够小，足够简单。再也不用担心运维管理的复杂了。了解了docker，服务编排，微服务的关系，我们在看看他们在企业的落地情况。</p>

<p>k8s实现了容器编排工具，能够满足微服务架构拆分落地的需求，包括了管理和运维。k8s算是一个工具，而微服务更多的是个一个概念，架构，可以使用k8s实现，Istio就是微服务使用k8s实现的一个实现。</p>

<h5 id="serverless">Serverless</h5>

<p>Serverless被翻译为“无服务器架构”，重应用，轻服务器，k8s其实就是这么一个概念。</p>

<h4 id="分布式事务">分布式事务</h4>

<p>分布式事务的解决方案依旧没有统一，还是要看大家的具体业务设计。</p>

<p>在这一代的发展趋势中，就更加注重大中台的发展策略了，微服务可以在大中台中更加彻底。组织架构</p>

<pre><code>大中台，小前台
</code></pre>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/architecture/microservices/microservices/">https://kingjcy.github.io/post/architecture/microservices/microservices/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/architecture/">
                            <i class="fa fa-tags"></i>
                            architecture
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/microservices/">
                            <i class="fa fa-tags"></i>
                            microservices
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/architecture/microservices/go-micro/">Go Micro</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月11日)</span></li><li id="li-rels"><a href="/post/architecture/server/">Server</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年01月31日)</span></li><li id="li-rels"><a href="/post/architecture/map/uml/">UML 基本使用</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2017年11月08日)</span></li><li id="li-rels"><a href="/post/architecture/cache/">Cache</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年06月15日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/database/postgresql/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/golang/go-server/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#微服务架构演变由来">微服务架构演变由来</a>
<ul>
<li><a href="#单体架构">单体架构</a></li>
<li><a href="#垂直拆分的垂直架构">垂直拆分的垂直架构</a></li>
<li><a href="#第一代微服务-服务化">第一代微服务&mdash;服务化</a>
<ul>
<li>
<ul>
<li><a href="#第一代微服务框架">第一代微服务框架</a></li>
<li><a href="#soa">SOA</a></li>
<li><a href="#中台">中台</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#大中台">大中台</a>
<ul>
<li><a href="#下一代微服务-去中心化">下一代微服务&ndash;去中心化</a>
<ul>
<li>
<ul>
<li><a href="#service-mesh">Service Mesh</a></li>
<li><a href="#k8s和微服务">k8s和微服务</a>
<ul>
<li><a href="#serverless">Serverless</a></li>
</ul></li>
<li><a href="#分布式事务">分布式事务</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

