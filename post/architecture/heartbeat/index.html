<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="在多客户端同时访问服务器的工作模式下，首先要保证服务器的运行正常。因此，Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕的服务器资源浪费。会使得服务器可服务的客户端数量大幅度减少。因此，针对短链接和长连接，根据业务的需求，配套不同的处理机制。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Heartbeat - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Heartbeat
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2018年04月18日 
                </div>
                <h1 class="post-title">Heartbeat</h1>
            </header>

            <div class="post-content">
                <p>在多客户端同时访问服务器的工作模式下，首先要保证服务器的运行正常。因此，Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕的服务器资源浪费。会使得服务器可服务的客户端数量大幅度减少。因此，针对短链接和长连接，根据业务的需求，配套不同的处理机制。</p>

<p>短连接</p>

<p>    一般建立完连接，就立刻传输数据。传输完数据，连接就关闭。服务端根据需要，设定连接的时长。超过时间长度，就算客户端超时。立刻关闭连接。</p>

<p>长连接</p>

<p>    建立连接后，传输数据，然后要保持连接，然后再次传输数据。直到连接关闭。</p>

<p> </p>

<p>socket读写可以通过 SetDeadline、SetReadDeadline、SetWriteDeadline设置阻塞的时间。</p>

<pre><code>func (*IPConn) SetDeadline  
func (c *IPConn) SetDeadline(t time.Time) error  

func (*IPConn) SetReadDeadline  
func (c *IPConn) SetReadDeadline(t time.Time) error  

func (*IPConn) SetWriteDeadline  
func (c *IPConn) SetWriteDeadline(t time.Time) error 
</code></pre>

<p>   
如果做短连接，直接在Server端的连接上设置SetReadDeadline。当你设置的时限到达，无论客户端是否还在继续传递消息，服务端都不会再接收。并且已经关闭连接。</p>

<pre><code>func main() {
    server := &quot;:7373&quot;
    netListen, err := net.Listen(&quot;tcp&quot;, server)
    if err != nil{
        Log(&quot;connect error: &quot;, err)
        os.Exit(1)
    }
    Log(&quot;Waiting for Client ...&quot;)
    for{
        conn, err := netListen.Accept()
        if err != nil{
            Log(conn.RemoteAddr().String(), &quot;Fatal error: &quot;, err)
            continue
        }

        //设置短连接(10秒)
        conn.SetReadDeadline(time.Now().Add(time.Duration(10)*time.Second))

        Log(conn.RemoteAddr().String(), &quot;connect success!&quot;)
        ...
    }
}
 
</code></pre>

<p>   
这就可以了。在这段代码中，每当10秒中的时限一道，连接就终止了。</p>

<p> </p>

<p>   
根据业务需要，客户端可能需要长时间保持连接。但是服务端不能无限制的保持。这就需要一个机制，如果超过某个时间长度，服务端没有获得客户端的数据，就判定客户端已经不需要连接了（比如客户端挂掉了）。</p>

<p>   
做到这个，需要一个心跳机制。在限定的时间内，客户端给服务端发送一个指定的消息，以便服务端知道客户端还活着。</p>

<pre><code>func sender(conn *net.TCPConn) {
    for i := 0; i &lt; 10; i++{
        words := strconv.Itoa(i)+&quot; Hello I'm MyHeartbeat Client.&quot;
        msg, err := conn.Write([]byte(words))
        if err != nil {
            Log(conn.RemoteAddr().String(), &quot;Fatal error: &quot;, err)
            os.Exit(1)
        }
        Log(&quot;服务端接收了&quot;, msg)
        time.Sleep(2 * time.Second)
    }
    for i := 0; i &lt; 2 ; i++ {
        time.Sleep(12 * time.Second)
    }
    for i := 0; i &lt; 10; i++{
        words := strconv.Itoa(i)+&quot; Hi I'm MyHeartbeat Client.&quot;
        msg, err := conn.Write([]byte(words))
        if err != nil {
            Log(conn.RemoteAddr().String(), &quot;Fatal error: &quot;, err)
            os.Exit(1)
        }
        Log(&quot;服务端接收了&quot;, msg)
        time.Sleep(2 * time.Second)
    }

}
</code></pre>

<p>   
这段客户端代码，实现了两个相同的信息发送频率给服务端。两个频率中间，我们让运行休息了12秒。是一种模拟心跳的方式。然后，我们在服务端的对应机制是这样的。</p>

<p> </p>

<pre><code>func HeartBeating(conn net.Conn, bytes chan byte, timeout int) {
    select {
    case fk := &lt;- bytes:
        Log(conn.RemoteAddr().String(), &quot;心跳:第&quot;, string(fk), &quot;times&quot;)
        conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Second))
        break

        case &lt;- time.After(5 * time.Second):
            Log(&quot;conn dead now&quot;)
            conn.Close()
    }
}
</code></pre>

<p>   
每次接收到心跳数据就 SetDeadline 延长一个时间段 timeout。如果没有接到心跳数据，5秒后连接关闭。</p>

<p> </p>

<p>服务端完整代码示例</p>

<pre><code>/**
* MyHeartbeatServer
* @Author:  Jian Junbo
* @Email:   junbojian@qq.com
* @Create:  2017/9/16 14:02
* Copyright (c) 2017 Jian Junbo All rights reserved.
*
* Description:  
*/
package main

import (
    &quot;net&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;time&quot;
)

func main() {
    server := &quot;:7373&quot;
    netListen, err := net.Listen(&quot;tcp&quot;, server)
    if err != nil{
        Log(&quot;connect error: &quot;, err)
        os.Exit(1)
    }
    Log(&quot;Waiting for Client ...&quot;)
    for{
        conn, err := netListen.Accept()
        if err != nil{
            Log(conn.RemoteAddr().String(), &quot;Fatal error: &quot;, err)
            continue
        }

        //设置短连接(10秒)
        conn.SetReadDeadline(time.Now().Add(time.Duration(10)*time.Second))

        Log(conn.RemoteAddr().String(), &quot;connect success!&quot;)
        go handleConnection(conn)

    }
}
func handleConnection(conn net.Conn) {
    buffer := make([]byte, 1024)
    for {
        n, err := conn.Read(buffer)
        if err != nil {
            Log(conn.RemoteAddr().String(), &quot; Fatal error: &quot;, err)
            return
        }

        Data := buffer[:n]
        message := make(chan byte)
        //心跳计时
        go HeartBeating(conn, message, 4)
        //检测每次是否有数据传入
        go GravelChannel(Data, message)

        Log(time.Now().Format(&quot;2006-01-02 15:04:05.0000000&quot;), conn.RemoteAddr().String(), string(buffer[:n]))
    }

    defer conn.Close()
}
func GravelChannel(bytes []byte, mess chan byte) {
    for _, v := range bytes{
        mess &lt;- v
    }
    close(mess)
}
func HeartBeating(conn net.Conn, bytes chan byte, timeout int) {
    select {
    case fk := &lt;- bytes:
        Log(conn.RemoteAddr().String(), &quot;心跳:第&quot;, string(fk), &quot;times&quot;)
        conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Second))
        break

        case &lt;- time.After(5 * time.Second):
            Log(&quot;conn dead now&quot;)
            conn.Close()
    }
}
func Log(v ...interface{}) {
    fmt.Println(v...)
    return
}
</code></pre>

<p>客户端完整代码示例</p>

<pre><code> 

/**
* MyHeartbeatClient
* @Author:  Jian Junbo
* @Email:   junbojian@qq.com
* @Create:  2017/9/16 14:21
* Copyright (c) 2017 Jian Junbo All rights reserved.
*
* Description:  
*/
package main

import (
    &quot;net&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;strconv&quot;
    &quot;time&quot;
)

func main() {
    server := &quot;127.0.0.1:7373&quot;

    tcpAddr, err := net.ResolveTCPAddr(&quot;tcp4&quot;,server)
    if err != nil{
        Log(os.Stderr,&quot;Fatal error:&quot;,err.Error())
        os.Exit(1)
    }
    conn, err := net.DialTCP(&quot;tcp&quot;,nil,tcpAddr)
    if err != nil{
        Log(&quot;Fatal error:&quot;,err.Error())
        os.Exit(1)
    }
    Log(conn.RemoteAddr().String(), &quot;connection succcess!&quot;)

    sender(conn)
    Log(&quot;send over&quot;)
}
func sender(conn *net.TCPConn) {
    for i := 0; i &lt; 10; i++{
        words := strconv.Itoa(i)+&quot; Hello I'm MyHeartbeat Client.&quot;
        msg, err := conn.Write([]byte(words))
        if err != nil {
            Log(conn.RemoteAddr().String(), &quot;Fatal error: &quot;, err)
            os.Exit(1)
        }
        Log(&quot;服务端接收了&quot;, msg)
        time.Sleep(2 * time.Second)
    }
    for i := 0; i &lt; 2 ; i++ {
        time.Sleep(12 * time.Second)
    }
    for i := 0; i &lt; 10; i++{
        words := strconv.Itoa(i)+&quot; Hi I'm MyHeartbeat Client.&quot;
        msg, err := conn.Write([]byte(words))
        if err != nil {
            Log(conn.RemoteAddr().String(), &quot;Fatal error: &quot;, err)
            os.Exit(1)
        }
        Log(&quot;服务端接收了&quot;, msg)
        time.Sleep(2 * time.Second)
    }

}
func Log(v ...interface{}) {
    fmt.Println(v...)
    return
}
</code></pre>

<p>这是一种比较简略的心跳实现方式，其实正常做法是在Server和Socket之间设计通讯机制，当两者之间没有信息交互时，双方便会定时发送数据包(心跳)，以维持连接状态。</p>

<p>在c/s模型下我认为一般都是要双方发送心跳包来告知对方，目前的状态，但是为了节省资源，个人认为最好：客户端主动发送,要是服务器超时没收到,也会发送反向心跳包过来检测的</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/architecture/heartbeat/">https://kingjcy.github.io/post/architecture/heartbeat/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/heartbeat/">
                            <i class="fa fa-tags"></i>
                            Heartbeat
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/middleware/mq/mq-compare/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/database/tsdb/influxdb/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

