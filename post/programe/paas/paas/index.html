<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="主要是移动容器云平台的建设
paas版本到1.0
paas平台是一个运行管理监控容器应用的自动化平台，集成了前端门户，api网关，权限模块，资源模块，应用模块，集群模块，监控告警，能力模块这些模块，实现了应用的快速开发，测试，简单部署，监控告警等运维功能的平台，主要使用了k8s相关组件，docker，harbor等容器技术，kong api网关技术，基于rbac的权限控制技术，prometheus&#43;grafana监控告警技术，flannel，caclio等网络技术，etcd，redis，mysql等存储技术，实现单点登录，服务发现，数据存储等。其实就是一个给产品跑的服务平台。
1.门户界面
登录&ndash;首页&mdash;-个人资源概览&ndash;应用／系统／资源运维&ndash;监控告警
具体看监控告警界面
有文件可以参考&mdash;ppt
租户&ndash;集群&ndash;namespace&ndash;应用-方法
cpu／内存／磁盘／应用／容器／镜像仓库（只有一个harbor，多个库）／审计日志（啥时干啥）／告警
cpu／内存／磁盘／应用／容器／镜像数／审计日志（啥时干啥）／告警
应用／容器／负载均衡器／审计日志（啥时干啥）／告警
cpu／内存／调用成功失败
调用的方法。qps一秒钟查询响应次数 ms响应时间
2.api网关&ndash;kong，中间件
kong 0.12.1
一个网关的基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。
API网关更专注于安全、流量、路由等问题
技术选型
kong tyK zuul apiaxle: Nodejs 实现的一个 API 网关。 api-umbrella: Ruby
对比了几个开源项目觉得Mashape/kong和TykTechnologies/tyk 可以选用，从star数来看空占优支持性较好，
但是微服务过渡团队更多的会使用golang作为开发语言，个人更倾向于tyk。
tyk部分功能存在收费，闭源问题。
kong 有nginx作支持更有保障，安装简单，扩展性强一点
并且选择kong的人多过tyk。
可扩展性，Kong依赖一个数据库来实现配置存储，
依赖 serf 来实现 instance 之间的通信。
任何一个节点修改了其他节点会收到通知并重新reload配置。
模块化，Kong 可以方便地增加新的插件，并且插件可以通过 Restful API 进行管理 Kong采用插件机制进行功能定制，插件集（可以是0或n个）在API请求响应循环的生命周期中被执行。插件使用Lua编写，目前已有几个基础功能：HTTP基本认证、密钥认证、CORS（ Cross-origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API请求限流、请求转发以及nginx监控。
数量瓶颈
水平扩展多个Kong服务器，通过前置的负载均衡配置把请求均匀地分发到各个Server，来应对大批量的网络请求。
kong 集群将使得系统通过增加更多机器，从而实现水平扩展，承接更多的请求流量。它们将共享同样的配置且使用同一个数据库。kong 集群中的的所有节点都连接同一个数据库。
你需要在 kong 集群的上一层架设一个负载均衡的代理服务器，以便请求能够平均分散转发到 kong 的各个节点上。
考虑到性能原因，当 kong 代理请求的时候，为了避免频繁的数据库连接操作，kong 将会把以下 db 内容缓存到本机内存中。这些缓存包括：API定义，用户信息，插件信息，授权认证信息等。由于这些值在本机缓存中，通过 Admin api 去更新任何一个节点本地缓存中的值，都需要传播给其他节点。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="项目系列---- PaaS平台 - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    项目系列---- PaaS平台
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2017年04月18日 
                </div>
                <h1 class="post-title">项目系列---- PaaS平台</h1>
            </header>

            <div class="post-content">
                <p>主要是移动容器云平台的建设</p>

<p>paas版本到1.0</p>

<p>paas平台是一个运行管理监控容器应用的自动化平台，集成了前端门户，api网关，权限模块，资源模块，应用模块，集群模块，监控告警，能力模块这些模块，实现了应用的快速开发，测试，简单部署，监控告警等运维功能的平台，主要使用了k8s相关组件，docker，harbor等容器技术，kong api网关技术，基于rbac的权限控制技术，prometheus+grafana监控告警技术，flannel，caclio等网络技术，etcd，redis，mysql等存储技术，实现单点登录，服务发现，数据存储等。其实就是一个给产品跑的服务平台。</p>

<p>1.门户界面</p>

<p>登录&ndash;首页&mdash;-个人资源概览&ndash;应用／系统／资源运维&ndash;监控告警</p>

<p>具体看监控告警界面</p>

<p>有文件可以参考&mdash;ppt</p>

<p>租户&ndash;集群&ndash;namespace&ndash;应用-方法</p>

<p>cpu／内存／磁盘／应用／容器／镜像仓库（只有一个harbor，多个库）／审计日志（啥时干啥）／告警</p>

<p>cpu／内存／磁盘／应用／容器／镜像数／审计日志（啥时干啥）／告警</p>

<p>应用／容器／负载均衡器／审计日志（啥时干啥）／告警</p>

<p>cpu／内存／调用成功失败</p>

<p>调用的方法。qps一秒钟查询响应次数 ms响应时间</p>

<p>2.api网关&ndash;kong，中间件</p>

<p>kong 0.12.1</p>

<p>一个网关的基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。</p>

<p>API网关更专注于安全、流量、路由等问题</p>

<p>技术选型</p>

<p>kong tyK  zuul  apiaxle: Nodejs 实现的一个 API 网关。
api-umbrella: Ruby</p>

<p>对比了几个开源项目觉得Mashape/kong和TykTechnologies/tyk 可以选用，从star数来看空占优支持性较好，</p>

<p>但是微服务过渡团队更多的会使用golang作为开发语言，个人更倾向于tyk。</p>

<p>tyk部分功能存在收费，闭源问题。</p>

<p>kong 有nginx作支持更有保障，安装简单，扩展性强一点</p>

<p>并且选择kong的人多过tyk。</p>

<p>可扩展性，Kong依赖一个数据库来实现配置存储，</p>

<p>依赖 serf 来实现 instance 之间的通信。</p>

<p>任何一个节点修改了其他节点会收到通知并重新reload配置。</p>

<p>模块化，Kong 可以方便地增加新的插件，并且插件可以通过 Restful API 进行管理
Kong采用插件机制进行功能定制，插件集（可以是0或n个）在API请求响应循环的生命周期中被执行。插件使用Lua编写，目前已有几个基础功能：HTTP基本认证、密钥认证、CORS（ Cross-origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API请求限流、请求转发以及nginx监控。</p>

<p>数量瓶颈</p>

<p>水平扩展多个Kong服务器，通过前置的负载均衡配置把请求均匀地分发到各个Server，来应对大批量的网络请求。</p>

<p>kong 集群将使得系统通过增加更多机器，从而实现水平扩展，承接更多的请求流量。它们将共享同样的配置且使用同一个数据库。kong 集群中的的所有节点都连接同一个数据库。</p>

<p>你需要在 kong 集群的上一层架设一个负载均衡的代理服务器，以便请求能够平均分散转发到 kong 的各个节点上。</p>

<p>考虑到性能原因，当 kong 代理请求的时候，为了避免频繁的数据库连接操作，kong 将会把以下 db 内容缓存到本机内存中。这些缓存包括：API定义，用户信息，插件信息，授权认证信息等。由于这些值在本机缓存中，通过 Admin api 去更新任何一个节点本地缓存中的值，都需要传播给其他节点。</p>

<p>所以在一个节点上进行操作时，其他节点会由于本地缓存不会立即更新，所以需要更新时间设置</p>

<p>◦ db_update_frequency (默认: 5 秒)</p>

<p>原理</p>

<p>通过8001端口注册api的请求参数和url</p>

<p>直接通过8000端口调用</p>

<p>使用插件对请求进行处理，如下</p>

<p>1.消息转发</p>

<p>就是不出来直接送到后端api中，也就是直接通过8000端口进行请求</p>

<p>用户鉴权</p>

<p>1、首先kong自身使用basic-auth插件进行检验</p>

<p>2.调用鉴权模块的api，这边写了一个插件，可以参考文档，有时间学习一些</p>

<p>流量控制</p>

<p>使用插件rate-limiting，
根据年、月、日、时、分、秒设置限流规则，多个限制同时生效。</p>

<p>比如：每天不能超过10次调用，每分不能超过3次。</p>

<p>当一分钟内，访问超过3次，第四次就会报错。</p>

<p>当一天内，访问次数超过10次，第十一次就会报错。</p>

<p>在过滤器的run方法中判断请求剩余次数，小于0就拦截请求：</p>

<p>熔断</p>

<p>当调用满足失败次数，失败比例就会触发熔断器打开，有程序自动切断当前的RPC调用,来防止错误进一步扩大。实现一个熔断器主要是考虑三种模式，关闭，打开，半开。各个状态的转换如下图。</p>

<p>熔断关闭: 熔断关闭不会对服务进行熔断，当请求服务失败次数符合设定的规则则进入熔断机制
半熔断： 部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断；
熔断打开：请求不再进行调用当前服务，内部设置时钟一般为(MTTR：平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态。
基于服务策略触发</p>

<p>问题处理</p>

<p>容错</p>

<p>网关的可降级、可限流、可隔离等等一系列容错能力
我们常见的降级，限流，熔断器，超时重试等等都是容错的方法。</p>

<p>1.使用nio异步非阻塞机制抗量
2.使用缓存，脱离db&ndash;多级缓存：本地缓存&ndash;reids&ndash;redis直接作为db，可以使用实效时间来实现冷热数据，穿透率：比如查询方法queryOrder(调用次数1000/1s)里面嵌套查询DB方法queryProductFromDb(调用次数300/s)，那么redis的穿透率就是300/1000,在这种使用缓存的方式下，是要重视穿透率的，穿透率大了说明缓存的效果不好。也可以不用失效时间，直接通过时间戳对比
3。超时重试
4.熔断
5。线程池隔离
6.降级，流量控制</p>

<p>网关监控与统计</p>

<p>那么每一步发生的异常要记录下来，统一存储到一个地方比如elasticserach中，便于后续对调用异常的分析</p>

<p>3.应用管理</p>

<p>就是对于产品的部署，运维，类似于应用市场的产品的一键流程发布</p>

<p>4.资源管理</p>

<p>资源申请审批分配</p>

<p>地域，机房，机架等资源信息录入，检测，分配，回收。</p>

<p>5.权限管理&ndash;系统管理</p>

<p>版本 自己定的0.2</p>

<p>基于rbac的管理。。。。。用户，角色，权限&mdash;&mdash;paas系统，harbor系统，kubernetes系统</p>

<p>租户。 集群</p>

<p>用户组 域</p>

<p>用户   角色。  权限。  资源</p>

<p>paas</p>

<p>Sysadmin
唯一，运维人员使用，具有所有权限
实际权限和Groupadmin一致，可在用户登录的时候，选择命名空间进行操作
系统管理员可在页面创建的namespace默认放到group为system的组下，系统管理员默认为system组的groupadmin
字段标识：0
systemAdmin只能创建admin，然后admin去创建其他用户。</p>

<p>Groupadmin
由sysadmin授权
只能管理自己所在组
对应harbor中的admin角色(只能管理自己组)
对应k8s中管理员角色(只能管理自己组)
可创建当前组用户
可创建当前组域
字段标识：1
只有sysadmin可以增删改查group
只能获取当前用户组下的用户</p>

<p>Namespaceadmin
1、管理独立域下的资源
2、可以将当前组下的用户设置为开发者
3、可创建当前域下的开发者用户
4、只能查询当前组下的namespace
5、只有groupadmin可以创建namespace，groupadmin创建的namespace只能在当前group下
6、创建namespace会在数据库中有一条记录，在harbor创建一个project，在k8s中创建一个namespace，有一个失败就报错。
7、删除修改逻辑还没有实现，目前只是修改数据库中的数据。</p>

<p>Dev
1、无rbac操作权限
2、角色权限由系统管理员分配</p>

<p>自定义角色
1、只归属于一个域，不共享，创建时候需要指定域
2、可以由组管理员、域管理员来创建</p>

<p>初始化流程
1. 初始化一个rbac的admin用户，用户名密码支持可配置，group为-1</p>

<ol>
<li><p>调用k8sapi来创建这些角色&rdquo;groupadmin&rdquo;,&ldquo;namespaceadmin&rdquo;,&ldquo;developer&rdquo;,&ldquo;guest对应的clusterrole，用户后面的角色授权模板</p></li>

<li><p>初始化rbac基本角色&rdquo;sysadmin&rdquo;,&ldquo;groupadmin&rdquo;,&ldquo;namespaceadmin&rdquo;,&ldquo;developer&rdquo;,&ldquo;guest&rdquo;</p></li>

<li><p>初始化k8s中已经存在的namespace同步到rbac中，并且划分到对应的group，group不存在则创建一个。</p></li>
</ol>

<p>登录
登录就是把输入的密码和数据库中的密码进行对比，登录成功后则将相关用户信息保存到session中，后面调用api前全部要检查是否登录，通过获取session中的user信息进行判断。登录结束时会返回当前用户的token，namespace，role.</p>

<p>授权
Namespacemember关联了Namespace ，User， Role表，给某个用户授予一个角色，先在数据库中创建一条关系数据，然后在harbor中创建这个角色(分配groupadmin不需要操作harbor),主要是同步用户，获取project，然后给他一个角色，最后在k8s中授予角色，同样需要同步用户，创建角色，还要进行角色绑定。</p>

<p>目前回收权限，修改权限还没有实现，只是操作数据库中的关系表。</p>

<p>角色
目前只能查看到当前角色权限之下的角色，自定义角色的的权重都是10，而上述说的角色的权重分别为1,2,3,4,5存在数据库中，同样删除修改只能在当前角色权重之下的角色。</p>

<p>Secret
目前是重harbor中获取auth然后到k8s中的当前namespace去创建一个名为currUser.Username + &ldquo;-pull-secret&rdquo;的secret。
K8s_proxy
用户授权
Api
/nl/api/rolebindings
参数：
Name：默认无，不填时 username+“-”+ roleName
Apiversion: 不填
Group：
Namespace：
roleName
userName
roleflag：0:sysadmin 1:groupadmin 2:其他</p>

<p>业务逻辑
授予系统管理员
条件：Roleflag = 0
流程：
创建系统管理员命名空间和组
namespace = &ldquo;default&rdquo; group := &ldquo;system&rdquo;
创建sa账户
在group为system，namespace为system，创建入参为username的用户
判断是否存在当前ClusterRole
创建ClusterRoleBinding</p>

<p>授予组管理员
条件：Roleflag = 1
流程：
查询入参group下的所有namespace
遍历所有namespace
查找入参roleName角色
若无，创建
查找入参为userName的所有sa
若无，创建
创建RoleBinding
完成</p>

<p>授予其他角色
条件：Roleflag != 0 &amp;&amp; Roleflag != 1
流程：
查找入参roleName、namespace下的serviceaccout，若无报错
查找入参roleName、namespace下的role，若无报错
创建rolebinding
创建namespace
创建ns
角色同步
创建完ns, 需要将该ns纳入到对应的用户管理下（比如groupAdmin），具体参见2.1.2.3</p>

<p>harbor。  1.2.0</p>

<p>k8s     1.8.8</p>

<p>6.集群管理</p>

<p>版本 1.8.8
端口 8080 6443</p>

<p>k8s集群持续集成</p>

<p>看k8s</p>

<p>组件原理</p>

<p>服务发现</p>

<p>7.监控告警</p>

<p>prometheus 2.2.0</p>

<p>node——exporter。0.15.2</p>

<p>alertmanager 0.14.0</p>

<p>grafana。 5.0.0</p>

<p>日志配置
路径：配置文件所在的路径。
格式：配置文件的格式。
解析器：可以选择ELK支持的解析器进行日志解析。</p>

<p>主要是采应用日志</p>

<p>告警主要是prometheus的采集数据发出告警</p>

<p>prometheus+grafana告警</p>

<p>prometheus联邦集群</p>

<p>同步k8s到本地的prometheus，使用prometheus告警模块</p>

<p>部署，脚本的自动化部署</p>

<p>在k8s中部署prometheus（9093），node_exporter（3000），结合kubelet中的cadvisor（4194），和k8s的服务发现机制，将数据采集到prometheus中，prometheus采用多副本数，形成一个service，完成高可用，然后采用分集群部署多个prometheus，最后过prometheus的faferation将相关的数据进行聚合</p>

<p>将alertmanager部署在k8s中，配置对应的告警规则</p>

<p>通过http api采集数据给ui使用，参考grafana的后端。</p>

<p>8.开发管理</p>

<p>依赖CICD应用开发代码提交到版本库，版本库触发自动编译生成新版本并上传到镜像库。</p>

<p>9.能力集成服务&ndash;工作流，工单，日志，配置</p>

<p>9台。  两个k8s集群</p>

<p>3个etcd</p>

<p>部署</p>

<p>部署前端的界面服务，部署kong网关，部署权限模块，部署资源管理模块，部署应用管理模块，部署能力集成模块&mdash;-</p>

<p>通过界面部署集群，监控告警，应用</p>

<p>登陆&ndash;申请资源&ndash;审批&mdash;自动化创建集群&mdash;创建应用&mdash;创建监控</p>

            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/programe/paas/paas/">https://kingjcy.github.io/post/programe/paas/paas/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/program/">
                            <i class="fa fa-tags"></i>
                            program
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/paas/">
                            <i class="fa fa-tags"></i>
                            paas
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/cloud/paas/paas/">云计算系列---- PaaS</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年01月02日)</span></li><li id="li-rels"><a href="/post/programe/paas/snpaas/">项目系列---- PaaS平台</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2017年04月18日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/middleware/network/application-netprotocol/websocket/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/programe/paas/snpaas/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

