<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="多做题，多做算法，保持思路的可扩展，与数学的结合。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Leetmeetcode 练习 - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Leetmeetcode 练习
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2018年11月05日 
                </div>
                <h1 class="post-title">Leetmeetcode 练习</h1>
            </header>

            <div class="post-content">
                <p>多做题，多做算法，保持思路的可扩展，与数学的结合。</p>

<h2 id="20181105">20181105</h2>

<p>题目</p>

<pre><code>1.partition labels

A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.



Example 1:

Input: S = &quot;ababcbacadefegdehijhklij&quot;
Output: [9,7,8]
Explanation:
The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.
This is a partition so that each letter appears in at most one part.
A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.


Note:

S will have length in range [1, 500].
S will consist of lowercase letters ('a' to 'z') only.
</code></pre>

<p>题解</p>

<p>把一个字符串尽可能分成多个部分，要求每个字符只能在一个字符串中出现</p>

<p>思路</p>

<p>遍历所有的字符串，以第一个为准，记住下一个出现的位置，循环往下，直到字符后面不会再出来的最后一个位置断开，以此类推，返回数组。</p>

<p>代码</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)
//import &quot;strings&quot;

func main() {
    var s string
    fmt.Println(&quot;please input strings:&quot;)
    fmt.Scan(&amp;s)

    site := make([]int,0)
    for {
        nSite := 0
        nTmp := 0

        for i := 0; i &lt; len(s); i++ {
            if i &gt; nSite{
                break
            }
            for j := i + 1; j &lt; len(s); j++ {
                if (s[i] == s[j]) {
                    fmt.Println(j)
                    if (nSite &gt;= nTmp) {
                        fmt.Println(nSite)
                        nSite = j
                        nTmp =nSite
                    }
                }
            }
        }


        site = append(site, nSite+1)
        fmt.Println(site)

        s = s[nSite+1:]
        fmt.Println(s)

        if s == &quot;&quot;{
            break
        }

        time.Sleep(1*time.Second)
    }

    fmt.Println(&quot;output: &quot;,site)
}
</code></pre>

<p>官方思路</p>

<p>一旦某个字母多次出现了，那么其最后一个出现位置必须要在当前子串中，我们关注的是每个字母最后的出现位置，我们可以使用一个HashMap来建立字母和其最后出现位置之间的映射，当前子串包含了所有已出现过的字母的最后一个位置，即之后的字符串里不会有之前出现过的字母了，此时就应该是断开的位置，我们将长度9加入结果res中</p>

<p>官方代码</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)
//import &quot;strings&quot;

func main() {
    var s string
    fmt.Println(&quot;please input strings:&quot;)
    fmt.Scan(&amp;s)

    mapHash := make(map[byte]int)
    site := make([]int,0)

    var nLast = 0
    var nStart = 0

    for i:=0; i&lt;len(s); i++ {
        mapHash[s[i]] = i
    }

    fmt.Println(&quot;map:&quot;,mapHash)

    for j:=0; j&lt;len(s); j++ {
        fmt.Println(s[j])
        nLast = int(math.Max(float64(nLast),float64(mapHash[s[j]])))
        fmt.Println(&quot;nLast:&quot;,nLast)
        if(j == nLast) {
            site = append(site,j-nStart+1)
            nStart = nLast+1
        }
    }
    fmt.Println(&quot;output: &quot;,site)

}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20190610-20190616">20190610-20190616</h2>

<p>题目</p>

<pre><code>Given a chemical formula (given as a string), return the count of each atom.

An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.

1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.

Two formulas concatenated together produce another formula. For example, H2O2He3Mg4 is also a formula.

A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.

Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.

Example 1:

Input:
formula = &quot;H2O&quot;
Output: &quot;H2O&quot;
Explanation:
The count of elements are {'H': 2, 'O': 1}.


Example 2:

Input:
formula = &quot;Mg(OH)2&quot;
Output: &quot;H2MgO2&quot;
Explanation:
The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.


Example 3:

Input:
formula = &quot;K4(ON(SO3)2)2&quot;
Output: &quot;K4N2O14S4&quot;
Explanation:
The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.


Note:

All atom names consist of lowercase letters, except for the first character which is uppercase.
The length of formula will be in the range [1, 1000].
formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.
</code></pre>

<p>题解</p>

<p>将化学方程式转化为元素个数这种string模式，并输出一个元素的k/v结构，化学方程式存在复数形式</p>

<p>思路</p>

<p>循环遍历，处理特殊情况</p>

<p>代码</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    &quot;unicode&quot;
)

/*
 * out of range?
 */

func main(){
    m := make(map[string]int)
    ms := make(map[string]int)

    var input string
    fmt.Println(&quot;please input chemical formula: &quot;)
    _,err := fmt.Scan(&amp;input)
    if err != nil {
        return
    }

    for i := 0;i &lt; len(input);i++ {
        if input[i] == '(' {
            fmt.Println(&quot;Brackets content :&quot;,input[i+1:])
            brackets := input[i+1:]
            for j := 0;j &lt; len(brackets);j++{
                if brackets[j] == ')' {
                    var coefficient int
                    if j+1 == len(brackets) {
                        coefficient = 1
                    }else {
                        if unicode.IsDigit(rune(brackets[j+1])) {
                            coefficient, err = strconv.Atoi(string(brackets[j+1]))
                            if err != nil {
                                return
                            }
                        }else {
                            coefficient = 1
                        }
                    }
                    fmt.Println(&quot;coefficient:&quot;,coefficient)

                    for k,v := range ms{
                        //fmt.Println(k,v)
                        ms[k] = v * coefficient
                    }

                    i = i + j + 2
                    break
                }
                if unicode.IsDigit(rune(brackets[j])){
                    coefficient,err := strconv.Atoi(string(brackets[j]))
                    fmt.Println(&quot;coefficient:&quot;,coefficient)
                    if err != nil {
                        return
                    }
                    ms[string(brackets[j-1])] = ms[string(brackets[j-1])] + coefficient - 1
                    continue
                }else {
                    ms[string(brackets[j])]++
                }

            }
        }else if unicode.IsDigit(rune(input[i])){
            coefficient,err := strconv.Atoi(string(input[i]))
            fmt.Println(&quot;coefficient:&quot;,coefficient)
            if err != nil {
                return
            }
            m[string(input[i-1])] = m[string(input[i-1])] + coefficient - 1
            continue
        }else {
            m[string(input[i])]++
        }
    }

    for k,v := range ms{
        m[k] = m[k] +v
    }

    for k,v := range m{
        fmt.Println(k,v)
    }

}
</code></pre>

<p>官方思路</p>

<p>无</p>

<p>官方代码</p>

<p>无</p>

<p>优化代码</p>

<p>无</p>

<h2 id="20190617-20190623">20190617-20190623</h2>

<p>题目</p>

<pre><code>Given an array of integers A, consider all non-empty subsequences of A.

For any sequence S, let the width of S be the difference between the maximum and minimum element of S.

Return the sum of the widths of all subsequences of A.

As the answer may be very large, return the answer modulo 10^9 + 7.

Example 1:

Input: [2,1,3]
Output: 6
Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].
The corresponding widths are 0, 0, 0, 1, 1, 2, 2.
The sum of these widths is 6.
Note:

1 &lt;= A.length &lt;= 20000
1 &lt;= A[i] &lt;= 20000
</code></pre>

<p>题解</p>

<p>给出一个数组，求出其所有的子队列，并求出每个子队列的最大值和最小值的差，然后将其求和返回</p>

<p>思路</p>

<p>求给出数组的长度，循环每个长度的组合</p>

<p>代码</p>

<p>官方思路</p>

<p>官方代码</p>

<p>优化代码</p>

<p>坚持</p>

<h2 id="20190916-20190922">20190916-20190922</h2>

<p>题目</p>

<pre><code>Given an array of integers A, consider all non-empty subsequences of A.

For any sequence S, let the width of S be the difference between the maximum and minimum element of S.

Return the sum of the widths of all subsequences of A.

As the answer may be very large, return the answer modulo 10^9 + 7.

Example 1:

Input: [2,1,3]
Output: 6
Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].
The corresponding widths are 0, 0, 0, 1, 1, 2, 2.
The sum of these widths is 6.
Note:

1 &lt;= A.length &lt;= 20000
1 &lt;= A[i] &lt;= 20000
</code></pre>

<p>题解</p>

<p>给出一个数组，求出其所有的子队列，并求出每个子队列的最大值和最小值的差，然后将其求和返回</p>

<p>思路</p>

<p>求给出数组的长度，循环每个长度的组合,将对应的差值放到一个数组中进行求和</p>

<p>代码</p>

<p>官方思路</p>

<p>官方代码</p>

<p>优化代码</p>

<h2 id="20191010">20191010</h2>

<p>题目</p>

<pre><code>Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>

<p>题解</p>

<p>给出一个数组，给出一个值，找出数组中两个数字之和的数字的下标</p>

<p>思路</p>

<p>循环遍历，直到a+b=target，输出下标</p>

<p>代码</p>

<pre><code>func twoSum(nums []int,target int)error{
    var targetIndex [2]int
    nLen := len(nums)
    for i:=0;i&lt;len(nums);i++{
        for j:=i;j&lt;nLen;j++{
            if nums[i] + nums[j] == target {
                targetIndex[0] = i
                targetIndex[1] = j
                fmt.Println(&quot;target index:&quot;,targetIndex)
                return nil
            }
        }
    }
    return errors.New(&quot;Do Not Find!&quot;)

}
</code></pre>

<p>官方思路</p>

<p>将数组的index和value做一个反向映射，遍历一个值为v，就能知道另一个值为target-v，这个时候直接使用map查找功能，就知道是否存在了，很nice</p>

<p>官方代码</p>

<pre><code>func twoSum(nums []int,target int)error{
    mNums := make(map[int]int,len(nums))

    for i,v := range nums {
        if j,ok := mNums[target-v];ok{
            fmt.Println(&quot;target index:&quot;,i,j)
            return nil
        }
        mNums[v] = i
    }

    return errors.New(&quot;Do Not Find!&quot;)
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191011">20191011</h2>

<p>题目</p>

<pre><code>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
</code></pre>

<p>题解</p>

<p>链表相加</p>

<p>思路</p>

<p>遍历，改变入表顺序即可</p>

<p>代码</p>

<pre><code>package main

import (
    &quot;container/list&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
)



func main() {
    fmt.Println(&quot;please first linklist:&quot;)
    l1,err := getLinkList()
    if err!= nil{
        fmt.Println(&quot;get first linklist faild!&quot;)
        return
    }

    fmt.Println(&quot;please Second linklist:&quot;)
    l2,err := getLinkList()
    if err!= nil{
        fmt.Println(&quot;get first linklist faild!&quot;)
        return
    }

    l := addLinkList(l1,l2)

    fmt.Println(&quot;Output:&quot;)
    for node := l.Front();node != nil;node = node.Next(){
        fmt.Print(node.Value,&quot;-&gt;&quot;)
    }

    addTwoNumbers(l1,l2)
}

func getLinkList()(*list.List,error){
    sContent := make([]byte, 100)
    n, err := os.Stdin.Read(sContent)
    if err != nil {
        fmt.Println(&quot;read array faild!&quot;)
        return nil,err
    }

    strContent := strings.Replace(string(sContent[:n]), &quot;\n&quot;, &quot;&quot;, -1)
    sstrContents := strings.Split(strContent, &quot;,&quot;)

    length := len(sstrContents)

    l := list.New()
    for i := 0; i &lt; length; i++ {
        nTmp, err := strconv.Atoi(string(sstrContents[i]))
        if err != nil {
            fmt.Println(&quot;transform array faild!&quot;, err)
            return nil,err
        }

        l.PushBack(nTmp)
    }

    return l,nil
}

func addLinkList(l1 *list.List,l2 *list.List)(*list.List){
    l := list.New()
    var bFlag = false
    var nSum  = 0

    for v1,v2 :=l1.Front(),l2.Front();v2 != nil &amp;&amp; v1 !=nil;v1,v2 = v1.Next(),v2.Next(){
        fmt.Println(v1.Value,v2.Value)
        if !bFlag{
            nSum = v1.Value.(int) + v2.Value.(int)
        }else {
            nSum = v1.Value.(int) + v2.Value.(int) + 1
            bFlag = false
        }

        if nSum &gt; 10 {
            l.PushBack(nSum-10)
            bFlag = true
        }else {
            l.PushBack(nSum)
        }

    }

    return l




}
</code></pre>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<p>无</p>

<p>优化代码</p>

<p>无</p>

<h2 id="20191012">20191012</h2>

<p>题目</p>

<pre><code>Given a string, find the length of the longest substring without repeating characters.

Example 1:

Input: &quot;abcabcbb&quot;
Output: 3
Explanation: The answer is &quot;abc&quot;, with the length of 3.
Example 2:

Input: &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.
Example 3:

Input: &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3.
             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</code></pre>

<p>题解</p>

<p>给一个字符串，找到它最长不重复的子字符串的长度</p>

<p>思路</p>

<p>未解决</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>定义一个数组，存储所有的字母的出现的上一次的位置，下标是对应字母的ASCII，如果数组的值比我们获取数组的left值大，说明有重复了，就将left更新成这个下标
在使用max来存储下标差的最大值就是需要的输出</p>

<p>官方代码</p>

<pre><code>func subString2(s string)(int){
    // location[s[i]] == j 表示：
    // s中第i个字符串，上次出现在s的j位置，所以，在s[j+1:i]中没有s[i]
    // location[s[i]] == -1 表示： s[i] 在s中第一次出现
    location := [256]int{} // 只有256长是因为，假定输入的字符串只有ASCII字符
    for i := range location {
        location[i] = -1 // 先设置所有的字符都没有见过
    }

    maxLen, left := 0, 0

    for i := 0; i &lt; len(s); i++ {
        // 说明s[i]已经在s[left:i+1]中重复了
        // 并且s[i]上次出现的位置在location[s[i]]
        if location[s[i]] &gt;= left {
            left = location[s[i]] + 1 // 在s[left:i+1]中去除s[i]字符及其之前的部分
        } else if i+1-left &gt; maxLen {
            // fmt.Println(s[left:i+1])
            maxLen = i + 1 - left
        }
        location[s[i]] = i
    }

    return maxLen
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191013">20191013</h2>

<p>题目</p>

<pre><code>There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Example 1:

nums1 = [1, 3]
nums2 = [2]
The median is 2.0
Example 2:

nums1 = [1, 2]
nums2 = [3, 4]
The median is (2 + 3)/2 = 2.5
</code></pre>

<p>题解</p>

<p>找到两个数组合并的中位数</p>

<p>思路</p>

<p>合并，排序，求中间数据</p>

<p>代码</p>

<pre><code>package median

import (
    &quot;fmt&quot;
    &quot;sort&quot;
)

type IntSlice []int

func (c IntSlice) Len() int {
    return len(c)
}
func (c IntSlice) Swap(i, j int) {
    c[i], c[j] = c[j], c[i]
}
func (c IntSlice) Less(i, j int) bool {
    return c[i] &lt; c[j]
}


func FindMedian(array1,array2 []int){
    var array IntSlice
    array = append(array1,array2...)
    fmt.Println(array1)
    fmt.Println(array2)
    fmt.Println(array)


    sort.Sort(array)

    fmt.Println(array)

    nMedian := len(array) /2
    nMod := len(array) % 2

    if nMod == 1 {
        fmt.Println(array[nMedian])
    }else{
        fmt.Println((array[nMedian] + array[nMedian+1])/2)
    }
}
</code></pre>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<p>无</p>

<p>优化代码</p>

<p>无</p>

<h2 id="20191016">20191016</h2>

<p>题目</p>

<pre><code>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example:

Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.
Example:

Input: &quot;cbbd&quot;
Output: &quot;bb&quot;
</code></pre>

<p>题解</p>

<p>求字符串中最长的回文，回文就是反过来一样</p>

<p>思路</p>

<p>遍历所有的字符串，判断是不是回文</p>

<p>代码</p>

<pre><code>package palindrome

import &quot;fmt&quot;

func Palindrome(str string)(string){
    var nMaxLength int
    var strPalindrom string
    for i:=0;i&lt;=len(str);i++{
        for j:=i+nMaxLength;j&lt;=len(str);j++{
            if ispalindrome(str[i:j]) {
                if nMaxLength &lt; j-i+1{
                    nMaxLength = j-i+1
                    strPalindrom = str[i:j]
                }
            }
        }
    }
    fmt.Println(strPalindrom)
    return strPalindrom
}

func ispalindrome(str string)(bool){
    i,j:=0,len(str)-1
    for {
        if i &lt;= j {
            if str[i] != str[j] {
                return false
            }
            i++
            j--
        }else {
                return true
        }
    }
}
</code></pre>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<pre><code>package problem0005

func longestPalindrome(s string) string {
    if len(s) &lt; 2 { // 肯定是回文，直接返回
        return s
    }

    // 最长回文的首字符索引，和最长回文的长度
    begin, maxLen := 0, 1

    // 在 for 循环中
    // b 代表回文的**首**字符索引号，
    // e 代表回文的**尾**字符索引号，
    // i 代表回文`正中间段`首字符的索引号
    // 在每一次for循环中
    // 先从i开始，利用`正中间段`所有字符相同的特性，让b，e分别指向`正中间段`的首尾
    // 再从`正中间段`向两边扩张，让b，e分别指向此`正中间段`为中心的最长回文的首尾
    for i := 0; i &lt; len(s); { // 以s[i]为`正中间段`首字符开始寻找最长回文。
        if len(s)-i &lt;= maxLen/2 {
            // 因为i是回文`正中间段`首字符的索引号
            // 假设此时能找到的最长回文的长度为l, 则，l &lt;= (len(s)-i)*2 - 1
            // 如果，len(s)-i &lt;= maxLen/2 成立
            // 则，l &lt;= maxLen - 1
            // 则，l &lt; maxLen
            // 所以，无需再找下去了。
            break
        }

        b, e := i, i
        for e &lt; len(s)-1 &amp;&amp; s[e+1] == s[e] {
            e++
            // 循环结束后，s[b:e+1]是一串相同的字符串
        }

        // 下一个回文的`正中间段`的首字符只会是s[e+1]
        // 为下一次循环做准备
        i = e + 1

        for e &lt; len(s)-1 &amp;&amp; b &gt; 0 &amp;&amp; s[e+1] == s[b-1] {
            e++
            b--
            // 循环结束后，s[b:e+1]是这次能找到的最长回文。
        }

        newLen := e + 1 - b
        // 创新记录的话，就更新记录
        if newLen &gt; maxLen {
            begin = b
            maxLen = newLen
        }
    }

    return s[begin : begin+maxLen]
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191017">20191017</h2>

<p>题目</p>

<pre><code>The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows:

func convert(text string, nRows int) string
convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;.
</code></pre>

<p>题解</p>

<p>将字符串按着Z子型来排列，然后获取横排重组</p>

<p>思路</p>

<p>p := 2*nRows-2</p>

<p>1:0*p,1*p
r:r,1*p-1,1*p+r,2*p-1,2*p+r,
最后：nRows-1+1*p，nRows-1+2*p，nRows-1+3*p</p>

<p>代码</p>

<pre><code>package zig

import &quot;fmt&quot;

func convert(text string, nRows int) string{
    p := 2*nRows-2
    var sContent []byte
    var nIndex = 0

    for i:=1;nIndex&lt;len(text);i++{
        sContent = append(sContent,text[nIndex])
        nIndex = i*p
    }

    nIndex=0

    for j:=1;j&lt;=nRows-2;j++{
        sContent = append(sContent,text[j])

        for k:=1;nIndex&lt;len(text);k++{
            nIndex = k*p -j
            if  nIndex &lt; len(text) {
                sContent = append(sContent, text[nIndex])
            }
            nIndex = k*p +j
            if nIndex &lt; len(text){
                sContent=append(sContent,text[nIndex])
            }

        }
    }

    r:=nRows-1
    nIndex=r
    for l:=1;nIndex&lt;len(text);l++{
        sContent=append(sContent,text[nIndex])
        nIndex=l*p+r
    }

    fmt.Println(string(sContent))
    return string(sContent)
}
</code></pre>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<p>无</p>

<p>优化代码</p>

<p>无</p>

<h2 id="20191018">20191018</h2>

<p>题目</p>

<pre><code>Reverse digits of an integer.

Example1: x = 123, return 321
Example2: x = -123, return -321
</code></pre>

<p>题解</p>

<p>将数字倒序</p>

<p>思路</p>

<p>slice倒叙</p>

<p>代码</p>

<pre><code>func reserve(n int){
    str := strconv.Itoa(n)
    var sContent []byte
    var nFlag = false

    if str[0] == '-' {
        sContent = append(sContent,str[0])
        nFlag = true
    }

    for i:=len(str)-1;i&gt;=0;i--{
        if nFlag &amp;&amp; i == 0{
            continue
        }
        sContent=append(sContent,str[i])
    }

    fmt.Println(string(sContent))
}
</code></pre>

<p>官方思路</p>

<p>求余相加</p>

<p>官方代码</p>

<pre><code>func reverse(x int) int {
    sign := 1

    // 处理负数
    if x &lt; 0 {
        sign = -1
        x = -1 * x
    }

    res := 0
    for x &gt; 0 {
        // 取出x的末尾
        temp := x % 10
        // 放入 res 的开头
        res = res*10 + temp
        // x 去除末尾
        x = x / 10
    }

    // 还原 x 的符号到 res
    res = sign * res

    // 处理 res 的溢出问题
    if res &gt; math.MaxInt32 || res &lt; math.MinInt32 {
        res = 0
    }

    return res
}
</code></pre>

<p>优化代码</p>

<p>一个正常思路，一个使用了字符串的特性</p>

<h2 id="20191021">20191021</h2>

<p>题目</p>

<pre><code>Implement &quot;atoi&quot; which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

Note:

Only the space character ' ' is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.
Example 1:

Input: &quot;42&quot;
Output: 42
Example 2:

Input: &quot;   -42&quot;
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42.
Example 3:

Input: &quot;4193 with words&quot;
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.
Example 4:

Input: &quot;words and 987&quot;
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.
Example 5:

Input: &quot;-91283472332&quot;
Output: -2147483648
Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Therefore INT_MIN (−231) is r
</code></pre>

<p>题解</p>

<p>把字符串转化为int类型</p>

<p>思路</p>

<p>byte类型可以直接使用int（）来转化</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>遍历，然后使用整数相加的模式</p>

<p>官方代码</p>

<pre><code>package myAtoi

func MyAtoi(str string) (result int) {
    if len(str)&gt;=0 {
        sign:=false
        for i:=0;i&lt;len(str);i++ {
            temp:=str[i:i+1]
            if temp != &quot; &quot; {
                temp1:=[]byte(temp)
                if i==0 &amp;&amp; (temp1[0] == '+' || temp1[0] == '-'){
                    if temp1[0] == '-' {
                        sign = true
                    }
                }else {
                    if temp1[0] &gt;= '0' &amp;&amp; temp1[0] &lt;= '9' {
                        result = result*10 + int(temp1[0] - '0')
                    } else {
                        break
                    }
                }
            }
        }
        if sign {
            result = -result
        }
        if result &lt;= (-1 &lt;&lt; 31) {
            result = -1 &lt;&lt; 31
        }
        if result &gt;= (1&lt;&lt;31 -1){
            result = 1&lt;&lt;31 -1
        }
    }
    return
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191022">20191022</h2>

<p>题目</p>

<pre><code>Determine whether an integer is a palindrome. Do this without extra space.
</code></pre>

<p>题解</p>

<p>检查一个字符串是否是回文</p>

<p>思路</p>

<p>正序遍历和逆序遍历是一样
前一半和后一半一样</p>

<p>代码</p>

<pre><code>package palindrome

func palindrome(str string)bool{
    i,j := 0,len(str)-1

    for i &lt;= j {
        if str[i] == str[j]{
            i++
            j--
        }else {
            return false
        }
    }
    return true
}
</code></pre>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<p>无</p>

<p>优化代码</p>

<p>无</p>

<h2 id="20191023">20191023</h2>

<p>题目</p>

<pre><code>Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and ''. Implement regular expression matching with support for '.' and ''.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
Example 2:

Input:
s = &quot;aa&quot;
p = &quot;a*&quot;
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.
Example 3:

Input:
s = &quot;ab&quot;
p = &quot;.*&quot;
Output: true
Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.
Example 4:

Input:
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.
Example 5:

Input:
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
Output: false
</code></pre>

<p>题解</p>

<p>给一个字符串和一个正则表达式，看他们能不能匹配</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>递归执行，每种情况都有正常字符和.*三种情况，然后递归调用</p>

<p>官方代码</p>

<pre><code>func isMatch(s string,p string)bool{
    if (len(p) &lt;= 0) {
        return len(s) &lt;= 0
    }
    match := (len(s) &gt; 0 &amp;&amp; (s[0] == p[0] || p[0] == '.'))
    if (len(p) &gt; 1 &amp;&amp; p[1] == '*'){
        return isMatch(s, p[2:]) || (match &amp;&amp; isMatch(s[1:], p))
    } else {
        return match &amp;&amp; isMatch(s[1:], p[1:])
    }
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191024">20191024</h2>

<p>题目</p>

<pre><code>Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and nis at least 2.





The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.



Example:

Input: [1,8,6,2,5,4,8,3,7]
Output: 49
</code></pre>

<p>题解</p>

<p>数组的k,v相当于x，y，对于这个数组算最大面积</p>

<p>思路</p>

<p>遍历对比</p>

<p>代码</p>

<p>算法复杂</p>

<p>官方思路</p>

<p>首位一个index，移动数值小的，因为只有大的才能有更大值，在x最大的情况下</p>

<p>官方代码</p>

<pre><code>func area(array []int){
    area := 0
    i,j:=0,len(array)-1
    for {
        if array[i] &lt; array[j] {
            if array[i] * (j-i) &gt; area {
                area = array[i] * (j-i)
            }
            i++
        }else {
            if array[j] * (j-i) &gt; area {
                area = array[j] * (j-i)
            }
            j--
        }

        if i&gt;=j {
            break
        }
    }
    fmt.Println(area)
}
</code></pre>

<p>优化代码</p>

<pre><code>func area(array []int){
    area := 0
    i,j:=0,len(array)-1
    for i&gt;=j {
        if array[i] &lt; array[j] {
            if array[i] * (j-i) &gt; area {
                area = array[i] * (j-i)
            }
            i++
        }else {
            if array[j] * (j-i) &gt; area {
                area = array[j] * (j-i)
            }
            j--
        }

    }
    fmt.Println(area)
}
</code></pre>

<h2 id="20191025">20191025</h2>

<p>题目</p>

<pre><code>oman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M(1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: 3
Output: &quot;III&quot;
Example 2:

Input: 4
Output: &quot;IV&quot;
Example 3:

Input: 9
Output: &quot;IX&quot;
Example 4:

Input: 58
Output: &quot;LVIII&quot;
Explanation: L = 50, V = 5, III = 3.
Example 5:

Input: 1994
Output: &quot;MCMXCIV&quot;
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
</code></pre>

<p>题解</p>

<pre><code>输入一个数字，输出对应的roman数字，roman有自己对应的规则
</code></pre>

<p>思路</p>

<p>根据规则来拼接roman</p>

<p>I II III IV V VI VII VIII IX X XI XII XIII XIV XV XVI XVII XVIII XIV XX</p>

<p>将数字转化为对应位的roman数值相加，然后拼接对应的字符</p>

<p>列举</p>

<p>代码</p>

<pre><code>func roman(n int){
    if n &lt; 0 || n &gt; 3999 {
        return
    }

    thousand := n / 1000
    n = n % 1000
    hundred := n / 100
    n = n % 100
    ten := n / 10
    one := n % 10

    d := [4][]string{
        []string{&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;},
        []string{&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;},
        []string{&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;},
        []string{&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;},
    }

    fmt.Println(d[3][thousand] +d[2][hundred]  + d[1][ten] + d[0][one])
}
</code></pre>

<p>官方思路</p>

<p>无</p>

<p>官方代码</p>

<p>无</p>

<p>优化代码</p>

<p>无</p>

<h2 id="20191028">20191028</h2>

<p>题目</p>

<pre><code>Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string &quot;&quot;.

Example 1:

Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
Output: &quot;fl&quot;
Example 2:

Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
Output: &quot;&quot;
Explanation: There is no common prefix among the input strings.
Note:

All given inputs are in lowercase letters a-z.
</code></pre>

<p>题解</p>

<p>求最大的共同前缀</p>

<p>思路</p>

<p>对比对应的字符是否一样就行</p>

<p>代码</p>

<pre><code>    func longsetCommonPrefix(strs []string){
        var minLen = len(strs[0])
        for _,v := range strs{
            if len(v) &lt; minLen {
                minLen = len(v)
            }
        }

        flag := false
        for i:=0;i&lt;minLen;i++{
            temp := strs[0][i]
            for _,v := range strs{
                if v[i] != temp {
                    fmt.Println(strs[0][:i])
                    flag = true
                break
            }
        }
        if flag {
            break
        }
    }

}
</code></pre>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<p>无</p>

<p>优化代码</p>

<p>无</p>

<h2 id="20191029">20191029</h2>

<p>题目</p>

<pre><code>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note: The solution set must not contain duplicate triplets.

For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre>

<p>题解</p>

<p>获取数组中所有三个数字相加等于0的</p>

<p>思路</p>

<p>遍历两个数相加，寻找第三个数,还要注意去重</p>

<p>代码</p>

<pre><code>func zero(array []int){
    var sum int
    var preNum = 0
    sort.Ints(array)
    for i:=0;i&lt;len(array);i++{
        if preNum == array[i]&amp;&amp;array[0] != 0{
            preNum = array[i]
            continue
        }
        preNum = array[i]
        for j:=i+1;j&lt;len(array);j++{
            sum = array[i] + array[j]
            for k:=j+1;k&lt;len(array);k++{
                if k != i &amp;&amp; k != j &amp;&amp; array[k] == -sum {
                    fmt.Println(array[i],array[j],array[k])
                    break
                }
            }
        }
    }
}
</code></pre>

<p>官方思路</p>

<p>将数据排序，range一个数字，寻找其他两个数字，另外两个数字重两边开始遍历，根据和和0的对比来决定坐标的移动，同时相同的需要拍重</p>

<p>官方代码</p>

<pre><code>package problem0015

import &quot;sort&quot;

func threeSum(nums []int) [][]int {
    // 排序后，可以按规律查找
    sort.Ints(nums)
    res := [][]int{}

    for i := range nums {
        if nums[i] &gt; 0 {
            break
        }
        // 避免添加重复的结果
        // i&gt;0 是为了防止nums[i-1]溢出
        if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] {
            continue
        }

        l, r := i+1, len(nums)-1

        for l &lt; r {
            s := nums[i] + nums[l] + nums[r]
            switch {
            case s &lt; 0:
                // 较小的 l 需要变大
                l++
            case s &gt; 0:
                // 较大的 r 需要变小
                r--
            default:
                res = append(res, []int{nums[i], nums[l], nums[r]})
                // 为避免重复添加，l 和 r 都需要移动到不同的元素上。
                l, r = next(nums, l, r)
            }
        }
    }

    return res
}

func next(nums []int, l, r int) (int, int) {
    for l &lt; r {
        switch {
        case nums[l] == nums[l+1]:
            l++
        case nums[r] == nums[r-1]:
            r--
        default:
            l++
            r--
            return l, r
        }
    }

    return l, r
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191030">20191030</h2>

<p>题目</p>

<pre><code>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

Example:

Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre>

<p>题解</p>

<p>寻找最接近target的三个数字之和</p>

<p>思路</p>

<p>遍历所有的sum获取差值最小的保存，如果为0直接返回</p>

<p>代码</p>

<pre><code>func closest(array []int,target int){
    var sum,margin,min = 0,float64(0),array[0] + array[1] + array[2]
    for i:= 0;i&lt;len(array);i++{
        for j:=i+1;j&lt;len(array);j++{
            for k:=j+1;k&lt;len(array);k++{
                sum = array[i] + array[j] + array[k]
                margin = math.Abs(float64(sum - target))
                if margin == 0 {
                    fmt.Println(0)
                    return
                }else if int(margin) &lt; min{
                    min = int(margin)
                }

            }
        }
    }
    fmt.Println(min)
}
</code></pre>

<p>官方思路</p>

<p>将数据排序，range一个数字，寻找其他两个数字，另外两个数字重两边开始遍历，根据和和target的对比来决定坐标的移动，获取最小值</p>

<p>官方代码</p>

<pre><code>package problem0016

import (
    &quot;math&quot;
    &quot;sort&quot;
)

func threeSumClosest(nums []int, target int) int {
    // 排序后，可以按规律查找
    sort.Ints(nums)
    res, delta := 0, math.MaxInt64

    for i := range nums {
        // 避免重复计算
        if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] {
            continue
        }

        l, r := i+1, len(nums)-1

        for l &lt; r {
            s := nums[i] + nums[l] + nums[r]
            switch {
            case s &lt; target:
                l++
                if delta &gt; target-s {
                    delta = target - s
                    res = s
                }
            case s &gt; target:
                r--
                if delta &gt; s-target {
                    delta = s - target
                    res = s
                }
            default:
                return s
            }
        }
    }

    return res
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191031">20191031</h2>

<p>题目</p>

<pre><code>Given a digit string, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below.

Input:Digit string &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]
Note: Although the above answer is in lexicographical order, your answer could be in any order you want.
</code></pre>

<p>题解</p>

<p>一个手机按键形成的字典，获取对应数字上字母的所有组合</p>

<p>思路</p>

<p>主要是字典的设定，使用map，其实使用数组也是一样的，下标相当于key，然后就是递归遍历</p>

<p>代码</p>

<p>未实现</p>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<pre><code>var digitMap = []string{&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}

func letterCombinations(digits string) []string {
    results := []string{}
    if len(digits) &lt; 1 {
        return []string{}
    }
    letters := digitMap[int(digits[0] - '0')]
    if len(digits) == 1 {
        for _, v := range letters {
            results = append(results, string(v))
        }
    } else {
        for _, v := range letters {
            for _, vs := range letterCombinations(string(digits[1:])) {
                results = append(results, string(v)+string(vs))
            }
        }
    }

    return results
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191101">20191101</h2>

<p>题目</p>

<pre><code>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note: The solution set must not contain duplicate quadruplets.

For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</code></pre>

<p>题解</p>

<p>四个数字相加等于target</p>

<p>思路</p>

<p>我想错了，我以为是只是最小的差值，再去找具体四个数字的所有组合还是比较麻烦的。</p>

<p>代码</p>

<pre><code>func fourSum(array []int,target int){
    var sum,margin,min = 0,float64(0),array[0] + array[1] + array[2] +array[3]
    for i:= 0;i&lt;len(array);i++{
        for j:=i+1;j&lt;len(array);j++{
            for k:=j+1;k&lt;len(array);k++{
                for l:=k+1;l&lt;len(array);l++ {
                    sum = array[i] + array[j] + array[k] + array[l]
                    margin = math.Abs(float64(sum - target))
                    if margin == 0 {
                        fmt.Println(0)
                        return
                    } else if int(margin) &lt; min {
                        min = int(margin)
                    }
                }

            }
        }
    }
    fmt.Println(min)
}
</code></pre>

<p>官方思路</p>

<p>在3sum上多一层寻找两个数的循环</p>

<p>官方代码</p>

<pre><code>func fourSum(nums []int, target int) [][]int {
    res := [][]int{}
    sort.Ints(nums)

    for i := 0; i &lt; len(nums)-3; i++ {
        // 避免添加重复的结果
        // i&gt;0 是为了防止nums[i-1]溢出
        if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] {
            continue
        }

        for j := i + 1; j &lt; len(nums)-2; j++ {
            // 避免添加重复的结果
            // nums[j-1]虽然不会溢出
            // 但是不添加 j &gt; i+1 的话，会漏掉那些i和j为相同数值的答案
            if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1] {
                continue
            }

            l, r := j+1, len(nums)-1
            for l &lt; r {
                s := nums[i] + nums[j] + nums[l] + nums[r]
                switch {
                case s &lt; target:
                    l++
                case s &gt; target:
                    r--
                default:
                    res = append(res, []int{nums[i], nums[j], nums[l], nums[r]})
                    l, r = next(nums, l, r)
                }
            }
        }

    }
    return res
}

func next(nums []int, l, r int) (int, int) {
    for l &lt; r {
        switch {
        case nums[l] == nums[l+1]:
            l++
        case nums[r] == nums[r-1]:
            r--
        default:
            l++
            r--
            return l, r
        }
    }

    return l, r
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191104">20191104</h2>

<p>题目</p>

<pre><code>Given a linked list, remove the nth node from the end of list and return its head.

For example,

Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.
After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
Note:

Given n will always be valid. 不存在链的长度&lt;n的情况
Try to do this in one pass.
</code></pre>

<p>题解</p>

<p>给一个链表，给出重链表结尾处第n个数据删除，返回这个新链表</p>

<p>思路</p>

<p>对于链表的表达有一点问题</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>直接将next指向下一个，最主要的是找到个node和链表的表达形式</p>

<p>官方代码</p>

<pre><code>package problem0019

/*
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

// ListNode 是节点
type ListNode struct {
    Val  int
    Next *ListNode
}

func removeNthFromEnd(head *ListNode, n int) *ListNode {
    d, headIsNthFromEnd := getDaddy(head, n)

    if headIsNthFromEnd {
        // 删除head节点
        return head.Next
    }

    d.Next = d.Next.Next

    return head
}

// 获取倒数第N个节点的父节点
func getDaddy(head *ListNode, n int) (daddy *ListNode, headIsNthFromEnd bool) {
    daddy = head

    for head != nil {
        if n &lt; 0 {
            daddy = daddy.Next
        }

        n--
        head = head.Next
    }

    // n==0，说明链的长度等于n
    headIsNthFromEnd = n == 0

    return
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191104-1">20191104</h2>

<p>题目</p>

<pre><code>Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: &quot;()&quot;
Output: true
Example 2:

Input: &quot;()[]{}&quot;
Output: true
Example 3:

Input: &quot;(]&quot;
Output: false
Example 4:

Input: &quot;([)]&quot;
Output: false
Example 5:

Input: &quot;{[]}&quot;
Output: true
Given a string containing just the characters `'( '`, `') '`, `'{ '`, `'} '`, `'[' and `'] '`, determine if the input string is valid.
The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not.
</code></pre>

<p>题解</p>

<p>必须字符相对应才能true</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>左半边符号则入栈，当遇到右边符号的时候，最后入栈的要和本符号相等</p>

<p>官方代码</p>

<pre><code>package problem20

import &quot;fmt&quot;

func isValid(s string)bool{
    length := len(s)

    stack := make(map[int]byte)
    index := 0

    for i:=0;i&lt;length;i++ {
        c := s[i]
        switch c {
        case '(':
            stack[index] = c + 1 //(+1=)
            index++
        case '[', '{':
            stack[index] = c + 2
            index++
        case ')', ']', '}':
            if stack[index-1] == c &amp;&amp; index &gt;0 {
                index--
            }else {
                    fmt.Println(&quot;false&quot;)
                    return false
            }
        }
    }
    fmt.Println(&quot;true&quot;)
    return index == 0
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191106">20191106</h2>

<p>题目</p>

<pre><code>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre>

<p>题解</p>

<p>合并两个链表并排序</p>

<p>思路</p>

<p>理解错误，合并两个有序链表</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>循环比较大小，放入到新建的链表中</p>

<p>官方代码</p>

<pre><code>package problem0021

/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

// ListNode 是链接节点
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    // 有一条链为nil，直接返回另一条链
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    // 此时，两条链都不为nil，可以直接使用l.Val，而不用担心panic
    // 在l1和l2之间，选择较小的节点作为head，并设置好node
    var head, node *ListNode
    if l1.Val &lt; l2.Val {
        head = l1
        node = l1
        l1 = l1.Next
    } else {
        head = l2
        node = l2
        l2 = l2.Next
    }

    // 循环比较l1和l2的值，始终选择较小的值连上node
    for l1 != nil &amp;&amp; l2 != nil {
        if l1.Val &lt; l2.Val {
            node.Next = l1
            l1 = l1.Next
        } else {
            node.Next = l2
            l2 = l2.Next
        }

        // 有了这一步，head才是一个完整的链
        node = node.Next
    }

    if l1 != nil {
        // 连上l1剩余的链
        node.Next = l1
    }

    if l2 != nil {
        // 连上l2剩余的链
        node.Next = l2
    }

    return head
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191107">20191107</h2>

<p>题目</p>

<pre><code>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
</code></pre>

<p>题解</p>

<p>给出几对括号，给出所有的正常的输出方式</p>

<p>思路</p>

<p>排列组合，然后判断是否合理（不通）</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>递归</p>

<p>需要从两个方面去思考：1. 选择与限制；2.结束条件</p>

<p>对于这道题，在任何时刻，你都有两种选择：</p>

<pre><code>加左括号。
加右括号。
</code></pre>

<p>同时有以下限制：</p>

<pre><code>如果左括号已经用完了，则不能再加左括号了。
如果已经出现的右括号和左括号一样多，则不能再加右括号了。因为那样的话新加入的右括号一定无法匹配。
</code></pre>

<p>结束条件是：</p>

<pre><code>左右括号都已经用完。
</code></pre>

<p>官方代码</p>

<pre><code>package exercise22

func generateParenthesis(n int) []string {
    res := make([]string, 0, n*n)
    bytes := make([]byte, n*2)
    dfs(n, n, 0, bytes, &amp;res)
    return res
}

func dfs(left, right, idx int, bytes []byte, res *[]string) {
    // 所有符号都添加完毕
    if left == 0 &amp;&amp; right == 0 {
        *res = append(*res, string(bytes))
        return
    }

    // &quot;(&quot; 不用担心匹配问题，
    // 只要 left &gt; 0 就可以直接添加
    if left &gt; 0 {
        bytes[idx] = '('
        dfs(left-1, right, idx+1, bytes, res)
    }

    // 想要添加 &quot;)&quot; 时
    // 需要 left &lt; right，
    // 即在 bytes[:idx] 至少有一个 &quot;(&quot; 可以与 这个 &quot;)&quot; 匹配
    if right &gt; 0 &amp;&amp; left &lt; right {
        bytes[idx] = ')'
        dfs(left, right-1, idx+1, bytes, res)
    }
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191108">20191108</h2>

<p>题目</p>

<pre><code>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre>

<p>题解</p>

<p>合并多个有序链表为一个有序链表</p>

<p>思路</p>

<p>for循环两个合并</p>

<p>代码</p>

<pre><code>package exercise23

type ListNode struct {
    Value int
    Next  *ListNode
}

func MergeList(ls []*ListNode)(l *ListNode) {
    for i:=0;i&lt; len(ls);i++{
        l = MergeTwo(l,ls[1])
    }
    return
}


func MergeTwo(l1 *ListNode,l2 *ListNode) (l *ListNode){
    // 有一条链为nil，直接返回另一条链
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    // 此时，两条链都不为nil，可以直接使用l.Val，而不用担心panic
    // 在l1和l2之间，选择较小的节点作为head，并设置好node
    var head, node *ListNode
    if l1.Value &lt; l2.Value {
        head = l1
        node = l1
        l1 = l1.Next
    } else {
        head = l2
        node = l2
        l2 = l2.Next
    }


    // 循环比较l1和l2的值，始终选择较小的值连上node
    for l1 != nil &amp;&amp; l2 != nil {
        if l1.Value &lt; l2.Value {
            node.Next = l1
            l1 = l1.Next
        } else {
            node.Next = l2
            l2 = l2.Next
        }

        // 有了这一步，head才是一个完整的链
        node = node.Next
    }

    if l1 != nil {
        // 连上l1剩余的链
        node.Next = l1
    }

    if l2 != nil {
        // 连上l2剩余的链
        node.Next = l2
    }

    return head
}
</code></pre>

<p>官方思路</p>

<p>递归调用，最后还是两个有序链表的合并，和我想法差不多</p>

<p>官方代码</p>

<pre><code>package problem0023

// ListNode 是链接节点
type ListNode struct {
    Val  int
    Next *ListNode
}

func merge(lists []*ListNode) *ListNode {
    length := len(lists)
    half := length / 2

    if length == 1 {
        return lists[0]
    }

    if length == 2 {
        var (
            l0, l1   = lists[0], lists[1]
            res, cur *ListNode
        )

        if l0 == nil {
            return l1
        }
        if l1 == nil {
            return l0
        }

        if l0.Val &lt; l1.Val {
            res, cur, l0 = l0, l0, l0.Next
        } else {
            res, cur, l1 = l1, l1, l1.Next
        }

        for l0 != nil &amp;&amp; l1 != nil {
            if l0.Val &lt; l1.Val {
                cur.Next, l0 = l0, l0.Next
            } else {
                cur.Next, l1 = l1, l1.Next
            }
            cur = cur.Next
        }

        if l0 != nil {
            cur.Next = l0
        }
        if l1 != nil {
            cur.Next = l1
        }

        return res
    }

    return mergeKLists([]*ListNode{mergeKLists(lists[half:]), mergeKLists(lists[:half])})
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }

    return merge(lists)
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191109">20191109</h2>

<p>题目</p>

<pre><code>Given a linked list, swap every two adjacent nodes and return its head.

For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
</code></pre>

<p>题解</p>

<p>链表每两个数字进行交换</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>递归，都是两个两个交换</p>

<p>官方代码</p>

<pre><code>package problem0024

import (
    &quot;github.com/aQuaYi/LeetCode-in-Go/kit&quot;
)

// ListNode is definition for singly-linked list
type ListNode = kit.ListNode

func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    newHead := head.Next
    head.Next = swapPairs(newHead.Next)
    newHead.Next = head

    return newHead
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191110">20191110</h2>

<p>题目</p>

<pre><code>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

Example:

Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5

For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5

For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5

Note:

Only constant extra memory is allowed.
You may not alter the values in the list's nodes, only nodes itself may be changed.
</code></pre>

<p>题解</p>

<p>k等于3，就几个数互换</p>

<p>思路</p>

<p>知道递归，但是不能想到怎么实现</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>截取k个数据进行swap，依次递归</p>

<p>官方代码</p>

<pre><code>package problem0025

import (
    &quot;github.com/aQuaYi/LeetCode-in-Go/kit&quot;
)

// ListNode defines for singly-linked list.
type ListNode = kit.ListNode

func reverseKGroup(head *ListNode, k int) *ListNode {
    if k &lt; 2 || head == nil || head.Next == nil {
        return head
    }

    tail, needReverse := getTail(head, k)

    if needReverse {
        tailNext := tail.Next
        /* 斩断 tail 后的链接 */
        tail.Next = nil
        head, tail = reverse(head, tail)
        /* tail 后面接上尾部的递归处理 */
        tail.Next = reverseKGroup(tailNext, k)
    }

    return head
}

func getTail(head *ListNode, k int) (*ListNode, bool) {
    for k &gt; 1 &amp;&amp; head != nil {
        head = head.Next
        k--
    }
    return head, k == 1 &amp;&amp; head != nil
}

func reverse(head, tail *ListNode) (*ListNode, *ListNode) {
    curPre, cur := head, head.Next
    for cur != nil {
        curPre, cur, cur.Next = cur, cur.Next, curPre
    }
    return tail, head
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191111">20191111</h2>

<p>题目</p>

<pre><code>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to0, 1, 2, 3, and4 respectively.

It doesn't matter what values are set beyondthe returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &lt; len; i++) {
  print(nums[i]);
}
</code></pre>

<p>题解</p>

<p>删除数组中的重复部分，然后返回数组的长度</p>

<p>思路</p>

<p>map中的key不会重复，计算map的值</p>

<p>代码</p>

<pre><code>func remove(str []string)(int){
    m := make(map[string]int)
    for k,v := range str{
        if _,ok := m[v]; !ok{
            m[v] = k
        }
    }
    return len(m)
}
</code></pre>

<p>官方思路</p>

<p>指针遍历</p>

<p>官方代码</p>

<pre><code>func removeDuplicates(a []int) int {
    left, right, size := 0, 1, len(a)
    for ; right &lt; size; right++ {
        if a[left] == a[right] {
            continue
        }
        left++
        a[left], a[right] = a[right], a[left]
    }
    return left + 1
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191112">20191112</h2>

<p>题目</p>

<pre><code>Given an array and a value, remove all instances of that value in place and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example: Given input array nums = [3,2,2,3], val = 3

Your function should return length = 2, with the first two elements of nums being 2.
</code></pre>

<p>题解</p>

<p>删除数组中指定的值</p>

<p>思路</p>

<p>遍历，删除指定值，使用slice的append</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>将指定数值交换到最后，获取前面的数组，很新颖的思路。</p>

<p>官方代码</p>

<pre><code>package problem0027

func removeElement(nums []int, val int) int {
    // j指向最后一个不为val的位置
    // i指向第一个值为val的位置
    i, j := 0, len(nums)-1
    for {
        for i &lt; len(nums) &amp;&amp; nums[i] != val {
            i++
        }

        for j &gt;= 0 &amp;&amp; nums[j] == val {
            j--
        }

        if i &gt;= j {
            break
        }

        nums[i], nums[j] = nums[j], nums[i]
    }

    return i
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191113">20191113</h2>

<p>题目</p>

<pre><code>Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
Output: 2
Example 2:

Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
</code></pre>

<p>题解</p>

<p>我们在一个字符串中找另一个字符串第一次出现的位置</p>

<p>思路</p>

<p>golang提供strings的直接函数index，题目中明确规定，不允许直接使用函数，所以下面方法不可取</p>

<p>代码</p>

<pre><code>func strIndex(str1 string,str2 string)(int){
    return strings.Index(str1,str2)
}
</code></pre>

<p>官方思路</p>

<p>遍历</p>

<p>官方代码</p>

<pre><code>package problem0028

func strStr(haystack string, needle string) int {
    hlen, nlen := len(haystack), len(needle)
    // 当hlen等于nlen的时候，需要i == 0
    for i := 0; i &lt;= hlen-nlen; i++ {
        if haystack[i:i+nlen] == needle {
            return i
        }
    }

    return -1
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191114">20191114</h2>

<p>题目</p>

<pre><code>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
</code></pre>

<p>题解</p>

<p>两数相除，不允许使用固定的符号</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>通过一个除数相加来递归和被除数进行比较，来回去最后值</p>

<p>官方代码</p>

<pre><code>package problem0029

import (
    &quot;math&quot;
)

func divide(m, n int) int {
    // 防止有人把0当做除数
    if n == 0 {
        return math.MaxInt32
    }

    signM, absM := analysis(m)
    signN, absN := analysis(n)

    res, _ := d(absM, absN, 1)

    // 修改res的符号
    if signM != signN {
        res = res - res - res
    }

    // 检查溢出
    if res &lt; math.MinInt32 || res &gt; math.MaxInt32 {
        return math.MaxInt32
    }

    return res
}

func analysis(num int) (sign, abs int) {
    sign = 1
    abs = num
    if num &lt; 0 {
        sign = -1
        abs = num - num - num
    }

    return
}

// d 计算m/n的值，返回结果和余数
// m &gt;= 0
// n &gt; 0
// count == 1, 代表初始n的个数，在递归过程中，count == 当前的n/初始的n
func d(m, n, count int) (res, remainder int) {
    switch {
    case m &lt; n:
        return 0, m
    case n &lt;= m &amp;&amp; m &lt; n+n:
        return count, m - n
    default:
        res, remainder = d(m, n+n, count+count)
        if remainder &gt;= n {
            return res + count, remainder - n
        }

        return
    }
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191118">20191118</h2>

<p>题目</p>

<pre><code>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

Example 1:

Input:
  s = &quot;barfoothefoobarman&quot;,
  words = [&quot;foo&quot;,&quot;bar&quot;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.
The output order does not matter, returning [9,0] is fine too.
Example 2:

Input:
  s = &quot;wordgoodstudentgoodword&quot;,
  words = [&quot;word&quot;,&quot;student&quot;]
Output: []
</code></pre>

<p>题解</p>

<p>将子字符串按不同的方式进行串联，找到对应在长字符串中的index</p>

<p>思路</p>

<p>一开始我想到的算法是：先用递归求出words数组中所有单词组合的全排列，并存入一个数组中，然后在字符串s中进行查找，判断数组中的元素是否是s的子串（可以使用Go自带的strings包中的Contains函数），如果是则记下子串首字符的下标。这种算法的主要复杂度集中于求words数组元素的全排列，当words数组的长度较长时，算法的时间复杂度极高，示例4是肯定过不了的。</p>

<p>代码</p>

<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;sort&quot;
)

func main() {
    s := &quot;foobarfoobar&quot;
    words := []string{&quot;foo&quot;,&quot;bar&quot;}
    //s := &quot;wordgoodgoodgoodbestword&quot;
    //words := []string{&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;}
    res := findSubstring(s, words)
    fmt.Println(res)
}

func findSubstring(s string, words []string) []int {
    var str []string
    var res []int
    permutation(words, 0, &amp;str)
    for _, r := range str {
        res = append(res, index(s, r)...)
    }
    sort.Ints(res)
    return res
}

func permutation(words []string, begin int, pStr *[]string) {
    if words == nil || len(words) == 0 || begin &lt; 0 || begin &gt; len(words) - 1 {
        return
    }
    if begin == len(words) - 1 {
        strNew := strings.Join(words, &quot;&quot;)
        if !contains(*pStr, strNew) {
            *pStr = append(*pStr, strNew)
        }
    } else {
        for i := 0; i &lt; len(words); i++ {
            words[begin], words[i] = words[i], words[begin]
            permutation(words, begin + 1, pStr)
            words[begin], words[i] = words[i], words[begin]
        }
    }
}

func contains(str []string, s string) bool{
    for _, r := range str {
        if s == r {
            return true
        }
    }
    return false
}

func index(s1, s2 string) []int{
    var indexes []int
    if strings.Contains(s1, s2) {
        for i := 0; i &lt;= len(s1) - len(s2); i++ {
            if s1[i: i + len(s2)] == s2 {
                indexes = append(indexes, i)
            }
        }
    }
    return indexes
}
</code></pre>

<p>官方思路</p>

<p>本题的关键在于这些单词的长度相同，这是一个很关键的条件，利用此条件，我们可以取words[0]这个字符串，借助它的下标进行遍历，可遍历完words中所有的字符串。我们可以使用两个Map来保存出现的字符串和次数。首先，在外循环中，遍历给定字符串s直到总长度减去单个待查找字符的长度（len(s) - len(words) * len(words[0])）；然后，在内循环中，按照每个单词的长度len(words[0])对给定字符串s进行切割，分别提取子串s[i + num * length : i + (num + 1) * length]，其中i为字符串s的字符索引，num用来维护当前匹配的次数，length即len(words[0])。如果words数组中包含该子串，则num加1，继续查询；如果不包含该子串，则跳出内循环，从给定字符串s的下一个字符开始查询。最后，当内循环结束后，判断num是否等于len(words)（因为子串恰好是words数组里的元素的一种组合），如果是，则保存起始下标到结果数组中。</p>

<p>官方代码</p>

<pre><code>package main
import &quot;fmt&quot;

func main() {
    s := &quot;barfoothefoobarman&quot;
    words := []string{&quot;foo&quot;,&quot;bar&quot;}
    //s := &quot;wordgoodgoodgoodbestword&quot;
    //words := []string{&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;}
    res := findSubstring(s, words)
    fmt.Println(res)
}

func findSubstring(s string, words []string) []int {
    var res []int
    if s == &quot;&quot; || len(s) == 0 || words == nil || len(words) == 0 {
        return res
    }
    // words数组中每个单词字符串长度一致, 取第一个单词
    length := len(words[0])
    // 定义一个wordsMap用于存放words数组中每个单词出现的次数
    wordsMap := make(map[string]int)
    for _, w := range words {
        put(wordsMap, w)
    }
    for i := 0; i &lt; len(s) - len(words) * length + 1; i++ {
        // 定义一个window用于存放匹配的单词出现的次数
        window := make(map[string]int)
        // 定义一个num维护当前匹配的次数
        var num int
        for num &lt; len(words) {
            // 根据查找取子串
            word := s[i + num * length : i + (num + 1) * length]
            _, ok := wordsMap[word]
            if ok {
                put(window, word)
                // window中word出现的次数超过words数组中，则跳出本次循环
                if window[word] &gt; wordsMap[word] {
                    break
                }
            } else {
                // 没有查询到, 跳出本次循环, 查找下一个字符
                break
            }
            num++
        }
        if num == len(words) {
            res = append(res, i)
        }
    }
    return res
}

func put(myMap map[string]int, key string) {
    _, ok := myMap[key]
    if ok {
        myMap[key] += 1
    } else {
        myMap[key] = 1
    }
}
</code></pre>

<p>优化代码</p>

<h2 id="20191119">20191119</h2>

<p>题目</p>

<pre><code>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre>

<p>题解</p>

<p>求下一个排列，不太懂怎么排列的</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<pre><code>1　　2　　7　　4　　3　　1

下一个排列为：

1　　3　　1　　2　　4　　7

那么是如何得到的呢，步骤如下：

从后往前，找到最长的降序排列

1　　2　　7　　4　　3　　1

把这个降序排列，转换成升序排列

1　　2　　1　　3　　4　　7

把序列前的元素，与序列中，第一个大于他的元素互换。

1　　3　　1　　2　　4　　7
</code></pre>

<p>官方代码</p>

<pre><code>package problem0031

func nextPermutation(a []int) {
    left := len(a) - 2
    for 0 &lt;= left &amp;&amp; a[left] &gt;= a[left+1] {
        left--
    }

    // 此时 a[left+1:] 是一个 递减 数列

    reverse(a, left+1)

    if left == -1 {
        return
    }

    // 此时 a[left+1:] 是一个 递增 数列

    right := search(a, left+1, a[left])
    a[left], a[right] = a[right], a[left]
}

// 逆转 a[l:]
func reverse(a []int, l int) {
    r := len(a) - 1
    for l &lt; r {
        a[l], a[r] = a[r], a[l]
        l++
        r--
    }
}

// 返回 a[l:] 中 &gt; target 的最小值的索引号
// a[l:] 是一个 递增 数列
func search(a []int, l, target int) int {
    r := len(a) - 1
    l--
    for l+1 &lt; r {
        mid := (l + r) / 2
        if target &lt; a[mid] {
            r = mid
        } else {
            l = mid
        }
    }
    return r
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191120">20191120</h2>

<p>题目</p>

<pre><code>Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2.

Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4.
</code></pre>

<p>题解</p>

<p>获取有效的括号对的长度</p>

<p>思路</p>

<p>遍历到）时如果有（就配对成功加2，获取最大值</p>

<p>代码</p>

<pre><code>package exercise28

import (
    &quot;strings&quot;
)

func longestValidParentheses(s string) int {
    var left, max, length int
    s = strings.Replace(s,&quot; &quot;,&quot;&quot;,-1)

    // 统计Record
    for _, b := range s {
        if b == '(' {
            left++
        } else if left &gt; 0 {
            left--
            length+=2
        }else {
            length = 0
        }


        if max &lt; length{
            max = length
        }
    }

    return max
}
</code></pre>

<p>官方思路</p>

<p>使用map，比较复杂，不推荐</p>

<p>官方代码</p>

<p>无</p>

<p>优化代码</p>

<p>无</p>

<h2 id="20191121">20191121</h2>

<p>题目</p>

<pre><code>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4].
</code></pre>

<p>题解</p>

<p>在数组中寻找指定值的下标范围</p>

<p>思路</p>

<p>遍历记录第一个开始和最后一个结束的。（思路错误，因为题目限制，需要使用二分查找）</p>

<p>代码</p>

<pre><code>func FindTargetRange(array []int,taeget int)(index []int){
    for i:=0;i&lt; len(array);i++{
        if array[i] == taeget{
            index = append(index,i)
        }
    }

    return
}
</code></pre>

<p>官方思路</p>

<p>二分查找</p>

<p>官方代码</p>

<pre><code>package problem0034

func searchRange(nums []int, target int) []int {
    // 查看target是否存在与nums中
    index := search(nums, target)
    if index == -1 {
        return []int{-1, -1}
    }

    // 利用二分法，查找第一个target
    first := index
    for {
        f := search(nums[:first], target)
        if f == -1 {
            break
        }
        first = f
    }

    // 利用二分法，查找最后一个target
    last := index
    for {
        l := search(nums[last+1:], target)
        if l == -1 {
            break
        }
        // 注意这里与查找first的不同
        last += l + 1
    }

    return []int{first, last}
}

// 二分查找法
func search(nums []int, target int) int {
    low, high := 0, len(nums)-1
    var median int

    for low &lt;= high {
        median = (low + high) / 2

        switch {
        case nums[median] &lt; target:
            low = median + 1
        case nums[median] &gt; target:
            high = median - 1
        default:
            return median
        }
    }
    return -1
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191122">20191122</h2>

<p>题目</p>

<pre><code>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Here are few examples.
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</code></pre>

<p>题解</p>

<p>给一个数组和target，按排序target应该插入什么位置</p>

<p>思路</p>

<p>遍历比较大小</p>

<p>代码</p>

<p>一样的就不写了</p>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<pre><code>package problem0035

func searchInsert(nums []int, target int) int {
    // 没有把i放入for语句中
    // 是为了兼容，len(nums) == 0 和 target &gt; nums[len(nums)-1]两种情况
    i := 0

    for i &lt; len(nums) &amp;&amp; nums[i] &lt;= target {
        // 相等的时候，直接返回
        if nums[i] == target {
            return i
        }

        // 否则，就去检查下一个
        i++
    }

    return i
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191125">20191125</h2>

<p>题目</p>

<pre><code>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.

The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

Example 1:

Input:
[
  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
Output: true
Example 2:

Input:
[
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being
    modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.
The given board contain only digits 1-9and the character '.'.
The given board size is always 9x9.
</code></pre>

<p>题解</p>

<p>验证一个矩阵是否是数独矩阵。</p>

<p>什么是数独</p>

<pre><code>横着的9个数，不能重复
竖着的9个数，不能重复
3×3小方块中的9个数，也不能重复
</code></pre>

<p>思路</p>

<p>依次遍历</p>

<p>代码</p>

<p>无思路，直接看官方代码</p>

<p>官方思路</p>

<p>依次遍历，最主要是最后一个小方块是怎么遍历的</p>

<p>官方代码</p>

<pre><code>package problem0036

import &quot;fmt&quot;

func isValidSudoku(board [][]byte) bool {
    for row := 0; row &lt; 9; row++ {
        if !isValidSudokuRow(board, row) {
            return false
        }
    }

    for col := 0; col &lt; 9; col++ {
        if !isValidSudokuCol(board, col) {
            return false
        }
    }

    for pod := 0; pod &lt; 9; pod++ {
        if !isValidSudokuPod(board, pod) {
            return false
        }
    }
    return true
}

func isValidSudokuRow(board [][]byte, row int) bool {
    var nums [10]bool
    for col := 0; col &lt; 9; col++ {
        n := convertToNumber(board[row][col])
        if n &lt; 0 {
            continue
        }
        if nums[n] {
            fmt.Println(&quot;Invalid row: &quot;, row)
            return false
        }
        nums[n] = true
    }
    return true
}

func isValidSudokuCol(board [][]byte, col int) bool {
    var nums [10]bool
    for row := 0; row &lt; 9; row++ {
        n := convertToNumber(board[row][col])
        if n &lt; 0 {
            continue
        }
        if nums[n] {
            fmt.Println(&quot;Invalid col: &quot;, col)
            return false
        }
        nums[n] = true
    }
    return true
}

func isValidSudokuPod(board [][]byte, pod int) bool {
    var nums [10]bool

    row := (pod / 3) * 3
    col := (pod % 3) * 3

    for drow := 0; drow &lt; 3; drow++ {
        for dcol := 0; dcol &lt; 3; dcol++ {
            n := convertToNumber(board[row+drow][col+dcol])
            if n &lt; 0 {
                continue
            }
            if nums[n] {
                fmt.Println(&quot;Invalid pod:&quot;, pod)
                fmt.Printf(&quot;Found duplicate number %d on row %d, col %d&quot;, n, row+drow, col+dcol)
                return false
            }
            nums[n] = true
        }
    }
    return true
}

func convertToNumber(b byte) int {
    if b == '.' {
        return -1
    }
    return int(b - '0')
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191126">20191126</h2>

<p>题目</p>

<pre><code>Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
Empty cells are indicated by the character '.'.
</code></pre>

<p>题解</p>

<p>求解数独</p>

<p>数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>我把数独框中，需要保证数字不重复的3×3小块，称为一个block。 由于数独需要保持每行，每列，每个block中的数字不重复。解题思路如下：</p>

<pre><code>依次往9个block中，分别填写1~9。
如果block中已经存在n了，去填写下一个数。
在可行的空位填好 n 后
如果后面的填写没有问题，返回true
如果后面的填写有问题，把n移入下一个可行的位置。
n在这个block中，没有位置放了，返回false
1～9都填写完了，就去填写下一个block分别填写1～9
所有的block都填写完了，结束。
</code></pre>

<p>官方代码</p>

<pre><code>    package problem0037

    func solveSudoku(board [][]byte) {
        solve(board, 0)
    }

    /* k 是把 board 转换成一维数组后，元素的索引值 */
    func solve(board [][]byte, k int) bool {
        if k == 81 {
            return true
        }

    r, c := k/9, k%9
    if board[r][c] != '.' {
        return solve(board, k+1)
    }

    /* bi, bj 是 rc 所在块的左上角元素的索引值 */
    bi, bj := r/3*3, c/3*3

    // 按照数独的规则，检查 b 能否放在 board[r][c]
    isValid := func(b byte) bool {
        for n := 0; n &lt; 9; n++ {
            if board[r][n] == b ||
                board[n][c] == b ||
                board[bi+n/3][bj+n%3] == b {
                return false
            }
        }
        return true
    }

    for b := byte('1'); b &lt;= '9'; b++ {
        if isValid(b) {
            board[r][c] = b
            if solve(board, k+1) {
                return true
            }
        }
    }

    board[r][c] = '.'

    return false
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191128">20191128</h2>

<p>题目</p>

<pre><code>The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 is read off as &quot;one 1&quot; or 11.

11 is read off as &quot;two 1s&quot; or 21.

21 is read off as &quot;one 2, then one 1&quot; or 1211.

Given an integer n, generate the nth term of the count-and-say sequence.

Note: Each term of the sequence of integers will be represented as a string.

Example 1:

Input: 1
Output: &quot;1&quot;
Example 2:

Input: 4
Output: &quot;1211&quot;
</code></pre>

<p>题解</p>

<p>第i+1个字符串是第i个字符串的读法</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>都是重第一个一个个循环得出，只是统计然后append</p>

<p>官方代码</p>

<pre><code>package problem0038

func countAndSay(n int) string {
    buf := []byte{'1'}

    for n &gt; 1 {
        buf = say(buf)
        n--
    }

    return string(buf)
}

func say(buf []byte) []byte {
    // res 长度不会超过 buf 的两倍，所以，可以事先指定容量，加快append的速度
    res := make([]byte, 0, len(buf)*2)

    i, j := 0, 1
    for i &lt; len(buf) {
        // 利用 j ，找到下一个不同的元素
        for j &lt; len(buf) &amp;&amp; buf[j] == buf[i] {
            j++
        }

        // res 中 res[i] 表示 res[i+1] 的个数，i 为0,2,4,6,...
        res = append(res, byte(j-i+'0'), buf[i])

        // 移动 i 到 j
        i = j
    }

    return res
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191129">20191129</h2>

<p>题目</p>

<pre><code>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</code></pre>

<p>题解</p>

<p>给一个target数字和给定的数字，有多少种组合方式，和兑换零钱一样的方式。</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>不会</p>

<p>官方思路</p>

<p>把target减去候选数，得到剩余target，继续查找，直到target为0。</p>

<p>官方代码</p>

<pre><code>func combinationSum(candidates []int, target int) [][]int {
    sort.Ints(candidates)

    return doCombinationSum(candidates, target)
}

func doCombinationSum(candidates []int, target int) [][]int {
    res := [][]int{}

    if len(candidates) == 0 {
        return res
    }

    t := target - candidates[0]

    if t &lt; 0 {
        return res
    } else if t == 0 {
        res = append(res, []int{candidates[0]})
    } else if t &gt; 0 {
        res = doCombinationSum(candidates, t)
        for i, v := range res {
            res[i] = append([]int{candidates[0]}, v...)
        }
    }

    res = append(res, doCombinationSum(candidates[1:], target)...)

    return res
}
</code></pre>

<p>优化代码</p>

<h2 id="20191202">20191202</h2>

<p>题目</p>

<pre><code>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

Each number in C may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
</code></pre>

<p>题解</p>

<p>给一个数组和一个target，不带重复，求其组合</p>

<p>思路</p>

<p>target-数值和0比较，遍历拍重</p>

<p>代码</p>

<pre><code>package exercise30

import &quot;sort&quot;

func combinationSum(candidates []int, target int) [][]int {
sort.Ints(candidates)

return doCombinationSum(candidates, target)
}

func doCombinationSum(candidates []int, target int) [][]int {
res := [][]int{}

if len(candidates) == 0 {
return res
}

t := target - candidates[0]

if t &lt; 0 {
return res
} else if t == 0 {
res = append(res, []int{candidates[0]})
} else if t &gt; 0 {
res = doCombinationSum(candidates[1:], t)
for i, v := range res {
res[i] = append([]int{candidates[0]}, v...)
}
}

res = append(res, doCombinationSum(candidates[1:], target)...)

return res
}
</code></pre>

<p>官方思路</p>

<p>上面思路不太对，官方用递归</p>

<p>官方代码</p>

<pre><code>package problem0040

import &quot;sort&quot;

func combinationSum2(candidates []int, target int) [][]int {
    sort.Ints(candidates)

    res := [][]int{}
    solution := []int{}
    cs2(candidates, solution, target, &amp;res)

    return res
}

func cs2(candidates, solution []int, target int, result *[][]int) {
    if target == 0 {
        *result = append(*result, solution)
    }

    if len(candidates) == 0 || target &lt; candidates[0] {
        // target &lt; candidates[0] 因为candidates是排序好的
        return
    }

    // 这样处理一下的用意是，让切片的容量等于长度，以后append的时候，会分配新的底层数组
    // 避免多处同时对底层数组进行修改，产生错误的答案。
    // 可以注释掉以下语句，运行单元测试，查看错误发生。
    solution = solution[:len(solution):len(solution)]

    // 去掉已使用了的candidates[0]
    cs2(candidates[1:], append(solution, candidates[0]), target-candidates[0], result)

    // 不使用candidates[0]的话，就要把所有和candidates[0]相等的元素都去掉。
    cs2(next(candidates), solution, target, result)
}

func next(candidates []int) []int {
    i := 0
    for i+1 &lt; len(candidates) &amp;&amp; candidates[i] == candidates[i+1] {
        i++
    }
    return candidates[i+1:]
}
</code></pre>

<p>优化代码</p>

<h2 id="20191203">20191203</h2>

<p>题目</p>

<pre><code>Given an unsorted integer array, find the first missing positive integer.

For example,

Given [1,2,0] return 3,
and [3,4,-1,1] return 2.
Your algorithm should run in O(n) time and uses constant space.
</code></pre>

<p>题解</p>

<p>找到第一正数</p>

<p>思路</p>

<p>将int放到map中，按数量进行循环寻找，找到说明已经存在，继续寻找下一个</p>

<p>代码</p>

<p>没有写</p>

<p>官方思路</p>

<p>整理 nums ，让 nums[k] == k+1，只要 k+1 存在于 nums 中，然后遍历</p>

<p>官方代码</p>

<pre><code>package problem0041

func firstMissingPositive(nums []int) int {
    // 整理 nums ，让 nums[k] == k+1，只要 k+1 存在于 nums 中
    for i := 0; i &lt; len(nums); i++ {

        // fmt.Println(i)

        for 0 &lt;= nums[i]-1 &amp;&amp; nums[i]-1 &lt; len(nums) &amp;&amp; nums[i] != nums[nums[i]-1] {
            // 当 for 的判断语句成立时，
            // nums[i]-1 就是 k ，nums[i] 的值是 k+1
            // nums[i] != nums[nums[i]-1] 即是 k+1 != nums[k] ，这说明
            // 1. k+1 存在与 nums 中，
            // 2. k+1 还没有在他该在的 nums[k] 中
            // 通过互换，让 k+1 到 nums[k] 中去
            nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]

            // fmt.Println(nums)

            // 使用 for 而不是 if 是因为
            // nums[i] 中的新值，有可能是另一个 k+1 ，需要再让其归为
            // 如果使用 if ，而这个新的 k+1 又只有一个的话，
            // 这个新的 k+1 不会被处理到，不会被放在 nums[k] 中
        }
    }
    // 循环结束后，所有 1&lt;=k+1&lt;=len(nums) 且 k+1 存在于nums中，都会被存放于 nums[k] 中

    // 整理后，第一个不存在的 k+1 就是答案
    for k := range nums {
        if nums[k] != k+1 {
            return k + 1
        }
    }
    return len(nums) + 1
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191204">20191204</h2>

<p>题目</p>

<pre><code>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. rainwatertrap

The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
</code></pre>

<p>题解</p>

<p>下标和数值组成了一个蓄水池，求最大的蓄水量</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>理解 i 点的存水量为 min(max(height[:i+1]&hellip;), max(height[i:]&hellip;)) - height[i]也就是i对应的左边最大和右边最大中较小的开始遍历
高效地找到 max(height[:i+1]&hellip;) 和 max(height[i:]&hellip;)</p>

<p>官方代码</p>

<pre><code>package problem0042

func bigger(a int, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

func smaller(a int, b int) int {
    if a &lt; b {
        return a
    }
    return b
}

func trap(height []int) int {
    length := len(height)
    if length &lt;= 2 {
        return 0
    }

    left, right := make([]int, length), make([]int, length)

    left[0], right[length-1] = height[0], height[length-1]

    for i := 1; i &lt; length; i++ {
        left[i] = bigger(left[i-1], height[i])
        right[length-1-i] = bigger(right[length-i], height[length-1-i])

        // left[i] 是 height[:i+1] 中的最大值
        // right[i] 是 height[i:] 中的最大值
    }

    water := 0
    for i := 0; i &lt; length; i++ {
        // 存水量取决于 左右最大值 中的较小值
        water += smaller(left[i], right[i]) - height[i]
    }

    return water
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191205">20191205</h2>

<p>题目</p>

<p>题解</p>

<p>思路</p>

<p>代码</p>

<p>官方思路</p>

<p>官方代码</p>

<p>优化代码</p>

<h2 id="20191205-1">20191205</h2>

<p>题目</p>

<pre><code>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.


Example 1:

Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;
Output: &quot;6&quot;
Example 2:

Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;
Output: &quot;56088&quot;


Note:

The length of both num1 and num2 is &lt; 110.
Both num1 and num2 contains only digits 0-9.
Both num1 and num2 does not contain any leading zero.
You must not use any built-in BigInteger library or convert the inputs to integer directly.
</code></pre>

<p>题解</p>

<p>两个字符串像乘，其实是写乘法的实现。</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>小学乘法的处理步骤：按位相乘</p>

<p>官方代码</p>

<pre><code>package problem0043

func multiply(num1 string, num2 string) string {
    if num1 == &quot;0&quot; || num2 == &quot;0&quot; {
        return &quot;0&quot;
    }

    // string转换成[]byte，容易取得相应位上的具体值
    bsi := []byte(num1)
    bsj := []byte(num2)

    // temp 的长度只可能为 len(num1)+len(num2) 或 len(num1)+len(num2)-1
    // 先选长的，免得位不够
    temp := make([]int, len(num1)+len(num2))
    for i := 0; i &lt; len(bsi); i++ {
        for j := 0; j &lt; len(bsj); j++ {
            // 每个位上的乘积，可以直接存入 temp 中相应的位置
            temp[i+j+1] += int(bsi[i]-'0') * int(bsj[j]-'0')
        }
    }

    // 统一处理进位
    for i := len(temp) - 1; i &gt; 0; i-- {
        temp[i-1] += temp[i] / 10
        temp[i] = temp[i] % 10
    }

    // num1 和 num2 较小的时候，temp的首位为0
    // 为避免输出结果以0开头，需要去掉temp的0首位
    if temp[0] == 0 {
        temp = temp[1:]
    }

    // 转换结果
    // temp 选用为[]int，而不是[]byte，是因为
    // Go中，byte的基础结构是uint8，最大值为255。
    // 不考虑进位的话，temp会溢出
    res := make([]byte, len(temp))
    for i := 0; i &lt; len(temp); i++ {
        res[i] = '0' + byte(temp[i])
    }

    return string(res)
}
</code></pre>

<p>优化代码</p>

<h2 id="20191206">20191206</h2>

<p>题目</p>

<pre><code>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like ? or *.
Example 1:

Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
Example 2:

Input:
s = &quot;aa&quot;
p = &quot;*&quot;
Output: true
Explanation:`'*' matches any sequence.
Example 3:

Input:
s = &quot;cb&quot;
p = &quot;?a&quot;
Output: false
Explanation:`'?' matches 'c', but the second letter is 'a', which does not match 'b'.
Example 4:

Input:
s = &quot;adceb&quot;
p = &quot;*a*b&quot;
Output: true
Explanation:`The first '*' matches the empty sequence, while the second '*' matches the substring &quot;dce&quot;.
Example 5:

Input:
s = &quot;acdcb&quot;
p = &quot;a*c?b&quot;
Output: false
</code></pre>

<p>题解</p>

<p>匹配是否正确，匹配规则</p>

<pre><code>'?' 可以匹配任意一个字符，但是不能匹配空字符&quot;&quot;
'*' 可以任意多个字符，包括&quot;&quot;
</code></pre>

<p>思路</p>

<p>遍历匹配，未实现</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>动态规划</p>

<p>dp[i][j]表示s到i位置,p到j位置是否匹配!</p>

<p>初始化:</p>

<p>dp[0][0]:什么都没有,所以为true
第一行dp[0][j],换句话说,s为空,与p匹配,所以只要p开始为*才为true
第一列dp[i][0],当然全部为False
动态方程:</p>

<p>如果(s[i] == p[j] || p[j] == &ldquo;?&rdquo;) &amp;&amp; dp[i-1][j-1] ,有dp[i][j] = true</p>

<p>如果p[j] == &ldquo;*&rdquo; &amp;&amp; (dp[i-1][j] = true || dp[i][j-1] = true) 有dp[i][j] = true</p>

<p>​ note:</p>

<p>​ dp[i][j-1],表示<em>代表是空字符,例如ab,ab</em></p>

<p>​ dp[i-1][j],表示<em>代表非空任何字符,例如abcd,ab</em></p>

<p>官方代码</p>

<pre><code>package problem0044

func isMatch(s string, p string) bool {
    sSize, pSize := len(s), len(p)

    dp := make([][]bool, sSize+1)
    for i := range dp {
        dp[i] = make([]bool, pSize+1)
    }
    // dp[i][j] == true 意味着，s[:i+1] 可以和 p[:j+1] 匹配
    dp[0][0] = true

    for j := 1; j &lt;= pSize; j++ {
        if p[j-1] == '*' {
            // 当 p[j-1] == '*' 时
            // 只要前面的匹配，dp[0][j] 就匹配
            // 一旦 p[j-1] != '*'，后面的 dp[0][j] 就都为 false
            dp[0][j] = dp[0][j-1]
        }
    }

    for i := 1; i &lt;= sSize; i++ {
        for j := 1; j &lt;= pSize; j++ {
            if p[j-1] != '*' {
                // 当 p[j-1] != '*' 时
                // 单个字符要匹配，并且之前的字符串也要匹配。
                dp[i][j] = dp[i-1][j-1] &amp;&amp;
                    (p[j-1] == s[i-1] || p[j-1] == '?')
            } else {
                // 当 p[j-1] == '*' 时
                //   要么，dp[i-1][j] == true，意味着，
                //   当 s[:i] 与 p[:j+1] 匹配，且p[j] == '*' 的时候，
                //   s[:i] 后接任意字符串的 s[:i+1] 仍与 p[:j+1] 匹配。
                //   要么，dp[i][j-1] == true，意味着，
                //   当 s[:i+1] 与 p[:j] 匹配后
                //   在 p[:j] 后添加'*'，s[:i+1] 与 p[:j+1] 任然匹配
                //   因为， '*' 可以匹配空字符。
                dp[i][j] = dp[i-1][j] || dp[i][j-1]
            }
        }
    }

    return dp[sSize][pSize]
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191207">20191207</h2>

<p>题目</p>

<pre><code>Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

For example:

Given array A = [2,3,1,1,4]
The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

Note:

You can assume that you can always reach the last index.
</code></pre>

<p>题解</p>

<p>value代表跳力，在这个范围内都可以跳过去，求最小的步数。</p>

<p>思路</p>

<p>求当前跳力内的最大值</p>

<p>代码</p>

<pre><code>package exercise30


func jump(nums []int) int {
    var max,count,maxi,nexti = 0,0,0,0
    for {
        for j := 0;j&lt;nums[nexti];j++{
            if nums[j] &gt;max{
                max = nums[j]
                maxi = j
            }
        }
        count++

        if nums[nexti] + max &gt; len(nums) {
            break
        }

        nexti += maxi


    }
    return count
}
</code></pre>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<pre><code>package problem0045

func jump(nums []int) int {
    i, count, end := 0, 0, len(nums)-1

    var nextI, maxNextI, maxI int
    for i &lt; end {
        if i+nums[i] &gt;= end {
            return count + 1
        }

        nextI, maxNextI = i+1, i+nums[i]
        for nextI &lt;= maxNextI {
            if nextI+nums[nextI] &gt; maxI {
                maxI, i = nextI+nums[nextI], nextI
            }

            nextI++
        }

        count++
    }

    return count
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191208">20191208</h2>

<p>题目</p>

<pre><code>Given a collection of distinct numbers, return all possible permutations.

For example, [1,2,3] have the following permutations:

[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>

<p>题解</p>

<p>给一个数组写出其所有的排列组合</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>递归回溯</p>

<p>看这个数据是否已经使用</p>

<p>官方代码</p>

<pre><code>package exercise32

import &quot;fmt&quot;

func permute(nums []int) [][]int {
    n := len(nums)
    // vector 是一组可能的解答
    vector := make([]int, n)
    // taken[i] == true 表示 nums[i] 已经出现在了 vector 中
    taken := make([]bool, n)

    var ans [][]int

    makePermutation(0, n, nums, vector, taken, &amp;ans)

    return ans
}

// 这个方式和我原来的方式相比，
// 增加了比较的次数
// 但是，减少了切片生成的次数。
// 所以，速度会快一些。
func makePermutation(cur, n int, nums, vector []int, taken []bool, ans *[][]int) {
    if cur == n {
        tmp := make([]int, n)
        copy(tmp, vector)
        fmt.Println(vector)
        *ans = append(*ans, tmp)
        return
    }

    for i := 0; i &lt; n; i++ {
        if !taken[i] {
            // 准备使用 nums[i]，所以，taken[i] == true
            taken[i] = true
            // NOTICE: 是 vector[cur]
            vector[cur] = nums[i]
            fmt.Println(vector)
            fmt.Println(taken)
            makePermutation(cur+1, n, nums, vector, taken, ans)

            // 下一个循环中
            // vector[cur] = nums[i+1]
            // 所以，在这个循环中，恢复 nums[i] 自由
            taken[i] = false
        }
    }
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191210">20191210</h2>

<p>题目</p>

<pre><code>Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example, [1,1,2] have the following unique permutations:

[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre>

<p>题解</p>

<p>可重复的组合</p>

<p>思路</p>

<p>不是太理解这些递归，今天特地看了许多的说明，还是不能融汇使用，放弃，人使用迭代，神使用递归。</p>

<p>递归</p>

<p>代码</p>

<p>官方思路</p>

<p>官方代码</p>

<p>优化代码</p>

<h2 id="20191211">20191211</h2>

<p>题目</p>

<pre><code>You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</code></pre>

<p>题解</p>

<p>旋转矩阵</p>

<p>思路</p>

<p>遍历换位置，比较low</p>

<pre><code>代码

package exercise33

func rotate(list [][]int) {
    Column := len(list)
    Row := len(list[0])

    for i:=0;i&lt;Row;i++{
        for j:=0;j&lt;Column;j++{
            list[i][j]//未写完对应的关系
        }
    }
}
</code></pre>

<p>官方思路</p>

<p>找到了技巧，对应的4个点，依次互换位置。</p>

<p>官方代码</p>

<pre><code>package problem0048

func rotate(m [][]int) {
    n := len(m)
    for i := 0; i &lt; n/2; i++ {
        for j := i; j &lt; n-i-1; j++ {
            temp := m[i][j]
            // 左边的行 等于 右边的列
            m[i][j] = m[n-j-1][i]
            m[n-j-1][i] = m[n-i-1][n-j-1]
            m[n-i-1][n-j-1] = m[j][n-i-1]
            m[j][n-i-1] = temp
        }
    }
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191213">20191213</h2>

<p>题目</p>

<pre><code>Given an array of strings, group anagrams together.

For example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Return:

[
  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</code></pre>

<p>题解</p>

<p>给字母分组，相同的字母为一组</p>

<p>思路</p>

<p>排序后一样的为一组</p>

<p>代码</p>

<p>未写</p>

<p>官方思路</p>

<p>一样的想法，它用了encode的方式</p>

<p>官方代码</p>

<pre><code>package problem0049

func groupAnagrams(ss []string) [][]string {
    tmp := make(map[int][]string, len(ss)/2)
    for _, s := range ss {
        c := encode(s)
        tmp[c] = append(tmp[c], s)
    }

    res := make([][]string, 0, len(tmp))
    for _, v := range tmp {
        res = append(res, v)
    }

    return res
}

// prime 与 A～Z 对应，英文中出现概率越大的字母，选用的质数越小
var prime = []int{5, 71, 37, 29, 2, 53, 59, 19, 11, 83, 79, 31, 43, 13, 7, 67, 97, 23, 17, 3, 41, 73, 47, 89, 61, 101}

func encode(s string) int {
    res := 1
    for i := range s {
        res *= prime[s[i]-'a']
    }
    return res
}
</code></pre>

<p>优化代码</p>

<h2 id="20191216">20191216</h2>

<p>题目</p>

<pre><code>Implement pow(x, n)

Example 1:
Input: 2.00000, 10
Output: 1024.00000

Example 2:
Input: 2.10000, 3
Output: 9.26100

Example 3:
Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
</code></pre>

<p>题解</p>

<p>实现pow(x, n)也就是x的n次方</p>

<p>思路</p>

<p>遍历，不符合算法的复杂度</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>递归</p>

<p>官方代码</p>

<pre><code>package problem0050

func myPow(x float64, n int) float64 {
    if n &lt; 0 {
        return 1.0 / pow(x, -n)
    }

    return pow(x, n)
}

func pow(x float64, n int) float64 {
    if x == 0 {
        return 0
    }

    if n == 0 {
        return 1
    }

    res := pow(x, n&gt;&gt;1)
    if n&amp;1 == 0 {
        return res * res
    }

    return res * res * x
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191217">20191217</h2>

<p>题目</p>

<pre><code>Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

Example:

Input: 4
Output: [
 [&quot;.Q..&quot;,  // Solution 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // Solution 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.
</code></pre>

<p>题解</p>

<p>解决八皇后问题，国际象棋中的皇后，可以横竖对角线行走，如何解决共存问题。</p>

<p>思路</p>

<pre><code>所在的行
所在的列
两条45度对角线上
</code></pre>

<p>第一行的所有位置上q，然后推到后面的数据，感觉很复杂，不太好，还是要会数独的递归</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>迭代标记递归</p>

<p>官方代码</p>

<pre><code>package problem0051

func solveNQueens(n int) [][]string {
    if n == 0 {
        return [][]string{}
    }

    cols := make([]bool, n)
    // 记录 '\' 方向的对角线的占用情况
    d1 := make([]bool, 2*n)
    // 记录 '/' 方向的对角线的占用情况
    d2 := make([]bool, 2*n)

    board := make([]string, n)

    res := [][]string{}

    dfs(0, cols, d1, d2, board, &amp;res)

    return res
}

func dfs(r int, cols, d1, d2 []bool, board []string, res *[][]string) {

    if r == len(board) {
        tmp := make([]string, len(board))
        copy(tmp, board)
        *res = append(*res, tmp)
        return
    }

    n := len(board)

    for c := 0; c &lt; len(board); c++ {
        id1 := r - c + n
        id2 := 2*n - r - c - 1
        if !cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2] {
            b := make([]byte, n)
            for i := range b {
                b[i] = '.'
            }
            b[c] = 'Q'
            board[r] = string(b)
            // 标记占用
            cols[c], d1[id1], d2[id2] = true, true, true

            dfs(r+1, cols, d1, d2, board, res)

            // 解除标记
            cols[c], d1[id1], d2[id2] = false, false, false
        }
    }
}
</code></pre>

<p>优化代码</p>

<h2 id="20191218">20191218</h2>

<p>题目</p>

<pre><code>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],

the contiguous subarray [4,-1,2,1] has the largest sum = 6.

More practice:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
</code></pre>

<p>题解</p>

<p>找到一个自数组，在其中可以求出最大的sum</p>

<p>题目都理解错了</p>

<p>找到一个子数组，在其中所有数字的sum是最大值</p>

<p>思路</p>

<p>找到最大的两个数，然后截取子字符串（不可取）</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>sum+n &lt; n，那就还不如直接从 n 开始统计。</p>

<p>官方代码</p>

<pre><code>package problem0053

func maxSubArray(nums []int) int {
    sum, maxSum := -1&lt;&lt;31, -1&lt;&lt;31
    for _, n := range nums {
        // sum+n &lt; n，那就还不如直接从 n 开始统计。
        sum = max(sum+n, n)
        maxSum = max(maxSum, sum)
    }
    return maxSum
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>

<p>优化代码</p>

<h2 id="20191219">20191219</h2>

<p>题目</p>

<pre><code>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

You should return [1,2,3,6,9,8,7,4,5].
</code></pre>

<p>题解</p>

<p>螺旋输出数组</p>

<p>思路</p>

<p>和官方思路一样</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>到达边界就旋转</p>

<p>官方代码</p>

<pre><code>func spiralOrder(matrix [][]int) []int {
    // 思路：
    // round为轮次(第一轮为0)
    // 1.每一轮顺时针遍历的起点都是(round,round)
    // 2.每一轮矩形的右下角点为(n-1-round,m-1-round)
    // 3.一共能进行多少轮:(m+1)/2和(n+1)/2的最小值

    m := len(matrix)
    // 边界检查
    if m==0{
        return nil
    }
    n := len(matrix[0])
    out := make([]int, m*n)
    var outIndex int
    var totalRound int
    if (m+1)/2 &lt; (n+1)/2 {
        totalRound = (m + 1) / 2
    } else {
        totalRound = (n + 1) / 2
    }

    for round := 0; round &lt; totalRound; round++ {
        minX, minY, maxX, maxY := round, round, n-1-round, m-1-round
        //  向右
        for i := minX; i &lt;= maxX; i++ {
            out[outIndex] = matrix[minY][i]
            outIndex++
        }
        //  向下
        for i := minY + 1; i &lt;= maxY; i++ {
            out[outIndex] = matrix[i][maxX]
            outIndex++
        }

        // 还有横向回程的条件
        if maxY-minY &gt;= 1 {
            //  向左
            for i := maxX - 1; i &gt;= minX; i-- {
                out[outIndex] = matrix[maxY][i]
                outIndex++
            }
        }
        // 还有纵向回程的条件
        if maxX-minX &gt;= 1 {
            //  向上
            for i := maxY - 1; i &gt; minY; i-- {
                out[outIndex] = matrix[i][minX]
                outIndex++
            }
        }
    }
    return out
}
</code></pre>

<p>优化代码</p>

<h2 id="20191220">20191220</h2>

<p>题目</p>

<pre><code>Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

For example:
A = [2,3,1,1,4], return true.
A = [3,2,1,0,4], return false.
</code></pre>

<p>题解</p>

<p>根据当前值的跳力，是否能达到最后一个值。</p>

<p>思路</p>

<p>找到0，前面的数据大于index的差就是true，否则就是false，主要看能不能跨过0</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<pre><code>package problem0055

func canJump(nums []int) bool {

    for i := len(nums) - 2; i &gt;= 0; i-- {
        // 找到数值为 0 的元素
        if nums[i] != 0 {
            continue
        }

        j := i - 1
        for ; j &gt;= 0; j-- {
            if i-j &lt; nums[j] {
                // 在 j 号位置上，可以跨过 0 元素
                i = j
                break
            }
        }

        if j == -1 {
            // 在 0 元素之前，没有位置可以跨过 0
            return false
        }
    }

    return true
}
</code></pre>

<p>优化代码</p>

<h2 id="20191223">20191223</h2>

<p>题目</p>

<pre><code>Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
</code></pre>

<p>题解</p>

<p>合并区间，如果前一个区间和后一个有交集</p>

<p>思路</p>

<p>排序对比就好</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<pre><code>package problem0056

import (
    &quot;sort&quot;
)

// Interval Definition for an interval.
type Interval struct {
    Start int
    End   int
}

func merge(its []Interval) []Interval {
    if len(its) &lt;= 1 {
        return its
    }

    sort.Slice(its, func(i int, j int) bool {
        return its[i].Start &lt; its[j].Start
    })

    res := make([]Interval, 0, len(its))

    temp := its[0]
    for i := 1; i &lt; len(its); i++ {
        if its[i].Start &lt;= temp.End {
            temp.End = max(temp.End, its[i].End)
        } else {
            res = append(res, temp)
            temp = its[i]
        }
    }
    res = append(res, temp)

    return res
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20191224">20191224</h2>

<p>题目</p>

<pre><code>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].
This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].
</code></pre>

<p>题解</p>

<p>插入一个新的区间进行重叠合并</p>

<p>思路</p>

<p>一样</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>按步比较</p>

<p>官方代码</p>

<pre><code>package problem0057

// Interval is a couple of int
type Interval struct {
    Start int
    End   int
}

func insert(a []Interval, newItv Interval) []Interval {
    lenA := len(a)

    if lenA == 0 {
        return []Interval{newItv}
    }

    if newItv.End &lt; a[0].Start {
        return append([]Interval{newItv}, a...)
    }

    if a[lenA-1].End &lt; newItv.Start {
        return append(a, newItv)
    }

    res := make([]Interval, 0, len(a))
    for i := range a {
        if isOverlap(a[i], newItv) {
            newItv = merge(a[i], newItv)

            if i == lenA-1 {
                res = append(res, newItv)
            }

            continue
        }

        if a[i].End &lt; newItv.Start {
            res = append(res, a[i])
            continue
        }

        if newItv.End &lt; a[i].Start {
            res = append(res, newItv)
            res = append(res, a[i:]...)
            break
        }

    }

    return res
}

func isOverlap(a, b Interval) bool {
    return (a.Start &lt;= b.Start &amp;&amp; b.Start &lt;= a.End) || (a.Start &lt;= b.End &amp;&amp; b.End &lt;= a.End) || (b.Start &lt;= a.Start &amp;&amp; a.Start &lt;= b.End)
}

func merge(a, b Interval) Interval {
    return Interval{
        Start: min(a.Start, b.Start),
        End:   max(a.End, b.End),
    }
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>

<p>优化代码</p>

<h2 id="20191225">20191225</h2>

<p>题目</p>

<pre><code>Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

For example,
Given s = &quot;Hello World&quot;,
return 5
</code></pre>

<p>题解</p>

<p>返回最后一个word的长度。</p>

<p>思路</p>

<p>如何定位最后一个单词，找到最后一个空格，以后的单词的长度</p>

<p>如何找到最后一个空格，遍历记录最后一个空格</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>重后面进行遍历，找到第一个空格。</p>

<p>官方代码</p>

<pre><code>package problem0058

func lengthOfLastWord(s string) int {
    size := len(s)
    if size == 0 {
        return 0
    }
    res := 0
    for i := size - 1; i &gt;= 0; i-- {
        if s[i] == ' ' {
            if res != 0 {
                return res
            }
            continue
        }
        res++
    }

    return res
}
</code></pre>

<p>优化代码</p>

<h2 id="20191226">20191226</h2>

<p>题目</p>

<pre><code>Given an integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.

For example, Given n = 3, You should return the following matrix:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</code></pre>

<p>题解</p>

<p>根据n返回int[n][n]的循环矩阵</p>

<p>思路</p>

<p>遍历n*n,遇到边界就旋转</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<pre><code>package problem0059

func generateMatrix(n int) [][]int {
    if n == 0 {
        return nil
    }

    res := make([][]int, n)
    for i := range res {
        res[i] = make([]int, n)
    }

    max := n * n
    next := nextFunc(n)

    for i := 1; i &lt;= max; i++ {
        x, y := next()
        res[x][y] = i
    }

    return res
}

func nextFunc(n int) func() (int, int) {
    top, down := 0, n-1
    left, right := 0, n-1
    x, y := 0, -1
    dx, dy := 0, 1
    return func() (int, int) {
        x += dx
        y += dy
        switch {
        case y+dy &gt; right:
            top++
            dx, dy = 1, 0
        case x+dx &gt; down:
            right--
            dx, dy = 0, -1
        case y+dy &lt; left:
            down--
            dx, dy = -1, 0
        case x+dx &lt; top:
            left++
            dx, dy = 0, 1
        }
        return x, y
    }
}
</code></pre>

<p>优化代码</p>

<h2 id="20191227">20191227</h2>

<p>题目</p>

<pre><code>The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3):

&quot;123&quot;
&quot;132&quot;
&quot;213&quot;
&quot;231&quot;
&quot;312&quot;
&quot;321&quot;
Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.
</code></pre>

<p>题解</p>

<p>给出一个n，表示n数组，求出其所有的组合</p>

<p>题目理解错了，让求出n个数字的第k个排列组合</p>

<p>思路</p>

<p>找到排列组合的规律</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<pre><code>同样先通过举例来获得更好的理解。以n = 4，k = 9为例：

1234
1243
1324
1342
1423
1432
2134
2143
2314  &lt;= k = 9
2341
2413
2431
3124
3142
3214
3241
3412
3421
4123
4132
4213
4231
4312
4321

最高位可以取{1, 2, 3, 4}，而每个数重复3! = 6次。所以第k=9个permutation的s[0]为{1, 2, 3, 4}中的第9/6+1 = 2个数字s[0] = 2。

而对于以2开头的6个数字而言，k = 9是其中的第k' = 9%(3!) = 3个。而剩下的数字{1, 3, 4}的重复周期为2! = 2次。所以s[1]为{1, 3, 4}中的第k'/(2!)+1 = 2个，即s[1] = 3。

对于以23开头的2个数字而言，k = 9是其中的第k'' = k'%(2!) = 1个。剩下的数字{1, 4}的重复周期为1! = 1次。所以s[2] = 1.

对于以231开头的一个数字而言，k = 9是其中的第k''' = k''/(1!)+1 = 1个。s[3] = 4
</code></pre>

<p>官方代码</p>

<pre><code>package problem0060

func getPermutation(n int, k int) string {
    if n == 0 {
        return &quot;&quot;
    }

    // 用于存放结果的字符
    res := make([]byte, n)

    // 存放待抓取的数字
    rec := make([]byte, n)
    for i := 0; i &lt; n; i++ {
        rec[i] = byte(i) + '1'
    }

    // 由于排列的序号是从 1 开始的。
    // k 需要减去 1 ，好从 0 开始表示
    k--

    base := 1
    for i := 2; i &lt; n; i++ {
        base *= i
    }

    for i := 0; i &lt; n-1; i++ {
        idx := k / base
        res[i] = rec[idx]
        // 从 rec 中去除已经使用的数 rec[idx]
        rec = append(rec[:idx], rec[idx+1:]...)
        k %= base
        base /= (n - i - 1)
    }
    // 不要忘记最后一个数
    res[n-1] = rec[0]

    return string(res)
}
</code></pre>

<p>优化代码</p>

<p>这是一个数学问题</p>

<h2 id="20200102">20200102</h2>

<p>题目</p>

<pre><code>Given a linked list, rotate the list to the right by k places, where k is non-negative.

Example 1:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
Explanation:
rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
Example 2:

Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4
Output: 2-&gt;0-&gt;1-&gt;NULL
Explanation:
rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL
rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL
rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL
rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL
</code></pre>

<p>题解</p>

<p>给出一个链表，给出k，按位移动k步，返回对应的链表。</p>

<p>思路</p>

<p>按循序移动指针就好</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>使用递归，递归一般都是在回头的时间解决问题</p>

<p>官方代码</p>

<pre><code>package problem0061

// ListNode 是题目预定义的节点
type ListNode struct {
    Val  int
    Next *ListNode
}

func rotateRight(head *ListNode, k int) *ListNode {
    if k == 0 || head == nil {
        return head
    }

    tail := head
    for i := 0; i &lt; k; i++ {
        if tail.Next == nil {
            // 处理 k 大于 list 的长度的情况
            // i+1 就是 list 的长度
            return rotateRight(head, k%(i+1))
        }
        tail = tail.Next
    }

    newTail := head
    for tail.Next != nil {
        newTail, tail = newTail.Next, tail.Next
    }

    newHead := newTail.Next
    newTail.Next, tail.Next = nil, head

    return newHead
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20200103">20200103</h2>

<p>题目</p>

<pre><code>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down
2. Right -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Right
Example 2:

Input: m = 7, n = 3
Output: 28
</code></pre>

<p>题解</p>

<p>给出一个矩阵，只能向右或者向下走，一共有多少种方法，可以重左上角到右下角</p>

<p>思路</p>

<p>收到官方思路触发，感觉可以使用递归</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>给每个格子都设置为1
第n个格子的方法是这个格子前面一个和上面一个之和</p>

<p>官方代码</p>

<pre><code>package problem0062

func uniquePaths(m int, n int) int {
    // path[i][j] 代表了，到达 (i,j) 格子的不同路径数目
    path := [100][100]int{}

    for i := 0; i &lt; m; i++ {
        // 到达第 0 列的格子，只有一条路径
        path[i][0] = 1
    }

    for j := 0; j &lt; n; j++ {
        // 到达第 0 行的格子，只有一条路径
        path[0][j] = 1
    }

    for i := 1; i &lt; m; i++ {
        for j := 1; j &lt; n; j++ {
            // 到达 (i,j) 格子的路径数目，等于
            // 到达 上方格子 和 左边格子 路径数之和
            path[i][j] = path[i-1][j] + path[i][j-1]
        }
    }

    return path[m-1][n-1]
}
</code></pre>

<p>优化代码</p>

<h2 id="20200106">20200106</h2>

<p>题目</p>

<pre><code>Follow up for &quot;Unique Paths&quot;:

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.

[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
The total number of unique paths is 2.

Note: m and n will be at most 100.
</code></pre>

<p>题解</p>

<p>设置障碍物就是中间的1，有多少种方法。</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>遇到1则不向加</p>

<p>官方代码</p>

<pre><code>package problem0063

func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m := len(obstacleGrid)
    if m == 0 {
        return 0
    }

    n := len(obstacleGrid[0])
    if n == 0 {
        return 0
    }

    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    if obstacleGrid[0][0] == 0 {
        dp[0][0] = 1
    }

    for i := 1; i &lt; m; i++ {
        if obstacleGrid[i][0] == 0 {
            dp[i][0] = dp[i-1][0]
        }
    }

    for j := 1; j &lt; n; j++ {
        if obstacleGrid[0][j] == 0 {
            dp[0][j] = dp[0][j-1]
        }
    }

    for i := 1; i &lt; m; i++ {
        for j := 1; j &lt; n; j++ {
            if obstacleGrid[i][j] == 0 {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }

    return dp[m-1][n-1]
}
</code></pre>

<p>优化代码</p>

<h2 id="202001010">202001010</h2>

<p>题目</p>

<pre><code>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.
</code></pre>

<p>题解</p>

<pre><code>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
</code></pre>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>既然要求到达右下角的最小路径和，那么可依次求出每个点的最小路径和，用原来的数组保存,返回dp[m-1][n-1]</p>

<p>官方代码</p>

<pre><code>package problem0064

func minPathSum(grid [][]int) int {
    // 已经默认 m 和 n 大于 0 了
    m := len(grid)
    n := len(grid[0])

    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    dp[0][0] = grid[0][0]

    for i := 1; i &lt; m; i++ {
        dp[i][0] = grid[i][0] + dp[i-1][0]
    }

    for j := 1; j &lt; n; j++ {
        dp[0][j] = grid[0][j] + dp[0][j-1]
    }

    for i := 1; i &lt; m; i++ {
        for j := 1; j &lt; n; j++ {
            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
        }
    }

    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20200113">20200113</h2>

<p>题目</p>

<pre><code>Validate if a given string is numeric.

Some examples:
&quot;0&quot; =&gt; true
&quot;   0.1  &quot; =&gt; true
&quot;abc&quot; =&gt; false
&quot;1 a&quot; =&gt; false
&quot;2e10&quot; =&gt; true
Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.
</code></pre>

<p>题解</p>

<p>判断一个字符串是不是数字</p>

<p>思路</p>

<p>遍历判断是不是在0～9之间或者.</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>遍历判断是不是在0～9之间或者.或者e</p>

<p>官方代码</p>

<pre><code>package problem0065

func isNumber(s string) bool {
    // 去掉首位的空格
    s = trim(s)

    // 判断是否是实数
    return isReal(s)
}

func isReal(s string) bool {
    if len(s) == 0 {
        return false
    }

    if s[0] == '-' || s[0] == '+' {
        return isNonnegReal(s[1:], false)
    }

    return isNonnegReal(s, false)
}

func isNonnegReal(s string, hasDot bool) bool {
    if len(s) == 0 {
        return false
    }

    for i, c := range s {
        switch {
        case '0' &lt;= c &amp;&amp; c &lt;= '9':
            continue
        case c == '.':
            if hasDot {
                // 前面已经有了一个 '.' 了
                return false
            }

            if i == len(s)-1 &amp;&amp; i != 0 {
                // 以 '.' 结尾的情况
                return true
            }

            if i+1 &lt; len(s) &amp;&amp; s[i+1] == 'e' {
                // &quot;2.e3&quot; 是正确的数字表
                // 但 &quot;.e1&quot; 不是
                return i != 0 &amp;&amp; isInteger(s[i+2:])
            }

            // 继续判断是否为 非负实数
            return isNonnegReal(s[i+1:], true)
        case c == 'e':
            if i == 0 {
                // 'e' 不能开头
                return false
            }
            return isInteger(s[i+1:])
        default:
            return false
        }
    }

    return true
}

func isInteger(s string) bool {
    if len(s) == 0 {
        return false
    }

    if s[0] == '-' || s[0] == '+' {
        return isNonnegativeInteger(s[1:])
    }

    return isNonnegativeInteger(s)
}

func isNonnegativeInteger(s string) bool {
    if len(s) == 0 {
        return false
    }

    for _, c := range s {
        if c &lt; '0' || '9' &lt; c {
            return false
        }
    }
    return true
}

func trim(s string) string {
    i := 0
    for i &lt; len(s) &amp;&amp; s[i] == ' ' {
        i++
    }

    j := len(s) - 1
    for i &lt;= j &amp;&amp; s[j] == ' ' {
        j--
    }

    return s[i : j+1]
}
</code></pre>

<p>优化代码</p>

<h2 id="20200114">20200114</h2>

<p>题目</p>

<pre><code>Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.

You may assume the integer do not contain any leading zero, except the number 0 itself.

The digits are stored such that the most significant digit is at the head of the list.
</code></pre>

<p>题解</p>

<p>数组表示一个非负整数，输出加一后的数据。</p>

<p>思路</p>

<p>直接相加，如果满10进1</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>一样</p>

<p>官方代码</p>

<pre><code>package problem0066

func plusOne(digits []int) []int {
    length := len(digits)
    if length == 0 {
        return []int{1}
    }

    // 末尾加一
    digits[length-1]++

    // 处理进位
    for i := length - 1; i &gt; 0; i-- {
        if digits[i] &lt; 10 {
            break
        }
        digits[i] -= 10
        digits[i-1]++
    }

    // 处理首位的进位
    if digits[0] &gt; 9 {
        digits[0] -= 10
        digits = append([]int{1}, digits...)
    }

    return digits
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="202001015">202001015</h2>

<p>题目</p>

<pre><code>Given two binary strings, return their sum (also a binary string).

For example,
a = &quot;11&quot;
b = &quot;1&quot;
Return &quot;100&quot;.
</code></pre>

<p>题解</p>

<p>给两个字符求和，二进制加法</p>

<p>思路</p>

<p>封二进一</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>封二进一，考虑多位</p>

<p>官方代码</p>

<pre><code>package problem0067

func addBinary(a string, b string) string {
    if len(a) &lt; len(b) {
        a, b = b, a
    }
    l := len(a)

    isA := trans(a, l)
    isB := trans(b, l)

    return makeString(add(isA, isB))
}

func trans(s string, l int) []int {
    res := make([]int, l)
    ls := len(s)
    for i, b := range s {
        res[l-ls+i] = int(b - '0')
    }

    return res
}

func add(a, b []int) []int {
    l := len(a) + 1
    res := make([]int, l)
    for i := l - 1; i &gt;= 1; i-- {
        temp := res[i] + a[i-1] + b[i-1]
        res[i] = temp % 2
        res[i-1] = temp / 2
    }

    i := 0
    // i &lt; l-1 而不是 &lt; l 的原因是
    // &quot;&quot; + &quot;&quot; == &quot;0&quot;
    // 需要保留最后一个 '0'
    for i &lt; l-1 &amp;&amp; res[i] == 0 {
        i++
    }

    return res[i:]
}

func makeString(nums []int) string {
    bytes := make([]byte, len(nums))
    for i := range bytes {
        bytes[i] = byte(nums[i]) + '0'
    }

    return string(bytes)
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20200117">20200117</h2>

<p>题目</p>

<pre><code>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

For example,
words: [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]
L: 16.

Return the formatted lines as:
[
   &quot;This    is    an&quot;,
   &quot;example  of text&quot;,
   &quot;justification.  &quot;
]
Note: Each word is guaranteed not to exceed L in length.

Corner Cases:

A line other than the last line might contain only one word. What should you do in this case? In this case, that line should be left-justified.
</code></pre>

<p>题解</p>

<p>给定一串字符串，将这个字符数组进行重新排序，需要在每行需要在给定的数字长度内，且左右对齐</p>

<p>思路</p>

<p>读单词，读到空格开始保存，看剩下的空间能不能支持下一个单词的放入，然后对每一个空格进行扩展。</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>一致</p>

<p>官方代码</p>

<pre><code>package problem0068

import &quot;strings&quot;

func fullJustify(words []string, maxWidth int) []string {
    res := []string{}
    temp := []string{}
    width := 0
    isLast := false

    for !isLast {
        words, temp, width, isLast = split(words, maxWidth)
        res = append(res, combine(temp, width, maxWidth, isLast))
    }

    return res
}

// 返回不组合的单词，需要组合的单词，和这些单词的长度之和, 是否是结尾
func split(words []string, maxWidth int) ([]string, []string, int, bool) {
    temp := make([]string, 1)
    temp[0] = words[0]
    width := len(words[0])

    i := 1
    for ; i &lt; len(words); i++ {
        if width+len(temp)+len(words[i]) &gt; maxWidth {
            break
        }
        temp = append(temp, words[i])
        width += len(words[i])
    }

    return words[i:], temp, width, i == len(words)
}

func combine(words []string, width, maxWidth int, isLast bool) string {
    wordCount := len(words)
    if wordCount == 1 || isLast {
        return combineSpecial(words, maxWidth)
    }
    spaceCount := wordCount - 1
    spaces := makeSpaces(spaceCount, maxWidth-width)

    res := &quot;&quot;
    for i, v := range spaces {
        res += words[i] + v
    }
    if wordCount &gt; 1 {
        res += words[wordCount-1]
    }

    return res
}

func makeSpaces(Len, count int) []string {
    res := make([]string, Len)
    for i := 0; i &lt; count; i++ {
        res[i%Len] += &quot; &quot;
    }

    return res
}

func combineSpecial(words []string, maxWidth int) string {
    res := strings.Join(words, &quot; &quot;)

    for len(res) &lt; maxWidth {
        res += &quot; &quot;
    }

    return res
}
</code></pre>

<p>优化代码</p>

<p>无</p>

<h2 id="20200120">20200120</h2>

<p>题目</p>

<pre><code>Implement int sqrt(int x).

Compute and return the square root of x.
</code></pre>

<p>题解</p>

<p>求开方</p>

<p>思路</p>

<p>无</p>

<p>代码</p>

<p>无</p>

<p>官方思路</p>

<p>二分查找</p>

<p>官方代码</p>

<pre><code>func mySqrt(x int) int {
      left,right := 0,x
    if x &lt;= 1 {
        return x
    }

    middle := x/2

    for left &lt; right {
        middle = (left+right)/2
        if middle * middle &lt; x {
            left = middle+1 //计算middle 到right的值
        }  else if middle * middle == x {
            return middle
        }  else {
            right = middle-1 //计算left到middle的值
        }
    }

    if left * left &gt; x {
        return left -1
    } else {
        return left
    }
}
</code></pre>

<p>优化代码</p>

<h2 id="20200121">20200121</h2>

<p>题目</p>

<pre><code>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
</code></pre>

<p>题解</p>

<p>有多少种方法，在每次只能爬1，2的情况下，到达n。</p>

<p>思路</p>

<p>代码</p>

<p>官方思路</p>

<p>官方代码</p>

<p>优化代码</p>

<h2 id="20200116">20200116</h2>

<p>题目</p>

<p>题解</p>

<p>思路</p>

<p>代码</p>

<p>官方思路</p>

<p>官方代码</p>

<p>优化代码</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/worklife/leetmeetcode/">https://kingjcy.github.io/post/worklife/leetmeetcode/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/code/">
                            <i class="fa fa-tags"></i>
                            code
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/algorithm/">
                            <i class="fa fa-tags"></i>
                            algorithm
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/monitor/zabbix/zabbixcode/">监控系列---- zabbix源码阅读</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2017年11月25日)</span></li><li id="li-rels"><a href="/post/computerbase/algorithm/algotithm/">计算机基础系列---- algorithm</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2014年04月16日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/monitor/prometheus/exporter/snmp_exporter/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/monitor/server/ntp/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#20181105">20181105</a></li>
<li><a href="#20190610-20190616">20190610-20190616</a></li>
<li><a href="#20190617-20190623">20190617-20190623</a></li>
<li><a href="#20190916-20190922">20190916-20190922</a></li>
<li><a href="#20191010">20191010</a></li>
<li><a href="#20191011">20191011</a></li>
<li><a href="#20191012">20191012</a></li>
<li><a href="#20191013">20191013</a></li>
<li><a href="#20191016">20191016</a></li>
<li><a href="#20191017">20191017</a></li>
<li><a href="#20191018">20191018</a></li>
<li><a href="#20191021">20191021</a></li>
<li><a href="#20191022">20191022</a></li>
<li><a href="#20191023">20191023</a></li>
<li><a href="#20191024">20191024</a></li>
<li><a href="#20191025">20191025</a></li>
<li><a href="#20191028">20191028</a></li>
<li><a href="#20191029">20191029</a></li>
<li><a href="#20191030">20191030</a></li>
<li><a href="#20191031">20191031</a></li>
<li><a href="#20191101">20191101</a></li>
<li><a href="#20191104">20191104</a></li>
<li><a href="#20191104-1">20191104</a></li>
<li><a href="#20191106">20191106</a></li>
<li><a href="#20191107">20191107</a></li>
<li><a href="#20191108">20191108</a></li>
<li><a href="#20191109">20191109</a></li>
<li><a href="#20191110">20191110</a></li>
<li><a href="#20191111">20191111</a></li>
<li><a href="#20191112">20191112</a></li>
<li><a href="#20191113">20191113</a></li>
<li><a href="#20191114">20191114</a></li>
<li><a href="#20191118">20191118</a></li>
<li><a href="#20191119">20191119</a></li>
<li><a href="#20191120">20191120</a></li>
<li><a href="#20191121">20191121</a></li>
<li><a href="#20191122">20191122</a></li>
<li><a href="#20191125">20191125</a></li>
<li><a href="#20191126">20191126</a></li>
<li><a href="#20191128">20191128</a></li>
<li><a href="#20191129">20191129</a></li>
<li><a href="#20191202">20191202</a></li>
<li><a href="#20191203">20191203</a></li>
<li><a href="#20191204">20191204</a></li>
<li><a href="#20191205">20191205</a></li>
<li><a href="#20191205-1">20191205</a></li>
<li><a href="#20191206">20191206</a></li>
<li><a href="#20191207">20191207</a></li>
<li><a href="#20191208">20191208</a></li>
<li><a href="#20191210">20191210</a></li>
<li><a href="#20191211">20191211</a></li>
<li><a href="#20191213">20191213</a></li>
<li><a href="#20191216">20191216</a></li>
<li><a href="#20191217">20191217</a></li>
<li><a href="#20191218">20191218</a></li>
<li><a href="#20191219">20191219</a></li>
<li><a href="#20191220">20191220</a></li>
<li><a href="#20191223">20191223</a></li>
<li><a href="#20191224">20191224</a></li>
<li><a href="#20191225">20191225</a></li>
<li><a href="#20191226">20191226</a></li>
<li><a href="#20191227">20191227</a></li>
<li><a href="#20200102">20200102</a></li>
<li><a href="#20200103">20200103</a></li>
<li><a href="#20200106">20200106</a></li>
<li><a href="#202001010">202001010</a></li>
<li><a href="#20200113">20200113</a></li>
<li><a href="#20200114">20200114</a></li>
<li><a href="#202001015">202001015</a></li>
<li><a href="#20200117">20200117</a></li>
<li><a href="#20200120">20200120</a></li>
<li><a href="#20200121">20200121</a></li>
<li><a href="#20200116">20200116</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

