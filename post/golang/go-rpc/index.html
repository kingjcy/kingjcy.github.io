<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="golang中实现基本的RPC框架">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="golang使用系列---- Rpc - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    golang使用系列---- Rpc
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2016年12月08日 
                </div>
                <h1 class="post-title">golang使用系列---- Rpc</h1>
            </header>

            <div class="post-content">
                <p>golang中实现基本的RPC框架</p>

<p>Go RPC的函数只有符合下面的条件才能被远程访问，不然会被忽略，详细的要求如下：</p>

<pre><code>函数必须是导出的(首字母大写)
必须有两个导出类型的参数，
第一个参数是接收的参数，第二个参数是返回给客- 户端的参数，第二个参数必须是指针类型的
函数还要有一个返回值error
</code></pre>

<p>举个例子，正确的RPC函数格式如下：</p>

<pre><code>func (t *T) MethodName(argType T1, replyType *T2) error
</code></pre>

<p>T、T1和T2类型必须能被encoding/gob包编解码。</p>

<p>在golang中实现RPC非常简单，有封装好的官方库和一些第三方库提供支持。Go RPC可以利用tcp或http来传递数据，可以对要传递的数据使用多种类型的编解码方式。</p>

<ol>
<li><p>golang官方的net/rpc库使用encoding/gob进行编解码，支持tcp或http数据传输方式，由于其他语言不支持gob编解码方式，所以使用net/rpc库实现的RPC方法没办法进行跨语言调用。</p></li>

<li><p>golang官方还提供了net/rpc/jsonrpc库实现RPC方法，JSON RPC采用JSON进行数据编解码，因而支持跨语言调用。但目前的jsonrpc库是基于tcp协议实现的，暂时不支持使用http进行数据传输。</p></li>

<li><p>除了golang官方提供的rpc库，还有许多第三方库为在golang中实现RPC提供支持，大部分第三方rpc库的实现都是使用protobuf进行数据编解码，根据protobuf声明文件自动生成rpc方法定义与服务注册代码，在golang中可以很方便的进行rpc服务调用。</p></li>
</ol>

<h2 id="net-rpc库">net/rpc库</h2>

<p>下面的例子演示一下如何使用golang官方的net/rpc库实现RPC方法，使用http作为RPC的载体，通过net/http包监听客户端连接请求。</p>

<p>$GOPATH/src/test/rpc/rpc_server.go</p>

<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;net/rpc&quot;
    &quot;os&quot;
)

// 算数运算结构体
type Arith struct {
}

// 算数运算请求结构体
type ArithRequest struct {
    A int
    B int
}

// 算数运算响应结构体
type ArithResponse struct {
    Pro int // 乘积
    Quo int // 商
    Rem int // 余数
}

// 乘法运算方法
func (this *Arith) Multiply(req ArithRequest, res *ArithResponse) error {
    res.Pro = req.A * req.B
    return nil
}

// 除法运算方法
func (this *Arith) Divide(req ArithRequest, res *ArithResponse) error {
    if req.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    res.Quo = req.A / req.B
    res.Rem = req.A % req.B
    return nil
}

func main() {
    rpc.Register(new(Arith)) // 注册rpc服务
    rpc.HandleHTTP()         // 采用http协议作为rpc载体

    lis, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8095&quot;)
    if err != nil {
        log.Fatalln(&quot;fatal error: &quot;, err)
    }

    fmt.Fprintf(os.Stdout, &quot;%s&quot;, &quot;start connection&quot;)

    http.Serve(lis, nil)
}
</code></pre>

<p>上述服务端程序运行后，将会监听本地的8095端口，我们可以实现一个客户端程序，连接服务端并实现RPC方法调用。</p>

<p>$GOPATH/src/test/rpc/rpc_client.go</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/rpc&quot;
)

// 算数运算请求结构体
type ArithRequest struct {
    A int
    B int
}

// 算数运算响应结构体
type ArithResponse struct {
    Pro int // 乘积
    Quo int // 商
    Rem int // 余数
}

func main() {
    conn, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:8095&quot;)
    if err != nil {
        log.Fatalln(&quot;dailing error: &quot;, err)
    }

    req := ArithRequest{9, 2}
    var res ArithResponse

    err = conn.Call(&quot;Arith.Multiply&quot;, req, &amp;res) // 乘法运算
    if err != nil {
        log.Fatalln(&quot;arith error: &quot;, err)
    }
    fmt.Printf(&quot;%d * %d = %d\n&quot;, req.A, req.B, res.Pro)

    err = conn.Call(&quot;Arith.Divide&quot;, req, &amp;res)
    if err != nil {
        log.Fatalln(&quot;arith error: &quot;, err)
    }
    fmt.Printf(&quot;%d / %d, quo is %d, rem is %d\n&quot;, req.A, req.B, res.Quo, res.Rem)
}
</code></pre>

<h2 id="net-rpc-jsonrpc库">net/rpc/jsonrpc库</h2>

<p>上面的例子我们演示了使用net/rpc实现RPC的过程，但是没办法在其他语言中调用上面例子实现的RPC方法。所以接下来的例子我们演示一下使用net/rpc/jsonrpc库实现RPC方法，此方式实现的RPC方法支持跨语言调用。</p>

<p>$GOPATH/src/test/rpc/jsonrpc_server.go</p>

<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;net/rpc/jsonrpc&quot;
    &quot;os&quot;
)

// 算数运算结构体
type Arith struct {
}

// 算数运算请求结构体
type ArithRequest struct {
    A int
    B int
}

// 算数运算响应结构体
type ArithResponse struct {
    Pro int // 乘积
    Quo int // 商
    Rem int // 余数
}

// 乘法运算方法
func (this *Arith) Multiply(req ArithRequest, res *ArithResponse) error {
    res.Pro = req.A * req.B
    return nil
}

// 除法运算方法
func (this *Arith) Divide(req ArithRequest, res *ArithResponse) error {
    if req.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    res.Quo = req.A / req.B
    res.Rem = req.A % req.B
    return nil
}

func main() {
    rpc.Register(new(Arith)) // 注册rpc服务

    lis, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8096&quot;)
    if err != nil {
        log.Fatalln(&quot;fatal error: &quot;, err)
    }

    fmt.Fprintf(os.Stdout, &quot;%s&quot;, &quot;start connection&quot;)

    for {
        conn, err := lis.Accept() // 接收客户端连接请求
        if err != nil {
            continue
        }

        go func(conn net.Conn) { // 并发处理客户端请求
            fmt.Fprintf(os.Stdout, &quot;%s&quot;, &quot;new client in coming\n&quot;)
            jsonrpc.ServeConn(conn)
        }(conn)
    }
}
</code></pre>

<p>上述服务端程序启动后，将会监听本地的8096端口，并处理客户端的tcp连接请求。我们可以用golang实现一个客户端程序连接上述服务端并进行RPC调用。</p>

<p>$GOPATH/src/test/rpc/jsonrpc_client.go</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/rpc/jsonrpc&quot;
)

// 算数运算请求结构体
type ArithRequest struct {
    A int
    B int
}

// 算数运算响应结构体
type ArithResponse struct {
    Pro int // 乘积
    Quo int // 商
    Rem int // 余数
}

func main() {
    conn, err := jsonrpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8096&quot;)
    if err != nil {
        log.Fatalln(&quot;dailing error: &quot;, err)
    }

    req := ArithRequest{9, 2}
    var res ArithResponse

    err = conn.Call(&quot;Arith.Multiply&quot;, req, &amp;res) // 乘法运算
    if err != nil {
        log.Fatalln(&quot;arith error: &quot;, err)
    }
    fmt.Printf(&quot;%d * %d = %d\n&quot;, req.A, req.B, res.Pro)

    err = conn.Call(&quot;Arith.Divide&quot;, req, &amp;res)
    if err != nil {
        log.Fatalln(&quot;arith error: &quot;, err)
    }
    fmt.Printf(&quot;%d / %d, quo is %d, rem is %d\n&quot;, req.A, req.B, res.Quo, res.Rem)
}
</code></pre>

<h2 id="protorpc库">protorpc库</h2>

<p>为了实现跨语言调用，在golang中实现RPC方法的时候我们应该选择一种跨语言的数据编解码方式，比如JSON，上述的jsonrpc可以满足此要求，但是也存在一些缺点，比如不支持http传输，数据编解码性能不高等。于是呢，一些第三方rpc库都选择采用protobuf进行数据编解码，并提供一些服务注册代码自动生成功能。下面的例子我们使用protobuf来定义RPC方法及其请求响应参数，并使用第三方的protorpc库来生成RPC服务注册代码。</p>

<p>首先，需要安装protobuf及protoc可执行命令，可以参考此篇文章：protobuf快速上手指南</p>

<p>然后，我们编写一个proto文件，定义要实现的RPC方法及其相关参数。</p>

<p>$GOPATH/src/test/rpc/pb/arith.proto</p>

<pre><code>syntax = &quot;proto3&quot;;
package pb;

// 算术运算请求结构
message ArithRequest {
    int32 a = 1;
    int32 b = 2;
}

// 算术运算响应结构
message ArithResponse {
    int32 pro = 1;  // 乘积
    int32 quo = 2;  // 商
    int32 rem = 3;  // 余数
}

// rpc方法
service ArithService {
    rpc multiply (ArithRequest) returns (ArithResponse);    // 乘法运算方法
    rpc divide (ArithRequest) returns (ArithResponse);      // 除法运算方法
}
</code></pre>

<p>接下来我们需要根据上述定义的arith.proto文件生成RPC服务代码。</p>

<p>要先安装protorpc库：go get github.com/chai2010/protorpc</p>

<p>然后使用protoc工具生成代码：protoc &ndash;go_out=plugin=protorpc=. arith.proto</p>

<p>执行protoc命令后，在与arith.proto文件同级的目录下生成了一个arith.pb.go文件，里面包含了RPC方法定义和服务注册的代码。</p>

<p>基于生成的arith.pb.go代码我们来实现一个rpc服务端</p>

<p>$GOPATH/src/test/rpc/protorpc_server.go</p>

<pre><code>package main

import (
    &quot;errors&quot;
    &quot;test/rpc/pb&quot;
)

// 算术运算结构体
type Arith struct {
}

// 乘法运算方法
func (this *Arith) Multiply(req *pb.ArithRequest, res *pb.ArithResponse) error {
    res.Pro = req.GetA() * req.GetB()
    return nil
}

// 除法运算方法
func (this *Arith) Divide(req *pb.ArithRequest, res *pb.ArithResponse) error {
    if req.GetB() == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    res.Quo = req.GetA() / req.GetB()
    res.Rem = req.GetA() % req.GetB()
    return nil
}

func main() {
    pb.ListenAndServeArithService(&quot;tcp&quot;, &quot;127.0.0.1:8097&quot;, new(Arith))
}
</code></pre>

<p>运行上述程序，将会监听本地的8097端口并接收客户端的tcp连接。</p>

<p>基于ariti.pb.go再来实现一个客户端程序。</p>

<p>$GOPATH/src/test/protorpc_client.go</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;test/rpc/pb&quot;
)

func main() {
    conn, err := pb.DialArithService(&quot;tcp&quot;, &quot;127.0.0.1:8097&quot;)
    if err != nil {
        log.Fatalln(&quot;dailing error: &quot;, err)
    }
    defer conn.Close()

    req := &amp;pb.ArithRequest{9, 2}

    res, err := conn.Multiply(req)
    if err != nil {
        log.Fatalln(&quot;arith error: &quot;, err)
    }
    fmt.Printf(&quot;%d * %d = %d\n&quot;, req.GetA(), req.GetB(), res.GetPro())

    res, err = conn.Divide(req)
    if err != nil {
        log.Fatalln(&quot;arith error &quot;, err)
    }
    fmt.Printf(&quot;%d / %d, quo is %d, rem is %d\n&quot;, req.A, req.B, res.Quo, res.Rem)
}
</code></pre>

<p>如何跨语言调用golang的RPC方法</p>

<p>上面的三个例子，我们分别使用net/rpc、net/rpc/jsonrpc、protorpc实现了golang中的RPC服务端，并给出了对应的golang客户端RPC调用示例，因为JSON和protobuf是支持多语言的，所以使用jsonrpc和protorpc实现的RPC方法我们是可以在其他语言中进行调用的。下面给出一个php客户端程序，通过socket连接调用jsonrpc实现的服务端RPC方法。</p>

<pre><code>$PHPROOT/jsonrpc.php

&lt;?php

class JsonRPC {

    private $conn;

    function __construct($host, $port) {
        $this-&gt;conn = fsockopen($host, $port, $errno, $errstr, 3);
        if (!$this-&gt;conn) {
            return false;
        }
    }

    public function Call($method, $params) {
        if (!$this-&gt;conn) {
            return false;
        }
        $err = fwrite($this-&gt;conn, json_encode(array(
                'method' =&gt; $method,
                'params' =&gt; array($params),
                'id'     =&gt; 0,
            )).&quot;\n&quot;);
        if ($err === false) {
            return false;
        }
        stream_set_timeout($this-&gt;conn, 0, 3000);
        $line = fgets($this-&gt;conn);
        if ($line === false) {
            return NULL;
        }
        return json_decode($line,true);
    }
}

$client = new JsonRPC(&quot;127.0.0.1&quot;, 8096);
$args = array('A'=&gt;9, 'B'=&gt;2);
$r = $client-&gt;Call(&quot;Arith.Multiply&quot;, $args);
printf(&quot;%d * %d = %d\n&quot;, $args['A'], $args['B'], $r['result']['Pro']);
$r = $client-&gt;Call(&quot;Arith.Divide&quot;, array('A'=&gt;9, 'B'=&gt;2));
printf(&quot;%d / %d, Quo is %d, Rem is %d\n&quot;, $args['A'], $args['B'], $r['result']['Quo'], $r['result']['Rem']);
</code></pre>

<h2 id="其他rpc库">其他RPC库</h2>

<p>除了上面提到的三种在golang实现RPC的方式外，还有一些其他的rpc库提供了类似的功能，比较出名的有google开源的grpc，但是grpc的初次安装比较麻烦，这里就不做进一步介绍了，有兴趣的可以自己了解。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-rpc/">https://kingjcy.github.io/post/golang/go-rpc/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/rpc/">
                            <i class="fa fa-tags"></i>
                            rpc
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/linux/centos/centos-update/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/linux/server/iptables/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#net-rpc库">net/rpc库</a></li>
<li><a href="#net-rpc-jsonrpc库">net/rpc/jsonrpc库</a></li>
<li><a href="#protorpc库">protorpc库</a></li>
<li><a href="#其他rpc库">其他RPC库</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

