<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="传输层安全协议（Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Golang使用系列---- Crypto/Tls - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Golang使用系列---- Crypto/Tls
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年11月19日 
                </div>
                <h1 class="post-title">Golang使用系列---- Crypto/Tls</h1>
            </header>

            <div class="post-content">
                <p>传输层安全协议（Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p>

<h1 id="证书生成">证书生成</h1>

<p>首先我们创建私钥和证书。</p>

<p>1.服务器端的证书生成</p>

<p>使用了&rdquo;服务端证书&rdquo;可以确保服务器不是假冒的。</p>

<p>1、 生成服务器端的私钥</p>

<pre><code>openssl genrsa -out server.key 2048
</code></pre>

<p>2、 生成服务器端证书</p>

<pre><code>openssl req -new -x509 -key server.key -out server.pem -days 3650
</code></pre>

<p>or</p>

<pre><code>go run $GOROOT/src/crypto/tls/generate_cert.go --host localhost
</code></pre>

<p>2.客户端的证书生成</p>

<p>除了&rdquo;服务端证书&rdquo;，在某些场合中还会涉及到&rdquo;客户端证书&rdquo;。所谓的&rdquo;客户端证书&rdquo;就是用来证明客户端访问者的身份。
比如在某些金融公司的内网，你的电脑上必须部署&rdquo;客户端证书&rdquo;，才能打开重要服务器的页面。
我会在后面的例子中演示&rdquo;客户端证书&rdquo;的使用。</p>

<p>3、 生成客户端的私钥</p>

<pre><code>openssl genrsa -out client.key 2048
</code></pre>

<p>4、 生成客户端的证书</p>

<pre><code>openssl req -new -x509 -key client.key -out client.pem -days 3650
</code></pre>

<h1 id="实例使用">实例使用</h1>

<p>Go Package tls部分实现了 tls 1.2的功能，可以满足我们日常的应用。Package crypto/x509提供了证书管理的相关操作。</p>

<p>服务器证书的使用</p>

<pre><code>package main
import (
    &quot;bufio&quot;
    &quot;crypto/tls&quot;
    &quot;log&quot;
    &quot;net&quot;
)
func main() {
    cert, err := tls.LoadX509KeyPair(&quot;server.pem&quot;, &quot;server.key&quot;)
    if err != nil {
        log.Println(err)
        return
    }
    config := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
    ln, err := tls.Listen(&quot;tcp&quot;, &quot;:443&quot;, config)
    if err != nil {
        log.Println(err)
        return
    }
    defer ln.Close()
    for {
        conn, err := ln.Accept()
        if err != nil {
            log.Println(err)
            continue
        }
        go handleConn(conn)
    }
}
func handleConn(conn net.Conn) {
    defer conn.Close()
    r := bufio.NewReader(conn)
    for {
        msg, err := r.ReadString('\n')
        if err != nil {
            log.Println(err)
            return
        }
        println(msg)
        n, err := conn.Write([]byte(&quot;world\n&quot;))
        if err != nil {
            log.Println(n, err)
            return
        }
    }
}
</code></pre>

<p>首先从上面我们创建的服务器私钥和pem文件中得到证书cert，并且生成一个tls.Config对象。这个对象有多个字段可以设置，本例中我们使用它的默认值。</p>

<p>然后用tls.Listen开始监听客户端的连接，accept后得到一个net.Conn，后续处理和普通的TCP程序一样。</p>

<p>然后，我们看看客户端是如何实现的：</p>

<pre><code>package main
import (
    &quot;crypto/tls&quot;
    &quot;log&quot;
)
func main() {
    conf := &amp;tls.Config{
        InsecureSkipVerify: true,
    }
    conn, err := tls.Dial(&quot;tcp&quot;, &quot;127.0.0.1:443&quot;, conf)
    if err != nil {
        log.Println(err)
        return
    }
    defer conn.Close()
    n, err := conn.Write([]byte(&quot;hello\n&quot;))
    if err != nil {
        log.Println(n, err)
        return
    }
    buf := make([]byte, 100)
    n, err = conn.Read(buf)
    if err != nil {
        log.Println(n, err)
        return
    }
    println(string(buf[:n]))
}
</code></pre>

<p>InsecureSkipVerify用来控制客户端是否证书和服务器主机名。如果设置为true,则不会校验证书以及证书中的主机名和服务器主机名是否一致。
因为在我们的例子中使用自签名的证书，所以设置它为true,仅仅用于测试目的。</p>

<p>可以看到，整个的程序编写和普通的TCP程序的编写差不太多，只不过初始需要做一些TLS的配置。</p>

<p>你可以go run server.go和go run client.go测试这个例子。</p>

<p>客户端证书的使用</p>

<p>在有的情况下，需要双向认证，服务器也需要验证客户端的真实性。在这种情况下，我们需要服务器和客户端进行一点额外的配置。</p>

<p>服务器端：</p>

<pre><code>package main
import (
    &quot;bufio&quot;
    &quot;crypto/tls&quot;
    &quot;crypto/x509&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net&quot;
)
func main() {
    cert, err := tls.LoadX509KeyPair(&quot;server.pem&quot;, &quot;server.key&quot;)
    if err != nil {
        log.Println(err)
        return
    }
    certBytes, err := ioutil.ReadFile(&quot;client.pem&quot;)
    if err != nil {
        panic(&quot;Unable to read cert.pem&quot;)
    }
    clientCertPool := x509.NewCertPool()
    ok := clientCertPool.AppendCertsFromPEM(certBytes)
    if !ok {
        panic(&quot;failed to parse root certificate&quot;)
    }
    config := &amp;tls.Config{
        Certificates: []tls.Certificate{cert},
        ClientAuth:   tls.RequireAndVerifyClientCert,
        ClientCAs:    clientCertPool,
    }
    ln, err := tls.Listen(&quot;tcp&quot;, &quot;:443&quot;, config)
    if err != nil {
        log.Println(err)
        return
    }
    defer ln.Close()
    for {
        conn, err := ln.Accept()
        if err != nil {
            log.Println(err)
            continue
        }
        go handleConn(conn)
    }
}
func handleConn(conn net.Conn) {
    defer conn.Close()
    r := bufio.NewReader(conn)
    for {
        msg, err := r.ReadString('\n')
        if err != nil {
            log.Println(err)
            return
        }
        println(msg)
        n, err := conn.Write([]byte(&quot;world\n&quot;))
        if err != nil {
            log.Println(n, err)
            return
        }
    }
}
</code></pre>

<p>因为需要验证客户端，我们需要额外配置下面两个字段：</p>

<p>ClientAuth:   tls.RequireAndVerifyClientCert,
ClientCAs:    clientCertPool,</p>

<p>然后客户端也配置这个clientCertPool:</p>

<pre><code>package main
import (
    &quot;crypto/tls&quot;
    &quot;crypto/x509&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
)
func main() {
    cert, err := tls.LoadX509KeyPair(&quot;client.pem&quot;, &quot;client.key&quot;)
    if err != nil {
        log.Println(err)
        return
    }
    certBytes, err := ioutil.ReadFile(&quot;client.pem&quot;)
    if err != nil {
        panic(&quot;Unable to read cert.pem&quot;)
    }
    clientCertPool := x509.NewCertPool()
    ok := clientCertPool.AppendCertsFromPEM(certBytes)
    if !ok {
        panic(&quot;failed to parse root certificate&quot;)
    }
    conf := &amp;tls.Config{
        RootCAs:            clientCertPool,
        Certificates:       []tls.Certificate{cert},
        InsecureSkipVerify: true,
    }
    conn, err := tls.Dial(&quot;tcp&quot;, &quot;127.0.0.1:443&quot;, conf)
    if err != nil {
        log.Println(err)
        return
    }
    defer conn.Close()
    n, err := conn.Write([]byte(&quot;hello\n&quot;))
    if err != nil {
        log.Println(n, err)
        return
    }
    buf := make([]byte, 100)
    n, err = conn.Read(buf)
    if err != nil {
        log.Println(n, err)
        return
    }
    println(string(buf[:n]))
}
</code></pre>

<p>运行这两个代码go run server2.go和go run client2.go,可以看到两者可以正常的通讯，如果用前面的客户端go run client.go，不能正常通讯，因为前面的客户端并没有提供客户端证书。</p>

<h1 id="pem">pem</h1>

<p>数据编码pem，这个在encodeing编码中也会讲解，在这边简单说明一下，加强理解。</p>

<p>golang中pem包是什么？</p>

<p>官方标准库给出的解释：pem包实现了PEM数据编码（源自保密增强邮件协议）。目前PEM编码主要用于TLS密钥和证书。</p>

<p>也就是这个包实现了对PEM解码，以及进行PEM编码</p>

<p>我们不必关心PEM格式的数据长怎么样，只要关注怎么将其他格式数据转换成PEM格式数据，以及将PEM格式数据转换成其他格式数据。</p>

<p>二、golang中的pem包为我们开发者提供了哪些功能？</p>

<p>根据前面分析出来的内容，可以知道分为两个内容，分别是对数据进行PEM编码和解码。也就是说，pem包就是围绕这两个功能进行操作的。</p>

<p>三、我们可以用pem包怎么进行编码以及解码？以及怎么使用代码实现？</p>

<p>1）编码操作</p>

<p>这边给出一个产生RSA公私密钥文件生成的代码实现。</p>

<pre><code>package main

import (
    &quot;flag&quot;
    &quot;crypto/rsa&quot;
    &quot;crypto/rand&quot;
    &quot;crypto/x509&quot;
    &quot;encoding/pem&quot;
    &quot;os&quot;
    &quot;log&quot;
)

func main() {
    var bits int
    flag.IntVar(&amp;bits, &quot;b&quot;, 1024, &quot;密钥长度，默认是1024&quot;)
    flag.Parse()

    if GenRsaKey(bits) != nil {
        log.Fatalln(&quot;密钥文件生成失败！&quot;)
    }
    log.Println(&quot;密钥文件生成成功！&quot;)
}

func GenRsaKey(bits int) error {
    // 生成私钥文件
    privateKey, err := rsa.GenerateKey(rand.Reader, bits)
    if err != nil {
        return nil
    }
    derStream := x509.MarshalPKCS1PrivateKey(privateKey)
    /* 核心代码开始 */
    block := &amp;pem.Block{
        Type:&quot;PRIVATE KEY&quot;,
        Bytes:derStream,
    }
    fi, err := os.Create(&quot;private.pem&quot;)
    if err != nil {
        return err
    }
    err = pem.Encode(fi, block)
    if err != nil {
        return err
    }
    /* 核心代码结束 */
    // 生成公钥文件
    publicKey := &amp;privateKey.PublicKey
    derPkix, err := x509.MarshalPKIXPublicKey(publicKey)
    if err != nil {
        return err
    }
    /* 核心代码开始 */
    block = &amp;pem.Block{
        Type:&quot;PUBLIC KEY&quot;,
        Bytes:derPkix,
    }
    fi, err = os.Create(&quot;public.pem&quot;)
    if err != nil {
        return err
    }
    err = pem.Encode(fi, block)
    /* 核心代码结束 */
    return err
}
</code></pre>

<p>2）解码操作</p>

<pre><code>package main

import (
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;github.com/syndtr/goleveldb/leveldb/errors&quot;
    &quot;encoding/pem&quot;
    &quot;crypto/x509&quot;
    &quot;crypto/rsa&quot;
    &quot;fmt&quot;
)

// 全局变量
var privateKey, publicKey []byte

func init() {
    var err error
    publicKey, err = ioutil.ReadFile(&quot;public.pem&quot;)
    if err != nil {
        log.Fatalln(err)
    }
    privateKey, err = ioutil.ReadFile(&quot;private.pem&quot;)
    if err != nil {
        log.Fatalln(err)
    }
}
/**
 * 功能：获取RSA公钥长度
 * 参数：public
 * 返回：成功则返回 RSA 公钥长度，失败返回 error 错误信息
 */
func GetPubKeyLen(pubKey []byte) (int, error) {
    if pubKey == nil {
        return 0, errors.New(&quot;input arguments error&quot;)
    }
    block, _ := pem.Decode(publicKey)
    if block == nil {
        return 0, errors.New(&quot;public rsaKey error&quot;)
    }
    pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        return 0, err
    }
    pub := pubInterface.(*rsa.PublicKey)
    return pub.N.BitLen(), nil
}
/*
    获取RSA私钥长度
    PriKey
    成功返回 RSA 私钥长度，失败返回error
 */
func GetPriKeyLen(priKey []byte) (int, error) {
    if priKey == nil {
        return 0, errors.New(&quot;input arguments error&quot;)
    }
    block, _ := pem.Decode(priKey)
    if block == nil {
        return 0, errors.New(&quot;private rsaKey error&quot;)
    }
    priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)
    if err != nil {
        return 0, err
    }
    return priv.N.BitLen(), nil
}

func main() {
    // 获取rsa 公钥长度
    pubKeyLen, _ := GetPubKeyLen(publicKey)
    fmt.Println(pubKeyLen)

    // 获取rsa 私钥长度
    privateLen, _ := GetPriKeyLen(privateKey)
    fmt.Println(privateLen)
}
</code></pre>

<h2 id="重要结构和函数">重要结构和函数</h2>

<h3 id="config">config</h3>

<pre><code>type Config struct {
    // Rand提供用于生成随机数和RSA盲签名的熵源，该接口必须能安全的用于并发。
    // 如果Rand是nil，会使用crypto/rand包的密码用随机数读取器。
    Rand io.Reader
    // Time返回当前时间，如果是nil会使用time.Now。
    Time func() time.Time
    // 不少于一个证书的链，用于提供给连接的另一端，服务端必须保证至少有一个证书。
    Certificates []Certificate
    // NameToCertificate映射证书名到证书。
    // 注意证书名可以是&quot;*.example.com &quot;的格式，因此证书名不是必须为域名。
    // 参见Config.BuildNameToCertificate方法。
    // 如本字段为nil，Certificates字段的第一个成员会被用于所有连接。
    NameToCertificate map[string]*Certificate
    // RootCAs定义权威根证书，客户端会在验证服务端证书时用到本字段。
    // 如果RootCAs是nil，TLS会使用主机的根CA池。
    RootCAs *x509.CertPool
    // 可以支持的应用层协议的列表
    NextProtos []string
    // 用于认证返回证书的主机名（除非设置了InsecureSkipVerify）。
    // 也被用在客户端的握手里，以支持虚拟主机。
    ServerName string
    // ClientAuth决定服务端的认证策略，默认是NoClientCert。
    ClientAuth ClientAuthType
    // ClientCAs定义权威根证书，服务端会在采用ClientAuth策略时使用它来认证客户端证书。
    ClientCAs *x509.CertPool
    // InsecureSkipVerify控制客户端是否认证服务端的证书链和主机名。
    // 如果InsecureSkipVerify为真，TLS连接会接受服务端提供的任何证书和该证书中的任何主机名。
    // 此时，TLS连接容易遭受中间人攻击，这种设置只应用于测试。
    InsecureSkipVerify bool
    // CipherSuites是支持的加密组合列表。如果CipherSuites为nil，
    // TLS连接会使用本包的实现支持的密码组合列表。
    CipherSuites []uint16
    // 本字段控制服务端是选择客户端最期望的密码组合还是服务端最期望的密码组合。
    // 如果本字段为真，服务端会优先选择CipherSuites字段中靠前的密码组合使用。
    PreferServerCipherSuites bool
    // SessionTicketsDisabled可以设为假以关闭会话恢复支持。
    SessionTicketsDisabled bool
    // SessionTicketKey被TLS服务端用于提供哦你会话恢复服务，参见RFC 5077。
    // 如果本字段为零值，它会在第一次服务端握手之前填写上随机数据。
    //
    // 如果多个服务端都在终止和同一主机的连接，它们应拥有相同的SessionTicketKey。
    // 如果SessionTicketKey泄露了，使用该键的之前的记录和未来的TLS连接可能会被盗用。
    SessionTicketKey [32]byte
    // SessionCache是ClientSessionState的缓存，用于恢复TLS会话。
    ClientSessionCache ClientSessionCache
    // MinVersion包含可接受的最低SSL/TLS版本。如果为0，会将SSLv3作为最低版本。
    MinVersion uint16
    // MaxVersion包含可接受的最高SSL/TLS版本。
    // 如果为0，会将本包使用的版本作为最高版本，目前是TLS 1.2。
    MaxVersion uint16
    // 本字段包含用于ECDHE握手的椭圆曲线的ID，按优先度排序。如为空，会使用默认值。
    CurvePreferences []CurveID
    // 内含隐藏或非导出字段
}
</code></pre>

<p>Config结构类型用于配置TLS客户端或服务端。在本类型的值提供给TLS函数后，就不应再修改该值。Config类型值可能被重用；tls包也不会修改它。</p>

<pre><code>func (c *Config) BuildNameToCertificate()
</code></pre>

<p>BuildNameToCertificate解析c.Certificates并将每一个叶证书的CommonName和SubjectAlternateName字段用于创建c.NameToCertificate。</p>

<h3 id="conn">conn</h3>

<pre><code>type Conn
type Conn struct {
    // 内含隐藏或非导出字段
}
</code></pre>

<p>Conn代表一个安全连接。本类型实现了net.Conn接口。</p>

<pre><code>func (c *Conn) LocalAddr() net.Addr
</code></pre>

<p>LocalAddr返回本地网络地址。</p>

<pre><code>func (c *Conn) RemoteAddr() net.Addr
</code></pre>

<p>LocalAddr返回远端网络地址。</p>

<pre><code>func (c *Conn) ConnectionState() ConnectionState
</code></pre>

<p>ConnectionState返回该连接的基本TLS细节。</p>

<pre><code>func (c *Conn) SetDeadline(t time.Time) error
</code></pre>

<p>SetDeadline设置该连接的读写操作绝对期限。t为Time零值表示不设置超时。在一次Write/Read方法超时后，TLS连接状态会被破坏，之后所有的读写操作都会返回同一错误。</p>

<pre><code>func (c *Conn) SetReadDeadline(t time.Time) error
</code></pre>

<p>SetReadDeadline设置该连接的读操作绝对期限。t为Time零值表示不设置超时。</p>

<pre><code>func (c *Conn) SetWriteDeadline(t time.Time) error
</code></pre>

<p>SetReadDeadline设置该连接的写操作绝对期限。t为Time零值表示不设置超时。在一次Write方法超时后，TLS连接状态会被破坏，之后所有的写操作都会返回同一错误。</p>

<pre><code>func (c *Conn) Handshake() error
</code></pre>

<p>Handshake执行客户端或服务端的握手协议（如果还没有执行的话）。本包的大多数应用不需要显式的调用Handsake方法：第一次Read或Write方法会自动调用本方法。</p>

<pre><code>func (c *Conn) VerifyHostname(host string) error
</code></pre>

<p>VerifyHostname检查用于连接到host的对等实体证书链是否合法。如果合法，它会返回nil；否则，会返回一个描述该问题的错误。</p>

<pre><code>func (c *Conn) OCSPResponse() []byte
</code></pre>

<p>OCSPResponse返回来自服务端的OCSP staple回复（如果有）。只有客户端可以使用本方法。</p>

<pre><code>func (c *Conn) Read(b []byte) (n int, err error)
</code></pre>

<p>Read从连接读取数据，可设置超时，参见SetDeadline和SetReadDeadline。</p>

<pre><code>func (c *Conn) Write(b []byte) (int, error)
</code></pre>

<p>Write将数据写入连接，可设置超时，参见SetDeadline和SetWriteDeadline。</p>

<pre><code>func (c *Conn) Close() error
</code></pre>

<p>Close关闭连接。</p>

<h3 id="create">create</h3>

<pre><code>func Client(conn net.Conn, config *Config) *Conn
</code></pre>

<p>Client使用conn作为下层传输接口返回一个TLS连接的客户端侧。配置参数config必须是非nil的且必须设置了ServerName或者InsecureSkipVerify字段。</p>

<pre><code>func Server(conn net.Conn, config *Config) *Conn
</code></pre>

<p>Server使用conn作为下层传输接口返回一个TLS连接的服务端侧。配置参数config必须是非nil的且必须含有至少一个证书。</p>

<pre><code>func Dial(network, addr string, config *Config) (*Conn, error)
</code></pre>

<p>Dial使用net.Dial连接指定的网络和地址，然后发起TLS握手，返回生成的TLS连接。Dial会将nil的配置视为零值的配置；参见Config类型的文档获取细节。</p>

<pre><code>func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)
</code></pre>

<p>DialWithDialer使用dialer.Dial连接指定的网络和地址，然后发起TLS握手，返回生成的TLS连接。dialer中的超时和期限设置会将连接和TLS握手作为一个整体来应用。</p>

<p>DialWithDialer会将nil的配置视为零值的配置；参见Config类型的文档获取细节。</p>

<pre><code>func Listen(network, laddr string, config *Config) (net.Listener, error)
</code></pre>

<p>函数创建一个TLS监听器，使用net.Listen函数接收给定地址上的连接。配置参数config必须是非nil的且必须含有至少一个证书。</p>

<pre><code>func NewListener(inner net.Listener, config *Config) net.Listener
</code></pre>

<p>函数创建一个TLS监听器，该监听器接受inner接收到的每一个连接，并调用Server函数包装这些连接。配置参数config必须是非nil的且必须含有至少一个证书。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-crypto-tls/">https://kingjcy.github.io/post/golang/go-crypto-tls/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/tls/">
                            <i class="fa fa-tags"></i>
                            tls
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li><li id="li-rels"><a href="/post/golang/go-threadsafety/">Go Threadsafety</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月04日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/monitor/zabbix/zabbix2tsdb/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/golang/go-web-safe/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#证书生成">证书生成</a></li>
<li><a href="#实例使用">实例使用</a></li>
<li><a href="#pem">pem</a>
<ul>
<li><a href="#重要结构和函数">重要结构和函数</a>
<ul>
<li><a href="#config">config</a></li>
<li><a href="#conn">conn</a></li>
<li><a href="#create">create</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

