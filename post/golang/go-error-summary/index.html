<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="主要是对平时遇到的一些错误进行总结整理">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Go Summary - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Go Summary
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2017年05月16日 
                </div>
                <h1 class="post-title">Go Summary</h1>
            </header>

            <div class="post-content">
                <p>主要是对平时遇到的一些错误进行总结整理</p>

<p>常见问题处理</p>

<ol>
<li>it has a non-exported method and is defined in a different package</li>
</ol>

<p>接口有实现函数没有定义</p>

<ol>
<li>import cycle not allowed</li>
</ol>

<p>golang不允许循环导包,如果检测到import cycle，会在编译时报错，通常import cycle是因为设计错误或包的规划问题。</p>

<p>import(</p>

<p>&ldquo;package A&rdquo;</p>

<p>&ldquo;package B&rdquo;</p>

<p>)</p>

<p>如果package A中已经导入package B，而本package中又导入package B</p>

<p>或者 package A依赖package B,同时 package B 依赖package A</p>

<p>这样就会在编译时报 &rdquo;import cycle not allowed&rdquo;。</p>

<p>如何避免重复导入包的问题，就需要在设计时规划好包。</p>

<ol>
<li>invalid memory address or nil pointer dereference</li>
</ol>

<p>空指针</p>

<ol>
<li>near &ldquo;user&rdquo;: syntax error</li>
</ol>

<p>sql语句写错了</p>

<p>1.</p>

<p>“
错误信息:</p>

<p>/tmp/sandbox826898458/main.go:6: syntax error: unexpected semicolon or newline before {
修正代码:</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 fmt.Println(&ldquo;works!&rdquo;)
}
未使用已定义的变量
级别：新手入门级</p>

<p>如果代码中有未使用的变量，那个代码编译的时候就会报错。Go要求在代码中所有声明的变量都需要被用到，当然，全局变量除外。
函数的参数也可以只被声明，不被使用。</p>

<p>对于未声明变量的调用同样会导致编译失败。和C语言一样，Go编译器也是个女人，他说什么你都要尽力满足。</p>

<p>出错代码：</p>

<p>package main</p>

<p>var gvar int //not an error</p>

<p>func main() {
 var one int //error, unused variable
 two := 2 //error, unused variable
 var three int //error, even though it&rsquo;s assigned 3 on the next line
 three = 3</p>

<p>func(unused string) {
 fmt.Println(&ldquo;Unused arg. No compile error&rdquo;)
 }(&ldquo;what?&rdquo;)
}
错误信息：</p>

<p>/tmp/sandbox473116179/main.go:6: one declared and not used /tmp/sandbox473116179/main.go:7: two declared and not used /tmp/sandbox473116179/main.go:8: three declared and not used
修正代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 var one int
 _ = one</p>

<p>two := 2
 fmt.Println(two)</p>

<p>var three int
 three = 3
 one = three</p>

<p>var four int
 four = four
}
当然，你也可以考虑删除那些没有使用的变量。</p>

<p>未使用的包
级别：新手入门级</p>

<p>当import一个包之后，如果不使用这个包，或者这个包中的函数/接口/数据结构/变量，那么将会编译失败。</p>

<p>如果真的确认要引入变量但是不使用的话，我们可以用“”标识符坐标记，避免编译失败。“”标识符表示为了得到这些包的副作用而引入这些包。</p>

<p>出错代码：</p>

<p>package main</p>

<p>import (
 &ldquo;fmt&rdquo;
 &ldquo;log&rdquo;
 &ldquo;time&rdquo;
)</p>

<p>func main() {
}
错误信息：</p>

<p>/tmp/sandbox627475386/main.go:4: imported and not used: &ldquo;fmt&rdquo;
/tmp/sandbox627475386/main.go:5: imported and not used: &ldquo;log&rdquo;
/tmp/sandbox627475386/main.go:6: imported and not used: &ldquo;time&rdquo;
修正代码</p>

<p>package main</p>

<p>import (
 _ &ldquo;fmt&rdquo;
 &ldquo;log&rdquo;
 &ldquo;time&rdquo;
)</p>

<p>var _ = log.Println</p>

<p>func main() {
 _ = time.Now
}</p>

<p>只能在函数内部使用简短的变量声明
级别：新手入门级
出错代码：</p>

<p>package main</p>

<p>myvar := 1 //error</p>

<p>func main() {
}
错误信息：</p>

<p>/tmp/sandbox265716165/main.go:3: non-declaration statement outside function body</p>

<p>修正代码：</p>

<p>package main</p>

<p>var myvar = 1</p>

<p>func main() {
}
无法使用精简的赋值语句对变量重新赋值
级别：新手入门级</p>

<p>不能使用精简的赋值语句重新赋值单个变量，但是可以使用精简的赋值语句同时赋值多个变量。</p>

<p>并且，重定义的变量必须写在同一个代码块。</p>

<p>错误信息：</p>

<p>package main</p>

<p>func main() {
 one := 0
 one := 1 //error
}
错误信息：</p>

<p>/tmp/sandbox706333626/main.go:5: no new variables on left side of :=
修正代码：</p>

<p>package main</p>

<p>func main() {
 one := 0
 one, two := 1,2</p>

<p>one,two = two,one
}
隐式变量（作用域）
级别：新手入门级</p>

<p>和 C 语言一样，Go 语言也有作用于，一个变量的作用范围仅仅是一个代码块。虽然精简的赋值语句很简单，但是注意作用域。</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := 1
 fmt.Println(x) //打印 1
 {
 fmt.Println(x) //打印 1
 x := 2
 fmt.Println(x) //打印 2
 }
 fmt.Println(x) //打印 1 ( 不是 2)
}
甚至对于有经验的开发者来说，这也是个不注意就会掉进去的深坑。</p>

<p>除非特别指定，否则无法使用 nil 对变量赋值
级别：新手入门级</p>

<p>nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。但是如果不特别指定的话，Go 语言不能识别类型，所以会报错。</p>

<p>错误信息：</p>

<p>package main</p>

<p>func main() {
 var x = nil //error</p>

<p>_ = x
}
错误信息：</p>

<p>/tmp/sandbox188239583/main.go:4: use of untyped nil
修正代码：</p>

<p>package main</p>

<p>func main() {
 var x interface{} = nil</p>

<p>_ = x
}
Slice 和 Map 的 nil 值
级别：新手入门级</p>

<p>初始值为 nil 的 Slice 是可以进行“添加”操作的，但是对于 Map 的“添加”操作会导致运行时恐慌。( ﹁ ﹁ ) 恐慌。</p>

<p>修正代码：</p>

<p>package main</p>

<p>func main() {
 var s []int
 s = append(s,1)
}</p>

<p>错误信息：</p>

<p>package main</p>

<p>func main() {
 var m map[string]int
 m[&ldquo;one&rdquo;] = 1 //error</p>

<p>}
Map 定长
级别：新手入门级</p>

<p>创建 Map 的时候可以指定 Map 的长度，但是在运行时是无法使用 cap() 功能重新指定 Map 的大小，Map 是定长的。</p>

<p>错误信息：</p>

<p>package main</p>

<p>func main() {
 m := make(map[string]int,99)
 cap(m) //error
}
错误信息：</p>

<p>/tmp/sandbox326543983/main.go:5: invalid argument m (type map[string]int) for cap
字符串无法为 nil
级别：新手入门级</p>

<p>所有的开发者都可能踩的坑，在 C 语言中是可以 char *String=NULL，但是 Go 语言中就无法赋值为 nil。</p>

<p>错误信息：</p>

<p>package main</p>

<p>func main() {
 var x string = nil //error</p>

<p>if x == nil { //error
 x = &ldquo;default&rdquo;
 }
}
Compile Errors:</p>

<p>/tmp/sandbox630560459/main.go:4: cannot use nil as type string in assignment /tmp/sandbox630560459/main.go:6: invalid operation: x == nil (mismatched types string and nil)
修正代码：</p>

<p>package main</p>

<p>func main() {
 var x string //defaults to &ldquo;&rdquo; (zero value)</p>

<p>if x == &ldquo;&rdquo; {
 x = &ldquo;default&rdquo;
 }
}
参数中的数组
Array Function Arguments</p>

<p>级别：新手入门级
对于 C 和 C++ 开发者来说，数组就是指针。给函数传递数组就是传递内存地址，对数组的修改就是对原地址数据的修改。但是 Go 语言中，传递的数组不是内存地址，而是原数组的拷贝，所以是无法通过传递数组的方法去修改原地址的数据的。</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := [3]int</p>

<p>func(arr [3]int) {
 arr[0] = 7
 fmt.Println(arr) //prints [7 2 3]
 }(x)</p>

<p>fmt.Println(x) //prints <a href="not ok if you need [7 2 3]">1 2 3</a>
}
如果需要修改原数组的数据，需要使用数组指针（array pointer）。</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := [3]int</p>

<p>func(arr *[3]int) {
 (*arr)[0] = 7
 fmt.Println(arr) //prints &amp;[7 2 3]
 }(&amp;x)</p>

<p>fmt.Println(x) //prints [7 2 3]
}
或者可以使用 Slice，</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := []int</p>

<p>func(arr []int) {
 arr[0] = 7
 fmt.Println(arr) //prints [7 2 3]
 }(x)</p>

<p>fmt.Println(x) //prints [7 2 3]
}
使用 Slice 和 Array 的 range 会导致预料外的结果
级别：新手入门级</p>

<p>如果你对别的语言中的 for in 和 foreach 熟悉的话，那么 Go 中的 range 使用方法完全不一样。因为每次的 range 都会返回两个值，第一个值是在 Slice 和 Array 中的编号，第二个是对应的数据。</p>

<p>出错代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := []string{&ldquo;a&rdquo;,&ldquo;b&rdquo;,&ldquo;c&rdquo;}</p>

<p>for v := range x {
 fmt.Println(v) //prints 0, 1, 2
 }
}
修正代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := []string{&ldquo;a&rdquo;,&ldquo;b&rdquo;,&ldquo;c&rdquo;}</p>

<p>for _, v := range x {
 fmt.Println(v) //prints a, b, c
 }
}
Slive 和 Array 维度是一维
级别：新手入门级</p>

<p>Go 看上去支持多维的 Array 和 Slice，但是其实不然。尽管可以创建 Array 的 Array，也可以创建 Slice 的 Slice。对于依赖多维 Array 的计算密集型的程序，无论是从性能还是复杂程度，Go 都不是最佳选择。</p>

<p>当然，如果你选择创建嵌套的 Array 与嵌套的 Slice，那么你就得自己负责进行索引、进行下表检查、以及 Array 增长时的内存分配。嵌套 Slice 分为两种，Slice 中嵌套独立的 Slice，或者 Slice 中嵌套共享数据的 Slice。</p>

<p>使用嵌套的独立 Slice 创建多维的 Array 需要两步。第一步，创建外围 Slice，然后分配每个内部的 Slice。内部的 Slice 是独立的，可以对每个单独的内部 Slice 进行缩放。</p>

<p>package main</p>

<p>func main() {
 x := 2
 y := 4</p>

<p>table := make([][]int,x)
 for i:= range table {
 table[i] = make([]int,y)
 }
}
使用嵌套、共享数据的 Slive 创建多维 Array 需要三步。第一，创建数据“容器”，第二部，创建外围 Slice，第三部，对内部的 Slice 进行初始化。</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 h, w := 2, 4</p>

<p>raw := make([]int,h*w)
 for i := range raw {
 raw[i] = i
 }
 fmt.Println(raw,&amp;raw[4])
 //prints: [0 1 2 3 4 5 6 7] <ptr_addr_x></p>

<p>table := make([][]int,h)
 for i:= range table {
 table[i] = raw[i*w:i*w + w]
 }</p>

<p>fmt.Println(table,&amp;table[1][0])
 //prints: [[0 1 2 3] [4 5 6 7]] <ptr_addr_x>
}
Go 语言也有对于支持多维 Array 和 Slice 的提案，不过不要期待太多。Go 语言官方将这些需求分在“低优先级”组中。</p>

<p>试图访问不存在的 Map 键值
级别：新手入门级</p>

<p>并不能在所有情况下都能通过判断 map 的记录值是不是 nil 判断记录是否存在。在 Go 语言中，对于“零值”是 nil 的数据类型可以这样判断，但是其他的数据类型不可以。简而言之，这种做法并不可靠（例如布尔变量的“零值”是 false）。最可靠的做法是检查 map 记录的第二返回值。
错误代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := map[string]string{&ldquo;one&rdquo;:&ldquo;a&rdquo;,&ldquo;two&rdquo;:&ldquo;&rdquo;,&ldquo;three&rdquo;:&ldquo;c&rdquo;}</p>

<p>if v := x[&ldquo;two&rdquo;]; v == &ldquo;&rdquo; { //incorrect
 fmt.Println(&ldquo;no entry&rdquo;)
 }
}
修正代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := map[string]string{&ldquo;one&rdquo;:&ldquo;a&rdquo;,&ldquo;two&rdquo;:&ldquo;&rdquo;,&ldquo;three&rdquo;:&ldquo;c&rdquo;}</p>

<p>if _,ok := x[&ldquo;two&rdquo;]; !ok {
 fmt.Println(&ldquo;no entry&rdquo;)
 }
}</p>

<p>String 不可变
级别：新手入门级</p>

<p>对于 String 中单个字符的操作会导致编译失败。String 是带有一些附加属性的只读的字节片（Byte Slices）。所以如果想要对 String 操作的话，应当使用字节片操作，而不是将它转换为 String 类型。</p>

<p>错误信息：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := &ldquo;text&rdquo;
 x[0] = &rsquo;T&rsquo;</p>

<p>fmt.Println(x)
}
错误信息：</p>

<p>/tmp/sandbox305565531/main.go:7: cannot assign to x[0]
修正代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
 x := &ldquo;text&rdquo;
 xbytes := []byte(x)
 xbytes[0] = &rsquo;T&rsquo;</p>

<p>fmt.Println(string(xbytes)) //prints Text
}
注意这里的操作并不就是最正确的操作，因为有些字符可能会存储在多个字节中。如果你的开发情景有这种情况的话，需要先把 String 转换为 rune 格式。即便是 rune，一个字符也可能会保存在多个 rune 中，因此 Go String 也表现为字节序列（String Sequences）。</p>

<p>String 与 Byte Slice 的转换
级别：新手入门级</p>

<p>当将 String 类型和 Byte Slice 类型互相转化的时候，得到的新数据都是原数据的拷贝，而不是原数据。类型转化和切片重组（Resliciing）不一样，切片重组后的变量仍然指向原变量，而类型转换后的变量指向原变量的拷贝。</p>

<p>Go 语言已经对 []byte 和 String 类型的互相转化做了优化，并且还会继续优化。</p>

<p>The first optimization avoids extra allocations when []byte keys are used to lookup entries in map[string] collections: m[string(key)].
一个优化是</p>

<p>The second optimization avoids extra allocations in for range clauses where strings are converted to []byte: for i,v := range []byte(str) {&hellip;}.</p>

<p>Strings and Index Operator</p>

<p>级别：新手入门级
The index operator on a string returns a byte value, not a character (like it&rsquo;s done in other languages).</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
x := &ldquo;text&rdquo;
fmt.Println(x[0]) //print 116
fmt.Printf(&ldquo;%T&rdquo;,x[0]) //prints uint8
}
If you need to access specific string &ldquo;characters&rdquo; (unicode code points/runes) use the for range clause. The official &ldquo;unicode/utf8&rdquo; package and the experimental utf8string package (golang.org/x/exp/utf8string) are also useful. The utf8string package includes a convenient At() method. Converting the string to a slice of runes is an option too.</p>

<p>Strings Are Not Always UTF8 Text</p>

<p>级别：新手入门级
String values are not required to be UTF8 text. They can contain arbitrary bytes. The only time strings are UTF8 is when string literals are used. Even then they can include other data using escape sequences.</p>

<p>To know if you have a UTF8 text string use the ValidString() function from the &ldquo;unicode/utf8&rdquo; package.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;unicode/utf8&rdquo;
)</p>

<p>func main() {
data1 := &ldquo;ABC&rdquo;
fmt.Println(utf8.ValidString(data1)) //prints: true</p>

<p>data2 := &ldquo;A\xfeC&rdquo;
fmt.Println(utf8.ValidString(data2)) //prints: false
}
String Length</p>

<p>级别：新手入门级
Let&rsquo;s say you are a python developer and you have the following piece of code:</p>

<p>data = u&rsquo;♥&rsquo;
print(len(data)) #prints: 1
When you convert it to a similar Go code snippet you might be surprised.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
data := &ldquo;♥&rdquo;
fmt.Println(len(data)) //prints: 3
}
The built-in len() function returns the number of bytes instead of the number of characters like it&rsquo;s done for unicode strings in Python.</p>

<p>To get the same results in Go use the RuneCountInString() function from the &ldquo;unicode/utf8&rdquo; package.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;unicode/utf8&rdquo;
)</p>

<p>func main() {
data := &ldquo;♥&rdquo;
fmt.Println(utf8.RuneCountInString(data)) //prints: 1
Technically the RuneCountInString() function doesn&rsquo;t return the number of characters because a single character may span multiple runes.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;unicode/utf8&rdquo;
)</p>

<p>func main() {
data := &ldquo;é&rdquo;
fmt.Println(len(data)) //prints: 3
fmt.Println(utf8.RuneCountInString(data)) //prints: 2
}
Missing Comma In Multi-Line Slice, Array, and Map Literals</p>

<p>级别：新手入门级
错误信息：</p>

<p>package main</p>

<p>func main() {
x := []int{
1,
2 //error
}
_ = x
}
Compile Errors:</p>

<p>/tmp/sandbox367520156/main.go:6: syntax error: need trailing comma before newline in composite literal /tmp/sandbox367520156/main.go:8: non-declaration statement outside function body /tmp/sandbox367520156/main.go:9: syntax error: unexpected }</p>

<p>修正代码：</p>

<p>package main</p>

<p>func main() {
x := []int{
1,
2,
}
x = x</p>

<p>y := []int //no error
y = y
}
You won&rsquo;t get a compiler error if you leave the trailing comma when you collapse the declaration to be on a single line.</p>

<p>log.Fatal and log.Panic Do More Than Log</p>

<p>级别：新手入门级
Logging libraries often provide different log levels. Unlike those logging libraries, the log package in Go does more than log if you call its Fatal() and Panic() functions. When your app calls those functions Go will also terminate your app :-)</p>

<p>package main</p>

<p>import &ldquo;log&rdquo;</p>

<p>func main() {
log.Fatalln(&ldquo;Fatal Level: log entry&rdquo;) //app exits here
log.Println(&ldquo;Normal Level: log entry&rdquo;)
}
Built-in Data Structure Operations Are Not Synchronized</p>

<p>级别：新手入门级
Even though Go has a number of features to support concurrency natively, concurrency safe data collections are not one them :-) It&rsquo;s your responsibility to ensure the data collection updates are atomic. Goroutines and channels are the recommended way to implement those atomic operations, but you can also leverage the &ldquo;sync&rdquo; package if it makes sense for your application.</p>

<p>Iteration Values For Strings in &ldquo;range&rdquo; Clauses</p>

<p>级别：新手入门级
The index value (the first value returned by the &ldquo;range&rdquo; operation) is the index of the first byte for the current &ldquo;character&rdquo; (unicode code point/rune) returned in the second value. It&rsquo;s not the index for the current &ldquo;character&rdquo; like it&rsquo;s done in other languages. Note that an actual character might be represented by multiple runes. Make sure to check out the &ldquo;norm&rdquo; package (golang.org/x/text/unicode/norm) if you need to work with characters.</p>

<p>The for range clauses with string variables will try to interpret the data as UTF8 text. For any byte sequences it doesn&rsquo;t understand it will return 0xfffd runes (aka unicode replacement characters) instead of the actual data. If you have arbitrary (non-UTF8 text) data stored in your string variables, make sure to convert them to byte slices to get all stored data as is.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
data := &ldquo;A\xfe\x02\xff\x04&rdquo;
for _,v := range data {
fmt.Printf(&ldquo;%#x &ldquo;,v)
}
//prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)</p>

<p>fmt.Println()
for _,v := range []byte(data) {
 fmt.Printf(&ldquo;%#x &ldquo;,v)
}
//prints: 0x41 0xfe 0x2 0xff 0x4 (good)
}
Iterating Through a Map Using a &ldquo;for range&rdquo; Clause</p>

<p>级别：新手入门级
This is a gotcha if you expect the items to be in a certain order (e.g., ordered by the key value). Each map iteration will produce different results. The Go runtime tries to go an extra mile randomizing the iteration order, but it doesn&rsquo;t always succeed so you may get several identical map iterations. Don&rsquo;t be surprised to see 5 identical iterations in a row.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
m := map[string]int{&ldquo;one&rdquo;:1,&ldquo;two&rdquo;:2,&ldquo;three&rdquo;:3,&ldquo;four&rdquo;:4}
for k,v := range m {
fmt.Println(k,v)
}
}
And if you use the Go Playground (<a href="https://play.golang.org/">https://play.golang.org/</a>) you&rsquo;ll always get the same results because it doesn&rsquo;t recompile the code unless you make a change.</p>

<p>Fallthrough Behavior in &ldquo;switch&rdquo; Statements</p>

<p>级别：新手入门级
The &ldquo;case&rdquo; blocks in &ldquo;switch&rdquo; statements break by default. This is different from other languages where the default behavior is to fall through to the next &ldquo;case&rdquo; block.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
isSpace := func(ch byte) bool {
switch(ch) {
case &lsquo; &lsquo;: //error
case &lsquo;\t&rsquo;:
return true
}
return false
}</p>

<p>fmt.Println(isSpace(&rsquo;\t&rsquo;)) //prints true (ok)
fmt.Println(isSpace(&rsquo; &lsquo;)) //prints false (not ok)
}
You can force the &ldquo;case&rdquo; blocks to fall through by using the &ldquo;fallthrough&rdquo; statement at the end of each &ldquo;case&rdquo; block. You can also rewrite your switch statement to use expression lists in the &ldquo;case&rdquo; blocks.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
isSpace := func(ch byte) bool {
switch(ch) {
case &lsquo; &lsquo;, &lsquo;\t&rsquo;:
return true
}
return false
}</p>

<p>fmt.Println(isSpace(&rsquo;\t&rsquo;)) //prints true (ok)
fmt.Println(isSpace(&rsquo; &lsquo;)) //prints true (ok)
}
Increments and Decrements</p>

<p>级别：新手入门级
Many languages have increment and decrement operators. Unlike other languages, Go doesn&rsquo;t support the prefix version of the operations. You also can&rsquo;t use these two operators in expressions.</p>

<p>错误信息：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
data := []int
i := 0
++i //error
fmt.Println(data[i++]) //error
}
Compile Errors:</p>

<p>/tmp/sandbox101231828/main.go:8: syntax error: unexpected ++ /tmp/sandbox101231828/main.go:9: syntax error: unexpected ++, expecting :</p>

<p>修正代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
data := []int
i := 0
i++
fmt.Println(data[i])
}
Bitwise NOT Operator</p>

<p>级别：新手入门级
Many languages use ~ as the unary NOT operator (aka bitwise complement), but Go reuses the XOR operator (^) for that.</p>

<p>错误信息：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
fmt.Println(~2) //error
}
错误信息：</p>

<p>/tmp/sandbox965529189/main.go:6: the bitwise complement operator is ^</p>

<p>修正代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
var d uint8 = 2
fmt.Printf(&ldquo;%08b\n&rdquo;,^d)
}
Go still uses ^ as the XOR operator, which may be confusing for some people.</p>

<p>If you want you can represent a unary NOT operation (e.g, NOT 0x02) with a binary XOR operation (e.g., 0x02 XOR 0xff). This could explain why ^ is reused to represent unary NOT operations.</p>

<p>Go also has a special &lsquo;AND NOT&rsquo; bitwise operator (&amp;^), which adds to the NOT operator confusion. It looks like a special feature/hack to support A AND (NOT B) without requiring parentheses.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
var a uint8 = 0x82
var b uint8 = 0x02
fmt.Printf(&ldquo;%08b [A]\n&rdquo;,a)
fmt.Printf(&ldquo;%08b [B]\n&rdquo;,b)</p>

<p>fmt.Printf(&ldquo;%08b (NOT B)\n&rdquo;,^b)
fmt.Printf(&ldquo;%08b ^ %08b = %08b [B XOR 0xff]\n&rdquo;,b,0xff,b ^ 0xff)</p>

<p>fmt.Printf(&ldquo;%08b ^ %08b = %08b [A XOR B]\n&rdquo;,a,b,a ^ b)
fmt.Printf(&ldquo;%08b &amp; %08b = %08b [A AND B]\n&rdquo;,a,b,a &amp; b)
fmt.Printf(&ldquo;%08b &amp;^%08b = %08b [A &lsquo;AND NOT&rsquo; B]\n&rdquo;,a,b,a &amp;^ b)
fmt.Printf(&ldquo;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&rdquo;,a,b,a &amp; (^b))
}
Operator Precedence Differences</p>

<p>级别：新手入门级
Aside from the &ldquo;bit clear&rdquo; operators (&amp;^) Go has a set of standard operators shared by many other languages. The operator precedence is not always the same though.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
fmt.Printf(&ldquo;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&rdquo;,0x2 &amp; 0x2 + 0x4)
//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6
//Go: (0x2 &amp; 0x2) + 0x4
//C++: 0x2 &amp; (0x2 + 0x4) -&gt; 0x2</p>

<p>fmt.Printf(&ldquo;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&rdquo;,0x2 + 0x2 &lt;&lt; 0x1)
//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6
//Go: 0x2 + (0x2 &lt;&lt; 0x1)
//C++: (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</p>

<p>fmt.Printf(&ldquo;0xf | 0x2 ^ 0x2 -&gt; %#x\n&rdquo;,0xf | 0x2 ^ 0x2)
//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd
//Go: (0xf | 0x2) ^ 0x2
//C++: 0xf | (0x2 ^ 0x2) -&gt; 0xf
}
Unexported Structure Fields Are Not Encoded</p>

<p>级别：新手入门级
The struct fields starting with lowercase letters will not be (json, xml, gob, etc.) encoded, so when you decode the structure you&rsquo;ll end up with zero values in those unexported fields.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;encoding/json&rdquo;
)</p>

<p>type MyData struct {
One int
two string
}</p>

<p>func main() {
in := MyData
fmt.Printf(&ldquo;%#v\n&rdquo;,in) //prints main.MyData</p>

<p>encoded,_ := json.Marshal(in)
fmt.Println(string(encoded)) //prints {&ldquo;One&rdquo;:1}</p>

<p>var out MyData
json.Unmarshal(encoded,&amp;out)</p>

<p>fmt.Printf(&ldquo;%#v\n&rdquo;,out) //prints main.MyData
}
App Exits With Active Goroutines</p>

<p>级别：新手入门级
The app will not wait for all your goroutines to complete. This is a common mistake for beginners in general. Everybody starts somewhere, so there&rsquo;s no shame in making rookie mistakes :-)</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>func main() {
workerCount := 2</p>

<p>for i := 0; i &lt; workerCount; i++ {
 go doit(i)
}
time.Sleep(1 * time.Second)
fmt.Println(&ldquo;all done!&rdquo;)
}</p>

<p>func doit(workerId int) {
fmt.Printf(&rdquo;[%v] is running\n&rdquo;,workerId)
time.Sleep(3 * time.Second)
fmt.Printf(&rdquo;[%v] is done\n&rdquo;,workerId)
}
You&rsquo;ll see:</p>

<p>[0] is running
[1] is running
all done!</p>

<p>One of the most common solutions is to use a &ldquo;WaitGroup&rdquo; variable. It will allow the main goroutine to wait until all worker goroutines are done. If your app has long running workers with message processing loops you&rsquo;ll also need a way to signal those goroutines that it&rsquo;s time to exit. You can send a &ldquo;kill&rdquo; message to each worker. Another option is to close a channel all workers are receiving from. It&rsquo;s a simple way to signal all goroutines at once.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;sync&rdquo;
)</p>

<p>func main() {
var wg sync.WaitGroup
done := make(chan struct{})
workerCount := 2</p>

<p>for i := 0; i &lt; workerCount; i++ {
 wg.Add(1)
 go doit(i,done,wg)
}</p>

<p>close(done)
wg.Wait()
fmt.Println(&ldquo;all done!&rdquo;)
}</p>

<p>func doit(workerId int,done &lt;-chan struct{},wg sync.WaitGroup) {
fmt.Printf(&rdquo;[%v] is running\n&rdquo;,workerId)
defer wg.Done()
&lt;- done
fmt.Printf(&rdquo;[%v] is done\n&rdquo;,workerId)
}
If you run this app you&rsquo;ll see:</p>

<p>[0] is running
[0] is done
[1] is running
[1] is done</p>

<p>Looks like the workers are done before the main goroutine exists. Great! However, you&rsquo;ll also see this:</p>

<p>fatal error: all goroutines are asleep - deadlock!</p>

<p>That&rsquo;s not so great :-) What&rsquo;s going on? Why is there a deadlock? The workers exited and they executed wg.Done(). The app should work.</p>

<p>The deadlock happens because each worker gets a copy of the original &ldquo;WaitGroup&rdquo; variable. When workers execute wg.Done() it has no effect on the &ldquo;WaitGroup&rdquo; variable in the main goroutine.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;sync&rdquo;
)</p>

<p>func main() {
var wg sync.WaitGroup
done := make(chan struct{})
wq := make(chan interface{})
workerCount := 2</p>

<p>for i := 0; i &lt; workerCount; i++ {
 wg.Add(1)
 go doit(i,wq,done,&amp;wg)
}</p>

<p>for i := 0; i &lt; workerCount; i++ {
 wq &lt;- i
}</p>

<p>close(done)
wg.Wait()
fmt.Println(&ldquo;all done!&rdquo;)
}</p>

<p>func doit(workerId int, wq &lt;-chan interface{},done &lt;-chan struct{},wg *sync.WaitGroup) {
fmt.Printf(&rdquo;[%v] is running\n&rdquo;,workerId)
defer wg.Done()
for {
select {
case m := &lt;- wq:
fmt.Printf(&rdquo;[%v] m =&gt; %v\n&rdquo;,workerId,m)
case &lt;- done:
fmt.Printf(&rdquo;[%v] is done\n&rdquo;,workerId)
return
}
}
}
Now it works as expected :-)</p>

<p>Sending to an Unbuffered Channel Returns As Soon As the Target Receiver Is Ready</p>

<p>级别：新手入门级
The sender will not be blocked until your message is processed by the receiver. Depending on the machine where you are running the code, the receiver goroutine may or may not have enough time to process the message before the sender continues its execution.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
ch := make(chan string)</p>

<p>go func() {
 for m := range ch {
 fmt.Println(&ldquo;processed:&ldquo;,m)
 }
}()</p>

<p>ch &lt;- &ldquo;cmd.1&rdquo;
ch &lt;- &ldquo;cmd.2&rdquo; //won&rsquo;t be processed
}
Sending to an Closed Channel Causes a Panic</p>

<p>级别：新手入门级
Receiving from a closed channel is safe. The ok return value in a receive statement will be set to false indicating that no data was received. If you are receiving from a buffered channel you&rsquo;ll get the buffered data first and once it&rsquo;s empty the ok return value will be false.</p>

<p>Sending data to a closed channel causes a panic. It is a documented behavior, but it&rsquo;s not very intuitive for new Go developers who might expect the send behavior to be similar to the receive behavior.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>func main() {
ch := make(chan int)
for i := 0; i &lt; 3; i++ {
go func(idx int) {
ch &lt;- (idx + 1) * 2
}(i)
}</p>

<p>//get the first result
fmt.Println(&lt;-ch)
close(ch) //not ok (you still have other senders)
//do other work
time.Sleep(2 * time.Second)
}
Depending on your application the fix will be different. It might be a minor code change or it might require a change in your application design. Either way, you&rsquo;ll need to make sure your application doesn&rsquo;t try to send data to a closed channel.</p>

<p>The buggy example can be fixed by using a special cancellation channel to signal the remaining workers that their results are no longer neeeded.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>func main() {
ch := make(chan int)
done := make(chan struct{})
for i := 0; i &lt; 3; i++ {
go func(idx int) {
select {
case ch &lt;- (idx + 1) * 2: fmt.Println(idx,&ldquo;sent result&rdquo;)
case &lt;- done: fmt.Println(idx,&ldquo;exiting&rdquo;)
}
}(i)
}</p>

<p>//get first result
fmt.Println(&ldquo;result:&ldquo;,&lt;-ch)
close(done)
//do other work
time.Sleep(3 * time.Second)
}
Using &ldquo;nil&rdquo; Channels</p>

<p>级别：新手入门级
Send and receive operations on a nil channel block forver. It&rsquo;s a well documented behavior, but it can be a surprise for new Go developers.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>func main() {
var ch chan int
for i := 0; i &lt; 3; i++ {
go func(idx int) {
ch &lt;- (idx + 1) * 2
}(i)
}</p>

<p>//get first result
fmt.Println(&ldquo;result:&ldquo;,&lt;-ch)
//do other work
time.Sleep(2 * time.Second)
}
If you run the code you&rsquo;ll see a runtime error like this: fatal error: all goroutines are asleep - deadlock!</p>

<p>This behavior can be used as a way to dynamically enable and disable case blocks in a select statement.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;
import &ldquo;time&rdquo;</p>

<p>func main() {
inch := make(chan int)
outch := make(chan int)</p>

<p>go func() {
 var in &lt;- chan int = inch
 var out chan &lt;- int
 var val int
 for {
 select {
 case out &lt;- val:
 out = nil
 in = inch
 case val = &lt;- in:
 out = outch
 in = nil
 }
 }
}()</p>

<p>go func() {
 for r := range outch {
 fmt.Println(&ldquo;result:&ldquo;,r)
 }
}()</p>

<p>time.Sleep(0)
inch &lt;- 1
inch &lt;- 2
time.Sleep(3 * time.Second)
}
Methods with Value Receivers Can&rsquo;t Change the Original Value</p>

<p>级别：新手入门级
Method receivers are like regular function arguments. If it&rsquo;s declared to be a value then your function/method gets a copy of your receiver argument. This means making changes to the receiver will not affect the original value unless your receiver is a map or slice variable and you are updating the items in the collection or the fields you are updating in the receiver are pointers.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type data struct {
num int
key *string
items map[string]bool
}</p>

<p>func (this *data) pmethod() {
this.num = 7
}</p>

<p>func (this data) vmethod() {
this.num = 8
*this.key = &ldquo;v.key&rdquo;
this.items[&ldquo;vmethod&rdquo;] = true
}</p>

<p>func main() {
key := &ldquo;key.1&rdquo;
d := data</p>

<p>fmt.Printf(&ldquo;num=%v key=%v items=%v\n&rdquo;,d.num,*d.key,d.items)
//prints num=1 key=key.1 items=map[]</p>

<p>d.pmethod()
fmt.Printf(&ldquo;num=%v key=%v items=%v\n&rdquo;,d.num,*d.key,d.items)
//prints num=7 key=key.1 items=map[]</p>

<p>d.vmethod()
fmt.Printf(&ldquo;num=%v key=%v items=%v\n&rdquo;,d.num,*d.key,d.items)
//prints num=7 key=v.key items=map[vmethod:true]
}</p>

<p>Closing HTTP Response Body</p>

<p>level: intermediate
When you make requests using the standard http library you get a http response variable. If you don&rsquo;t read the response body you still need to close it. Note that you must do it for empty responses too. It&rsquo;s very easy to forget especially for new Go developers.</p>

<p>Some new Go developers do try to close the response body, but they do it in the wrong place.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;net/http&rdquo;
&ldquo;io/ioutil&rdquo;
)</p>

<p>func main() {
resp, err := http.Get(&ldquo;<a href="https://api.ipify.org?format=json&quot;">https://api.ipify.org?format=json&quot;</a>)
defer resp.Body.Close()//not ok
if err != nil {
fmt.Println(err)
return
}</p>

<p>body, err := ioutil.ReadAll(resp.Body)
if err != nil {
 fmt.Println(err)
 return
}</p>

<p>fmt.Println(string(body))
}
This code works for successful requests, but if the http request fails the resp variable might be nil, which will cause a runtime panic.</p>

<p>The most common why to close the response body is by using a defer call after the http response error check.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;net/http&rdquo;
&ldquo;io/ioutil&rdquo;
)</p>

<p>func main() {
resp, err := http.Get(&ldquo;<a href="https://api.ipify.org?format=json&quot;">https://api.ipify.org?format=json&quot;</a>)
if err != nil {
fmt.Println(err)
return
}</p>

<p>defer resp.Body.Close()//ok, most of the time :-)
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
 fmt.Println(err)
 return
}</p>

<p>fmt.Println(string(body))
}
Most of the time when your http request fails the resp variable will be nil and the err variable will be non-nil. However, when you get a redirection failure both variables will be non-nil. This means you can still end up with a leak.</p>

<p>You can fix this leak by adding a call to close non-nil response bodies in the http response error handling block. Another option is to use one defer call to close response bodies for all failed and successful requests.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;net/http&rdquo;
&ldquo;io/ioutil&rdquo;
)</p>

<p>func main() {
resp, err := http.Get(&ldquo;<a href="https://api.ipify.org?format=json&quot;">https://api.ipify.org?format=json&quot;</a>)
if resp != nil {
defer resp.Body.Close()
}</p>

<p>if err != nil {
 fmt.Println(err)
 return
}</p>

<p>body, err := ioutil.ReadAll(resp.Body)
if err != nil {
 fmt.Println(err)
 return
}</p>

<p>fmt.Println(string(body))
}
The orignal implementation for resp.Body.Close() also reads and discards the remaining response body data. This ensured that the http connection could be reused for another request if the keepalive http connection behavior is enabled. The latest http client behavior is different. Now it&rsquo;s your responsibility to read and discard the remaining response data. If you don&rsquo;t do it the http connection might be closed instead of being reused. This little gotcha is supposed to be documented in Go 1.5.</p>

<p>If reusing the http connection is important for your application you might need to add something like this at the end of your response processing logic:</p>

<p>_, err = io.Copy(ioutil.Discard, resp.Body)
It might be necessary if you don&rsquo;t read the entire response body right away, which might happen if you are processing json http API response with code like this:</p>

<p>json.NewDecoder(resp.Body).Decode(&amp;data)
Closing HTTP Connections</p>

<p>level: intermediate
Some HTTP servers keep network connections open for a while (based on the HTTP 1.1 spec and the server &ldquo;keep-alive&rdquo; configurations). By default, the standard http library will close the network connections only when the target HTTP server asks for it. This means your app may run out of sockets/file descriptors under certain conditions.</p>

<p>You can ask the http library to close the connection after your request is done by setting the Close field in the request variable to true.</p>

<p>Another option is to add a Connection request header and set it to close. The target HTTP server should respond with a Connection: close header too. When the http library sees this response header it will also close the connection.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;net/http&rdquo;
&ldquo;io/ioutil&rdquo;
)</p>

<p>func main() {
req, err := http.NewRequest(&ldquo;GET&rdquo;,&ldquo;<a href="http://golang.org&quot;,nil">http://golang.org&quot;,nil</a>)
if err != nil {
fmt.Println(err)
return
}</p>

<p>req.Close = true
//or do this:
//req.Header.Add(&ldquo;Connection&rdquo;, &ldquo;close&rdquo;)</p>

<p>resp, err := http.DefaultClient.Do(req)
if resp != nil {
 defer resp.Body.Close()
}</p>

<p>if err != nil {
 fmt.Println(err)
 return
}</p>

<p>body, err := ioutil.ReadAll(resp.Body)
if err != nil {
 fmt.Println(err)
 return
}</p>

<p>fmt.Println(len(string(body)))
}
You can also disable http connection reuse globally. You&rsquo;ll need to create a custom http transport configuration for it.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;net/http&rdquo;
&ldquo;io/ioutil&rdquo;
)</p>

<p>func main() {
tr := &amp;http.Transport
client := &amp;http.Client</p>

<p>resp, err := client.Get(&ldquo;<a href="http://golang.org&quot;">http://golang.org&quot;</a>)
if resp != nil {
 defer resp.Body.Close()
}</p>

<p>if err != nil {
 fmt.Println(err)
 return
}</p>

<p>fmt.Println(resp.StatusCode)</p>

<p>body, err := ioutil.ReadAll(resp.Body)
if err != nil {
 fmt.Println(err)
 return
}</p>

<p>fmt.Println(len(string(body)))
}
If you send a lot of requests to the same HTTP server it&rsquo;s ok to keep the network connection open. However, if your app sends one or two requests to many different HTTP servers in a short period of time it&rsquo;s a good idea to close the network connections right after your app receives the responses. Increasing the open file limit might be a good idea too. The correct solution depends on your application though.</p>

<p>Comparing Structs, Arrays, Slices, and Maps</p>

<p>level: intermediate
You can use the equality operator, ==, to compare struct variables if each structure field can be compared with the equality operator.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type data struct {
num int
fp float32
complex complex64
str string
char rune
yes bool
events &lt;-chan string
handler interface{}
ref *byte
raw [10]byte
}</p>

<p>func main() {
v1 := data{}
v2 := data{}
fmt.Println(&ldquo;v1 == v2:&ldquo;,v1 == v2) //prints: v1 == v2: true
}
If any of the struct fields are not comparable then using the equality operator will result in compile time errors. Note that arrays are comparable only if their data items are comparable.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type data struct {
num int //ok
checks [10]func() bool //not comparable
doit func() bool //not comparable
m map[string] string //not comparable
bytes []byte //not comparable
}</p>

<p>func main() {
v1 := data{}
v2 := data{}
fmt.Println(&ldquo;v1 == v2:&ldquo;,v1 == v2)
}
Go does provide a number of helper functions to compare variables that can&rsquo;t be compared using the comparison operators.</p>

<p>The most generic solution is to use the DeepEqual() function in the reflect package.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;reflect&rdquo;
)</p>

<p>type data struct {
num int //ok
checks [10]func() bool //not comparable
doit func() bool //not comparable
m map[string] string //not comparable
bytes []byte //not comparable
}</p>

<p>func main() {
v1 := data{}
v2 := data{}
fmt.Println(&ldquo;v1 == v2:&ldquo;,reflect.DeepEqual(v1,v2)) //prints: v1 == v2: true</p>

<p>m1 := map[string]string{&ldquo;one&rdquo;: &ldquo;a&rdquo;,&ldquo;two&rdquo;: &ldquo;b&rdquo;}
m2 := map[string]string{&ldquo;two&rdquo;: &ldquo;b&rdquo;, &ldquo;one&rdquo;: &ldquo;a&rdquo;}
fmt.Println(&ldquo;m1 == m2:&ldquo;,reflect.DeepEqual(m1, m2)) //prints: m1 == m2: true</p>

<p>s1 := []int
s2 := []int
fmt.Println(&ldquo;s1 == s2:&ldquo;,reflect.DeepEqual(s1, s2)) //prints: s1 == s2: true
}
Aside from being slow (which may or may not be a deal breaker for your application), DeepEqual() also has its own gotchas.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;reflect&rdquo;
)</p>

<p>func main() {
var b1 []byte = nil
b2 := []byte{}
fmt.Println(&ldquo;b1 == b2:&ldquo;,reflect.DeepEqual(b1, b2)) //prints: b1 == b2: false
}
DeepEqual() doesn&rsquo;t consider an empty slice to be equal to a &ldquo;nil&rdquo; slice. This behavior is different from the behavior you get using the bytes.Equal() function. bytes.Equal() considers &ldquo;nil&rdquo; and empty slices to be equal.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;bytes&rdquo;
)</p>

<p>func main() {
var b1 []byte = nil
b2 := []byte{}
fmt.Println(&ldquo;b1 == b2:&ldquo;,bytes.Equal(b1, b2)) //prints: b1 == b2: true
}
DeepEqual() isn&rsquo;t always perfect comparing slices.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;reflect&rdquo;
&ldquo;encoding/json&rdquo;
)</p>

<p>func main() {
var str string = &ldquo;one&rdquo;
var in interface{} = &ldquo;one&rdquo;
fmt.Println(&ldquo;str == in:&ldquo;,str == in,reflect.DeepEqual(str, in))
//prints: str == in: true true</p>

<p>v1 := []string{&ldquo;one&rdquo;,&ldquo;two&rdquo;}
v2 := []interface{}{&ldquo;one&rdquo;,&ldquo;two&rdquo;}
fmt.Println(&ldquo;v1 == v2:&ldquo;,reflect.DeepEqual(v1, v2))
//prints: v1 == v2: false (not ok)</p>

<p>data := map[string]interface{}{
 &ldquo;code&rdquo;: 200,
 &ldquo;value&rdquo;: []string{&ldquo;one&rdquo;,&ldquo;two&rdquo;},
}
encoded, _ := json.Marshal(data)
var decoded map[string]interface{}
json.Unmarshal(encoded, &amp;decoded)
fmt.Println(&ldquo;data == decoded:&ldquo;,reflect.DeepEqual(data, decoded))
//prints: data == decoded: false (not ok)
}
If your byte slices (or strings) contain text data you might be tempted to use ToUpper() or ToLower() from the &ldquo;bytes&rdquo; and &ldquo;strings&rdquo; packages when you need to compare values in a case insensitive manner (before using ==,bytes.Equal(), or bytes.Compare()). It will work for English text, but it will not work for text in many other languages. strings.EqualFold() and bytes.EqualFold() should be used instead.</p>

<p>If your byte slices contain secrets (e.g., cryptographic hashes, tokens, etc.) that need to be validated against user-provided data, don&rsquo;t use reflect.DeepEqual(), bytes.Equal(), or bytes.Compare() because those functions will make your application vulnerable to timing attacks. To avoid leaking the timing information use the functions from the &lsquo;crypto/subtle&rsquo; package (e.g., subtle.ConstantTimeCompare()).</p>

<p>Recovering From a Panic</p>

<p>level: intermediate
The recover() function can be used to catch/intercept a panic. Calling recover() will do the trick only when it&rsquo;s done in a deferred function.</p>

<p>Incorrect:</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
recover() //doesn&rsquo;t do anything
panic(&ldquo;not good&rdquo;)
recover() //won&rsquo;t be executed :)
fmt.Println(&ldquo;ok&rdquo;)
}
修正代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
defer func() {
fmt.Println(&ldquo;recovered:&ldquo;,recover())
}()</p>

<p>panic(&ldquo;not good&rdquo;)
}
The call to recover() works only if it&rsquo;s called directly in your deferred function.</p>

<p>错误信息：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func doRecover() {
fmt.Println(&ldquo;recovered =&gt;&rdquo;,recover()) //prints: recovered =&gt;
}</p>

<p>func main() {
defer func() {
doRecover() //panic is not recovered
}()</p>

<p>panic(&ldquo;not good&rdquo;)
}
Updating and Referencing Item Values in Slice, Array, and Map &ldquo;range&rdquo; Clauses</p>

<p>level: intermediate
The data values generated in the &ldquo;range&rdquo; clause are copies of the actual collection elements. They are not references to the original items. This means that updating the values will not change the original data. It also means that taking the address of the values will not give you pointers to the original data.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
data := []int
for _,v := range data {
v *= 10 //original item is not changed
}</p>

<p>fmt.Println(&ldquo;data:&ldquo;,data) //prints data: [1 2 3]
}
If you need to update the original collection record value use the index operator to access the data.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
data := []int
for i,_ := range data {
data[i] *= 10
}</p>

<p>fmt.Println(&ldquo;data:&ldquo;,data) //prints data: [10 20 30]
}
If your collection holds pointer values then the rules are slightly different. You still need to use the index operator if you want the original record to point to another value, but you can update the data stored at the target location using the second value in the &ldquo;for range&rdquo; clause.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
data := []*struct {,,}</p>

<p>for _,v := range data {
 v.num *= 10
}</p>

<p>fmt.Println(data[0],data[1],data[2]) //prints &amp; &amp; &amp;
}
&ldquo;Hidden&rdquo; Data in Slices</p>

<p>level: intermediate
When you reslice a slice, the new slice will reference the array of the original slice. If you forget about this behavior it can lead to unexpected memory usage if your application allocates large temporary slices creating new slices from them to refer to small sections of the original data.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func get() []byte {
raw := make([]byte,10000)
fmt.Println(len(raw),cap(raw),&amp;raw[0]) //prints: 10000 10000
return raw[:3]
}</p>

<p>func main() {
data := get()
fmt.Println(len(data),cap(data),&amp;data[0]) //prints: 3 10000
}
To avoid this trap make sure to copy the data you need from the temporary slice (instead of reslicing it).</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func get() []byte {
raw := make([]byte,10000)
fmt.Println(len(raw),cap(raw),&amp;raw[0]) //prints: 10000 10000
res := make([]byte,3)
copy(res,raw[:3])
return res
}</p>

<p>func main() {
data := get()
fmt.Println(len(data),cap(data),&amp;data[0]) //prints: 3 3
}
Slice Data &ldquo;Corruption&rdquo;</p>

<p>level: intermediate
Let&rsquo;s say you need to rewrite a path (stored in a slice). You reslice the path to reference each directory modifying the first folder name and then you combine the names to create a new path.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;bytes&rdquo;
)</p>

<p>func main() {
path := []byte(&ldquo;AAAA/BBBBBBBBB&rdquo;)
sepIndex := bytes.IndexByte(path,&lsquo;/&rsquo;)
dir1 := path[:sepIndex]
dir2 := path[sepIndex+1:]
fmt.Println(&ldquo;dir1 =&gt;&rdquo;,string(dir1)) //prints: dir1 =&gt; AAAA
fmt.Println(&ldquo;dir2 =&gt;&rdquo;,string(dir2)) //prints: dir2 =&gt; BBBBBBBBB</p>

<p>dir1 = append(dir1,&ldquo;suffix&rdquo;&hellip;)
path = bytes.Join([][]byte,[]byte{&lsquo;/&rsquo;})</p>

<p>fmt.Println(&ldquo;dir1 =&gt;&rdquo;,string(dir1)) //prints: dir1 =&gt; AAAAsuffix
fmt.Println(&ldquo;dir2 =&gt;&rdquo;,string(dir2)) //prints: dir2 =&gt; uffixBBBB (not ok)</p>

<p>fmt.Println(&ldquo;new path =&gt;&rdquo;,string(path))
}
It didn&rsquo;t work as you expected. Instead of &ldquo;AAAAsuffix/BBBBBBBBB&rdquo; you ended up with &ldquo;AAAAsuffix/uffixBBBB&rdquo;. It happened because both directory slices referenced the same underlying array data from the original path slice. This means that the original path is also modified. Depending on your application this might be a problem too.</p>

<p>This problem can fixed by allocating new slices and copying the data you need. Another option is to use the full slice expression.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;bytes&rdquo;
)</p>

<p>func main() {
path := []byte(&ldquo;AAAA/BBBBBBBBB&rdquo;)
sepIndex := bytes.IndexByte(path,&lsquo;/&rsquo;)
dir1 := path[:sepIndex:sepIndex] //full slice expression
dir2 := path[sepIndex+1:]
fmt.Println(&ldquo;dir1 =&gt;&rdquo;,string(dir1)) //prints: dir1 =&gt; AAAA
fmt.Println(&ldquo;dir2 =&gt;&rdquo;,string(dir2)) //prints: dir2 =&gt; BBBBBBBBB</p>

<p>dir1 = append(dir1,&ldquo;suffix&rdquo;&hellip;)
path = bytes.Join([][]byte,[]byte{&lsquo;/&rsquo;})</p>

<p>fmt.Println(&ldquo;dir1 =&gt;&rdquo;,string(dir1)) //prints: dir1 =&gt; AAAAsuffix
fmt.Println(&ldquo;dir2 =&gt;&rdquo;,string(dir2)) //prints: dir2 =&gt; BBBBBBBBB (ok now)</p>

<p>fmt.Println(&ldquo;new path =&gt;&rdquo;,string(path))
}
The extra parameter in the full slice expression controls the capacity for the new slice. Now appending to that slice will trigger a new buffer allocation instead of overwriting the data in the second slice.</p>

<p>&ldquo;Stale&rdquo; Slices</p>

<p>level: intermediate
Multiple slices can reference the same data. This can happen when you create a new slice from an existing slice, for example. If your application relies on this behavior to function properly then you&rsquo;ll need to worry about &ldquo;stale&rdquo; slices.</p>

<p>At some point adding data to one of the slices will result in a new array allocation when the original array can&rsquo;t hold any more new data. Now other slices will point to the old array (with old data).</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
s1 := []int
fmt.Println(len(s1),cap(s1),s1) //prints 3 3 [1 2 3]</p>

<p>s2 := s1[1:]
fmt.Println(len(s2),cap(s2),s2) //prints 2 2 [2 3]</p>

<p>for i := range s2 { s2[i] += 20 }</p>

<p>//still referencing the same array
fmt.Println(s1) //prints [1 22 23]
fmt.Println(s2) //prints [22 23]</p>

<p>s2 = append(s2,4)</p>

<p>for i := range s2 { s2[i] += 10 }</p>

<p>//s1 is now &ldquo;stale&rdquo;
fmt.Println(s1) //prints [1 22 23]
fmt.Println(s2) //prints [32 33 14]
}
Type Declarations and Methods</p>

<p>level: intermediate
When you create a type declaration by defining a new type from an existing (non-interface) type, you don&rsquo;t inherit the methods defined for that existing type.</p>

<p>错误信息：</p>

<p>package main</p>

<p>import &ldquo;sync&rdquo;</p>

<p>type myMutex sync.Mutex</p>

<p>func main() {
var mtx myMutex
mtx.Lock() //error
mtx.Unlock() //error
}
Compile Errors:</p>

<p>/tmp/sandbox106401185/main.go:9: mtx.Lock undefined (type myMutex has no field or method Lock) /tmp/sandbox106401185/main.go:10: mtx.Unlock undefined (type myMutex has no field or method Unlock)</p>

<p>If you do need the methods from the original type you can define a new struct type embedding the original type as an anonymous field.</p>

<p>修正代码：</p>

<p>package main</p>

<p>import &ldquo;sync&rdquo;</p>

<p>type myLocker struct {
sync.Mutex
}</p>

<p>func main() {
var lock myLocker
lock.Lock() //ok
lock.Unlock() //ok
}
Interface type declarations also retain their method sets.</p>

<p>修正代码：</p>

<p>package main</p>

<p>import &ldquo;sync&rdquo;</p>

<p>type myLocker sync.Locker</p>

<p>func main() {
var lock myLocker = new(sync.Mutex)
lock.Lock() //ok
lock.Unlock() //ok
}
Breaking Out of &ldquo;for switch&rdquo; and &ldquo;for select&rdquo; Code Blocks</p>

<p>level: intermediate
A &ldquo;break&rdquo; statement without a label only gets you out of the inner switch/select block. If using a &ldquo;return&rdquo; statement is not an option then defining a label for the outer loop is the next best thing.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
loop:
for {
switch {
case true:
fmt.Println(&ldquo;breaking out&hellip;&rdquo;)
break loop
}
}</p>

<p>fmt.Println(&ldquo;out!&rdquo;)
}
A &ldquo;goto&rdquo; statement will do the trick too&hellip;</p>

<p>Iteration Variables and Closures in &ldquo;for&rdquo; Statements</p>

<p>level: intermediate
This is the most common gotcha in Go. The iteration variables in for statements are reused in each iteration. This means that each closure (aka function literal) created in your for loop will reference the same variable (and they&rsquo;ll get that variable&rsquo;s value at the time those goroutines start executing).</p>

<p>Incorrect:</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>func main() {
data := []string{&ldquo;one&rdquo;,&ldquo;two&rdquo;,&ldquo;three&rdquo;}</p>

<p>for _,v := range data {
 go func() {
 fmt.Println(v)
 }()
}</p>

<p>time.Sleep(3 * time.Second)
//goroutines print: three, three, three
}
The easiest solution (that doesn&rsquo;t require any changes to the goroutine) is to save the current iteration variable value in a local variable inside the for loop block.</p>

<p>修正代码：</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>func main() {
data := []string{&ldquo;one&rdquo;,&ldquo;two&rdquo;,&ldquo;three&rdquo;}</p>

<p>for _,v := range data {
 vcopy := v //
 go func() {
 fmt.Println(vcopy)
 }()
}</p>

<p>time.Sleep(3 * time.Second)
//goroutines print: one, two, three
}
Another solution is to pass the current iteration variable as a parameter to the anonymous goroutine.</p>

<p>修正代码：</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>func main() {
data := []string{&ldquo;one&rdquo;,&ldquo;two&rdquo;,&ldquo;three&rdquo;}</p>

<p>for _,v := range data {
 go func(in string) {
 fmt.Println(in)
 }(v)
}</p>

<p>time.Sleep(3 * time.Second)
//goroutines print: one, two, three
}
Here&rsquo;s a slightly more complicated version of the trap.</p>

<p>Incorrect:</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>type field struct {
name string
}</p>

<p>func (p *field) print() {
fmt.Println(p.name)
}</p>

<p>func main() {
data := []field{{&ldquo;one&rdquo;},{&ldquo;two&rdquo;},{&ldquo;three&rdquo;}}</p>

<p>for _,v := range data {
 go v.print()
}</p>

<p>time.Sleep(3 * time.Second)
//goroutines print: three, three, three
}
修正代码：</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>type field struct {
name string
}</p>

<p>func (p *field) print() {
fmt.Println(p.name)
}</p>

<p>func main() {
data := []field{{&ldquo;one&rdquo;},{&ldquo;two&rdquo;},{&ldquo;three&rdquo;}}</p>

<p>for _,v := range data {
 v := v
 go v.print()
}</p>

<p>time.Sleep(3 * time.Second)
//goroutines print: one, two, three
}
What do you think you&rsquo;ll see when you run this code (and why)?</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;time&rdquo;
)</p>

<p>type field struct {
name string
}</p>

<p>func (p *field) print() {
fmt.Println(p.name)
}</p>

<p>func main() {
data := []*field{{&ldquo;one&rdquo;},{&ldquo;two&rdquo;},{&ldquo;three&rdquo;}}</p>

<p>for _,v := range data {
 go v.print()
}</p>

<p>time.Sleep(3 * time.Second)
}
Deferred Function Call Argument Evaluation</p>

<p>level: intermediate
Arguments for a deferred function call are evaluated when the defer statement is evaluated (not when the function is actually executing).</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
var i int = 1</p>

<p>defer fmt.Println(&ldquo;result =&gt;&rdquo;,func() int { return i * 2 }())
i++
//prints: result =&gt; 2 (not ok if you expected 4)
}
Deferred Function Call Execution</p>

<p>level: intermediate
The deferred calls are executed at the end of the containing function and not at the end of the containing code block. It&rsquo;s an easy mistake to make for new Go developers confusing the deferred code execution rules with the variable scoping rules. It can become a problem if you have a long running function with a for loop that tries to defer resource cleanup calls in each iteration.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;os&rdquo;
&ldquo;path/filepath&rdquo;
)</p>

<p>func main() {
if len(os.Args) != 2 {
os.Exit(-1)
}</p>

<p>start, err := os.Stat(os.Args[1])
if err != nil || !start.IsDir(){
 os.Exit(-1)
}</p>

<p>var targets []string
filepath.Walk(os.Args[1], func(fpath string, fi os.FileInfo, err error) error {
 if err != nil {
 return err
 }</p>

<p>if !fi.Mode().IsRegular() {
 return nil
 }</p>

<p>targets = append(targets,fpath)
 return nil
})</p>

<p>for _,target := range targets {
 f, err := os.Open(target)
 if err != nil {
 fmt.Println(&ldquo;bad target:&ldquo;,target,&ldquo;error:&ldquo;,err) //prints error: too many open files
 break
 }
 defer f.Close() //will not be closed at the end of this code block
 //do something with the file&hellip;
}
}
One way to solve the problem is by wrapping the code block in a function.</p>

<p>package main</p>

<p>import (
&ldquo;fmt&rdquo;
&ldquo;os&rdquo;
&ldquo;path/filepath&rdquo;
)</p>

<p>func main() {
if len(os.Args) != 2 {
os.Exit(-1)
}</p>

<p>start, err := os.Stat(os.Args[1])
if err != nil || !start.IsDir(){
 os.Exit(-1)
}</p>

<p>var targets []string
filepath.Walk(os.Args[1], func(fpath string, fi os.FileInfo, err error) error {
 if err != nil {
 return err
 }</p>

<p>if !fi.Mode().IsRegular() {
 return nil
 }</p>

<p>targets = append(targets,fpath)
 return nil
})</p>

<p>for _,target := range targets {
 func() {
 f, err := os.Open(target)
 if err != nil {
 fmt.Println(&ldquo;bad target:&ldquo;,target,&ldquo;error:&ldquo;,err)
 return
 }
 defer f.Close() //ok
 //do something with the file&hellip;
 }()
}
}
Another option is to get rid of the defer statement :-)</p>

<p>Failed Type Assertions</p>

<p>level: intermediate
Failed type assertions return the &ldquo;zero value&rdquo; for the target type used in the assertion statement. This can lead to unexpected behavior when it&rsquo;s mixed with variable shadowing.</p>

<p>Incorrect:</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
var data interface{} = &ldquo;great&rdquo;</p>

<p>if data, ok := data.(int); ok {
 fmt.Println(&rdquo;[is an int] value =&gt;&ldquo;,data)
} else {
 fmt.Println(&rdquo;[not an int] value =&gt;&ldquo;,data)
 //prints: [not an int] value =&gt; 0 (not &ldquo;great&rdquo;)
}
}
修正代码：</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
var data interface{} = &ldquo;great&rdquo;</p>

<p>if res, ok := data.(int); ok {
 fmt.Println(&rdquo;[is an int] value =&gt;&ldquo;,res)
} else {
 fmt.Println(&rdquo;[not an int] value =&gt;&ldquo;,data)
 //prints: [not an int] value =&gt; great (as expected)
}
}
Blocked Goroutines and Resource Leaks</p>

<p>level: intermediate
Rob Pike talked about a number of fundamental concurrency patterns in his &ldquo;Go Concurrency Patterns&rdquo; presentation at Google I/O in 2012. Fetching the first result from a number of targets is one of them.</p>

<p>func First(query string, replicas &hellip;Search) Result {
c := make(chan Result)
searchReplica := func(i int) { c &lt;- replicasi }
for i := range replicas {
go searchReplica(i)
}
return &lt;-c
}
The function starts a goroutines for each search replica. Each goroutine sends its search result to the result channel. The first value from the result channel is returned.</p>

<p>What about the results from the other goroutines? What about the goroutines themselves?</p>

<p>The result channel in the First() function is unbuffered. This means that only the first goroutine returns. All other goroutines are stuck trying to send their results. This means if you have more than one replica each call will leak resources.</p>

<p>To avoid the leaks you need to make sure all goroutines exit. One potential solution is to use a buffered result channel big enough to hold all results.</p>

<p>func First(query string, replicas &hellip;Search) Result {
c := make(chan Result,len(replicas))
searchReplica := func(i int) { c &lt;- replicasi }
for i := range replicas {
go searchReplica(i)
}
return &lt;-c
}
Another potential solution is to use a select statement with a default case and a buffered result channel that can hold one value. The default case ensures that the goroutines don&rsquo;t get stuck even when the result channel can&rsquo;t receive messages.</p>

<p>func First(query string, replicas &hellip;Search) Result {
c := make(chan Result,1)
searchReplica := func(i int) {
select {
case c &lt;- replicasi:
default:
}
}
for i := range replicas {
go searchReplica(i)
}
return &lt;-c
}
You can also use a special cancellation channel to interrupt the workers.</p>

<p>func First(query string, replicas &hellip;Search) Result {
c := make(chan Result)
done := make(chan struct{})
defer close(done)
searchReplica := func(i int) {
select {
case c &lt;- replicasi:
case &lt;- done:
}
}
for i := range replicas {
go searchReplica(i)
}</p>

<p>return &lt;-c
}
Why did the presentation contain these bugs? Rob Pike simply didn&rsquo;t want to comlicate the slides. It makes sense, but it can be a problem for new Go developers who would use the code as is without thinking that it might have problems.</p>

<p>Using Pointer Receiver Methods On Value Instances</p>

<p>level: advanced
It&rsquo;s OK to call a pointer receiver method on a value as long as the value is addressable. In other words, you don&rsquo;t need to have a value receiver version of the method in some cases.</p>

<p>Not every variable is addressable though. Map elements are not addressable. Variables referenced through interfaces are also not addressable.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type data struct {
name string
}</p>

<p>func (p *data) print() {
fmt.Println(&ldquo;name:&ldquo;,p.name)
}</p>

<p>type printer interface {
print()
}</p>

<p>func main() {
d1 := data{&ldquo;one&rdquo;}
d1.print() //ok</p>

<p>var in printer = data{&ldquo;two&rdquo;} //error
in.print()</p>

<p>m := map[string]data {&ldquo;x&rdquo;:data{&ldquo;three&rdquo;}}
m[&ldquo;x&rdquo;].print() //error
}
Compile Errors:</p>

<p>/tmp/sandbox017696142/main.go:21: cannot use data literal (type data) as type printer in assignment: data does not implement printer (print method has pointer receiver)
/tmp/sandbox017696142/main.go:25: cannot call pointer method on m[&ldquo;x&rdquo;] /tmp/sandbox017696142/main.go:25: cannot take the address of m[&ldquo;x&rdquo;]</p>

<p>Updating Map Value Fields</p>

<p>level: advanced
If you have a map of struct values you can&rsquo;t update individual struct fields.</p>

<p>错误信息：</p>

<p>package main</p>

<p>type data struct {
name string
}</p>

<p>func main() {
m := map[string]data {&ldquo;x&rdquo;:{&ldquo;one&rdquo;}}
m[&ldquo;x&rdquo;].name = &ldquo;two&rdquo; //error
}
错误信息：</p>

<p>/tmp/sandbox380452744/main.go:9: cannot assign to m[&ldquo;x&rdquo;].name</p>

<p>It doesn&rsquo;t work because map elements are not addressable.</p>

<p>What can be extra confusing for new Go devs is the fact that slice elements are addressable.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type data struct {
name string
}</p>

<p>func main() {
s := []data {{&ldquo;one&rdquo;}}
s[0].name = &ldquo;two&rdquo; //ok
fmt.Println(s) //prints: []
}
Note that a while ago it was possible to update map element fields in one of the Go compilers (gccgo), but that behavior was quickly fixed :-) It was also considered as a potential feature for Go 1.3. It wasn&rsquo;t important enough to support at that point in time, so it&rsquo;s still on the todo list.</p>

<p>The first work around is to use a temporary variable.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type data struct {
name string
}</p>

<p>func main() {
m := map[string]data {&ldquo;x&rdquo;:{&ldquo;one&rdquo;}}
r := m[&ldquo;x&rdquo;]
r.name = &ldquo;two&rdquo;
m[&ldquo;x&rdquo;] = r
fmt.Printf(&ldquo;%v&rdquo;,m) //prints: map[x:]
}
Another workaround is to use a map of pointers.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type data struct {
name string
}</p>

<p>func main() {
m := map[string]*data {&ldquo;x&rdquo;:{&ldquo;one&rdquo;}}
m[&ldquo;x&rdquo;].name = &ldquo;two&rdquo; //ok
fmt.Println(m[&ldquo;x&rdquo;]) //prints: &amp;
}
By the way, what happens when you run this code?</p>

<p>package main</p>

<p>type data struct {
name string
}</p>

<p>func main() {
m := map[string]*data {&ldquo;x&rdquo;:{&ldquo;one&rdquo;}}
m[&ldquo;z&rdquo;].name = &ldquo;what?&rdquo; //???
}
&ldquo;nil&rdquo; Interfaces and &ldquo;nil&rdquo; Interfaces Values</p>

<p>level: advanced
This is the second most common gotcha in Go because interfaces are not pointers even though they may look like pointers. Interface variables will be &ldquo;nil&rdquo; only when their type and value fields are &ldquo;nil&rdquo;.</p>

<p>The interface type and value fields are populated based on the type and value of the variable used to create the corresponding interface variable. This can lead to unexpected behavior when you are trying to check if an interface variable equals to &ldquo;nil&rdquo;.</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
var data *byte
var in interface{}</p>

<p>fmt.Println(data,data == nil) //prints: <nil> true
fmt.Println(in,in == nil) //prints: <nil> true</p>

<p>in = data
fmt.Println(in,in == nil) //prints: <nil> false
//&lsquo;data&rsquo; is &lsquo;nil&rsquo;, but &lsquo;in&rsquo; is not &lsquo;nil&rsquo;
}
Watch out for this trap when you have a function that returns interfaces.</p>

<p>Incorrect:</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
doit := func(arg int) interface{} {
var result *struct{} = nil</p>

<p>if(arg &gt; 0) {
 result = &amp;struct{}{}
 }</p>

<h2 id="panic-fatal-error-malloc-deadlock">panic fatal error: malloc deadlock</h2>

<p>运行时：不检查printany中的字符串/错误方法或者已经被preprintpanics调用，或者由于在gopanic开始时检查了各种条件而无法安全地调用它们</p>

<h2 id="fatal-error-concurrent-map-read-and-map-write">fatal error: concurrent map read and map write</h2>

<p>因为map为引用类型，所以即使函数传值调用，参数副本依然指向映射m, 所以多个goroutine并发写同一个映射m， 写过多线程程序的同学都知道，对于共享变量，资源，并发读写会产生竞争的， 故共享资源遭到破坏</p>

<p>解决方式：</p>

<ol>
<li><p>加锁</p></li>

<li><p>channel处理</p></li>
</ol>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-error-summary/">https://kingjcy.github.io/post/golang/go-error-summary/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags//">
                            <i class="fa fa-tags"></i>
                            
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/go-unsafe/">Go Unsafe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-text/">Go Text</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-plugin/">Go Plugin</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-mine/">Go Mine</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-internal/">Go Internal</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-index/">Go Index</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-image/">Go Image</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-html/">Go Html</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-hash/">Go Hash</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-go/">Go Go</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/language/ruby/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/distributed/store/calamari/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#panic-fatal-error-malloc-deadlock">panic fatal error: malloc deadlock</a></li>
<li><a href="#fatal-error-concurrent-map-read-and-map-write">fatal error: concurrent map read and map write</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

