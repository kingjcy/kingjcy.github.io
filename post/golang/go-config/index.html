<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="go语言中使用YAML、json、xml、ini作为配置文件。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="config - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    config
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2017年07月07日 
                </div>
                <h1 class="post-title">config</h1>
            </header>

            <div class="post-content">
                <p>go语言中使用YAML、json、xml、ini作为配置文件。</p>

<h1 id="json">json</h1>

<p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。轻量级主要体现在占有空间小，相比于xml更加简洁。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>

<h3 id="常用实例">常用实例</h3>

<p>新建一个文件名为conf.json，键入内容：</p>

<pre><code>{
    &quot;enabled&quot;: true,
    &quot;path&quot;: &quot;/usr/local&quot;
}
</code></pre>

<p>新建main.go，键入内容：</p>

<pre><code>package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

type configuration struct {
    Enabled bool
    Path    string
}

func main() {
    file, _ := os.Open(&quot;conf.json&quot;)
    defer file.Close()

    decoder := json.NewDecoder(file)
    conf := configuration{}
    err := decoder.Decode(&amp;conf)
    if err != nil {
        fmt.Println(&quot;Error:&quot;, err)
    }
    fmt.Println(conf.Path)
}
</code></pre>

<p>通在上面的示例代码中，我们首先定义了与json数据对应的结构体，数组对应slice，字段名对应JSON里面的KEY，具体看下面的json的三种类型。</p>

<p>在解析的时候，如何将json数据与struct字段相匹配呢?例如JSON的key是Foo，那么怎么找对应的字段呢?</p>

<pre><code>首先查找tag含有Foo的可导出的struct字段(首字母大写) 其次查找字段名是Foo的导出字段 最后查找类似FOO或者FoO这样的除了首字母之外其他大小写不敏感的导出字段
</code></pre>

<p>聪明的你一定注意到了这一点:能够被赋值的字段必须是可导出字段(即首字母大写)。同时JSON解析的时候只会解析能找得到的字段，如果找不到的字段会被忽略，这样的一个好处是:当你接收到一个很大的JSON数据结构而你却只想获取其中的部分数据的时候，你只需将你想要的数据对应的字段名大写，即可轻松解决这个问题。</p>

<p>JSON 语言定义的内容非常简洁，主要分为三种类型：对象（object）、数组（array）和基本类型（value）。</p>

<ol>
<li><p>基本类型（value）包括：</p>

<p>string 字符串，双引号括起来的 unciode 字符序列
number 数字，可以是整数，也可以是浮点数，但是不支持八进制和十六进制表示的数字
true，false 真值和假值，一般对应语言中的 bool 类型
null 空值，对应于语言中的空指针等</p></li>

<li><p>数组（array）就是方括号括[]起来的任意值的序列，中间以逗号 , 隔开。</p></li>

<li><p>对象（object）是一系列无序的键值组合，键必须是字符串，键值对之间以逗号 , 隔开，键和值以冒号 : 隔开。数组和对象中的值都可以是嵌套的。</p></li>
</ol>

<p>NOTE：Go 语言中一些特殊的类型，比如 Channel、complex、function 是不能被解析成 JSON 的。</p>

<h3 id="序列化">序列化</h3>

<p>序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure）</p>

<pre><code>数据结构 --&gt; 指定格式 = 序列化 或 编码（传输之前）
指定格式 --&gt; 数据格式 = 反序列化 或 解码（传输之后）
</code></pre>

<p>编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。</p>

<h3 id="json控制">json控制</h3>

<p>在定义 struct 字段的时候，可以在字段后面添加 tag，来控制 encode/decode 的过程：是否要 decode/encode 某个字段，JSON 中的字段名称是什么。</p>

<p>可以选择的控制字段有三种：</p>

<pre><code>-：不要解析这个字段
omitempty：当字段为空（默认值）时，不要解析这个字段。比如 false、0、nil、长度为 0 的 array，map，slice，string
FieldName：当解析 json 的时候，使用这个名字
</code></pre>

<p>举例来说吧：</p>

<pre><code>// 解析的时候忽略该字段。默认情况下会解析这个字段，因为它是大写字母开头的
Field int   `json:&quot;-&quot;`

// 解析（encode/decode） 的时候，使用 `other_name`，而不是 `Field`
Field int   `json:&quot;other_name&quot;`

// 解析的时候使用 `other_name`，如果struct 中这个值为空，就忽略它
Field int   `json:&quot;other_name,omitempty&quot;`
</code></pre>

<h3 id="解析动态内容-interface">解析动态内容: interface{}</h3>

<p>上面的解析过程有一个假设——你要事先知道要解析的 JSON 内容格式，然后定义好对应的数据结构。如果你不知道要解析的内容呢？ Go 提供了 interface{} 的格式，这个接口没有限定任何的方法，因此所有的类型都是满足这个接口的。在解析 JSON 的时候，任意动态的内容都可以解析成 interface{}。</p>

<p>比如还是上面的数据，我们可以这样做：</p>

<pre><code>data := []byte(`{&quot;Name&quot;:&quot;cizixs&quot;,&quot;IsAdmin&quot;:true,&quot;Followers&quot;:36}`)

var f interface{}
json.Unmarshal(data, &amp;f)
</code></pre>

<p>但是要使用 f，还是很麻烦的，我们要使用 type assertion：</p>

<pre><code>name := f.(map[string]interface{})[&quot;Name&quot;].(string)
</code></pre>

<p>对于比较复杂的结构，这样的访问很麻烦，也很容易出错。</p>

<p>如果已经知道 JSON 数据是对象，而不是基本类型（bool，number，string，array）等，因为 JSON 对象键都是字符串，所以可以把上面的例子修改为：</p>

<pre><code>var f map[string]interface{}

// 省去了上面 f 的 type assertion 步骤
name := f[&quot;Name&quot;].(string)
</code></pre>

<p>需要注意的是，尽管 Followers 字段没有小数点，我们希望它是整数值，解析的时候它还是会被解析成 float64，如果直接把它当做 int 访问，会出现错误：</p>

<pre><code>followers := f[&quot;Followers&quot;].(int)

// panic: interface conversion: interface is float64, not int
而必须自己做类型转换：

followers := int(f[&quot;Followers&quot;].(float64))
</code></pre>

<p>这个是官方提供的解决方案，其实有一些开源的包以及很好的解决这个问题，使用起来十分简单，比如  <a href="https://github.com/bitly/go-simplejson">https://github.com/bitly/go-simplejson</a></p>

<pre><code>js, err := NewJson([]byte(`{ 
    &quot;test&quot;: {
        &quot;array&quot;: [1, &quot;2&quot;, 3],
        &quot;int&quot;: 10,
        &quot;float&quot;: 5.150,
        &quot;bignum&quot;: 9223372036854775807, &quot;string&quot;: &quot;simplejson&quot;, &quot;bool&quot;: true
    } 
}`))

arr, _ := js.Get(&quot;test&quot;).Get(&quot;array&quot;).Array() 
i, _ := js.Get(&quot;test&quot;).Get(&quot;int&quot;).Int()
ms := js.Get(&quot;test&quot;).Get(&quot;string&quot;).MustString()
</code></pre>

<p>有解码就有编码，序列化过程都是可逆的</p>

<p>func Marshal(v interface{}) ([]byte, error)</p>

<h3 id="延迟解析-json-rawmessage">延迟解析：json.RawMessage</h3>

<p>在解析的时候，还可以把某部分先保留为 JSON 数据不要解析，等到后面得到更多信息的时候再去解析。继续拿 User 举例，比如我们要添加认证的信息，认证可以是用户名和密码，也可以是 token 认证。</p>

<pre><code>type BasicAuth struct {
    Email string
    Password string
}

type TokenAuth struct {
    Token string
}

type User struct {
    Name string
    IsAdmin bool
    Followers uint
    Auth json.RawMessage
}
</code></pre>

<p>我们在定义 User 结构体的时候，把认证字段的类型定义为 json.RawMessage，这样解析 JSON 数据的时候，对应的字段会先不急着转换成 Go 数据结构。然后我们可以自己去再次调用 Unmarshal 去读取里面的值：</p>

<pre><code>err := json.Unmarshal(data, &amp;basicAuth)
if basicAuth.Email != &quot;&quot; {
    // 这是用户名/密码认证方式，在这里继续做一些处理
} else {
    json.Unmarshal(data, &amp;tokenAuth)
    if tokenAuth.Token != &quot;&quot; {
        // 这是 token 认证方法
    }
}
</code></pre>

<h3 id="自定义解析方法">自定义解析方法</h3>

<p>如果希望自己控制怎么解析成 JSON，或者把 JSON 解析成自定义的类型，只需要实现对应的接口（interface）。encoding/json 提供了两个接口：Marshaler 和 Unmarshaler：</p>

<pre><code>// Marshaler 接口定义了怎么把某个类型 encode 成 JSON 数据
type Marshaler interface {
        MarshalJSON() ([]byte, error)
}

// Unmarshaler 接口定义了怎么把 JSON 数据 decode 成特定的类型数据。如果后续还要使用 JSON 数据，必须把数据拷贝一份
type Unmarshaler interface {
        UnmarshalJSON([]byte) error
}
</code></pre>

<p>标准库 time.Time 就实现了这两个接口。另外一个简单的例子（这个例子来自于参考资料中 Go and JSON 文章）：</p>

<pre><code>type Month struct {
    MonthNumber int
    YearNumber int
}

func (m Month) MarshalJSON() ([]byte, error){
    return []byte(fmt.Sprintf(&quot;%d/%d&quot;, m.MonthNumber, m.YearNumber)), nil
}

func (m *Month) UnmarshalJSON(value []byte) error {
    parts := strings.Split(string(value), &quot;/&quot;)
    m.MonthNumber = strconv.ParseInt(parts[0], 10, 32)
    m.YearNumber = strconv.ParseInt(parts[1], 10, 32)

    return nil
}
</code></pre>

<h3 id="和-stream-中-json-打交道">和 stream 中 JSON 打交道</h3>

<p>上面所有的 JSON 数据来源都是预先定义的 []byte 缓存，在很多时候，如果能读取/写入其他地方的数据就好了。encoding/json 库中有两个专门处理这个事情的结构：Decoder 和 Encoder：</p>

<pre><code>// Decoder 从 r io.Reader 中读取数据，`Decode(v interface{})` 方法把数据转换成对应的数据结构
func NewDecoder(r io.Reader) *Decoder

// Encoder 的 `Encode(v interface{})` 把数据结构转换成对应的 JSON 数据，然后写入到 w io.Writer 中
func NewEncoder(w io.Writer) *Encoder
</code></pre>

<p>下面的例子就是从标准输入流中读取数据，解析成数据结构，删除所有键不是 Name 的字段，然后再 encode 成 JSON 数据，打印到标准输出。</p>

<pre><code>package main

import (
    &quot;encoding/json&quot;
    &quot;log&quot;
    &quot;os&quot;
)

func main() {
    dec := json.NewDecoder(os.Stdin)
    enc := json.NewEncoder(os.Stdout)
    for {
        var v map[string]interface{}
        if err := dec.Decode(&amp;v); err != nil {
            log.Println(err)
            return
        }
        for k := range v {
            if k != &quot;Name&quot; {
                delete(v, k)
            }
        }
        if err := enc.Encode(&amp;v); err != nil {
            log.Println(err)
        }
    }
}
</code></pre>

<h1 id="xml">xml</h1>

<p>可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。</p>

<h3 id="常用实例-1">常用实例</h3>

<p>新建一个文件名为conf.xml，键入内容：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;Config&gt;
   &lt;enabled&gt;true&lt;/enabled&gt;
   &lt;path&gt;/usr/local&lt;/path&gt;
&lt;/Config&gt;
</code></pre>

<p>新建main.go，键入内容：</p>

<pre><code>package main

import (
    &quot;encoding/xml&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

type configuration struct {
    Enabled bool   `xml:&quot;enabled&quot;`
    Path    string `xml:&quot;path&quot;`
}

func main() {
    xmlFile, err := os.Open(&quot;conf.xml&quot;)
    if err != nil {
        fmt.Println(&quot;Error opening file:&quot;, err)
        return
    }
    defer xmlFile.Close()

    var conf configuration
    if err := xml.NewDecoder(xmlFile).Decode(&amp;conf); err != nil {
        fmt.Println(&quot;Error Decode file:&quot;, err)
        return
    }

    fmt.Println(conf.Enabled)
    fmt.Println(conf.Path)

}
</code></pre>

<p>另一种函数接口用法</p>

<pre><code>package main

import ( &quot;encoding/xml&quot;
    &quot;fmt&quot; &quot;io/ioutil&quot; &quot;os&quot;
)

type Recurlyservers struct {
    XMLName xml.Name `xml:&quot;servers&quot;` 
    Version string `xml:&quot;version,attr&quot;` 
    Svs []server `xml:&quot;server&quot;` 
    Description string `xml:&quot;,innerxml&quot;`
}

type server struct {
    XMLName xml.Name `xml:&quot;server&quot;` 
    ServerName string `xml:&quot;serverName&quot;` 
    ServerIP string `xml:&quot;serverIP&quot;`
}

func main() {
    file, err := os.Open(&quot;servers.xml&quot;) // For read access. 
    if err != nil {
        fmt.Printf(&quot;error: %v&quot;, err)
        return 
    }

    defer file.Close()

    data, err := ioutil.ReadAll(file) 
    if err != nil {
        fmt.Printf(&quot;error: %v&quot;, err) return
    }

    v := Recurlyservers{}
    err = xml.Unmarshal(data, &amp;v) 
    if err != nil {
        fmt.Printf(&quot;error: %v&quot;, err)
        return 
    }
    fmt.Println(v) 
}
</code></pre>

<p>XML本质上是一种树形的数据格式，而我们可以定义与之匹配的go 语言的 struct类型，然后通过xml.Unmarshal来将xml中的数据解析成对应的struct对象</p>

<p>解析XML到struct的时候遵循如下的规则:</p>

<pre><code>1.如果struct的一个字段是string或者[]byte类型且它的tag含有&quot;,innerxml&quot;，Unmarshal将会将此字段所对 应的元素内所有内嵌的原始xml累加到此字段上，如上面例子Description定义。最后的输出是

    ShanghaiVPN 127.0.0.1 BeijingVPN 127.0.0.2

2.如果struct中有一个叫做XMLName，且类型为xml.Name字段，那么在解析的时候就会保存这个element的名字到该字段,如上面例子中的servers。

3.如果某个struct字段的tag定义中含有XML结构中element的名称，那么解析的时候就会把相应的element值赋值给该字段，如上servername和serverip定义。

4.如果某个struct字段的tag定义了中含有&quot;,attr&quot;，那么解析的时候就会将该结构所对应的element的与字段 同名的属性的值赋值给该字段，如上version定义。

5.如果某个struct字段的tag定义 型如&quot;a&gt;b&gt;c&quot;,则解析的时候，会将xml结构a下面的b下面的c元素的值赋值给 该字段。

6.如果某个struct字段的tag定义了&quot;-&quot;,那么不会为该字段解析匹配任何xml数据。 如果struct字段后面的tag定义了&quot;,any&quot;，如果他的子元素在不满足其他的规则的时候就会匹配到这个字
</code></pre>

<p>段。</p>

<pre><code>7.如果某个XML元素包含一条或者多条注释，那么这些注释将被累加到第一个tag含有&quot;,comments&quot;的字段上，这个字段的类型可能是[]byte或string,如果没有这样的字段存在，那么注释将会被抛弃。
</code></pre>

<p>当然还可以反解析生成xml报文</p>

<pre><code>func Marshal(v interface{}) ([]byte, error)
func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)
</code></pre>

<p>具体规则如下，使用的不多，如果使用可以查找</p>

<pre><code>XMLName不会被输出
tag中含有&quot;-&quot;的字段不会输出 tag中含有&quot;name,attr&quot;，会以name作为属性名，字段值作为值输出为这个XML元素的属性，如上version字段所描述
tag中含有&quot;,attr&quot;，会以这个struct的字段名作为属性名输出为XML元素的属性，类似上一条，只是这个 name默认是字段名了。
tag中含有&quot;,chardata&quot;，输出为xml的 character data而非element。 tag中含有&quot;,innerxml&quot;，将会被原样输出，而不会进行常规的编码过程 tag中含有&quot;,comment&quot;，将被当作xml注释来输出，而不会进行常规的编码过程，字段值中不能含有&quot;--&quot;字 符串 tag中含有&quot;omitempty&quot;,如果该字段的值为空值那么该字段就不会被输出到XML，空值包括:false、0、nil 指针或nil接口，任何长度为0的array, slice, map或者string
tag中含有&quot;a&gt;b&gt;c&quot;，那么就会循环输出三个元素a包含b，b包含c，例如如下代码就会输出 FirstName string `xml:&quot;name&gt;first&quot;`
LastName string `xml:&quot;name&gt;last&quot;`
&lt;name&gt; &lt;first&gt;Asta&lt;/first&gt; &lt;last&gt;Xie&lt;/last&gt; &lt;/name&gt;
</code></pre>

<h1 id="ini">ini</h1>

<p>INI文件格式是某些平台或软件上的配置文件的非正式标准，以节(section)和键(key)构成，常用于微软Windows操作系统中。这种配置文件的文件扩展名多为INI，故名。</p>

<h3 id="常用实例-2">常用实例</h3>

<p>新建一个文件名为conf.ini，键入内容：</p>

<pre><code>[Section]
enabled = true
path = /usr/local # another comment
</code></pre>

<p>使用第三方库：go get gopkg.in/gcfg.v1</p>

<p>新建main.go，键入代码：</p>

<pre><code>package main

import (
    &quot;fmt&quot;

    &quot;gopkg.in/gcfg.v1&quot;
)

func main() {
    config := struct {
        Section struct {
            Enabled bool
            Path    string
        }
    }{}

    err := gcfg.ReadFileInto(&amp;config, &quot;conf.ini&quot;)
    if err != nil {
        fmt.Println(&quot;Failed to parse config file: %s&quot;, err)
    }
    fmt.Println(config.Section.Enabled)
    fmt.Println(config.Section.Path)
}

输出： 
true 
/usr/local
</code></pre>

<h1 id="yaml">yaml</h1>

<p>何为yaml? 百度百科上这么说的：</p>

<p>YAML是“另一种标记语言”的外语缩写[1] （见前方参考资料原文内容）；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。</p>

<p>wiki上这么说的：</p>

<pre><code>YAML is a human-readable data serialization language. It is commonly used for configuration files, but could be used in many applications where data is being stored (e.g. debugging output) or transmitted (e.g. document headers). YAML targets many of the same communications applications as XML, but has taken a more minimal approach which intentionally breaks compatibility with SGML.[1] YAML 1.2 is a superset of JSON, another minimalist data serialization format where braces and brackets are used instead of indentation.
</code></pre>

<p>通俗的说，也就是一种标记语言。</p>

<p>golang的标准库中暂时没有给我们提供操作yaml的标准库，但是github上有很多优秀的第三方库开源给我们使用。</p>

<h3 id="常用实例-3">常用实例</h3>

<p>新建一个文件名为conf.yaml，键入内容：</p>

<pre><code>enabled: true
path: /usr/local
</code></pre>

<h4 id="go-gypsy">go-gypsy</h4>

<p><a href="https://github.com/kylelemons/go-gypsy">https://github.com/kylelemons/go-gypsy</a></p>

<p>go get -u github.com/kylelemons/go-gypsy</p>

<p>新建文件main.go，键入内容：</p>

<pre><code>package main

import (
    &quot;fmt&quot;

    &quot;github.com/kylelemons/go-gypsy/yaml&quot;
)

func main() {
    config, err := yaml.ReadFile(&quot;conf.yaml&quot;)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(config.Get(&quot;path&quot;))
    fmt.Println(config.GetBool(&quot;enabled&quot;))
}
</code></pre>

<h4 id="yaml-v2">yaml.v2</h4>

<p>gopkg.in/yaml.v2</p>

<p>go get gopkg.in/yaml.v2</p>

<p>修改main.go代码：</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;

    &quot;gopkg.in/yaml.v2&quot;
)

type conf struct {
    Enabled bool   `yaml:&quot;enabled&quot;`
    Path    string `yaml:&quot;path&quot;`
}

func (c *conf) getConf() *conf {

    yamlFile, err := ioutil.ReadFile(&quot;conf.yaml&quot;)
    if err != nil {
        log.Printf(&quot;yamlFile.Get err   #%v &quot;, err)
    }
    err = yaml.Unmarshal(yamlFile, c)
    if err != nil {
        log.Fatalf(&quot;Unmarshal: %v&quot;, err)
    }

    return c
}

func main() {
    var c conf
    c.getConf()

    fmt.Println(c)
}
</code></pre>

<h4 id="yaml-1">yaml</h4>

<p><a href="https://github.com/ghodss/yaml">https://github.com/ghodss/yaml</a></p>

<p>go get -u github.com/ghodss/yaml</p>

<p>修改main代码，这里主要是使用了yaml和json的相互转换：</p>

<pre><code>package main

import (
    &quot;fmt&quot;

    &quot;github.com/ghodss/yaml&quot;
)

func main() {
    j := []byte(`{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}`)
    y, err := yaml.JSONToYAML(j)
    if err != nil {
        fmt.Printf(&quot;err: %v\n&quot;, err)
        return
    }
    fmt.Println(string(y))
    /* Output:
    name: John
    age: 30
    */
    j2, err := yaml.YAMLToJSON(y)
    if err != nil {
        fmt.Printf(&quot;err: %v\n&quot;, err)
        return
    }
    fmt.Println(string(j2))
    /* Output:
    {&quot;age&quot;:30,&quot;name&quot;:&quot;John&quot;}
    */
}
</code></pre>

<h4 id="go-ucfg">go-ucfg</h4>

<p>github.com/elastic/go-ucfg</p>

<p>elastic 推出的配置文件yaml解析库</p>

<p>直接使用这个函数</p>

<pre><code>func NewConfigWithFile
func NewConfigWithFile(name string, opts ...ucfg.Option) (*ucfg.Config, error)
</code></pre>

<h4 id="protobuf">protobuf</h4>

<p>protobuf：go get github.com/gogo/protobuf/proto</p>

<p>最近的项目中，一直使用Json做数据传输。Json用起来的确很方便。但相对于protobuf数据量更大些。做一个移动端应用，为用户省点流量还是很有必要的。正好也可以学习一下protobuf的使用</p>

<p>优点：</p>

<pre><code>跟Json相比protobuf性能更高，更加规范

编解码速度快，数据体积小

使用统一的规范，不用再担心大小写不同导致解析失败等蛋疼的问题了

但也失去了一些便利性

改动协议字段，需要重新生成文件。

数据没有可读性
</code></pre>

<p>实例：</p>

<pre><code>test.proto

syntax = &quot;proto3&quot;;  //指定版本，必须要写（proto3、proto2）  
package proto;

enum FOO 
{ 
    X = 0; 
};

//message是固定的。UserInfo是类名，可以随意指定，符合规范即可
message UserInfo{
    string message = 1;   //消息
    int32 length = 2;    //消息大小
    int32 cnt = 3;      //消息计数
}
</code></pre>

<p>client_protobuf.go</p>

<pre><code>package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;os&quot;
    stProto &quot;proto&quot;
    &quot;time&quot;

    //protobuf编解码库,下面两个库是相互兼容的，可以使用其中任意一个
    &quot;github.com/golang/protobuf/proto&quot;
    //&quot;github.com/gogo/protobuf/proto&quot;
)

func main() {
    strIP := &quot;localhost:6600&quot;
    var conn net.Conn
    var err error

    //连接服务器
    for conn, err = net.Dial(&quot;tcp&quot;, strIP); err != nil; conn, err = net.Dial(&quot;tcp&quot;, strIP) {
        fmt.Println(&quot;connect&quot;, strIP, &quot;fail&quot;)
        time.Sleep(time.Second)
        fmt.Println(&quot;reconnect...&quot;)
    }
    fmt.Println(&quot;connect&quot;, strIP, &quot;success&quot;)
    defer conn.Close()

    //发送消息
    cnt := 0
    sender := bufio.NewScanner(os.Stdin)
    for sender.Scan() {
        cnt++
        stSend := &amp;stProto.UserInfo{
            Message: sender.Text(),
            Length:  *proto.Int(len(sender.Text())),
            Cnt:     *proto.Int(cnt),
        }

        //protobuf编码
        pData, err := proto.Marshal(stSend)
        if err != nil {
            panic(err)
        }

        //发送
        conn.Write(pData)
        if sender.Text() == &quot;stop&quot; {
            return
        }
    }
}
</code></pre>

<p>server_protobuf.go</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;os&quot;
    stProto &quot;proto&quot;

    //protobuf编解码库,下面两个库是相互兼容的，可以使用其中任意一个
    &quot;github.com/golang/protobuf/proto&quot;
    //&quot;github.com/gogo/protobuf/proto&quot;
)

func main() {
    //监听
    listener, err := net.Listen(&quot;tcp&quot;, &quot;localhost:6600&quot;)
    if err != nil {
        panic(err)
    }

    for {
        conn, err := listener.Accept()
        if err != nil {
            panic(err)
        }
        fmt.Println(&quot;new connect&quot;, conn.RemoteAddr())
        go readMessage(conn)
    }
}

//接收消息
func readMessage(conn net.Conn) {
    defer conn.Close()
    buf := make([]byte, 4096, 4096)
    for {
        //读消息
        cnt, err := conn.Read(buf)
        if err != nil {
            panic(err)
        }

        stReceive := &amp;stProto.UserInfo{}
        pData := buf[:cnt]

        //protobuf解码
        err = proto.Unmarshal(pData, stReceive)
        if err != nil {
            panic(err)
        }

        fmt.Println(&quot;receive&quot;, conn.RemoteAddr(), stReceive)
        if stReceive.Message == &quot;stop&quot; {
            os.Exit(1)
        }
    }
}
</code></pre>

<h4 id="自解析">自解析</h4>

<p>unix 风格的配置文件</p>

<pre><code>[default]
path= c:/go
version = 1.44

[test]
num =   666
something  = wrong  #注释1
#fdfdfd = fdfdfd    注释整行
refer= refer       //注释3
</code></pre>

<p>config.go</p>

<pre><code>package conf

import (
    &quot;bufio&quot;
    &quot;io&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

const middle = &quot;=========&quot;

type Config struct {
    Mymap  map[string]string
    strcet string
}

func (c *Config) InitConfig(path string) {
    c.Mymap = make(map[string]string)

    f, err := os.Open(path)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    r := bufio.NewReader(f)
    for {
        b, _, err := r.ReadLine()
        if err != nil {
            if err == io.EOF {
                break
            }
            panic(err)
        }

        s := strings.TrimSpace(string(b))
        //fmt.Println(s)
        if strings.Index(s, &quot;#&quot;) == 0 {
            continue
        }

        n1 := strings.Index(s, &quot;[&quot;)
        n2 := strings.LastIndex(s, &quot;]&quot;)
        if n1 &gt; -1 &amp;&amp; n2 &gt; -1 &amp;&amp; n2 &gt; n1+1 {
            c.strcet = strings.TrimSpace(s[n1+1 : n2])
            continue
        }

        if len(c.strcet) == 0 {
            continue
        }
        index := strings.Index(s, &quot;=&quot;)
        if index &lt; 0 {
            continue
        }

        frist := strings.TrimSpace(s[:index])
        if len(frist) == 0 {
            continue
        }
        second := strings.TrimSpace(s[index+1:])

        pos := strings.Index(second, &quot;\t#&quot;)
        if pos &gt; -1 {
            second = second[0:pos]
        }

        pos = strings.Index(second, &quot; #&quot;)
        if pos &gt; -1 {
            second = second[0:pos]
        }

        pos = strings.Index(second, &quot;\t//&quot;)
        if pos &gt; -1 {
            second = second[0:pos]
        }

        pos = strings.Index(second, &quot; //&quot;)
        if pos &gt; -1 {
            second = second[0:pos]
        }

        if len(second) == 0 {
            continue
        }

        key := c.strcet + middle + frist
        c.Mymap[key] = strings.TrimSpace(second)
    }
}

func (c Config) Read(node, key string) string {
    key = node + middle + key
    v, found := c.Mymap[key]
    if !found {
        return &quot;&quot;
    }
    return v
}
</code></pre>

<p>main.go</p>

<pre><code>package main

import (
    &quot;conf&quot;
    &quot;fmt&quot;
)

func main() {
    myConfig := new(cf.Config)
    myConfig.InitConfig(&quot;c:/config.txt&quot;)
    fmt.Println(myConfig.Read(&quot;default&quot;, &quot;path&quot;))
    fmt.Printf(&quot;%v&quot;, myConfig.Mymap)
}


result:
    c:/go
    map[default=========path:c:/go default=========version:1.44 test=========num:666 test=========something:wrong test=========refer:refer]
</code></pre>

<h3 id="配置热加载">配置热加载</h3>

<p>常规思路还是比较简单的，当获取配置文件内容后，会开启一个goroutine，去 循环读配置文件，当然这里不可能不限制的一直循环，而是设置了一个定时器，定时去读文件，根据文件的修改时间是否变化，从而确定是否重新reload配置文件。</p>

<p>实例</p>

<pre><code>signal

func init() {
    loadConfig()
    fmt.Println(&quot;Load config: &quot;, *config)
    s := make(chan os.Signal, 1)
    signal.Notify(s, syscall.SIGUSR2)
    go func() {
        for {
            &lt;-s
            loadConfig()
            fmt.Println(&quot;ReLoad config: &quot;, *config)
        }
    }()
}
</code></pre>

<p>定时</p>

<pre><code>func (c *Config) reload(){
    // 这里启动一个定时器，每5秒重新加载一次配置文件
    ticker := time.NewTicker(time.Second*5)
    for _ = range ticker.C{
        func(){
            file,err := os.Open(c.filename)
            if err != nil{
                fmt.Printf(&quot;open %s failed,err:%v\n&quot;,c.filename,err)
                return
            }
            defer file.Close()
            fileInfo,err := file.Stat()
            if err != nil{
                fmt.Printf(&quot;stat %s failed,err:%v\n&quot;,c.filename,err)
                return
            }
            curModifyTime := fileInfo.ModTime().Unix()
            fmt.Printf(&quot;%v --- %v\n&quot;,curModifyTime,c.lastModifyTime)
            //判断文件的修改时间是否大于最后一次修改时间
            if curModifyTime &gt; c.lastModifyTime{
                m,err := c.parse()
                if err != nil{
                    fmt.Println(&quot;parse failed,err:&quot;,err)
                    return
                }
                c.rwLock.Lock()
                c.data = m
                c.rwLock.Unlock()
                for _, n:=range c.notifyList{
                    n.Callback(c)
                }
                c.lastModifyTime = curModifyTime
            }
        }()
    }
}
</code></pre>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-config/">https://kingjcy.github.io/post/golang/go-config/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/config/">
                            <i class="fa fa-tags"></i>
                            config
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/ai/gpu/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/monitor/prometheus/prometheus/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#json">json</a>
<ul>
<li>
<ul>
<li><a href="#常用实例">常用实例</a></li>
<li><a href="#序列化">序列化</a></li>
<li><a href="#json控制">json控制</a></li>
<li><a href="#解析动态内容-interface">解析动态内容: interface{}</a></li>
<li><a href="#延迟解析-json-rawmessage">延迟解析：json.RawMessage</a></li>
<li><a href="#自定义解析方法">自定义解析方法</a></li>
<li><a href="#和-stream-中-json-打交道">和 stream 中 JSON 打交道</a></li>
</ul></li>
</ul></li>
<li><a href="#xml">xml</a>
<ul>
<li>
<ul>
<li><a href="#常用实例-1">常用实例</a></li>
</ul></li>
</ul></li>
<li><a href="#ini">ini</a>
<ul>
<li>
<ul>
<li><a href="#常用实例-2">常用实例</a></li>
</ul></li>
</ul></li>
<li><a href="#yaml">yaml</a>
<ul>
<li>
<ul>
<li><a href="#常用实例-3">常用实例</a>
<ul>
<li><a href="#go-gypsy">go-gypsy</a></li>
<li><a href="#yaml-v2">yaml.v2</a></li>
<li><a href="#yaml-1">yaml</a></li>
<li><a href="#go-ucfg">go-ucfg</a></li>
<li><a href="#protobuf">protobuf</a></li>
<li><a href="#自解析">自解析</a></li>
</ul></li>
<li><a href="#配置热加载">配置热加载</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

