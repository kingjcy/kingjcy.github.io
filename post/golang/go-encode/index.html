<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="编码是我们编程过程中常用的方法，encoding包定义了供其它包使用的可以将数据在字节和文本之间转换的接口。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Golang使用系列---- encode - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Golang使用系列---- encode
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年06月17日 
                </div>
                <h1 class="post-title">Golang使用系列---- encode</h1>
            </header>

            <div class="post-content">
                <p>编码是我们编程过程中常用的方法，encoding包定义了供其它包使用的可以将数据在字节和文本之间转换的接口。</p>

<h1 id="总结">总结</h1>

<p>encoding中有多个子包，实现了多种编码格式：</p>

<pre><code>ascii85：用于btoa工具、Adobe的PostScript 脚本和PDF文档格式，资料很少
asn1：证书组成结构标准用ASN.1来进行描述，如X.509
base32：使用了可打印的字符中的32个（A~Z和2~7）对任意字节数据进行编码
base64：使用了可打印的字符中的32个（A~Z,a~z,0~9,&quot;+&quot;,&quot;/&quot;）对任意字节数据进行编码
binary：实现了了VarInt编码，低位在前，单byte最高位为1代表有后续字节，使用zig-zag编码映射有符号数（在最低位：正数x.VarInt=2x+0，负数x.VarInt=2x+1）
csv：逗号分隔值Comma-Separated Values编码，记录之间用'\n'分割
gob：rpc的编码格式
hex：编码为16进制小写字符&quot;0x3e&quot;，效率低下
json：json编码
xml：xml编码
pem：常见在证书、密钥格式，包含Type（-----BEGIN TYPE-----）和内容（base64格式）与可选的Headers（asd: dsa）
</code></pre>

<h2 id="ascii85">ascii85</h2>

<p>ascii85包实现了ascii85数据编码（5个ascii字符表示4个字节），该编码用于btoa工具和Adobe的PostScript语言和PDF文档格式。</p>

<p>基本函数接口</p>

<pre><code>func MaxEncodedLen(n int) int
</code></pre>

<p>返回n字节源数据编码后的最大字节数。</p>

<pre><code>func Encode(dst, src []byte) int
</code></pre>

<p>将src编码成最多MaxEncodedLen(len(src))数据写入dst，返回实际写入的字节数。编码每4字节一段进行一次，最后一个片段采用特殊的处理方式，因此不应将本函数用于处理大数据流的某一独立数据块。</p>

<p>一般来说ascii85编码数据会被&rsquo;&lt;~&lsquo;和&rsquo;~&gt;&lsquo;包括起来，函数并未添加上它们。</p>

<pre><code>func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err error)
</code></pre>

<p>将src解码后写入dst，返回写入dst的字节数、从src解码的字节数。如果src含有非法数据，函数将返回成功执行的数据（两个数字）和CorruptInputError。如果flush为真，则函数会认为src代表输入流的结尾，完全处理src，而不会等待另一个32字节的数据块。</p>

<p>函数会忽略src中的空格和控制字符，一般来说ascii85编码数据会被&rsquo;&lt;~&lsquo;和&rsquo;~&gt;&lsquo;包括起来，但是调用者应自行去掉它们。</p>

<pre><code>func NewEncoder(w io.Writer) io.WriteCloser
</code></pre>

<p>创建一个将数据编码为ascii85流写入w的编码器。Ascii85编码算法操作32位块，写入结束后，必须调用Close方法将缓存中保留的不完整块刷新到w里。</p>

<pre><code>func NewDecoder(r io.Reader) io.Reader
</code></pre>

<p>创建一个从r解码ascii85流的解码器。</p>

<h2 id="asn1">asn1</h2>

<p>asn1包实现了DER编码的ASN.1数据结构的解析，主要是证书的数据结构。</p>

<p>主要函数接口</p>

<pre><code>func Marshal(val interface{}) ([]byte, error)
</code></pre>

<p>Marshal函数返回val的ASN.1编码。</p>

<p>此外还提供了供Unmarshal函数识别的结构体标签，可用如下标签：</p>

<pre><code>ia5:           使字符串序列化为ASN.1 IA5String类型
omitempty:     使空切片被跳过
printable:     使字符串序列化为ASN.1 PrintableString类型
utf8:          使字符串序列化为ASN.1 UTF8字符串


func Unmarshal(b []byte, val interface{}) (rest []byte, err error)
</code></pre>

<p>Unmarshal函数解析DER编码的ASN.1结构体数据并使用reflect包填写val指向的任意类型值。因为本函数使用了reflect包，结构体必须使用大写字母起始的字段名。</p>

<pre><code>ASN.1 INTEGER 类型值可以写入int、int32、int64或*big.Int（math/big包）类型。类型不匹配会返回解析错误。

ASN.1 BIT STRING类型值可以写入BitString类型。

ASN.1 OCTET STRING类型值可以写入[]byte类型。

ASN.1 OBJECT IDENTIFIER类型值可以写入ObjectIdentifier类型。

ASN.1 ENUMERATED类型值可以写入Enumerated类型。

ASN.1 UTCTIME类型值或GENERALIZEDTIME 类型值可以写入time.Time类型。

ASN.1 PrintableString类型值或者IA5String类型值可以写入string类型。
</code></pre>

<p>以上任一ASN.1类型值都可写入interface{}类型。保存在接口里的类型为对应的Go类型，ASN.1整型对应int64。</p>

<p>如果类型x可以写入切片的成员类型，则类型x的ASN.1 SEQUENCE或SET类型可以写入该切片。</p>

<p>ASN.1 SEQUENCE或SET类型如果其每一个成员都可以写入某结构体的对应字段，则可以写入该结构体</p>

<p>对Unmarshal函数，下列字段标签有特殊含义：</p>

<pre><code>application    指明使用了APPLICATION标签
default:x      设置一个可选整数字段的默认值
explicit       给一个隐式的标签设置一个额外的显式标签
optional       标记字段为ASN.1 OPTIONAL的
set            表示期望一个SET而不是SEQUENCE类型
tag:x          指定ASN.1标签码，隐含ASN.1 CONTEXT SPECIFIC
</code></pre>

<p>如果结构体的第一个字段的类型为RawContent，则会将原始ASN1结构体内容包存在该字段。</p>

<p>如果切片成员的类型名以&rdquo;SET&rdquo;结尾，则视为该字段有&rdquo;set&rdquo;标签。这是给不能使用标签的嵌套切片使用的。</p>

<p>其它ASN.1类型不支持，如果遭遇这些类型，Unmarshal返回解析错误。</p>

<p>简单使用实例</p>

<pre><code>package main

import (
    &quot;encoding/asn1&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    mdata, err := asn1.Marshal(13)
    checkError(err)

    var n int
    _, err1 := asn1.Unmarshal(mdata, &amp;n)
    checkError(err1)

    fmt.Println(&quot;After marshal/unmarshal: &quot;, n)
}

func checkError(err error) {
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Fatal error: %s&quot;, err.Error())
        os.Exit(1)
    }
}
</code></pre>

<h2 id="base32">base32</h2>

<p>使用32个可见字符来表示一个二进制数组，编码后数据大小变成原来的8/5,也即5个字符用8个可见字符表示，但是最后如果不足8个字符，将用=来补充。</p>

<p>函数功能详解</p>

<p>1）func NewDecoder(enc *Encoding, r io.Reader) io.Reader</p>

<p>参数列表：</p>

<pre><code>1）enc Encoding 结构指针
2）w io.Reader 接口
</code></pre>

<p>返回值：</p>

<pre><code>io.Reader 接口
</code></pre>

<p>功能说明：</p>

<pre><code>返回一个io.Reader 接口，用于流式解码
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;strings&quot;
    &quot;encoding/base32&quot;
    &quot;fmt&quot;
)

func main() {
    src := &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;
    reader := strings.NewReader(src)
    dst := &quot;&quot;
    decoder := base32.NewDecoder(base32.StdEncoding, reader)
    // 使用一个很小的输出buffer，测试流式解码
    buf := make([]byte, 2)
    for {
        n, err := decoder.Read(buf)
        if err != nil || n == 0 {
            break
        }
        dst += string(buf[:n])
        fmt.Println(dst)
    }
}
</code></pre>

<p>2）func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</p>

<p>参数列表：</p>

<pre><code>1）enc Encoding 结构体
2）w io.Writer 接口
</code></pre>

<p>返回值：</p>

<pre><code>io.WriteCloser 接口
</code></pre>

<p>功能说明：</p>

<pre><code>返回一个io.WriteCloser接口，用于流式编码
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;encoding/base32&quot;
    &quot;os&quot;
)

func main() {
    encoder := base32.NewEncoder(base32.StdEncoding, os.Stdout)
    encoder.Write([]byte(&quot;this is a test string.&quot;))
    encoder.Close()
}
</code></pre>

<p>3）func NewEncoding(encoder string) *Encoding</p>

<p>参数列表：</p>

<pre><code>encoder 32字节长的字符串，用做转换表
</code></pre>

<p>返回值：</p>

<pre><code>Encoding结构体
</code></pre>

<p>功能说明：</p>

<pre><code>计算 base32 解码输出需要的最大字节数
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;encoding/base32&quot;
    &quot;fmt&quot;
)

func main() {
    encodeTest := &quot;--------------------------------&quot;
    enc :=base32.NewEncoding(encodeTest)
    src := &quot;this is a test string.&quot;
    dst := enc.EncodeToString([]byte(src))

    // 最后不足8字节的会用&quot;=&quot;补全
    fmt.Println(dst)
    fmt.Println(len(dst))
}
</code></pre>

<p>4）func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</p>

<p>参数列表：</p>

<pre><code>dst  解码缓冲区
src 要解码的字符串切片
</code></pre>

<p>返回值：</p>

<pre><code>n    解码到缓冲区的字节数
err  可能的错误
</code></pre>

<p>功能说明：</p>

<pre><code>对输入的字符串进行base32 解码
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;encoding/base32&quot;
    &quot;log&quot;
    &quot;fmt&quot;
)

func main() {
    src := []byte(&quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;)
    // 解码后数据的最长长度
    maxLen := base32.StdEncoding.DecodedLen(len(src))
    // 解码后的缓存区
    dst := make([]byte, maxLen)
    // base32 解码
    n, err := base32.StdEncoding.Decode(dst, src)
    // 打印解码的数据
    if err != nil {
        log.Fatalln(err)
    }
    fmt.Println(&quot;解码后的数据:&quot;, string(dst[:n]))
}
</code></pre>

<p>5）func (enc *Encoding) DecodeString(s string) ([]byte, error)</p>

<p>参数列表：</p>

<pre><code>s 是要进行 base32 解码的字符串
</code></pre>

<p>返回值：</p>

<pre><code>经过base32解码后的字符串切片
可能的错误
</code></pre>

<p>功能说明：</p>

<pre><code>对传入的字符串进行base32解码
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;encoding/base32&quot;
    &quot;log&quot;
    &quot;fmt&quot;
)

func main() {
    src := &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;
    dst, err := base32.StdEncoding.DecodeString(src)
    if err != nil {
        log.Fatalln(err)
    }
    fmt.Println(&quot;解码后数据:&quot;, string(dst))
}
</code></pre>

<p>6）func (enc *Encoding) DecodedLen(n int) int</p>

<p>参数列表：</p>

<pre><code>n 表示要进行base32 解码的字节数
</code></pre>

<p>返回值：</p>

<pre><code>base32 解码输出需要的最大字节数
</code></pre>

<p>功能说明：</p>

<pre><code>计算 base32 解码输出需要的最大字节数
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;encoding/base32&quot;
    &quot;fmt&quot;
)

func main() {
    src := &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;
    maxLen := base32.StdEncoding.DecodedLen(len(src))
    fmt.Println(&quot;解码后的数据最长为:&quot;, maxLen)
}
</code></pre>

<p>7）func (enc *Encoding) Encode(dst, src []byte)</p>

<p>参数列表：</p>

<pre><code>dst  编码缓冲区
src 要编码的字符串切片
</code></pre>

<p>返回值：</p>

<pre><code>无
</code></pre>

<p>功能说明：</p>

<pre><code>对输入的字符串进行base32编码
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;encoding/base32&quot;
    &quot;fmt&quot;
)

func main() {
    src := []byte(&quot;this is a test string.&quot;)
    maxLen := base32.StdEncoding.EncodedLen(len(src))
    dst := make([]byte, maxLen)
    base32.StdEncoding.Encode(dst, src)
    fmt.Println(&quot;编码后的数据为:&quot;, string(dst))
}
</code></pre>

<p>8）func (enc *Encoding) EncodeToString(src []byte) string</p>

<p>参数列表：</p>

<pre><code>src 要进行 base32 编码的字符串切片
</code></pre>

<p>返回值：</p>

<pre><code>经过base32 编码后的字符串
</code></pre>

<p>功能说明：</p>

<pre><code>对传入的字符串切片进行 base32 编码
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;encoding/base32&quot;
    &quot;fmt&quot;
)

func main() {
    src := []byte(&quot;this is a test string.&quot;)
    dst := base32.StdEncoding.EncodeToString(src)
    fmt.Println(&quot;编码后的数据为:&quot;, dst)
}
</code></pre>

<p>9）func (enc *Encoding) EncodedLen(n int) int</p>

<p>参数列表：</p>

<pre><code>n 要进行 base32 编码的字节数
</code></pre>

<p>返回值：</p>

<pre><code>经过 base32 编码后的字节数
</code></pre>

<p>功能说明：</p>

<pre><code>计算编码输出的字节数
</code></pre>

<p>代码实例：</p>

<pre><code>package main

import (
    &quot;encoding/base32&quot;
    &quot;fmt&quot;
)

func main() {
    src := []byte(&quot;this is a test string.&quot;)
    maxLen := base32.StdEncoding.EncodedLen(len(src))
    fmt.Println(&quot;编码后的数据长度为:&quot;, maxLen)
}
</code></pre>

<p>三、进行编码和解码的几种方式</p>

<p>编码：</p>

<p>1）方法一：base32.StdEncoding.Encode</p>

<p>2）方法二：base32.StdEncoding.EncodeToString</p>

<p>解码：</p>

<p>1）方法一：base32.StdEncoding.Decode</p>

<p>2）方法二：base32.StdEncoding.DecodeString</p>

<p>不管是编码还是解码，方法一和方法二不同之处是传入的是[]byte、还是string。</p>

<h2 id="base64">base64</h2>

<p>使用64个可见字符来表示一个二进制数组，编码后数据大小变成原来的4/3,也即3个字符用4个可见字符来表示。</p>

<p>Go提供了对base64编码和解码的内置支持，直接通过实例来看</p>

<p>实例</p>

<pre><code>package main
// 这种导入包的语法将默认的base64起了一个别名b64，这样
// 我们在下面就可以直接使用b64表示这个包，省点输入量
import b64 &quot;encoding/base64&quot;
import &quot;fmt&quot;
func main() {
    // 这里是我们用来演示编码和解码的字符串
    data := &quot;abc123!?$*&amp;()'-=@~&quot;
    // Go支持标准的和兼容URL的base64编码。
    // 我们这里使用标准的base64编码，这个
    // 函数需要一个`[]byte`参数，所以将这
    // 个字符串转换为字节数组
    sEnc := b64.StdEncoding.EncodeToString([]byte(data))
    fmt.Println(sEnc)
    // 解码一个base64编码可能返回一个错误，
    // 如果你不知道输入是否是正确的base64
    // 编码，你需要检测一些解码错误
    sDec, _ := b64.StdEncoding.DecodeString(sEnc)
    fmt.Println(string(sDec))
    fmt.Println()
    // 使用兼容URL的base64编码和解码
    uEnc := b64.URLEncoding.EncodeToString([]byte(data))
    fmt.Println(uEnc)
    uDec, _ := b64.URLEncoding.DecodeString(uEnc)
    fmt.Println(string(uDec))
}
</code></pre>

<p>运行结果</p>

<pre><code>YWJjMTIzIT8kKiYoKSctPUB+
abc123!?$*&amp;()'-=@~
YWJjMTIzIT8kKiYoKSctPUB-
abc123!?$*&amp;()'-=@~
</code></pre>

<p>函数和base32是一样的。简单说明</p>

<pre><code>type Encoding struct {
    // 内含隐藏或非导出字段
}
</code></pre>

<p>双向的编码/解码协议，根据一个64字符的字符集定义，RFC 4648标准化了两种字符集。默认字符集用于MIME（RFC 2045）和PEM（RFC 1421）编码；另一种用于URL和文件名，用&rsquo;-&lsquo;和&rsquo;_&lsquo;替换了&rsquo;+&lsquo;和&rsquo;/&lsquo;。</p>

<pre><code>func NewEncoding(encoder string) *Encoding
</code></pre>

<p>使用给出的字符集生成一个*Encoding，字符集必须是64字节的字符串。</p>

<pre><code>func (enc *Encoding) DecodedLen(n int) int
</code></pre>

<p>返回n字节base64编码的数据解码后的最大长度。</p>

<pre><code>func (enc *Encoding) Decode(dst, src []byte) (n int, err error)
</code></pre>

<p>将src的数据解码后存入dst，最多写DecodedLen(len(src))字节数据到dst，并返回写入的字节数。 如果src包含非法字符，将返回成功写入的字符数和CorruptInputError。换行符（\r、\n）会被忽略。</p>

<pre><code>func (enc *Encoding) DecodeString(s string) ([]byte, error)
</code></pre>

<p>返回base64编码的字符串s代表的数据。</p>

<pre><code>func (enc *Encoding) EncodedLen(n int) int
</code></pre>

<p>返回n字节数据进行base64编码后的最大长度。</p>

<pre><code>func (enc *Encoding) Encode(dst, src []byte)
</code></pre>

<p>将src的数据编码后存入dst，最多写EncodedLen(len(src))字节数据到dst，并返回写入的字节数。</p>

<p>函数会把输出设置为4的倍数，因此不建议对大数据流的独立数据块执行此方法，使用NewEncoder()代替。</p>

<pre><code>func (enc *Encoding) EncodeToString(src []byte) string
</code></pre>

<p>返回将src编码后的字符串。</p>

<pre><code>func NewDecoder(enc *Encoding, r io.Reader) io.Reader
</code></pre>

<p>创建一个新的base64流解码器。</p>

<pre><code>func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser
</code></pre>

<p>创建一个新的base64流编码器。写入的数据会在编码后再写入w，base32编码每3字节执行一次编码操作；写入完毕后，使用者必须调用Close方法以便将未写入的数据从缓存中刷新到w中。</p>

<h2 id="binary">binary</h2>

<p>binary包实现了简单的数字与字节序列的转换以及变长值的编解码。</p>

<p>read</p>

<pre><code>func Read(r io.Reader, order ByteOrder, data interface{}) error
</code></pre>

<p>从r中读取binary编码的数据并赋给data，data必须是一个指向定长值的指针或者定长值的切片。从r读取的字节使用order指定的字节序解码并写入data的字段里当写入结构体是，名字中有&rsquo;_&lsquo;的字段会被跳过，这些字段可用于填充（内存空间）。</p>

<p>Example</p>

<pre><code>var pi float64
b := []byte{0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40}
buf := bytes.NewReader(b)
err := binary.Read(buf, binary.LittleEndian, &amp;pi)
if err != nil {
    fmt.Println(&quot;binary.Read failed:&quot;, err)
}
fmt.Print(pi)

Output:

3.141592653589793
</code></pre>

<p>write</p>

<pre><code>func Write(w io.Writer, order ByteOrder, data interface{}) error
</code></pre>

<p>将data的binary编码格式写入w，data必须是定长值、定长值的切片、定长值的指针。order指定写入数据的字节序，写入结构体时，名字中有&rsquo;_&lsquo;的字段会置为0。</p>

<p>Example</p>

<pre><code>buf := new(bytes.Buffer)
var pi float64 = math.Pi
err := binary.Write(buf, binary.LittleEndian, pi)
if err != nil {
    fmt.Println(&quot;binary.Write failed:&quot;, err)
}
fmt.Printf(&quot;% x&quot;, buf.Bytes())
Output:

18 2d 44 54 fb 21 09 40
</code></pre>

<p>Example (Multi)</p>

<pre><code>buf := new(bytes.Buffer)
var data = []interface{}{
    uint16(61374),
    int8(-54),
    uint8(254),
}
for _, v := range data {
    err := binary.Write(buf, binary.LittleEndian, v)
    if err != nil {
        fmt.Println(&quot;binary.Write failed:&quot;, err)
    }
}
fmt.Printf(&quot;%x&quot;, buf.Bytes())
Output:

beefcafe
</code></pre>

<h2 id="csv">csv</h2>

<p>逗号分隔值（Comma-Separated Values，CSV），其文件以纯文本形式存储表格数据（数字和文本），文件的每一行都是一个数据记录。每个记录由一个或多个字段组成，用逗号分隔。使用逗号作为字段分隔符是此文件格式的名称的来源，因为分隔字符也可以不是逗号，有时也称为字符分隔值。</p>

<p>CSV是操作数据的常用格式。将CSV文件导入或导出到Excel中亦是很常见的操作。Go的CSV包提供了数据操作接口，因此可以轻松地将数据写入缓冲区，标准输出，文件或socket。本节将展示将数据导入和导出CSV格式的一些常用方法。</p>

<p>函数接口</p>

<p>1.Reader</p>

<pre><code>type Reader struct {
    Comma            rune // 字段分隔符（NewReader将之设为','）
    Comment          rune // 一行开始位置的注释标识符
    FieldsPerRecord  int  // 每条记录期望的字段数
    LazyQuotes       bool // 允许懒引号
    TrailingComma    bool // 忽略，出于后端兼容性而保留
    TrimLeadingSpace bool // 去除前导的空白
    // 内含隐藏或非导出字段
}
</code></pre>

<p>Reader从csv编码的文件中读取记录。</p>

<p>NewReader返回的*Reader期望输入符合RFC 4180。在首次调用Read或者ReadAll之前可以设定导出字段的细节。</p>

<p>Comma是字段分隔符，默认为&rsquo;,&lsquo;。</p>

<p>Comment如果不是0，则表示注释标识符，以Comment开始的行会被忽略。</p>

<p>如果FieldsPerRecord大于0，Read方法要求每条记录都有给定数目的字段。</p>

<p>如果FieldsPerRecord等于0，Read方法会将其设为第一条记录的字段数，因此其余的记录必须有同样数目的字段。
如果FieldsPerRecord小于0，不会检查字段数，允许记录有不同数量的字段。</p>

<p>如果LazyQuotes为真，引号可以出现在非受引字段里，不连续两个的引号可以出现在受引字段里。</p>

<p>如果TrimLeadingSpace为真，字段前导的空白会忽略掉。</p>

<pre><code>func NewReader(r io.Reader) *Reader
</code></pre>

<p>NewReader函数返回一个从r读取的*Reader。</p>

<pre><code>func (r *Reader) Read() (record []string, err error)
</code></pre>

<p>Read从r读取一条记录，返回值record是字符串的切片，每个字符串代表一个字段。</p>

<pre><code>func (r *Reader) ReadAll() (records [][]string, err error)
</code></pre>

<p>ReadAll从r中读取所有剩余的记录，每个记录都是字段的切片，成功的调用返回值err为nil而不是EOF。因为ReadAll方法定义为读取直到文件结尾，因此它不会将文件结尾视为应该报告的错误。</p>

<p>2.Writer</p>

<pre><code>type Writer struct {
    Comma   rune // 字段分隔符（NewWriter将之设为','）
    UseCRLF bool // 如为真，则换行时使用\r\n
    // 内含隐藏或非导出字段
}
</code></pre>

<p>Writer类型的值将记录写入一个csv编码的文件。</p>

<p>NewWriter返回的*Writer写入记录时，以换行结束记录，用&rsquo;,&lsquo;分隔字段。在第一次调用Write或WriteAll之前，可以设置导出字段的细节。</p>

<p>Comma是字段分隔符。如果UseCRLF为真，Writer在每条记录结束时用\r\n代替\n。</p>

<pre><code>func NewWriter(w io.Writer) *Writer
</code></pre>

<p>NewWriter返回一个写入w的*Writer。</p>

<pre><code>func (w *Writer) Write(record []string) (err error)
</code></pre>

<p>向w中写入一条记录，会自行添加必需的引号。记录是字符串切片，每个字符串代表一个字段。</p>

<pre><code>func (w *Writer) WriteAll(records [][]string) (err error)
</code></pre>

<p>WriteAll方法使用Write方法向w写入多条记录，并在最后调用Flush方法清空缓存。</p>

<pre><code>func (w *Writer) Flush()
</code></pre>

<p>将缓存中的数据写入底层的io.Writer。要检查Flush时是否发生错误的话，应调用Error方法。</p>

<pre><code>func (w *Writer) Error() error
</code></pre>

<p>Error返回在之前的Write方法和Flush方法执行时出现的任何错误。</p>

<p>实践</p>

<p>read_csv.go：</p>

<pre><code>package csvformat

import (
    &quot;bytes&quot;
    &quot;encoding/csv&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;strconv&quot;
)

// Movie用来存储CSV解析后的内容
type Movie struct {
    Title    string
    Director string
    Year     int
}

// ReadCSV 展示了如何处理CSV
// 接收的参数通过io.Reader传入
func ReadCSV(b io.Reader) ([]Movie, error) {

    //返回的是csv.Reader
    r := csv.NewReader(b)

    // 分隔符和注释是csv.Reader结构体中的字段
    r.Comma = ';'
    r.Comment = '-'

    var movies []Movie

    // 读取并返回一个字符串切片和错误信息
    // 我们也可以将其用于字典键或其他形式的查找
    // 此处忽略了返回的切片 目的是跳过csv首行标题
    _, err := r.Read()
    if err != nil &amp;&amp; err != io.EOF {
        return nil, err
    }

    // 循环直到全部处理完毕
    for {
        record, err := r.Read()
        if err == io.EOF {
            break
        } else if err != nil {
            return nil, err
        }

        year, err := strconv.ParseInt(record[2], 10, 64)
        if err != nil {
            return nil, err
        }

        m := Movie{record[0], record[1], int(year)}
        movies = append(movies, m)
    }
    return movies, nil
}

// AddMoviesFromText 将字符串按 CSV 格式解析
func AddMoviesFromText() error {

    in := `
    - first our headers
    movie title;director;year released

    - then some data
    Guardians of the Galaxy Vol. 2;James Gunn;2017
    Star Wars: Episode VIII;Rian Johnson;2017
    `

    b := bytes.NewBufferString(in)
    m, err := ReadCSV(b)
    if err != nil {
        return err
    }
    fmt.Printf(&quot;%#v\n&quot;, m)
    return nil
}
</code></pre>

<p>write_csv.go：</p>

<pre><code>package csvformat

import (
    &quot;bytes&quot;
    &quot;encoding/csv&quot;
    &quot;io&quot;
    &quot;os&quot;
)

// 结构体Book有Author和Title两个字段
type Book struct {
    Author string
    Title  string
}

// Books是Book的切片类型
type Books []Book

// ToCSV将Books写入传进来的 io.Writer
// 返回任何可能发生的错误
func (books *Books) ToCSV(w io.Writer) error {
    n := csv.NewWriter(w)
    err := n.Write([]string{&quot;Author&quot;, &quot;Title&quot;})
    if err != nil {
        return err
    }
    for _, book := range *books {
        err := n.Write([]string{book.Author, book.Title})
        if err != nil {
            return err
        }
    }

    n.Flush()
    return n.Error()
}

// WriteCSVOutput 初始化Books并调用ToCSV
// 并写入到标准输出
func WriteCSVOutput() error {
    b := Books{
        Book{
            Author: &quot;F Scott Fitzgerald&quot;,
            Title:  &quot;The Great Gatsby&quot;,
        },
        Book{
            Author: &quot;J D Salinger&quot;,
            Title:  &quot;The Catcher in the Rye&quot;,
        },
    }

    return b.ToCSV(os.Stdout)
}

// WriteCSVBuffer 初始化Books并调用ToCSV
// 并写入到bytes.Buffers
func WriteCSVBuffer() (*bytes.Buffer, error) {
    b := Books{
        Book{
            Author: &quot;F Scott Fitzgerald&quot;,
            Title:  &quot;The Great Gatsby&quot;,
        },
        Book{
            Author: &quot;J D Salinger&quot;,
            Title:  &quot;The Catcher in the Rye&quot;,
        },
    }

    w := &amp;bytes.Buffer{}
    err := b.ToCSV(w)
    return w, err
}
</code></pre>

<p>main.go：</p>

<pre><code>import (
    &quot;fmt&quot;

    &quot;github.com/agtorre/go-cookbook/chapter1/csvformat&quot;
)

func main() {
    if err := csvformat.AddMoviesFromText(); err != nil {
        panic(err)
    }

    if err := csvformat.WriteCSVOutput(); err != nil {
        panic(err)
    }

    buffer, err := csvformat.WriteCSVBuffer()
    if err != nil {
        panic(err)
    }

    fmt.Println(&quot;Buffer = &quot;, buffer.String())
}
</code></pre>

<p>运行main.go，这会输出：</p>

<pre><code>[]csvformat.Movie{csvformat.Movie{Title:&quot;Guardians of the Galaxy Vol. 2&quot;, Director:&quot;James Gunn&quot;, Year:2017}, csvformat.Movie{Title:&quot;Star Wars: Episode VIII&quot;, Director:&quot;Rian Johnson&quot;, Year:2017}}
Author,Title
F Scott Fitzgerald,The Great Gatsby
J D Salinger,The Catcher in the Rye
Buffer =  Author,Title
F Scott Fitzgerald,The Great Gatsby
J D Salinger,The Catcher in the Rye
</code></pre>

<h2 id="gob">gob</h2>

<h2 id="hex">hex</h2>

<h2 id="json">json</h2>

<h2 id="pem">pem</h2>

<p>pem.Block{
        Type:    &ldquo;pem&rdquo;,
        Headers: m,
        Bytes:   []byte(&ldquo;山东核炸朝鲜&rdquo;),
}
结果：</p>

<p>&mdash;&ndash;BEGIN pem&mdash;&ndash;
asd: das</p>

<p>5bGx5Lic5qC454K45pyd6bKc
&mdash;&ndash;END pem&mdash;&ndash;</p>

<h2 id="xml">xml</h2>

<p>正常使用passwd的加密</p>

<pre><code>func EncodePassowrd(passwd string, name string) string {
    str := passwd + name
    h := sha256.New()
    h.Write([]byte(str))
    return hex.EncodeToString(h.Sum(nil))
}
</code></pre>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-encode/">https://kingjcy.github.io/post/golang/go-encode/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/encode/">
                            <i class="fa fa-tags"></i>
                            encode
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li><li id="li-rels"><a href="/post/golang/go-threadsafety/">Go Threadsafety</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月04日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/monitor/prometheus/exporter/blackbox_exporter/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/middleware/network/icmp/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#总结">总结</a>
<ul>
<li><a href="#ascii85">ascii85</a></li>
<li><a href="#asn1">asn1</a></li>
<li><a href="#base32">base32</a></li>
<li><a href="#base64">base64</a></li>
<li><a href="#binary">binary</a></li>
<li><a href="#csv">csv</a></li>
<li><a href="#gob">gob</a></li>
<li><a href="#hex">hex</a></li>
<li><a href="#json">json</a></li>
<li><a href="#pem">pem</a></li>
<li><a href="#xml">xml</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

