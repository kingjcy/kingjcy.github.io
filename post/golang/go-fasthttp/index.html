<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="fasthttp 是 Go 的一款不同于标准库 net/http 的 HTTP 实现。fasthttp 的性能可以达到标准库的 10 倍，说明他魔性的实现方式。主要的点在于四个方面：
1.net/http 的实现是一个连接新建一个 goroutine；fasthttp 是利用一个 worker 复用 goroutine，减轻 runtime 调度 goroutine 的压力 2.net/http 解析的请求数据很多放在 map[string]string(http.Header) 或 map[string][]string(http.Request.Form)，有不必要的 []byte 到 string 的转换，是可以规避的 3.net/http 解析 HTTP 请求每次生成新的 *http.Request 和 http.ResponseWriter; fasthttp 解析 HTTP 数据到 *fasthttp.RequestCtx，然后使用 sync.Pool 复用结构实例，减少对象的数量 4.fasthttp 会延迟解析 HTTP 请求中的数据，尤其是 Body 部分。这样节省了很多不直接操作 Body 的情况的消耗
但是因为 fasthttp 的实现与标准库差距较大，所以 API 的设计完全不同。使用时既需要理解 HTTP 的处理过程，又需要注意和标准库的差别。
package main import ( &quot;fmt&quot; &quot;github.com/valyala/fasthttp&quot; ) // RequestHandler 类型，使用 RequestCtx 传递 HTTP 的数据 func httpHandle(ctx *fasthttp.">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Go Fasthttp - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Go Fasthttp
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年08月27日 
                </div>
                <h1 class="post-title">Go Fasthttp</h1>
            </header>

            <div class="post-content">
                <p>fasthttp 是 Go 的一款不同于标准库 net/http 的 HTTP 实现。fasthttp 的性能可以达到标准库的 10 倍，说明他魔性的实现方式。主要的点在于四个方面：</p>

<p>1.net/http 的实现是一个连接新建一个 goroutine；fasthttp 是利用一个 worker 复用 goroutine，减轻 runtime 调度 goroutine 的压力
2.net/http 解析的请求数据很多放在 map[string]string(http.Header) 或 map[string][]string(http.Request.Form)，有不必要的 []byte 到 string 的转换，是可以规避的
3.net/http 解析 HTTP 请求每次生成新的 *http.Request 和 http.ResponseWriter; fasthttp 解析 HTTP 数据到 *fasthttp.RequestCtx，然后使用 sync.Pool 复用结构实例，减少对象的数量
4.fasthttp 会延迟解析 HTTP 请求中的数据，尤其是 Body 部分。这样节省了很多不直接操作 Body 的情况的消耗</p>

<p>但是因为 fasthttp 的实现与标准库差距较大，所以 API 的设计完全不同。使用时既需要理解 HTTP 的处理过程，又需要注意和标准库的差别。</p>

<pre><code>package main

import (
    &quot;fmt&quot;

    &quot;github.com/valyala/fasthttp&quot;
)

// RequestHandler 类型，使用 RequestCtx 传递 HTTP 的数据
func httpHandle(ctx *fasthttp.RequestCtx) {
    fmt.Fprintf(ctx, &quot;hello fasthttp&quot;) // *RequestCtx 实现了 io.Writer
}

func main() {
    // 一定要写 httpHandle，否则会有 nil pointer 的错误，没有处理 HTTP 数据的函数
    if err := fasthttp.ListenAndServe(&quot;0.0.0.0:12345&quot;, httpHandle); err != nil {
        fmt.Println(&quot;start fasthttp fail:&quot;, err.Error())
    }
}
</code></pre>

<p>路由</p>

<p>net/http 提供 http.ServeMux 实现路由服务，但是匹配规则简陋，功能很简单，基本不会使用。fasthttp 吸取教训，默认没有提供路由支持。因此使用第三方的 fasthttp 的路由库 fasthttprouter 来辅助路由实现：</p>

<pre><code>package main

import (
    &quot;fmt&quot;

    &quot;github.com/buaazp/fasthttprouter&quot;
    &quot;github.com/valyala/fasthttp&quot;
)

// fasthttprouter.RequestCtx.UserValue() 可以获得路由匹配得到的参数，如规则 /hello/:name 中的 :name
func httpHandle(ctx *fasthttp.RequestCtx) {
    fmt.Fprintf(ctx, &quot;hello, %s!\n&quot;, ctx.UserValue(&quot;name&quot;))
}

func main() {
    // 使用 fasthttprouter 创建路由
    router := fasthttprouter.New()
    router.GET(&quot;/hello/:name&quot;, httpHandle)
    if err := fasthttp.ListenAndServe(&quot;0.0.0.0:12345&quot;, router.Handler); err != nil {
        fmt.Println(&quot;start fasthttp fail:&quot;, err.Error())
    }
}
</code></pre>

<p>RequestCtx 操作</p>

<p>*RequestCtx 综合 http.Request 和 http.ResponseWriter 的操作，可以更方便的读取和返回数据。</p>

<p>首先，一个请求的基本数据是必然有的：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    ctx.SetContentType(&quot;text/html&quot;) // 记得添加 Content-Type:text/html，否则都当纯文本返回
    fmt.Fprintf(ctx, &quot;Method:%s &lt;br/&gt;&quot;, ctx.Method())
    fmt.Fprintf(ctx, &quot;URI:%s &lt;br/&gt;&quot;, ctx.URI())
    fmt.Fprintf(ctx, &quot;RemoteAddr:%s &lt;br/&gt;&quot;, ctx.RemoteAddr())
    fmt.Fprintf(ctx, &quot;UserAgent:%s &lt;br/&gt;&quot;, ctx.UserAgent())
    fmt.Fprintf(ctx, &quot;Header.Accept:%s &lt;br/&gt;&quot;, ctx.Request.Header.Peek(&quot;Accept&quot;))
}
</code></pre>

<p>fasthttp 还添加很多更方便的方法读取基本数据，如：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    ctx.SetContentType(&quot;text/html&quot;)
    fmt.Fprintf(ctx, &quot;IP:%s &lt;br/&gt;&quot;, ctx.RemoteIP())
    fmt.Fprintf(ctx, &quot;Host:%s &lt;br/&gt;&quot;, ctx.Host())
    fmt.Fprintf(ctx, &quot;ConnectTime:%s &lt;br/&gt;&quot;, ctx.ConnTime()) // 连接收到处理的时间
    fmt.Fprintf(ctx, &quot;IsGET:%v &lt;br/&gt;&quot;, ctx.IsGet())          // 类似有 IsPOST, IsPUT 等
}
</code></pre>

<p>更详细的 API 可以阅读 godoc.org。</p>

<p>表单数据</p>

<p>RequestCtx 有同标准库的 FormValue() 方法，还对 GET 和 POST/PUT 传递的参数进行了区分:</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    ctx.SetContentType(&quot;text/html&quot;)

    // GET ?abc=abc&amp;abc=123
    getValues := ctx.QueryArgs()
    fmt.Fprintf(ctx, &quot;GET abc=%s &lt;br/&gt;&quot;,
        getValues.Peek(&quot;abc&quot;)) // Peek 只获取第一个值
    fmt.Fprintf(ctx, &quot;GET abc=%s &lt;br/&gt;&quot;,
        bytes.Join(getValues.PeekMulti(&quot;abc&quot;), []byte(&quot;,&quot;))) // PeekMulti 获取所有值

    // POST xyz=xyz&amp;xyz=123
    postValues := ctx.PostArgs()
    fmt.Fprintf(ctx, &quot;POST xyz=%s &lt;br/&gt;&quot;,
        postValues.Peek(&quot;xyz&quot;))
    fmt.Fprintf(ctx, &quot;POST xyz=%s &lt;br/&gt;&quot;,
        bytes.Join(postValues.PeekMulti(&quot;xyz&quot;), []byte(&quot;,&quot;)))
}
</code></pre>

<p>可以看到输出结果：</p>

<pre><code>GET abc=abc 
GET abc=abc,123 
POST xyz=xyz 
POST xyz=xyz,123 
Body 消息体
</code></pre>

<p>fasthttp 提供比标准库丰富的 Body 操作 API，而且支持解析 Gzip 过的数据：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    body := ctx.PostBody() // 获取到的是 []byte
    fmt.Fprintf(ctx, &quot;Body:%s&quot;, body)

    // 因为是 []byte，解析 JSON 很简单
    var v interface{}
    json.Unmarshal(body,&amp;v)
}

func httpHandle2(ctx *fasthttp.RequestCtx) {
    ungzipBody, err := ctx.Request.BodyGunzip()
    if err != nil {
        ctx.SetStatusCode(fasthttp.StatusServiceUnavailable)
        return
    }
    fmt.Fprintf(ctx, &quot;Ungzip Body:%s&quot;, ungzipBody)
}
</code></pre>

<p>上传文件</p>

<p>fasthttp 对文件上传的部分没有做大修改，使用和 net/http 一样：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    // 这里直接获取到 multipart.FileHeader, 需要手动打开文件句柄
    f, err := ctx.FormFile(&quot;file&quot;)
    if err != nil {
        ctx.SetStatusCode(500)
        fmt.Println(&quot;get upload file error:&quot;, err)
        return
    }
    fh, err := f.Open()
    if err != nil {
        fmt.Println(&quot;open upload file error:&quot;, err)
        ctx.SetStatusCode(500)
        return
    }
    defer fh.Close() // 记得要关

    // 打开保存文件句柄
    fp, err := os.OpenFile(&quot;saveto.txt&quot;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
    if err != nil {
        fmt.Println(&quot;open saving file error:&quot;, err)
        ctx.SetStatusCode(500)
        return
    }
    defer fp.Close() // 记得要关

    if _, err = io.Copy(fp, fh); err != nil {
        fmt.Println(&quot;save upload file error:&quot;, err)
        ctx.SetStatusCode(500)
        return
    }
    ctx.Write([]byte(&quot;save file successfully!&quot;))
}
</code></pre>

<p>上面的操作可以对比我写的上一篇文章 Go 开发 HTTP，非常类似。多文件上传同样使用 *RequestCtx.MultipartForm() 获取到整个表单内容，各个文件处理就可以。</p>

<p>返回内容</p>

<p>不像 http.ResponseWriter 那么简单，*RequestCtx 和 *RequestCtx.Response 提供了丰富的 API 为 HTTP 返回数据：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    ctx.WriteString(&quot;hello,fasthttp&quot;)
    // 因为实现不同，fasthttp 的返回内容不是即刻返回的
    // 不同于标准库，添加返回内容后设置状态码，也是有效的
    ctx.SetStatusCode(404)

    // 返回的内容也是可以获取的，不需要标准库的用法，需要自己扩展 http.ResponseWriter
    fmt.Println(string(ctx.Response.Body()))
}
</code></pre>

<p>下载文件也有直接的方法：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    ctx.SendFile(&quot;abc.txt&quot;)
}
</code></pre>

<p>可以阅读 fasthttp.Response 的 API 文档，有很多方法可以简化操作。</p>

<p>RequestCtx 复用引发数据竞争</p>

<p>RequestCtx 在 fasthttp 中使用 sync.Pool 复用。在执行完了 RequestHandler 后当前使用的 RequestCtx 就返回池中等下次使用。如果你的业务逻辑有跨 goroutine 使用 RequestCtx，那可能遇到：同一个 RequestCtx 在 RequestHandler 结束时放回池中，立刻被另一次连接使用；业务 goroutine 还在使用这个 RequestCtx，读取的数据发生变化。</p>

<p>为了解决这种情况，一种方式是给这次请求处理设置 timeout ，保证 RequestCtx 的使用时 RequestHandler 没有结束：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    resCh := make(chan string, 1)
    go func() {
        // 这里使用 ctx 参与到耗时的逻辑中
        time.Sleep(5 * time.Second)
        resCh &lt;- string(ctx.FormValue(&quot;abc&quot;))
    }()

    // RequestHandler 阻塞，等着 ctx 用完或者超时
    select {
    case &lt;-time.After(1 * time.Second):
        ctx.TimeoutError(&quot;timeout&quot;)
    case r := &lt;-resCh:
        ctx.WriteString(&quot;get: abc = &quot; + r)
    }
}
</code></pre>

<p>还提供 fasthttp.TimeoutHandler 帮助封装这类操作。</p>

<p>另一个角度，fasthttp 不推荐复制 RequestCtx。但是根据业务思考，如果只是收到请求数据立即返回，后续处理数据的情况，复制 RequestCtx.Request 是可以的，因此也可以使用：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    var req fasthttp.Request
    ctx.Request.CopyTo(&amp;req)
    go func() {
        time.Sleep(5 * time.Second)
        fmt.Println(&quot;GET abc=&quot; + string(req.URI().QueryArgs().Peek(&quot;abc&quot;)))
    }()
    ctx.WriteString(&quot;hello fasthttp&quot;)
}
</code></pre>

<p>需要注意 RequestCtx.Response 也是可以 Response.CopyTo 复制的。但是如果 RequestHandler 结束，RequestCtx.Response 肯定已发出返回内容。在别的 goroutine 修改复制的 Response，没有作用的。</p>

<p>BytesBuffer</p>

<p>fasthttp 用了很多特殊的优化技巧来提高性能。一些方法也暴露出来可以使用，比如重用的 Bytes：</p>

<pre><code>func httpHandle(ctx *fasthttp.RequestCtx) {
    b := fasthttp.AcquireByteBuffer()
    b.B = append(b.B, &quot;Hello &quot;...)
    // 这里是编码过的 HTML 文本了，&amp;gt;strong 等
    b.B = fasthttp.AppendHTMLEscape(b.B, &quot;&lt;strong&gt;World&lt;/strong&gt;&quot;)
    defer fasthttp.ReleaseByteBuffer(b) // 记得释放

    ctx.Write(b.B)
}
</code></pre>

<p>原理就是简单的把 []byte 作为复用的内容在池中存取。对于非常频繁存取 BytesBuffer 的情况，可能同一个 []byte 不停地被使用 append，而频繁存取导致没有空闲时刻，[]byte 无法得到释放，使用时需要注意一点。</p>

<p>fasthttp 的不足</p>

<p>两个比较大的不足：</p>

<p>HTTP/2.0 不支持
WebSocket 不支持
严格来说 Websocket 通过 Hijack() 是可以支持的，但是 fasthttp 想自己提供直接操作的 API。那还需要等待开发。</p>

<p>总结
比较标准库的粗犷，fasthttp 有更精细的设计，对 Go 网络并发编程的主要痛点做了很多工作，达到了很好的效果。目前，iris 和 echo 支持 fasthttp，性能上和使用 net/http 的别的 Web 框架对比有明显的优势。如果选择 Web 框架，支持 fasthttp 可以看作是一个真好的卖点，值得注意。</p>

            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-fasthttp/">https://kingjcy.github.io/post/golang/go-fasthttp/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags//">
                            <i class="fa fa-tags"></i>
                            
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/go-unsafe/">Go Unsafe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-text/">Go Text</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-plugin/">Go Plugin</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-mine/">Go Mine</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-internal/">Go Internal</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-index/">Go Index</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-image/">Go Image</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-html/">Go Html</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-hash/">Go Hash</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-go/">Go Go</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/computerbase/computer/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/middleware/serverdiscovery/grpc-sd/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

