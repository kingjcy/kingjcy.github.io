<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="最近工作需要，对 WebSocket 进行了一点研究， WebSocket 协议、WebSocket 的 Go 语言实现，以及 socket.io 服务端库的 Go 语言实现的理解。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Go Websocket - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Go Websocket
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年03月01日 
                </div>
                <h1 class="post-title">Go Websocket</h1>
            </header>

            <div class="post-content">
                <p>最近工作需要，对 WebSocket 进行了一点研究， WebSocket 协议、WebSocket 的 Go 语言实现，以及 socket.io 服务端库的 Go 语言实现的理解。</p>

<h2 id="websocket-简介">WebSocket 简介</h2>

<p>WebSocket 旨在实现 Web 应用（例如 IM、游戏等）里和 Server 的双向通信（两端称为 peer），以替代 HTTP 轮询等方案。</p>

<p>WebSocket 协议包括两部分：握手，数据传输。它基于 TCP 的字节流传输机制，提供了 frame 的传输机制。</p>

<p>WebSocket 是基于 TCP 的协议，它和 HTTP 的关系仅仅是其握手可以被 HTTP 服务器理解为 Upgrade 请求。</p>

<h3 id="为什么会出现websocket">为什么会出现WebSocket？</h3>

<p>我们知道HTTP协议（底层使用的是TCP协议）是无状态的，即一次Request，一个Response就结束了。实际中的场景就是客户端（比如浏览器）向服务器发送一次请求，然后服务器返回一个响应，一次交互就结束了，底层的TCP连接也会断掉，下次请求时，重新再创建新的连接。而且这种通信是被动式的，就是说服务器端不能主动向客户端发响应，只能是客户端一个Request，服务的一个Response这种模式（当然最新的协议里面，可能可以将多个Request合并一次发给服务端，但模型仍旧是这种模式）。</p>

<p>如果你曾经使用TCP协议写过通信程序，应该非常熟悉那种模式：客户端和服务端（有时都没有清晰的界限）通过三步握手建立连接后，就可以相互随便发送数据，除非网络异常或者主动关闭，否则该TCP连接将一直存在。而WebSocket的出现就是为了在应用层实现类似传输层的TCP协议，当然它底层和HTTP一样使用的是TCP协议。这样我们就明白一些了，WebSocket不像HTTP协议，一次交互后就结束，它建立后会一直存在（除非主动断开或者网络异常等），而且客户端和服务端可以任意向对方发送数据，不再像以前那么“傻”了。也就是说，HTTP协议是一次性的，“单工的”；而WebSocket是真正意义上的长连接，且是全双工的。当然，上述提及的需求HTTP通过poll和轮循等方式也可以实现，但弊端非常多：</p>

<pre><code>服务器端需要在底层为每个HTTP连接维护一个TCP连接，比如一个用于发送消息，一个用于接收消息等。
资源浪费，每次的HTTP请求中都需要携带消息头。
客户端还必须通过一些手段知道哪些响应对应发出去的哪些请求。
</code></pre>

<p>好吧，这就是为什么出现了WebSocket。</p>

<h2 id="建立连接的握手">建立连接的握手</h2>

<p>握手的请求与响应和 HTTP 1.1 格式相同，这是为了让 HTTP 协议的服务器程序和 WebSocket 协议的服务器程序可以挂在同一个 Web 服务器后面。</p>

<p>客户端请求：</p>

<pre><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</code></pre>

<p>服务端响应：</p>

<pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
</code></pre>

<p>客户端握手请求实际上是一个 HTTP Upgrade 请求。Upgrade 和 Connection 字段表明这是 WebSocket Upgrade 请求和响应。</p>

<p>Sec-WebSocket-Key 是客户端随机提供的字符串的 base64 编码结果，服务端收到后，将（编码结果）值与一个特殊的 GUID 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接，然后求拼接结果字符串的 SHA-1，最后将 SHA-1 二进制结果做 base64 编码，作为 Sec-WebSocket-Accept 字段返回。客户端会对其进行校验。</p>

<p>101 状态码表明服务器接受了 Upgrade，其他状态码都表明 Upgrade 失败。</p>

<p>客户端提供的 Sec-WebSocket-Protocol 字段表明了客户端支持的一系列子协议，服务端可以选择其中一个返回。</p>

<h2 id="关闭连接的握手">关闭连接的握手</h2>

<p>任一端都可以发送一个「开始关闭」的控制帧，另一端收到后，如果未发送过「关闭」帧则发送之，发起端收到后，就可以关闭连接了。</p>

<p>peer 发送了「开始关闭」帧后，就不再发送数据，peer 收到「开始关闭」帧后，会丢弃之后收到的数据。</p>

<p>这个关闭连接的握手，是对 TCP 四次握手的补充。</p>

<h1 id="数据传输">数据传输</h1>

<p>握手成功后，数据被封装为 message 在连接内传输。message 由 frame 构成，这两个概念和底层协议的封包没有关系。</p>

<p>WebSocket 的 frame 采取的是 header + payload 的结构，header 里有 length 字段以分隔 frame。</p>

<p>客户端发送的数据必须应用掩码，服务端发送的数据一定不能应用掩码。</p>

<h2 id="websocket的数据">websocket的数据</h2>

<p>WebSocket的协议颇为简单，在第一次handshake通过以后，连接便建立成功，其后的通讯数据都是以”\x00′′开头，
以”\xFF”结尾。在客户端，这个是透明的，WebSocket组件会自动将原始数据“掐头去尾”。</p>

<h2 id="websocket-go实现">WebSocket Go实现</h2>

<p>官方并没有实现标准库支持，可以使用一些第三方库来实现</p>

<p>1.go get code.google.com/p/go.net/websocket</p>

<p>2.gorilla/websocket 这个 Go 语言的 WebSocket 协议实现的源码。我们可以直接使用gorilla/websocket包</p>

<p>server</p>

<p>server有两个作用，第一是监听请求并发送我们的html文件，第二是监听用户输入内容并加以答复。</p>

<pre><code>package main

import (
  &quot;log&quot;
  &quot;net/http&quot;
  &quot;github.com/gorilla/websocket&quot;
)
var upgrader = websocket.Upgrader{}
</code></pre>

<p>我们需要一个Conn类型来表示我们的websocket连接。在客户端，我们需要用一个upgrader对象调用Upgrade函数来获得这个连接的指针。所以，我们首先需要创建这个Upgrader。</p>

<pre><code>func main() {
    http.HandleFunc(&quot;/echo&quot;, echo)
    http.HandleFunc(&quot;/&quot;, home)
    log.Fatal(http.ListenAndServe(&quot;localhost:8080&quot;, nil))
}
</code></pre>

<p>在主函数中，我们设定了两个路由，一个是用于send我们的客户端html文件的，一个是用来监听用户输入内容的。最后，我们监听了本地的8080端口。</p>

<pre><code>func home(w http.ResponseWriter, r *http.Request) {
  http.ServeFile(w, r, &quot;home.html&quot;)
}
</code></pre>

<p>home函数用于发送客户端html文件。</p>

<pre><code>func echo( w http.ResponseWriter, r *http.Request){
        c, _ := upgrader.Upgrade(w, r, nil)
    defer c.Close()
    for {
        mt, message, _ := c.ReadMessage()
            c.WriteMessage(mt, append([]byte(&quot;hello &quot;),message[:]...))
    }
}
</code></pre>

<p>echo函数负责处理我们的websocket连接。首先，我们调用upgrader.Upgrade(w, r, nil)获得这个连接的指针。然后，我们进入一个循环，不停的读取连接中传来的信息，当有信息传来时，对信息处理后返回给客户端。这里有一点要注意，就是c.ReadMessage()是阻塞的，，也就是说，当有消息来时，它后面的代码才会被执行。</p>

<p>客户端</p>

<pre><code>ws = new WebSocket(&quot;ws://127.0.0.1:8080/echo&quot;);
ws.onopen = function(evt) {...}
ws.onmessage = function(evt) {...}            
ws.onerror = function(evt) {...}
document.getElementById(&quot;send&quot;).onclick = function(evt) {
    if (!ws) {return false;}
    ws.send(input.value);
    return;
};
</code></pre>

<p>客户端（前端代码）很简单，这里我只写一个框架。首先，用new WebSocket(&hellip;)建立一个连接，并为这个连接绑定几个函数，这里我们可以设定onopen(建立连接)，onmessage(收到服务端消息),onerror(发生错误)。然后，我们可以给我们的send按钮绑定单击事件，单击后发送数据到后台。</p>

<h3 id="聊天实例">聊天实例</h3>

<p>server.go</p>

<pre><code>package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;

    &quot;github.com/gorilla/websocket&quot;
    &quot;github.com/satori/go.uuid&quot;
)

type ClientManager struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    id     string
    socket *websocket.Conn
    send   chan []byte
}

type Message struct {
    Sender    string `json:&quot;sender,omitempty&quot;`
    Recipient string `json:&quot;recipient,omitempty&quot;`
    Content   string `json:&quot;content,omitempty&quot;`
}

var manager = ClientManager{
    broadcast:  make(chan []byte),
    register:   make(chan *Client),
    unregister: make(chan *Client),
    clients:    make(map[*Client]bool),
}

func (manager *ClientManager) start() {
    for {
        select {
        case conn := &lt;-manager.register:
            manager.clients[conn] = true
            jsonMessage, _ := json.Marshal(&amp;Message{Content: &quot;/A new socket has connected.&quot;})
            manager.send(jsonMessage, conn)
        case conn := &lt;-manager.unregister:
            if _, ok := manager.clients[conn]; ok {
                close(conn.send)
                delete(manager.clients, conn)
                jsonMessage, _ := json.Marshal(&amp;Message{Content: &quot;/A socket has disconnected.&quot;})
                manager.send(jsonMessage, conn)
            }
        case message := &lt;-manager.broadcast:
            for conn := range manager.clients {
                select {
                case conn.send &lt;- message:
                default:
                    close(conn.send)
                    delete(manager.clients, conn)
                }
            }
        }
    }
}

func (manager *ClientManager) send(message []byte, ignore *Client) {
    for conn := range manager.clients {
        if conn != ignore {
            conn.send &lt;- message
        }
    }
}

func (c *Client) read() {
    defer func() {
        manager.unregister &lt;- c
        c.socket.Close()
    }()

    for {
        _, message, err := c.socket.ReadMessage()
        if err != nil {
            manager.unregister &lt;- c
            c.socket.Close()
            break
        }
        jsonMessage, _ := json.Marshal(&amp;Message{Sender: c.id, Content: string(message)})
        manager.broadcast &lt;- jsonMessage
    }
}

func (c *Client) write() {
    defer func() {
        c.socket.Close()
    }()

    for {
        select {
        case message, ok := &lt;-c.send:
            if !ok {
                c.socket.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }

            c.socket.WriteMessage(websocket.TextMessage, message)
        }
    }
}

func main() {
    fmt.Println(&quot;Starting application...&quot;)
    go manager.start()
    http.HandleFunc(&quot;/ws&quot;, wsPage)
    http.ListenAndServe(&quot;:12345&quot;, nil)
}

func wsPage(res http.ResponseWriter, req *http.Request) {
    conn, error := (&amp;websocket.Upgrader{CheckOrigin: func(r *http.Request) bool { return true }}).Upgrade(res, req, nil)
    if error != nil {
        http.NotFound(res, req)
        return
    }
    client := &amp;Client{id: uuid.NewV4().String(), socket: conn, send: make(chan []byte)}

    manager.register &lt;- client

    go client.read()
    go client.write()
}
</code></pre>

<p>Go Client</p>

<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;net/url&quot;
    &quot;time&quot;

    &quot;github.com/gorilla/websocket&quot;
)

var addr = flag.String(&quot;addr&quot;, &quot;localhost:12345&quot;, &quot;http service address&quot;)

func main() {
    u := url.URL{Scheme: &quot;ws&quot;, Host: *addr, Path: &quot;/ws&quot;}
    var dialer *websocket.Dialer

    conn, _, err := dialer.Dial(u.String(), nil)
    if err != nil {
        fmt.Println(err)
        return
    }

    go timeWriter(conn)

    for {
        _, message, err := conn.ReadMessage()
        if err != nil {
            fmt.Println(&quot;read:&quot;, err)
            return
        }

        fmt.Printf(&quot;received: %s\n&quot;, message)
    }
}

func timeWriter(conn *websocket.Conn) {
    for {
        time.Sleep(time.Second * 2)
        conn.WriteMessage(websocket.TextMessage, []byte(time.Now().Format(&quot;2006-01-02 15:04:05&quot;)))
    }
</code></pre>

<hr />
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-websocket/">https://kingjcy.github.io/post/golang/go-websocket/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/websocket/">
                            <i class="fa fa-tags"></i>
                            websocket
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/golang/go-threadsafety/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/tool/pressure_test/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#websocket-简介">WebSocket 简介</a>
<ul>
<li><a href="#为什么会出现websocket">为什么会出现WebSocket？</a></li>
</ul></li>
<li><a href="#建立连接的握手">建立连接的握手</a></li>
<li><a href="#关闭连接的握手">关闭连接的握手</a></li>
</ul></li>
<li><a href="#数据传输">数据传输</a>
<ul>
<li><a href="#websocket的数据">websocket的数据</a></li>
<li><a href="#websocket-go实现">WebSocket Go实现</a>
<ul>
<li><a href="#聊天实例">聊天实例</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

