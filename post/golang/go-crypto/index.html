<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Golang的加密库都放在crypto目录下。在crypto这个文件中搜集了常用的密码（算法）常量。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="golang使用系列---- Crypto - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    golang使用系列---- Crypto
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年06月06日 
                </div>
                <h1 class="post-title">golang使用系列---- Crypto</h1>
            </header>

            <div class="post-content">
                <p>Golang的加密库都放在crypto目录下。在crypto这个文件中搜集了常用的密码（算法）常量。</p>

<h1 id="加密方法总结">加密方法总结</h1>

<p>1.aes</p>

<p>按照美国的定义，aes实现AES加密（以前称为Rijndael）</p>

<p>2.cipher</p>

<p>包密码实现了标准块密码模式，可以围绕低级块密码实现。</p>

<p>3.des</p>

<p>Package des实现了美国定义的数据加密标准（DES）和三重数据加密算法（TDEA）</p>

<p>4.dsa</p>

<p>软件包dsa实现了FIPS 186-3中定义的数字签名算法。</p>

<p>5.ecdsa</p>

<p>软件包ecdsa实现了FIPS 186-3中定义的椭圆曲线数字签名算法。</p>

<p>6.elliptic</p>

<p>椭圆包椭圆实现了在素数域上的几个标准椭圆曲线。</p>

<p>7.hmac</p>

<p>包hmac实现美国定义的Keyed-Hash消息认证码（HMAC）</p>

<p>8.internal/cipherhw</p>

<p>包cipherhw公开了用于检测是否存在对某些密码和认证器的硬件支持的常用功能。</p>

<p>9.md5</p>

<p>包md5实现了RFC 1321中定义的MD5哈希算法。</p>

<p>10.rand</p>

<p>Package rand实现了一个密码安全的伪随机数生成器。</p>

<p>11.rc4</p>

<p>软件包rc4实现了RC4加密，如Bruce Schneier的应用密码术中所定义。</p>

<p>12.rsa</p>

<p>软件包rsa按照PKCS＃1中的规定实现RSA加密。</p>

<p>13.sha1</p>

<p>包sha1实现了RFC 3174中定义的SHA-1哈希算法。</p>

<p>14.sha256</p>

<p>软件包sha256实现FIPS 180-4中定义的SHA224和SHA256哈希算法。</p>

<p>15.sha512</p>

<p>软件包sha512实现FIPS 180-4中定义的SHA-384，SHA-512，SHA-512/224和SHA-512/256哈希算法。</p>

<p>16.subtle</p>

<p>包微妙地实现了在密码学中经常使用的功能，但需要仔细考虑才能正确使用。</p>

<p>17.tls</p>

<p>按照RFC 5246的规定，软件包部分实现了TLS 1.2。</p>

<p>18.x509</p>

<p>软件包x509分析X.509编码的密钥和证书。</p>

<p>19.x509/pkix</p>

<p>包pkix包含用于ASN.1解析和序列化X.509证书，CRL和OCSP的共享低级别结构。</p>

<h1 id="主要使用">主要使用</h1>

<p>当前我们项目中常用的加解密的方式无非三种.</p>

<pre><code>对称加密, 加解密都使用的是同一个密钥, 其中的代表就是AES、DES
非对加解密, 加解密使用不同的密钥, 其中的代表就是RSA
签名算法, 如MD5、SHA1、HMAC等, 主要用于验证，防止信息被修改, 如：文件校验、数字签名、鉴权协议
</code></pre>

<p>Base64不是加密算法，它是一种数据编码方式，虽然是可逆的，但是它的编码方式是公开的。虽然属于encoding，这边也先会简单说明一下。</p>

<p>下面会对所有涉及到的加密方法都进行讲解，但是一般我们常用的就base64，md5，更加专业的也就是AES等，当然tls也是常用的。</p>

<h2 id="aes">aes</h2>

<p>密码学中的高级加密标准（Advanced Encryption Standard，AES)(对称加密算法)，又称Rijndael加密法，这个标准用来替代原先的DES。AES加密数据块分组长度必须为128bit，密钥长度可以是128bit、192bit、256bit中的任意一个。</p>

<p>AES，即高级加密标准（Advanced Encryption Standard），是一个对称分组密码算法，旨在取代DES成为广泛使用的标准。AES中常见的有三种解决方案，分别为AES-128、AES-192和AES-256。</p>

<p>AES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。</p>

<p>AES 有五种加密模式：电码本模式（Electronic Codebook Book (ECB)）、密码分组链接模式（Cipher Block Chaining (CBC)）、计算器模式（Counter (CTR)）、密码反馈模式（Cipher FeedBack (CFB)）和输出反馈模式（Output FeedBack (OFB)）</p>

<p>示例代码</p>

<pre><code>package main

import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;crypto/rand&quot;
    &quot;encoding/hex&quot;
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;sync&quot;
)

func main() {
    se, err := AesEncrypt(&quot;aes-20170416-30-1000&quot;)
    fmt.Println(se, err)
    sd, err := AesDecrypt(se)
    fmt.Println(sd, err)
}

var (
    commonkey = []byte(&quot;nanjishidu170416&quot;)
    syncMutex sync.Mutex
)

func SetAesKey(key string) {
    syncMutex.Lock()
    defer syncMutex.Unlock()
    commonkey = []byte(key)
}
func AesEncrypt(plaintext string) (string, error) {
    block, err := aes.NewCipher(commonkey)
    if err != nil {
        return &quot;&quot;, err
    }
    ciphertext := make([]byte, aes.BlockSize+len(plaintext))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        return &quot;&quot;, err
    }
    cipher.NewCFBEncrypter(block, iv).XORKeyStream(ciphertext[aes.BlockSize:],
        []byte(plaintext))
    return hex.EncodeToString(ciphertext), nil

}
func AesDecrypt(d string) (string, error) {
    ciphertext, err := hex.DecodeString(d)
    if err != nil {
        return &quot;&quot;, err
    }
    block, err := aes.NewCipher(commonkey)
    if err != nil {
        return &quot;&quot;, err
    }
    if len(ciphertext) &lt; aes.BlockSize {
        return &quot;&quot;, errors.New(&quot;ciphertext too short&quot;)
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]
    fmt.Println(len(ciphertext), len(iv))
    cipher.NewCFBDecrypter(block, iv).XORKeyStream(ciphertext, ciphertext)
    return string(ciphertext), nil
}
</code></pre>

<p>实例2</p>

<pre><code>import (
    &quot;bytes&quot;
    &quot;crypto/aes&quot;
    &quot;fmt&quot;
    &quot;crypto/cipher&quot;
    &quot;encoding/base64&quot;
)

func main() {
    orig := &quot;hello world&quot;
    key := &quot;123456781234567812345678&quot;
    fmt.Println(&quot;原文：&quot;, orig)

    encryptCode := AesEncrypt(orig, key)
    fmt.Println(&quot;密文：&quot; , encryptCode)

    decryptCode := AesDecrypt(encryptCode, key)
    fmt.Println(&quot;解密结果：&quot;, decryptCode)
}

func AesEncrypt(orig string, key string) string {
    // 转成字节数组
    origData := []byte(orig)
    k := []byte(key)

    // 分组秘钥
    block, _ := aes.NewCipher(k)
    // 获取秘钥块的长度
    blockSize := block.BlockSize()
    // 补全码
    origData = PKCS7Padding(origData, blockSize)
    // 加密模式
    blockMode := cipher.NewCBCEncrypter(block, k[:blockSize])
    // 创建数组
    cryted := make([]byte, len(origData))
    // 加密
    blockMode.CryptBlocks(cryted, origData)

    return base64.StdEncoding.EncodeToString(cryted)

}

func AesDecrypt(cryted string, key string) string {
    // 转成字节数组
    crytedByte, _ := base64.StdEncoding.DecodeString(cryted)
    k := []byte(key)

    // 分组秘钥
    block, _ := aes.NewCipher(k)
    // 获取秘钥块的长度
    blockSize := block.BlockSize()
    // 加密模式
    blockMode := cipher.NewCBCDecrypter(block, k[:blockSize])
    // 创建数组
    orig := make([]byte, len(crytedByte))
    // 解密
    blockMode.CryptBlocks(orig, crytedByte)
    // 去补全码
    orig = PKCS7UnPadding(orig)
    return string(orig)
}

//补码
func PKCS7Padding(ciphertext []byte, blocksize int) []byte {
    padding := blocksize - len(ciphertext)%blocksize
    padtext := bytes.Repeat([]byte{byte(padding)}, padding)
    return append(ciphertext, padtext...)
}

//去码
func PKCS7UnPadding(origData []byte) []byte {
    length := len(origData)
    unpadding := int(origData[length-1])
    return origData[:(length - unpadding)]
}
</code></pre>

<h2 id="cipher">cipher</h2>

<p>加密包（Package cipher）实现了标准块密码模式，可以围绕低级块密码实现。</p>

<p>1.AEAD</p>

<p>AEAD是一种密码模式，提供带有关联数据的认证加密。有关该方法的说明，请参阅</p>

<pre><code>type AEAD interface {
    // NonceSize返回必须传递给Seal的随机数的大小
    // and Open.
    NonceSize() int

    // Overhead返回以下两者间的最大差异
    // plaintext 和 its ciphertext.
    Overhead() int

    // 密封加密和验证明文，验证
    // 附加数据并将结果附加到dst，并返回更新
    // slice。 nonce必须是NonceSize()字节长且对所有人都是唯一的
    // time, 对于给定的密钥。
    //
    // 明文和dst可能完全或根本不是别名。 重用
    // 明文的加密输出存储，使用 plaintext[:0]作为dst。
    Seal(dst, nonce, plaintext, additionalData []byte) []byte

    // 打开解密并验证密文，验证密文
    // 额外的数据，如果成功的话，附加结果明文
    // 到dst，返回更新的片。 nonce必须是NonceSize()
    // 字节长，它和附加数据必须匹配
    // 值传递给Seal。
    //
    // 密文和dst可以完全混淆或根本不混淆。 重用
    // 密文的解密输出存储，使用ciphertext [:0]作为dst。
    //
    // 即使该功能失败，dst的内容，直到其容量，
    // 可能会被覆盖。
    Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error)
}
</code></pre>

<p>新建AEAD上网的方法</p>

<pre><code>func NewGCM(cipher Block) (AEAD, error)
</code></pre>

<p>NewGCM 返回给定的128-bit，以伽罗华计数器模式(Galois Counter Mode包装的分组密码，其标准随机数长度。</p>

<p>一般来说，这种 GCM 实施的 GHASH 操作不是一个固定时间。当硬件支持 AES 的系统上由 aes.NewCipher 创建底层 Block 时，则是个例外。有关详细信息，请参阅 crypto/aes 软件包文档。</p>

<p>示例（Decrypt）</p>

<pre><code>package main

import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;encoding/hex&quot;
    &quot;fmt&quot;
)

func main() {
    // 关键参数应该是AES密钥，16或32个字节
    // 选择 AES-128 或 AES-256。
    key := []byte(&quot;AES256Key-32Characters1234567890&quot;)
    ciphertext, _ := hex.DecodeString(&quot;1019aa66cd7c024f9efd0038899dae1973ee69427f5a6579eba292ffe1b5a260&quot;)

    nonce, _ := hex.DecodeString(&quot;37b8e8a308c354048d245f6d&quot;)

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err.Error())
    }

    aesgcm, err := cipher.NewGCM(block)
    if err != nil {
        panic(err.Error())
    }

    plaintext, err := aesgcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        panic(err.Error())
    }

    fmt.Printf(&quot;%s\n&quot;, plaintext)
}
</code></pre>

<p>示例（Encrypt）</p>

<pre><code>package main

import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;crypto/rand&quot;
    &quot;fmt&quot;
    &quot;io&quot;
)

func main() {
    // 关键参数应该是AES密钥，16或32个字节
    // 选择AES-128或AES-256。
    key := []byte(&quot;AES256Key-32Characters1234567890&quot;)
    plaintext := []byte(&quot;exampleplaintext&quot;)

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err.Error())
    }

    // 由于存在重复的风险，请勿使用给定密钥使用超过2^32个随机值。
    nonce := make([]byte, 12)
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        panic(err.Error())
    }

    aesgcm, err := cipher.NewGCM(block)
    if err != nil {
        panic(err.Error())
    }

    ciphertext := aesgcm.Seal(nil, nonce, plaintext, nil)
    fmt.Printf(&quot;%x\n&quot;, ciphertext)
}


func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)
</code></pre>

<p>NewGCMWithNonceSize 返回给定的 128 位，以 Galois 计数器模式包装的分组密码，它接受给定长度的随机数。</p>

<p>如果您需要与使用非标准随机数长度的现有密码系统兼容，请仅使用此功能。所有其他用户都应该使用 NewGCM，它更快，更耐滥用。</p>

<p>2.Block</p>

<p>块表示使用给定密钥的分组密码的实现。它提供了加密或解密各个块的功能。模式实现将该能力扩展到块流。</p>

<pre><code>type Block interface {
        // BlockSize返回密码的块大小。
        BlockSize() int

        // 加密将src中的第一个块加密到dst中。
        // Dst和src可能指向相同的内存。
        Encrypt(dst, src []byte)

        // 解密将src中的第一个块解密为dst。
        // Dst和src可能指向相同的内存。
        Decrypt(dst, src []byte)
}
</code></pre>

<p>BlockMode表示以基于块的模式运行的分组密码（CBC，ECB等）。</p>

<pre><code>type BlockMode interface {
        // BlockSize返回模式的块大小。
        BlockSize() int

        // CryptBlocks加密或解密一些块。 The length of
        // src必须是块大小的倍数。 Dst和src可能指向
        // 相同的内存。
        CryptBlocks(dst, src []byte)
}
</code></pre>

<p>新建black的方法</p>

<pre><code>func NewCBCDecrypter(b Block, iv []byte) BlockMode
</code></pre>

<p>NewCB​​CDecrypter 返回一个 BlockMode，它使用给定的Block 以密码块链接模式解密。iv 的长度必须与 Block 的块大小相同，并且必须与用于加密数据的 iv 相匹配。</p>

<p>示例</p>

<pre><code>package main

import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;encoding/hex&quot;
    &quot;fmt&quot;
)

func main() {
    key := []byte(&quot;example key 1234&quot;)
    ciphertext, _ := hex.DecodeString(&quot;f363f3ccdcb12bb883abf484ba77d9cd7d32b5baecb3d4b1b3e0e4beffdb3ded&quot;)

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // IV需要独特，但不安全。 所以这很常见
    // 将其包括在密文的开头。
    if len(ciphertext) &lt; aes.BlockSize {
        panic(&quot;ciphertext too short&quot;)
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]

    // CBC模式总是在整个模块中工作。
    if len(ciphertext)%aes.BlockSize != 0 {
        panic(&quot;ciphertext is not a multiple of the block size&quot;)
    }

    mode := cipher.NewCBCDecrypter(block, iv)

    // 如果两个参数相同，CryptBlocks可以在原地工作。
    mode.CryptBlocks(ciphertext, ciphertext)

    // 如果原始plaintext长度不是块的倍数
    // 大小，填充将不得不在加密时添加，这将是
    // 在这一点删除。 有关示例，请参阅
    // https://tools.ietf.org/html/rfc5246#section-6.2.3.2. 然而，
    // 至关重要的是要注意密文必须被认证（即通过
    // 使用crypto/hmac）解密之前，以避免创建
    // 一个填充oracle。

    fmt.Printf(&quot;%s\n&quot;, ciphertext)
}


func NewCBCEncrypter(b Block, iv []byte) BlockMode
</code></pre>

<p>NewCB​​CEncrypter 返回一个 BlockMode，它使用给定的 Block 以密码块链接模式加密。iv 的长度必须与块的块大小相同。</p>

<p>示例</p>

<pre><code>package main

import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;crypto/rand&quot;
    &quot;fmt&quot;
    &quot;io&quot;
)

func main() {
    key := []byte(&quot;example key 1234&quot;)
    plaintext := []byte(&quot;exampleplaintext&quot;)

    // CBC模式在块上工作，所以明文可能需要填充到块
    // 下一个整块。 有关这种填充的示例，请参阅
    // https://tools.ietf.org/html/rfc5246#section-6.2.3.2. 这里，我们将
    // 假定 plaintext 已经是正确的长度。
    if len(plaintext)%aes.BlockSize != 0 {
        panic(&quot;plaintext is not a multiple of the block size&quot;)
    }

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // IV需要独特，但不安全。 所以这很常见
    // 将其包括在密文的开头。
    ciphertext := make([]byte, aes.BlockSize+len(plaintext))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        panic(err)
    }

    mode := cipher.NewCBCEncrypter(block, iv)
    mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)

    // 记住密文必须经过认证是很重要的
    // （即通过使用crypto/hmac）以及为了加密而被加密
    // 保持secure。

    fmt.Printf(&quot;%x\n&quot;, ciphertext)
}
</code></pre>

<p>3.Stream</p>

<p>Stream表示流密码。</p>

<pre><code>type Stream interface {
        // XORKeyStream将给定片中的每个字节与来自该字节的一个字节异或
        // 密码的密钥流。 Dst和src可能指向相同的内存。
        // 如果len（dst）&lt;len（src），XORKeyStream应该是恐慌的。 它是可以接受的
        // 传递比src更大的dst，在那种情况下，XORKeyStream会
        // 只更新dst[:len(src)]并且不会触及dst的其余部分。
        XORKeyStream(dst, src []byte)
}
</code></pre>

<p>新建stream的方法</p>

<pre><code>func NewCFBDecrypter(block Block, iv []byte) Stream
</code></pre>

<p>新的 CFB 解密器使用给定的块返回一个使用密码反馈模式解密的 Stream。iv 的长度必须与块的块大小相同。</p>

<p>示例
    package main</p>

<pre><code>import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;encoding/hex&quot;
    &quot;fmt&quot;
)

func main() {
    key := []byte(&quot;example key 1234&quot;)
    ciphertext, _ := hex.DecodeString(&quot;22277966616d9bc47177bd02603d08c9a67d5380d0fe8cf3b44438dff7b9&quot;)

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // IV需要独特，但不安全。 所以这很常见
    // 将其包括在密文的开头。
    if len(ciphertext) &lt; aes.BlockSize {
        panic(&quot;ciphertext too short&quot;)
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]

    stream := cipher.NewCFBDecrypter(block, iv)

    // 如果两个参数相同，XORKeyStream可以在原地工作。
    stream.XORKeyStream(ciphertext, ciphertext)
    fmt.Printf(&quot;%s&quot;, ciphertext)
}


func NewCFBEncrypter(block Block, iv []byte) Stream
</code></pre>

<p>NewCFBEncrypter 使用给定的 Block 返回一个使用密码反馈模式加密的 Stream。iv 的长度必须与块的块大小相同。</p>

<p>示例</p>

<pre><code>package main

import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;crypto/rand&quot;
    &quot;io&quot;
)

func main() {
    key := []byte(&quot;example key 1234&quot;)
    plaintext := []byte(&quot;some plaintext&quot;)

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // IV需要独特，但不安全。 所以这很常见
    // 将其包括在密文的开头。
    ciphertext := make([]byte, aes.BlockSize+len(plaintext))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        panic(err)
    }

    stream := cipher.NewCFBEncrypter(block, iv)
    stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)

    // 记住密文必须经过认证是很重要的
    // （即通过使用crypto/hmac）以及为了加密而被加密
    // 保持secure。
}


func NewCTR(block Block, iv []byte) Stream
</code></pre>

<p>NewCTR 返回一个 Stream，它使用计数器模式下的给定 Block加密/解密。iv 的长度必须与块的块大小相同。</p>

<p>示例
    package main</p>

<pre><code>import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;crypto/rand&quot;
    &quot;fmt&quot;
    &quot;io&quot;
)

func main() {
    key := []byte(&quot;example key 1234&quot;)
    plaintext := []byte(&quot;some plaintext&quot;)

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // IV需要独特，但不安全。 所以这很常见
    // 将其包括在密文的开头。
    ciphertext := make([]byte, aes.BlockSize+len(plaintext))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        panic(err)
    }

    stream := cipher.NewCTR(block, iv)
    stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)

    // 记住密文必须经过认证是很重要的
    // （即通过使用crypto/hmac）以及为了加密而被加密
    // 保持secure。

    // CTR模式对于加密和解密都是一样的，所以我们可以
    // 也用NewCTR解密该密文。
    plaintext2 := make([]byte, len(plaintext))
    stream = cipher.NewCTR(block, iv)
    stream.XORKeyStream(plaintext2, ciphertext[aes.BlockSize:])

    fmt.Printf(&quot;%s\n&quot;, plaintext2)
}


func NewOFB(b Block, iv []byte) Stream
</code></pre>

<p>NewOFB 返回一个在输出反馈模式下使用分组密码 b 进行加密或解密的 Stream。初始化矢量 iv 的长度必须等于 b 的块大小。</p>

<p>示例
    package main</p>

<pre><code>import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;crypto/rand&quot;
    &quot;fmt&quot;
    &quot;io&quot;
)

func main() {
    key := []byte(&quot;example key 1234&quot;)
    plaintext := []byte(&quot;some plaintext&quot;)

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // IV需要独特，但不安全。 所以这很常见
    // 将其包括在密文的开头。
    ciphertext := make([]byte, aes.BlockSize+len(plaintext))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        panic(err)
    }

    stream := cipher.NewOFB(block, iv)
    stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)

    // 记住密文必须经过认证是很重要的
    // （即通过使用crypto/hmac）以及为了加密而被加密
    // 保持secure。

    // OFB模式对加密和解密都是一样的，所以我们可以
    // 也使用 NewOFB 解密该密文。

    plaintext2 := make([]byte, len(plaintext))
    stream = cipher.NewOFB(block, iv)
    stream.XORKeyStream(plaintext2, ciphertext[aes.BlockSize:])

    fmt.Printf(&quot;%s\n&quot;, plaintext2)
}
</code></pre>

<p>StreamReader 将 Stream 封装到 io.Reader 中。它调用 XORKeyStream 来处理通过的每一片数据。</p>

<pre><code>type StreamReader struct {
        S Stream
        R io.Reader
}
</code></pre>

<p>示例
    package main</p>

<pre><code>import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    key := []byte(&quot;example key 1234&quot;)

    inFile, err := os.Open(&quot;encrypted-file&quot;)
    if err != nil {
        panic(err)
    }
    defer inFile.Close()

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // 如果密钥对于每个密文都是唯一的，那么可以使用零
    // IV.
    var iv [aes.BlockSize]byte
    stream := cipher.NewOFB(block, iv[:])

    outFile, err := os.OpenFile(&quot;decrypted-file&quot;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
    if err != nil {
        panic(err)
    }
    defer outFile.Close()

    reader := &amp;cipher.StreamReader{S: stream, R: inFile}
    // 将输入文件复制到输出文件，随着我们的解密。
    if _, err := io.Copy(outFile, reader); err != nil {
        panic(err)
    }

    // 请注意，这个例子是简单的，因为它省略了
    // 加密数据的认证。 如果你真的使用
    // StreamReader以这种方式，攻击者可以翻转任意位
    // 输出。
}
</code></pre>

<p>方法</p>

<pre><code>func (r StreamReader) Read(dst []byte) (n int, err error)
</code></pre>

<p>StreamWriter 将 Stream 封装到 io.Writer 中。它调用 XORKeyStream 来处理通过的每一片数据。如果任何写入调用返回短，那么 StreamWriter 不同步并且必须被丢弃。StreamWriter 没有内部缓冲；不需要调用 Close 来刷新写入数据。</p>

<pre><code>type StreamWriter struct {
        S   Stream
        W   io.Writer
        Err error // unused
}
</code></pre>

<p>示例</p>

<pre><code>package main

import (
    &quot;crypto/aes&quot;
    &quot;crypto/cipher&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    key := []byte(&quot;example key 1234&quot;)

    inFile, err := os.Open(&quot;plaintext-file&quot;)
    if err != nil {
        panic(err)
    }
    defer inFile.Close()

    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }

    // 如果密钥对于每个密文都是唯一的，那么可以使用zero
    // IV.
    var iv [aes.BlockSize]byte
    stream := cipher.NewOFB(block, iv[:])

    outFile, err := os.OpenFile(&quot;encrypted-file&quot;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
    if err != nil {
        panic(err)
    }
    defer outFile.Close()

    writer := &amp;cipher.StreamWriter{S: stream, W: outFile}
    // 将输入文件复制到输出文件，并随时加密。
    if _, err := io.Copy(writer, inFile); err != nil {
        panic(err)
    }

    // 请注意，这个例子是简单的，因为它省略了
    // 加密数据的认证。 如果你真的使用
    // StreamReader以这种方式，攻击者可以翻转任意位
    // 解密的结果。
}
</code></pre>

<p>方法</p>

<pre><code>func (w StreamWriter) Close() error
</code></pre>

<p>Close 关闭底层 Writer 并返回其 Close 返回值，如果 Writer 也是 io.Closer。否则它返回零。</p>

<pre><code>func (StreamWriter) Write
</code></pre>

<h2 id="md5">md5</h2>

<p>其中MD5库在crypto/md5包中，md5包实现了MD5哈希算法，该包主要提供了New和Sum函数。</p>

<p>MD5的全称是Message-DigestAlgorithm 5，它可以把一个任意长度的字节数组转换成一个定长的整数，并且这种转换是不可逆的。对于任意长度的数据，转换后的MD5值长度是固定的，而且MD5的转换操作很容易，只要原数据有一点点改动，转换后结果就会有很大的差异。正是由于MD5算法的这些特性，它经常用于对于一段信息产生信息摘要，以防止其被篡改。其还广泛就于操作系统的登录过程中的安全验证，比如Unix操作系统的密码就是经过MD5加密后存储到文件系统中，当用户登录时输入密码后， 对用户输入的数据经过MD5加密后与原来存储的密文信息比对，如果相同说明密码正确，否则输入的密码就是错误的。</p>

<p>MD5以512位为一个计算单位对数据进行分组，每一分组又被划分为16个32位的小组，经过一系列处理后，输出4个32位的小组，最后组成一个128位的哈希值。对处理的数据进行512求余得到N和一个余数，如果余数不为448,填充1和若干个0直到448位为止，最后再加上一个64位用来保存数据的长度，这样经过预处理后，数据变成（N+1）x 512位。</p>

<pre><code>package main

import (
&quot;crypto/md5&quot;
&quot;fmt&quot;
&quot;io&quot;
)

func main() {
str := &quot;abc123&quot;

//方法一
data := []byte(str)
has := md5.Sum(data)
md5str1 := fmt.Sprintf(&quot;%x&quot;, has) //将[]byte转成16进制

fmt.Println(md5str1)

//方法二

w := md5.New()
io.WriteString(w, str)   //将需要加密的字符串str写入到w中
md5str2: = fmt.Sprintf(&quot;%x&quot;, w.Sum(nil))  //w.Sum(nil)将w的hash转成[]byte格式

fmt.Println(mdtstr2)
}
</code></pre>

<p>打印结果：</p>

<pre><code>e99a18c428cb38d5f260853678922e03

e99a18c428cb38d5f260853678922e03
</code></pre>

<h1 id="sha256">sha256</h1>

<p>sha256包实现了SHA224和SHA256哈希算法。该包主要提供了sum和new方法。</p>

<pre><code>import (
    &quot;fmt&quot;
    &quot;crypto/sha256&quot;
    &quot;os&quot;
    &quot;io&quot;
    &quot;crypto/md5&quot;
    &quot;golang.org/x/crypto/ripemd160&quot;
)

func main()  {
    str := &quot;hello world&quot;
    sum := sha256.Sum256([]byte(str))
    fmt.Printf(&quot;SHA256：%x\n&quot;, sum)

    fileSha156()

    result := md5.Sum([]byte(str))
    fmt.Printf(&quot;MD5：%x\n&quot;, result)

    hasher := ripemd160.New()
    // 将加密内容的字节数组拷贝到ripemd160
    hasher.Write([]byte(str))
    fmt.Printf(&quot;RIPEMD160：%x&quot;, hasher.Sum(nil))
}

/**
 * 使用SHA256加密文件内容
 */
func fileSha156() {
    file, err := os.OpenFile(&quot;e:/test.txt&quot;, os.O_RDONLY, 0777)
    if err != nil {
        panic(err)
    }
    defer file.Close()

    h := sha256.New()
    // 将文件内容拷贝到sha256中
    io.Copy(h, file)
    fmt.Printf(&quot;%x\n&quot;, h.Sum(nil))
}
</code></pre>

<h1 id="des">DES</h1>

<p>DES是一种对称加密算法，又称为美国数据加密标准。DES加密时以64位分组对数据进行加密，加密和解密都使用的是同一个长度为64位的密钥，实际上只用到了其中的56位，密钥中的第8、16…64位用来作奇偶校验。DES有ECB（电子密码本）和CBC（加密块）等加密模式。</p>

<p>DES算法的安全性很高，目前除了穷举搜索破解外， 尚无更好的的办法来破解。其密钥长度越长，破解难度就越大。</p>

<pre><code>import (
    &quot;bytes&quot;
    &quot;crypto/cipher&quot; //cipher密码
    &quot;crypto/des&quot;
    &quot;encoding/base64&quot; //将对象转换成字符串
    &quot;fmt&quot;
)

/**
 * DES加密方法
 */
func MyDesEncrypt(orig, key string) string{

    // 将加密内容和秘钥转成字节数组
    origData := []byte(orig)
    k := []byte(key)

    // 秘钥分组
    block, _ := des.NewCipher(k)

    //将明文按秘钥的长度做补全操作
    origData = PKCS5Padding(origData, block.BlockSize())

    //设置加密方式－CBC
    blockMode := cipher.NewCBCDecrypter(block, k)

    //创建明文长度的字节数组
    crypted := make([]byte, len(origData))

    //加密明文
    blockMode.CryptBlocks(crypted, origData)

    //将字节数组转换成字符串，base64编码
    return base64.StdEncoding.EncodeToString(crypted)

}

/**
 * DES解密方法
 */
func MyDESDecrypt(data string, key string) string {

    k := []byte(key)

    //将加密字符串用base64转换成字节数组
    crypted, _ := base64.StdEncoding.DecodeString(data)

    //将字节秘钥转换成block快
    block, _ := des.NewCipher(k)

    //设置解密方式－CBC
    blockMode := cipher.NewCBCEncrypter(block, k)

    //创建密文大小的数组变量
    origData := make([]byte, len(crypted))

    //解密密文到数组origData中
    blockMode.CryptBlocks(origData, crypted)

    //去掉加密时补全的部分
    origData = PKCS5UnPadding(origData)

    return string(origData)
}

/**
 * 实现明文的补全
 * 如果ciphertext的长度为blockSize的整数倍，则不需要补全
 * 否则差几个则被几个，例：差5个则补5个5
 */
func PKCS5Padding(ciphertext []byte, blockSize int) []byte {
    padding := blockSize - len(ciphertext)%blockSize
    padtext := bytes.Repeat([]byte{byte(padding)}, padding)
    return append(ciphertext, padtext...)
}

/**
 * 实现去补码，PKCS5Padding的反函数
 */
func PKCS5UnPadding(origData []byte) []byte {
    length := len(origData)
    // 去掉最后一个字节 unpadding 次
    unpadding := int(origData[length-1])
    return origData[:(length - unpadding)]
}

func main() {

    orig := &quot;Hello World!&quot;
    fmt.Println(&quot;原文：&quot;, orig)

    //声明秘钥,利用此秘钥实现明文的加密和密文的解密，长度必须为8
    key := &quot;12345678&quot;

    //加密
    encyptCode := MyDesEncrypt(orig, key)
    fmt.Println(&quot;密文：&quot;, encyptCode)

    //解密
    decyptCode := MyDESDecrypt(encyptCode, key)
    fmt.Println(&quot;解密结果：&quot;, decyptCode)
}
</code></pre>

<h1 id="3des">3DES</h1>

<p>其实也是在des中实现的。</p>

<pre><code>import (
    &quot;bytes&quot;
    &quot;crypto/cipher&quot;
    &quot;crypto/des&quot;
    &quot;encoding/base64&quot;
    &quot;fmt&quot;
)

func main() {
    orig := &quot;hello world&quot;
    // 3DES的秘钥长度必须为24位
    key := &quot;123456781234567812345678&quot;
    fmt.Println(&quot;原文：&quot;, orig)

    encryptCode := TripleDesEncrypt(orig, key)
    fmt.Println(&quot;密文：&quot;, encryptCode)

    decryptCode := TipleDesDecrypt(encryptCode, key)
    fmt.Println(&quot;解密结果：&quot;, decryptCode)

}

/**
 * 加密
 */
func TripleDesEncrypt(orig, key string) string {
    // 转成字节数组
    origData := []byte(orig)
    k := []byte(key)

    // 3DES的秘钥长度必须为24位
    block, _ := des.NewTripleDESCipher(k)
    // 补全码
    origData = PKCS5Padding(origData, block.BlockSize())
    // 设置加密方式
    blockMode := cipher.NewCBCEncrypter(block, k[:8])
    // 创建密文数组
    crypted := make([]byte, len(origData))
    // 加密
    blockMode.CryptBlocks(crypted, origData)

    return base64.StdEncoding.EncodeToString(crypted)
}

/**
 * 解密
 */
func TipleDesDecrypt(crypted string, key string) string {
    // 用base64转成字节数组
    cryptedByte, _ := base64.StdEncoding.DecodeString(crypted)
    // key转成字节数组
    k := []byte(key)

    block, _ := des.NewTripleDESCipher(k)
    blockMode := cipher.NewCBCDecrypter(block, k[:8])
    origData := make([]byte, len(cryptedByte))
    blockMode.CryptBlocks(origData, cryptedByte)
    origData = PKCS5UnPadding(origData)

    return string(origData)
}

func PKCS5Padding(orig []byte, size int) []byte {
    length := len(orig)
    padding := size - length%size
    paddintText := bytes.Repeat([]byte{byte(padding)}, padding)
    return append(orig, paddintText...)
}

func PKCS5UnPadding(origData []byte) []byte {
    length := len(origData)
    // 去掉最后一个字节 unpadding 次
    unpadding := int(origData[length-1])
    return origData[:(length - unpadding)]
}
</code></pre>

<h2 id="tls">tls</h2>

<p>tls是比较常见网络验证的方式，我们单独说明。</p>

<h2 id="rsa">rsa</h2>

<p>首先使用openssl生成公私钥，使用RSA的时候需要提供公钥和私钥 ， 可以通过openss来生成对应的pem格式的公钥和私钥匙</p>

<pre><code>import (
    &quot;crypto/rand&quot;
    &quot;crypto/rsa&quot;
    &quot;crypto/x509&quot;
    &quot;encoding/base64&quot;
    &quot;encoding/pem&quot;
    &quot;errors&quot;
    &quot;fmt&quot;
)

// 私钥生成
//openssl genrsa -out rsa_private_key.pem 1024
var privateKey = []byte(`
-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgQDcGsUIIAINHfRTdMmgGwLrjzfMNSrtgIf4EGsNaYwmC1GjF/bM
h0Mcm10oLhNrKNYCTTQVGGIxuc5heKd1gOzb7bdTnCDPPZ7oV7p1B9Pud+6zPaco
qDz2M24vHFWYY2FbIIJh8fHhKcfXNXOLovdVBE7Zy682X1+R1lRK8D+vmQIDAQAB
AoGAeWAZvz1HZExca5k/hpbeqV+0+VtobMgwMs96+U53BpO/VRzl8Cu3CpNyb7HY
64L9YQ+J5QgpPhqkgIO0dMu/0RIXsmhvr2gcxmKObcqT3JQ6S4rjHTln49I2sYTz
7JEH4TcplKjSjHyq5MhHfA+CV2/AB2BO6G8limu7SheXuvECQQDwOpZrZDeTOOBk
z1vercawd+J9ll/FZYttnrWYTI1sSF1sNfZ7dUXPyYPQFZ0LQ1bhZGmWBZ6a6wd9
R+PKlmJvAkEA6o32c/WEXxW2zeh18sOO4wqUiBYq3L3hFObhcsUAY8jfykQefW8q
yPuuL02jLIajFWd0itjvIrzWnVmoUuXydwJAXGLrvllIVkIlah+lATprkypH3Gyc
YFnxCTNkOzIVoXMjGp6WMFylgIfLPZdSUiaPnxby1FNM7987fh7Lp/m12QJAK9iL
2JNtwkSR3p305oOuAz0oFORn8MnB+KFMRaMT9pNHWk0vke0lB1sc7ZTKyvkEJW0o
eQgic9DvIYzwDUcU8wJAIkKROzuzLi9AvLnLUrSdI6998lmeYO9x7pwZPukz3era
zncjRK3pbVkv0KrKfczuJiRlZ7dUzVO0b6QJr8TRAA==
-----END RSA PRIVATE KEY-----
`)

// 公钥: 根据私钥生成
//openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem
var publicKey = []byte(`
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcGsUIIAINHfRTdMmgGwLrjzfM
NSrtgIf4EGsNaYwmC1GjF/bMh0Mcm10oLhNrKNYCTTQVGGIxuc5heKd1gOzb7bdT
nCDPPZ7oV7p1B9Pud+6zPacoqDz2M24vHFWYY2FbIIJh8fHhKcfXNXOLovdVBE7Z
y682X1+R1lRK8D+vmQIDAQAB
-----END PUBLIC KEY-----
`)

// 加密
func RsaEncrypt(origData []byte) ([]byte, error) {
    //解密pem格式的公钥
    block, _ := pem.Decode(publicKey)
    if block == nil {
        return nil, errors.New(&quot;public key error&quot;)
    }
    // 解析公钥
    pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        return nil, err
    }
    // 类型断言
    pub := pubInterface.(*rsa.PublicKey)
    //加密
    return rsa.EncryptPKCS1v15(rand.Reader, pub, origData)
}

// 解密
func RsaDecrypt(ciphertext []byte) ([]byte, error) {
    //解密
    block, _ := pem.Decode(privateKey)
    if block == nil {
        return nil, errors.New(&quot;private key error!&quot;)
    }
    //解析PKCS1格式的私钥
    priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)
    if err != nil {
        return nil, err
    }
    // 解密
    return rsa.DecryptPKCS1v15(rand.Reader, priv, ciphertext)
}
func main() {
    data, _ := RsaEncrypt([]byte(&quot;hello world&quot;))
    fmt.Println(base64.StdEncoding.EncodeToString(data))
    origData, _ := RsaDecrypt(data)
    fmt.Println(string(origData))
}
</code></pre>

<h2 id="dsa">dsa</h2>

<p>dsa包实现FIPS 186-3定义的数字签名算法（Digital Signature Algorithm），即DSA算法。</p>

<h2 id="ecdsa">ecdsa</h2>

<p>ecdsa包实现了椭圆曲线数字签名算法，参见FIPS 186-3。</p>

<h2 id="elliptic">elliptic</h2>

<p>elliptic包实现了几条覆盖素数有限域的标准椭圆曲线。</p>

<h2 id="hmac">hmac</h2>

<p>hmac包实现了U.S. Federal Information Processing Standards Publication 198规定的HMAC（加密哈希信息认证码）。</p>

<p>HMAC是使用key标记信息的加密hash。接收者使用相同的key逆运算来认证hash。</p>

<p>出于安全目的，接收者应使用Equal函数比较认证码：</p>

<pre><code>// 如果messageMAC是message的合法HMAC标签，函数返回真
func CheckMAC(message, messageMAC, key []byte) bool {
    mac := hmac.New(sha256.New, key)
    mac.Write(message)
    expectedMAC := mac.Sum(nil)
    return hmac.Equal(messageMAC, expectedMAC)
}
</code></pre>

<h2 id="rand">rand</h2>

<p>rand包实现了用于加解密的更安全的随机数生成器。</p>

<p>Example</p>

<pre><code>c := 10
b := make([]byte, c)
_, err := rand.Read(b)
if err != nil {
    fmt.Println(&quot;error:&quot;, err)
    return
}
// The slice should now contain random bytes instead of only zeroes.
fmt.Println(bytes.Equal(b, make([]byte, c)))

Output:

false
</code></pre>

<h2 id="rc4">rc4</h2>

<p>rc4包实现了RC4加密算法，参见Bruce Schneier&rsquo;s Applied Cryptography。</p>

<h2 id="sha1">sha1</h2>

<p>sha1包实现了SHA1哈希算法。</p>

<p>Example</p>

<pre><code>h := sha1.New()
io.WriteString(h, &quot;His money is twice tainted:&quot;)
io.WriteString(h, &quot; 'taint yours and 'taint mine.&quot;)
fmt.Printf(&quot;% x&quot;, h.Sum(nil))
Output:

59 7f 6a 54 00 10 f9 4c 15 d7 18 06 a9 9a 2c 87 10 e7 47 bd
</code></pre>

<h2 id="sha512">sha512</h2>

<p>sha512包实现了SHA384和SHA512哈希算法</p>

<h2 id="x509">x509</h2>

<p>x509包解析X.509编码的证书和密钥。</p>

<h2 id="pkix">pkix</h2>

<p>pkix包提供了共享的、低层次的结构体，用于ASN.1解析和X.509证书、CRL、OCSP的序列化。</p>

<h2 id="base64">Base64</h2>

<p>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>

<p>首先使用Base64编码需要一个含有64个字符的表，这个表由大小写字母、数字、+和/组成。采用Base64编码处理数据时，会把每三个字节共24位作为一个处理单元，再分为四组，每组6位，查表后获得相应的字符即编码后的字符串。编码后的字符串长32位，这样，经Base64编码后，原字符串增长1/3。如果要编码的数据不是3的倍数，最后会剩下一到两个字节，Base64编码中会采用\x00在处理单元后补全，编码后的字符串最后会加上一到两个 = 表示补了几个字节。</p>

<pre><code>const (
   base64Table = &quot;IJjkKLMNO567PQX12RVW3YZaDEFGbcdefghiABCHlSTUmnopqrxyz04stuvw89+/&quot;

)

var coder = base64.NewEncoding(base64Table)

func Base64Encode(src []byte) []byte {         //编码
   return []byte(coder.EncodeToString(src))
}

func Base64Decode(src []byte) ([]byte, error) {   //解码
   return coder.DecodeString(string(src))
}
</code></pre>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-crypto/">https://kingjcy.github.io/post/golang/go-crypto/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/crypto/">
                            <i class="fa fa-tags"></i>
                            crypto
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-threadsafety/">Go Threadsafety</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月04日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/monitor/prometheus/cluster/cortex/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/distributed/store/oss/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#加密方法总结">加密方法总结</a></li>
<li><a href="#主要使用">主要使用</a>
<ul>
<li><a href="#aes">aes</a></li>
<li><a href="#cipher">cipher</a></li>
<li><a href="#md5">md5</a></li>
</ul></li>
<li><a href="#sha256">sha256</a></li>
<li><a href="#des">DES</a></li>
<li><a href="#3des">3DES</a>
<ul>
<li><a href="#tls">tls</a></li>
<li><a href="#rsa">rsa</a></li>
<li><a href="#dsa">dsa</a></li>
<li><a href="#ecdsa">ecdsa</a></li>
<li><a href="#elliptic">elliptic</a></li>
<li><a href="#hmac">hmac</a></li>
<li><a href="#rand">rand</a></li>
<li><a href="#rc4">rc4</a></li>
<li><a href="#sha1">sha1</a></li>
<li><a href="#sha512">sha512</a></li>
<li><a href="#x509">x509</a></li>
<li><a href="#pkix">pkix</a></li>
<li><a href="#base64">Base64</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

