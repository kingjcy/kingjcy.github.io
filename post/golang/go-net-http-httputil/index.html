<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="package httputil

import &ldquo;net/http/httputil&rdquo;

httputil包提供了HTTP公用函数，是对net/http包的更常见函数的补充。还有反向代理的实现。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Go Net Http Httputil - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Go Net Http Httputil
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年09月26日 
                </div>
                <h1 class="post-title">Go Net Http Httputil</h1>
            </header>

            <div class="post-content">
                <p>package httputil</p>

<p>import &ldquo;net/http/httputil&rdquo;</p>

<p>httputil包提供了HTTP公用函数，是对net/http包的更常见函数的补充。还有反向代理的实现。</p>

<h2 id="代理">代理</h2>

<p>httputil实现代理的核心就是在客户端集成一个client去重新发送这个请求。</p>

<p>代理的核心功能可以用一句话概括：接受客户端的请求，转发到后端服务器，获得应答之后返回给客户端。</p>

<p>代理的功能有很多，事实上整个互联网到处都充斥着代理服务器。如果所有的 HTTP 访问都是客户端和服务器端直接进行的话，我们的网络不仅会变得缓慢，而且性能会大打折扣。</p>

<p>代理服务器根据不同的配置和使用，可能会有不同的功能，这些功能主要包括：</p>

<pre><code>内容过滤：代理可以根据一定的规则限制某些请求的连接。比如有些公司会设置内部网络无法访问某些购物、游戏网站，或者学校的网络不让学生访问色情暴力的网站等
节省成本：代理服务器可以作为缓存使用，对于某些资源只需要第一次访问的时候去下载，以后代理直接把缓存的结果返回给客户端，节约网络带宽的开销
提高性能：通过代理服务器的缓存（比如 CDN）和负载均衡（比如 nginx lb）功能，服务器端可以加速请求的访问，在更快的时间内返回结果）
增加安全性：公司可以在内网和外网之间通过代理进行转发，这样不仅对外隐藏了实现的细节，而且可以在代理层对爬虫、病毒性请求进行过滤，保护内部服务
</code></pre>

<p>所有的这些功能的实现都依赖于代理的特性，它可以在客户端和服务器端做一些事情，根据代理做的事情不同，它的角色和功能也就不同。那么，代理具体可以做哪些事情呢？比如：</p>

<pre><code>修改 HTTP 请求：url、header、body
过滤请求：根据一定的规则丢弃、过滤请求
决定转发到哪个后端（可以是静态定义的，也可以是动态决定）
保存服务器的应答，后续的请求可以直接使用保存的应答
修改应答：对应答做一些格式的转换，修改数据，甚至返回完全不一样的应答数据
重试机制，如果后端服务器暂时无法响应，隔一段时间重试
</code></pre>

<p>分类</p>

<p>代理可以分为正向代理和反向代理两种。</p>

<p>正向代理需要客户端来配置，一般来说我们会通过浏览器或者操作系统提供的工具或者界面来配置。这个时候，代理对客户端不是透明的，客户端需要知道代理的地址并且手动配置。配置了代理，浏览器在发送请求的时候会对报文做特殊的修改。</p>

<p>反向代理对客户端是透明的，也就是说客户端一般不知道代理的存在，认为自己是直接和服务器通信。我们大部分访问的网站就是反向代理服务器，反向代理服务器会转发到真正的服务器，一般在反向代理这一层实现负载均衡和高可用的功能。而且这里也可以看到，客户端是不会知道真正服务器端的 ip 地址和端口的，这在一定程度上起到了安全保护的作用。</p>

<p>服务器地址发现</p>

<p>在反向代理中，代理服务器要转发的服务器地址都是事先知道的（包括静态配置和动态配置）。比如 使用 nginx 来配置负载均衡 。</p>

<p>而对于正向代理来说，客户端可能访问的服务器地址是无法事先知道的。因为HTTP 协议活动在应用层，它无法获取网络层（IP层）信息，那么该协议要有一个地方可以拿到这个信息。HTTP 中可能保存这个信息的地方有两个：URL 和 header。默认情况下，HTTP 请求的 status line 有三部分组成：方法、uri 和协议版本，比如：</p>

<pre><code>GET /index.html HTTP/1.0
User-Agent: gohttp 1.0
</code></pre>

<p>如果客户端（比如浏览器）知道自己在通过正向代理进行报文传输，那么它会在 status line 加上要访问服务器的真实地址。这个时候发送的报文是：</p>

<pre><code>GET http://www.marys-antiques.com/index.html HTTP/1.0
User-Agent: gohttp 1.0
</code></pre>

<p>代理路径</p>

<p>客户端不管是通过代理服务器，还是直接访问后端服务器对于最终的结果是没有区别的，也就是说大多数情况下客户端根本不关心它访问的到底是什么，只需要（准确快速地）拿到想要的信息就够了。但是有时候，我们还是希望知道请求到底在中间经历了哪些代理，比如用来调试网络异常，或者做数据统计，而 HTTP 协议也提供了响应的功能。</p>

<p>虽然 RFC 2616 定义了 Via 头部字段来跟踪 HTTP 请求经过的代理路径，但在实际中用的更多的还是 X-Forwarded-For 字段， X-Forwarded-For 是 Squid 缓存代理服务软件引入的，目前已经在规范化在 RFC 7239 文档。</p>

<p>X-Forwarded-For 头部格式也比较简单，比如某个服务器接受到请求的对应头部可能是：</p>

<pre><code>X-Forwarded-For: client, proxy1, proxy2
</code></pre>

<p>对应的值有多个字段，每个字段代表中间的一个节点，它们之间由逗号和空格隔开，从左到右距离当前节点越来越近。</p>

<p>每个代理服务器会在 X-Forwarded-For 头部填上前一个节点的 ip 地址，这个地址可以通过 TCP 请求的 remote address 获取。为什么每个代理服务器不填写自己的 ip 地址呢？有两个原因，如果由代理服务器填写自己的 ip 地址，那么代理可以很简单地伪造这个地址，而上一个节点的 remote address 是根据 TCP 连接获取的（如果不建立正确的 TCP 连接是无法进行 HTTP 通信的）；另外一个原因是如果由当前节点填写 X-Forwarded-For ，那么很多情况客户端无法判断自己是否会通过代理的。</p>

<p>NOTE：</p>

<p>最终客户端或者服务器端接受的请求， X-Forwarded-For 是没有最邻近节点的 ip 地址的，而这个地址可以通过 remote address 获取
每个节点（不管是客户端、代理服务器、真实服务器）都可以随便更改 X-Forwarded-For 的值，因此这个字段只能作为参考</p>

<p>使用golang内置的net/http/httputil实现正向和反向代理</p>

<p>正向代理</p>

<p>按照我们之前介绍的代理原理，我们可以编写出这样的代码：</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
)

type Pxy struct {}

func (p *Pxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
    fmt.Printf(&quot;Received request %s %s %s\n&quot;, req.Method, req.Host, req.RemoteAddr)

    transport :=  http.DefaultTransport

    // step 1
    outReq := new(http.Request)
    *outReq = *req // this only does shallow copies of maps

    if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {
        if prior, ok := outReq.Header[&quot;X-Forwarded-For&quot;]; ok {
            clientIP = strings.Join(prior, &quot;, &quot;) + &quot;, &quot; + clientIP
        }
        outReq.Header.Set(&quot;X-Forwarded-For&quot;, clientIP)
    }

    // step 2
    res, err := transport.RoundTrip(outReq)
    if err != nil {
        rw.WriteHeader(http.StatusBadGateway)
        return
    }

    // step 3
    for key, value := range res.Header {
        for _, v := range value {
            rw.Header().Add(key, v)
        }
    }

    rw.WriteHeader(res.StatusCode)
    io.Copy(rw, res.Body)
    res.Body.Close()
}

func main() {
    fmt.Println(&quot;Serve on :8080&quot;)
    http.Handle(&quot;/&quot;, &amp;Pxy{})
    http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)
}
</code></pre>

<p>这段代码比较直观，只包含了最核心的代码逻辑，完全按照最上面的代理图例进行组织。一共分成几个步骤：</p>

<pre><code>代理接收到客户端的请求，复制了原来的请求对象，并根据数据配置新请求的各种参数（添加上 X-Forward-For 头部等）
把新请求发送到服务器端，并接收到服务器端返回的响应
代理服务器对响应做一些处理，然后返回给客户端
</code></pre>

<p>上面的代码运行之后，会在本地的 8080 端口启动代理服务。修改浏览器的代理为 127.0.0.1：:8080 再访问网站，可以验证代理正常工作，也能看到它在终端打印出所有的请求信息。</p>

<p>虽然这段代码非常简短，但是你可以添加更多的逻辑实现非常有用的功能。比如在请求发送之前进行过滤，根据一定的规则直接阻止某些请求的访问；或者对请求进行限流，某个客户端在一定的时间里执行的请求有最大限额；统计请求的数据进行分析等等。</p>

<p>这个代理目前不支持 HTTPS 协议，因为它只提供了 HTTP 请求的转发功能，并没有处理证书和认证有关的内容。如果了解 HTTPS 协议的话，你会明白这种模式下是无法完成 HTTPS 握手的，虽然代理可以和真正的服务器建立连接（知道了对方的公钥和证书），但是代理无法代表服务器和客户端建立连接，因为代理服务器无法知道真正服务器的私钥。</p>

<p>反向代理</p>

<p>编写反向代理按照上面的思路当然没有问题，只需要在第二步的时候，根据之前的配置修改 outReq 的 URL Host 地址可以了。不过 Golang 已经给我们提供了编写代理的框架： httputil.ReverseProxy 。我们可以用非常简短的代码来实现自己的代理，而且内部的细节问题都已经被很好地处理了。</p>

<p>这部分我们会实现一个简单的反向代理，它能够对请求实现负载均衡，随机地把请求发送给某些配置好的后端服务器。使用 httputil.ReverseProxy 编写反向代理最重要的就是实现自己的 Director 对象，这是 GoDoc 对它的介绍：</p>

<p>Director must be a function which modifies the request into a new request to be sent using Transport. Its response is then copied back to the original client unmodified. Director must not access the provided Request after returning.</p>

<p>简单翻译的话， Director 是一个函数，它接受一个请求作为参数，然后对其进行修改。修改后的请求会实际发送给服务器端，因此我们编写自己的 Director 函数，每次把请求的 Scheme 和 Host 修改成某个后端服务器的地址，就能实现负载均衡的效果（其实上面的正向代理也可以通过相同的方法实现）。看代码：</p>

<pre><code>package main

import (
        &quot;log&quot;
        &quot;math/rand&quot;
        &quot;net/http&quot;
        &quot;net/http/httputil&quot;
        &quot;net/url&quot;
)

func NewMultipleHostsReverseProxy(targets []*url.URL) *httputil.ReverseProxy {
        director := func(req *http.Request) {
                target := targets[rand.Int()%len(targets)]
                req.URL.Scheme = target.Scheme
                req.URL.Host = target.Host
                req.URL.Path = target.Path
        }
        return &amp;httputil.ReverseProxy{Director: director}
}

func main() {
        proxy := NewMultipleHostsReverseProxy([]*url.URL{
                {
                        Scheme: &quot;http&quot;,
                        Host:   &quot;localhost:9091&quot;,
                },
                {
                        Scheme: &quot;http&quot;,
                        Host:   &quot;localhost:9092&quot;,
                },
        })
        log.Fatal(http.ListenAndServe(&quot;:9090&quot;, proxy))
}
</code></pre>

<p>我们让代理监听在 9090 端口，在后端启动两个返回不同响应的服务器分别监听在 9091 和 9092 端口，通过 curl 访问，可以看到多次请求会返回不同的结果。</p>

<pre><code>➜  curl http://127.0.0.1:9090
116064a9eb83
➜  curl http://127.0.0.1:9090
8f7ccc11718f
</code></pre>

<p>实例</p>

<pre><code>package main

import (
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;net/http/httputil&quot;
    &quot;net/url&quot;
)

type handle struct {
    host string
    port string
}

func (this *handle) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    remote, err := url.Parse(&quot;http://&quot; + this.host + &quot;:&quot; + this.port)
    if err != nil {
        panic(err)
    }
    proxy := httputil.NewSingleHostReverseProxy(remote)
    proxy.ServeHTTP(w, r)
}

func startServer() {
    //被代理的服务器host和port
    h := &amp;handle{host: &quot;127.0.0.1&quot;, port: &quot;80&quot;}
    err := http.ListenAndServe(&quot;:8888&quot;, h)
    if err != nil {
        log.Fatalln(&quot;ListenAndServe: &quot;, err)
    }
}

func main() {
    startServer()
}
</code></pre>

<p>我们来看一下这个结构体</p>

<pre><code>type ReverseProxy struct {
    // Director must be a function which modifies
    // the request into a new request to be sent
    // using Transport. Its response is then copied
    // back to the original client unmodified.
    // Director must not access the provided Request
    // after returning.
    Director func(*http.Request)    //重制req请求内容

    // The transport used to perform proxy requests.
    // If nil, http.DefaultTransport is used.
    Transport http.RoundTripper    //发送请求，主要是获取连接，发送请求，获取返回，默认是default，根据req来建立连接。也可以自己自定义，可以去看http的transport的结构体

    // FlushInterval specifies the flush interval
    // to flush to the client while copying the
    // response body.
    // If zero, no periodic flushing is done.
    // A negative value means to flush immediately
    // after each write to the client.
    // The FlushInterval is ignored when ReverseProxy
    // recognizes a response as a streaming response;
    // for such responses, writes are flushed to the client
    // immediately.
    FlushInterval time.Duration

    // ErrorLog specifies an optional logger for errors
    // that occur when attempting to proxy the request.
    // If nil, logging is done via the log package's standard logger.
    ErrorLog *log.Logger // Go 1.4

    // BufferPool optionally specifies a buffer pool to
    // get byte slices for use by io.CopyBuffer when
    // copying HTTP response bodies.
    BufferPool BufferPool // Go 1.6

    // ModifyResponse is an optional function that modifies the
    // Response from the backend. It is called if the backend
    // returns a response at all, with any HTTP status code.
    // If the backend is unreachable, the optional ErrorHandler is
    // called without any call to ModifyResponse.
    //
    // If ModifyResponse returns an error, ErrorHandler is called
    // with its error value. If ErrorHandler is nil, its default
    // implementation is used.
    ModifyResponse func(*http.Response) error // Go 1.8

    // ErrorHandler is an optional function that handles errors
    // reaching the backend or errors from ModifyResponse.
    //
    // If nil, the default is to log the provided error and return
    // a 502 Status Bad Gateway response.
    ErrorHandler func(http.ResponseWriter, *http.Request, error) // Go 1.11
}
</code></pre>

<p>我简化使用</p>

<pre><code>type ReverseProxy struct {
    // Director必须是将请求修改为新的请求的函数。
    // 修改后的请求会使用Transport发送，得到的回复会不经修改的返回给客户端。
    Director func(*http.Request)
    // Transport用于执行代理请求。
    // 如果本字段为nil，会使用http.DefaultTransport。
    Transport http.RoundTripper
    // FlushInterval指定拷贝回复的主体时将数据刷新给客户端的时间间隔。
    // 如果本字段为零值，不会进行周期的刷新。（拷贝完回复主体后再刷新）
    FlushInterval time.Duration
}




type Transport struct {
    // Proxy指定一个对给定请求返回代理的函数。
    // 如果该函数返回了非nil的错误值，请求的执行就会中断并返回该错误。
    // 如果Proxy为nil或返回nil的*URL置，将不使用代理。
    Proxy func(*Request) (*url.URL, error)
    // Dial指定创建TCP连接的拨号函数。如果Dial为nil，会使用net.Dial。
    Dial func(network, addr string) (net.Conn, error)
    // TLSClientConfig指定用于tls.Client的TLS配置信息。
    // 如果该字段为nil，会使用默认的配置信息。
    TLSClientConfig *tls.Config
    // TLSHandshakeTimeout指定等待TLS握手完成的最长时间。零值表示不设置超时。
    TLSHandshakeTimeout time.Duration
    // 如果DisableKeepAlives为真，会禁止不同HTTP请求之间TCP连接的重用。
    DisableKeepAlives bool
    // 如果DisableCompression为真，会禁止Transport在请求中没有Accept-Encoding头时，
    // 主动添加&quot;Accept-Encoding: gzip&quot;头，以获取压缩数据。
    // 如果Transport自己请求gzip并得到了压缩后的回复，它会主动解压缩回复的主体。
    // 但如果用户显式的请求gzip压缩数据，Transport是不会主动解压缩的。
    DisableCompression bool
    // 如果MaxIdleConnsPerHost!=0，会控制每个主机下的最大闲置连接。
    // 如果MaxIdleConnsPerHost==0，会使用DefaultMaxIdleConnsPerHost。
    MaxIdleConnsPerHost int
    // ResponseHeaderTimeout指定在发送完请求（包括其可能的主体）之后，
    // 等待接收服务端的回复的头域的最大时间。零值表示不设置超时。
    // 该时间不包括获取回复主体的时间。
    ResponseHeaderTimeout time.Duration
    // 内含隐藏或非导出字段
}
</code></pre>

<p>transport其实是客户端访问服务端的一个方法，这边其实就是重新进行访问，下面简单介绍一下</p>

<h3 id="roundtripper-is-an-interface-representing-the-ability-to-execute-a-single-http-transaction-obtaining-the-response-for-a-given-request">RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</h3>

<p>对于http客户端，可以使用不同的实现了 RoundTripper 接口的Transport实现来配置它的行为，这个正常在http调用的时候就会使用默认，在http反向代理的时候会需要自己定义。</p>

<p>RoundTripper 有点像 http.Client 的中间件</p>

<p>接口定义</p>

<pre><code>type RoundTripper interface { 
       RoundTrip(*Request) (*Response, error)
}
</code></pre>

<p>需要实现RoundTrip函数</p>

<p>type SomeClient struct {}</p>

<p>func (s *SomeClient) RoundTrip(r *http.Request)(*Response, error) {
    //Something comes here&hellip;Maybe
}</p>

<p>使用场景</p>

<p>1.缓存 responses，比如 app需要访问 Github api，获取 trending repos，这个数据变动不频繁，假设30分钟变动一次，你显然不希望每次都要点击api都要来请求Github api，解决这个问题的方法是实现这样的http.RoundTripper</p>

<pre><code>有缓存时从缓存取出response数据
过期，数据通过重新请求api获取
</code></pre>

<p>2.根据需要设置http header, 一个容易想到的例子go-github一个Github的 api的go客户端。某些github api不需要认证，有些需要认证则需要提供自己的http client，比如 ghinstallation,下面是ghinstallation 的 RoundTrip 函数实现，设置 Authorization 头</p>

<p>3.限速(Rate limiting) 控制请求速率</p>

<p>其次要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：</p>

<pre><code>tr := &amp;http.Transport{
    TLSClientConfig:    &amp;tls.Config{RootCAs: pool},
    DisableCompression: true,
}
client := &amp;http.Client{Transport: tr}
resp, err := client.Get(&quot;https://example.com&quot;)
</code></pre>

<p>Client和Transport类型都可以安全的被多个go程同时使用。出于效率考虑，应该一次建立、尽量重用。</p>

<p>实例</p>

<p>实现http.RoundTripper 缓存 http response的逻辑。</p>

<pre><code>package main

import (
    &quot;bufio&quot;
    &quot;bytes&quot;
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;net/http/httputil&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;strings&quot;
    &quot;sync&quot;
    &quot;syscall&quot;
    &quot;time&quot;
)

func main() {

    cachedTransport := newTransport()

    //Create a custom client so we can make use of our RoundTripper
    //If you make use of http.Get(), the default http client located at http.DefaultClient is used instead
    //Since we have special needs, we have to make use of our own http.RoundTripper implementation
    client := &amp;http.Client{
        Transport: cachedTransport,
        Timeout:   time.Second * 5,
    }

    //Time to clear the cache store so we can make request to the original server
    cacheClearTicker := time.NewTicker(time.Second * 5)

    //Make a new request every second
    //This would help demonstrate if the response is actually coming from the real server or from the cache
    reqTicker := time.NewTicker(time.Second * 1)

    terminateChannel := make(chan os.Signal, 1)

    signal.Notify(terminateChannel, syscall.SIGTERM, syscall.SIGHUP)

    req, err := http.NewRequest(http.MethodGet, &quot;http://localhost:8000&quot;, strings.NewReader(&quot;&quot;))

    if err != nil {
        log.Fatalf(&quot;An error occurred ... %v&quot;, err)
    }

    for {
        select {
        case &lt;-cacheClearTicker.C:
            // Clear the cache so we can hit the original server
            cachedTransport.Clear()

        case &lt;-terminateChannel:
            cacheClearTicker.Stop()
            reqTicker.Stop()
            return

        case &lt;-reqTicker.C:

            resp, err := client.Do(req)

            if err != nil {
                log.Printf(&quot;An error occurred.... %v&quot;, err)
                continue
            }

            buf, err := ioutil.ReadAll(resp.Body)

            if err != nil {
                log.Printf(&quot;An error occurred.... %v&quot;, err)
                continue
            }

            fmt.Printf(&quot;The body of the response is \&quot;%s\&quot; \n\n&quot;, string(buf))
        }
    }
}

func cacheKey(r *http.Request) string {
    return r.URL.String()
}

type cacheTransport struct {
    data              map[string]string
    mu                sync.RWMutex
    originalTransport http.RoundTripper
}

func (c *cacheTransport) Set(r *http.Request, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data[cacheKey(r)] = value
}

func (c *cacheTransport) Get(r *http.Request) (string, error) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    if val, ok := c.data[cacheKey(r)]; ok {
        return val, nil
    }

    return &quot;&quot;, errors.New(&quot;key not found in cache&quot;)
}



//cacheTransport 中 RoundTrip 函数实现读取缓存中的reponse
// There be dragons!!!
func (c *cacheTransport) RoundTrip(r *http.Request) (*http.Response, error) {

    // Check if we have the response cached..
    // If yes, we don't have to hit the server
    // We just return it as is from the cache store.
    if val, err := c.Get(r); err == nil {
        fmt.Println(&quot;Fetching the response from the cache&quot;)
        return cachedResponse([]byte(val), r)
    }

    // Ok, we don't have the response cached, the store was probably cleared.
    // Make the request to the server.
    resp, err := c.originalTransport.RoundTrip(r)

    if err != nil {
        return nil, err
    }

    // Get the body of the response so we can save it in the cache for the next request.
    buf, err := httputil.DumpResponse(resp, true)

    if err != nil {
        return nil, err
    }

    // Saving it to the cache store
    c.Set(r, string(buf))

    fmt.Println(&quot;Fetching the data from the real source&quot;)
    return resp, nil
}

func (c *cacheTransport) Clear() error {
    c.mu.Lock()
    defer c.mu.Unlock()

    c.data = make(map[string]string)
    return nil
}

func cachedResponse(b []byte, r *http.Request) (*http.Response, error) {
    buf := bytes.NewBuffer(b)
    return http.ReadResponse(bufio.NewReader(buf), r)
}

func newTransport() *cacheTransport {
    return &amp;cacheTransport{
        data:              make(map[string]string),
        originalTransport: http.DefaultTransport,
    }
}
</code></pre>

<p>具体的原理可以查看http客户端的使用原理。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-net-http-httputil/">https://kingjcy.github.io/post/golang/go-net-http-httputil/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags//">
                            <i class="fa fa-tags"></i>
                            
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/go-unsafe/">Go Unsafe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-text/">Go Text</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-plugin/">Go Plugin</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-mine/">Go Mine</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-internal/">Go Internal</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-index/">Go Index</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-image/">Go Image</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-html/">Go Html</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-hash/">Go Hash</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-go/">Go Go</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/golang/go-proxy/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/golang/go-net-http-cgi/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#代理">代理</a>
<ul>
<li><a href="#roundtripper-is-an-interface-representing-the-ability-to-execute-a-single-http-transaction-obtaining-the-response-for-a-given-request">RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

