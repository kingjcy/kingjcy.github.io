<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="os/signal包实现对信号的处理">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Go Signal - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Go Signal
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2016年09月12日 
                </div>
                <h1 class="post-title">Go Signal</h1>
            </header>

            <div class="post-content">
                <p>os/signal包实现对信号的处理</p>

<p>Golang 的系统信号处理主要涉及os包、os.signal包以及syscall包。golang中对信号的处理主要使用os/signal包中的两个方法：一个是notify方法用来监听收到的信号；一个是 stop方法用来取消监听。</p>

<p>其中监听信号最主要的函数是signal包中的Notify函数：</p>

<pre><code>func Notify(c chan&lt;- os.Signal, sig …os.Signal)
</code></pre>

<p>该函数会将进程收到的系统Signal转发给channel c。转发哪些信号由该函数的可变参数决定，如果你没有传入sig参数，那么Notify会将系统收到的所有信号转发给c。如果你像下面这样调用Notify：</p>

<pre><code>signal.Notify(c, syscall.SIGINT, syscall.SIGUSR1, syscall.SIGUSR2)
</code></pre>

<p>取消监听主要用stop方法：</p>

<pre><code>func Stop(c chan&lt;- os.Signal)

func main() {
    c := make(chan os.Signal, 0)
    signal.Notify(c)

    signal.Stop(c) //不允许继续往c中存入内容
    s := &lt;-c       //c无内容，此处阻塞，所以不会执行下面的语句，也就没有输出
    fmt.Println(&quot;Got signal:&quot;, s)
}
</code></pre>

<p>由于signal存入channel中，所以可以利用channel特性，通过select针对不同的signal使得系统或者进程执行不同的操作．</p>

<p>高级使用实例</p>

<p>//signal.go</p>

<pre><code>package main

import &quot;fmt&quot;
import &quot;time&quot;
import &quot;os&quot;
import &quot;os/signal&quot;
import &quot;syscall&quot;

type signalHandler func(s os.Signal, arg interface{})

type signalSet struct {
    m map[os.Signal]signalHandler
}

func signalSetNew()(*signalSet){
    ss := new(signalSet)
    ss.m = make(map[os.Signal]signalHandler)
    return ss
}

func (set *signalSet) register(s os.Signal, handler signalHandler) {
    if _, found := set.m[s]; !found {
        set.m[s] =  handler
    }
}

func (set *signalSet) handle(sig os.Signal, arg interface{})(err error) {
    if _, found := set.m[sig]; found {
        set.m[sig](sig, arg)
        return nil
    } else {
        return fmt.Errorf(&quot;No handler available for signal %v&quot;, sig)
    }

    panic(&quot;won't reach here&quot;)
}

func main() {
    go sysSignalHandleDemo()
    time.Sleep(time.Hour) // make the main goroutine wait!
}

func sysSignalHandleDemo() {
    ss := signalSetNew()
    handler := func(s os.Signal, arg interface{}) {
        fmt.Printf(&quot;handle signal: %v\n&quot;, s)
    }

    ss.register(syscall.SIGINT, handler)
    ss.register(syscall.SIGUSR1, handler)
    ss.register(syscall.SIGUSR2, handler)

    for {
        c := make(chan os.Signal)
        var sigs []os.Signal
        for sig := range ss.m {
            sigs = append(sigs, sig)
        }
        signal.Notify(c)
        sig := &lt;-c

        err := ss.handle(sig, nil)
        if (err != nil) {
            fmt.Printf(&quot;unknown signal received: %v\n&quot;, sig)
            os.Exit(1)
        }
    }
}
</code></pre>

<p>上例中Notify函数只有一个参数，没有传入要关注的sig，因此程序会将收到的所有类型Signal都转发到channel c中。build该源文件并执行程序：</p>

<pre><code>$&gt; go build signal.go
$&gt; signal
</code></pre>

<p>在另外一个窗口下执行如下命令：</p>

<pre><code>$&gt; ps -ef|grep signal
tonybai  25271  1087  0 16:27 pts/1    00:00:00 signal
$&gt; kill -n 2 25271
$&gt; kill -n 12 25271
$&gt; kill 25271
</code></pre>

<p>我们在第一个窗口会看到如下输出：</p>

<pre><code>$&gt; signal
handle signal: interrupt
handle signal: user defined signal 2
unknown signal received: terminated
</code></pre>

<p>在sysSignalHandleDemo中我们也可以为Notify传入我们所关注的Signal集合：</p>

<pre><code>signal.Notify(c, sigs…)
</code></pre>

<p>这样只有在该集合中的信号我们才能捕获，收到未在集合中的信号时，程序多直接退出。上面只是一个Demo，只是说明了我们可以捕捉到我们所关注的信号，并未体现程序如何优雅退出，不同程序的退出方式不同，这里没有通用方法，就不细说了，你的程序需要你专门的设计。</p>

<p>这边我们经常使用的优雅的推出进程</p>

<pre><code>SIGHUP
1
Term
终端控制进程结束(终端连接断开)


SIGINT
2
Term
用户发送INTR字符(Ctrl+C)触发


SIGQUIT
3
Core
用户发送QUIT字符(Ctrl+/)触发


SIGILL
4
Core
非法指令(程序错误、试图执行数据段、栈溢出等)


SIGABRT
6
Core
调用abort函数触发


SIGFPE
8
Core
算术运行错误(浮点运算错误、除数为零等)


SIGKILL
9
Term
无条件结束程序(不能被捕获、阻塞或忽略)


SIGSEGV
11
Core
无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)


SIGPIPE
13
Term
消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)


SIGALRM
14
Term
时钟定时信号


SIGTERM
15
Term
结束程序(可以被捕获、阻塞或忽略)


SIGUSR1
30,10,16
Term
用户保留


SIGUSR2
31,12,17
Term
用户保留


SIGCHLD
20,17,18
Ign
子进程结束(由父进程接收)


SIGCONT
19,18,25
Cont
继续执行已经停止的进程(不能被阻塞)


SIGSTOP
17,19,23
Stop
停止进程(不能被捕获、阻塞或忽略)


SIGTSTP
18,20,24
Stop
停止进程(可以被捕获、阻塞或忽略)


SIGTTIN
21,21,26
Stop
后台程序从终端中读取数据时触发


SIGTTOU
22,22,27
Stop
后台程序向终端中写数据时触发
</code></pre>

<p>在SUSv2和POSIX.1-2001标准中的信号列表:</p>

<pre><code>SIGTRAP
5
Core
Trap指令触发(如断点，在调试器中使用)


SIGBUS
0,7,10
Core
非法地址(内存地址对齐错误)


SIGPOLL

Term
Pollable event (Sys V). Synonym for SIGIO


SIGPROF
27,27,29
Term
性能时钟信号(包含系统调用时间和进程占用CPU的时间)


SIGSYS
12,31,12
Core
无效的系统调用(SVr4)


SIGURG
16,23,21
Ign
有紧急数据到达Socket(4.2BSD)


SIGVTALRM
26,26,28
Term
虚拟时钟信号(进程占用CPU的时间)(4.2BSD)


SIGXCPU
24,24,30
Core
超过CPU时间资源限制(4.2BSD)


SIGXFSZ
25,25,31
Core
超过文件大小资源限制(4.2BSD)
</code></pre>

<p>应用程序如何优雅退出</p>

<p>Linux Server端的应用程序经常会长时间运行，在运行过程中，可能申请了很多系统资源，也可能保存了很多状态，在这些场景下，我们希望进程在退出前，可以释放资源或将当前状态dump到磁盘上或打印一些重要的日志，也就是希望进程优雅退出（exit gracefully）。</p>

<p>从上面的介绍不难看出，优雅退出可以通过捕获SIGTERM来实现。具体来讲，通常只需要两步动作：
1）注册SIGTERM信号的处理函数并在处理函数中做一些进程退出的准备。信号处理函数的注册可以通过signal()或sigaction()来实现，其中，推荐使用后者来实现信号响应函数的设置。信号处理函数的逻辑越简单越好，通常的做法是在该函数中设置一个bool型的flag变量以表明进程收到了SIGTERM信号，准备退出。
2）在主进程的main()中，通过类似于while(!bQuit)的逻辑来检测那个flag变量，一旦bQuit在signal handler function中被置为true，则主进程退出while()循环，接下来就是一些释放资源或dump进程当前状态或记录日志的动作，完成这些后，主进程退出。</p>

<p>Go中的Signal发送和处理</p>

<p>golang中对信号的处理主要使用os/signal包中的两个方法：</p>

<pre><code>notify方法用来监听收到的信号
stop方法用来取消监听
</code></pre>

<p>1.监听全部信号</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
)

// 监听全部信号
func main()  {
    //合建chan
    c := make(chan os.Signal)
    //监听所有信号
    signal.Notify(c)
    //阻塞直到有信号传入
    fmt.Println(&quot;启动&quot;)
    s := &lt;-c
    fmt.Println(&quot;退出信号&quot;, s)
}
</code></pre>

<p>启动</p>

<pre><code>go run example-1.go
启动

ctrl+c退出,输出
退出信号 interrupt

kill pid 输出
退出信号 terminated
</code></pre>

<p>2.监听指定信号</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
)

// 监听指定信号
func main()  {
    //合建chan
    c := make(chan os.Signal)
    //监听指定信号 ctrl+c kill
    signal.Notify(c, os.Interrupt, os.Kill, syscall.SIGUSR1, syscall.SIGUSR2)
    //阻塞直到有信号传入
    fmt.Println(&quot;启动&quot;)
    //阻塞直至有信号传入
    s := &lt;-c
    fmt.Println(&quot;退出信号&quot;, s)
}
</code></pre>

<p>启动</p>

<pre><code>go run example-2.go
启动

ctrl+c退出,输出
退出信号 interrupt

kill pid 输出
退出信号 terminated

kill -USR1 pid 输出
退出信号 user defined signal 1

kill -USR2 pid 输出
退出信号 user defined signal 2
</code></pre>

<p>3.优雅退出go守护进程</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
    &quot;time&quot;
)

// 优雅退出go守护进程
func main()  {
    //创建监听退出chan
    c := make(chan os.Signal)
    //监听指定信号 ctrl+c kill
    signal.Notify(c, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGUSR1, syscall.SIGUSR2)
    go func() {
        for s := range c {
            switch s {
            case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:
                fmt.Println(&quot;退出&quot;, s)
                ExitFunc()
            case syscall.SIGUSR1:
                fmt.Println(&quot;usr1&quot;, s)
            case syscall.SIGUSR2:
                fmt.Println(&quot;usr2&quot;, s)
            default:
                fmt.Println(&quot;other&quot;, s)
            }
        }
    }()

    fmt.Println(&quot;进程启动...&quot;)
    sum := 0
    for {
        sum++
        fmt.Println(&quot;sum:&quot;, sum)
        time.Sleep(time.Second)
    }
}

func ExitFunc()  {
    fmt.Println(&quot;开始退出...&quot;)
    fmt.Println(&quot;执行清理...&quot;)
    fmt.Println(&quot;结束退出...&quot;)
    os.Exit(0)
}



kill -USR1 pid 输出
usr1 user defined signal 1

kill -USR2 pid 
usr2 user defined signal 2

kill pid 
退出 terminated
开始退出...
执行清理...
结束退出...
</code></pre>

<p>执行输出</p>

<pre><code>go run example-3.go
进程启动...
sum: 1
sum: 2
sum: 3
sum: 4
sum: 5
sum: 6
sum: 7
sum: 8
sum: 9
usr1 user defined signal 1
sum: 10
sum: 11
sum: 12
sum: 13
sum: 14
usr2 user defined signal 2
sum: 15
sum: 16
sum: 17
退出 terminated
开始退出...
执行清理...
结束退出...
</code></pre>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-signal/">https://kingjcy.github.io/post/golang/go-signal/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/signal/">
                            <i class="fa fa-tags"></i>
                            signal
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/middleware/network/ip/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/architecture/sso/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

