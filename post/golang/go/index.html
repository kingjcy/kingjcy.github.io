<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="学习使用go语言已经有一段时间了，积累了很多的经验，这边进行不断接触的知识点进行零散的整理并持续积累，也便于后期的备忘。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="golang使用系列---- go基本使用积累 - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    golang使用系列---- go基本使用积累
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
			<li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/categories/">归档</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="https://kingjcy.github.io/"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年03月23日 
                </div>
                <h1 class="post-title">golang使用系列---- go基本使用积累</h1>
            </header>

            <div class="post-content">
                <p>学习使用go语言已经有一段时间了，积累了很多的经验，这边进行不断接触的知识点进行零散的整理并持续积累，也便于后期的备忘。</p>

<h1 id="为什么使用go">为什么使用go？</h1>

<pre><code>1、相对于c/c++开发来说，go的封装和丰富的标准库，极大的提高了开发的效率。基本的服务端开发都可以使用golang来开发。
2、go的编译和执行效率相对来说很快，部署也很简单
3、go原生支持高并发这块也是很优秀的。
</code></pre>

<p>主要使用领域：微服务解决方案（istio），云平台（k8s），web服务（各种web框架，http原生支持并发）&mdash;服务端（高并发），区块链，分布式（存储，推送系统）</p>

<p>Go语言的三位最初的缔造者 — Rob Pike、Robert Griesemer 和 Ken Thompson 中，Robert Griesemer 参与设计了Java的HotSpot虚拟机和Chrome浏览器的JavaScript V8引擎，Rob Pike 在大名鼎鼎的bell lab侵淫多年，参与了Plan9操作系统、C编译器以及多种语言编译器的设计和实现，Ken Thompson 更是图灵奖得主、Unix之父、C语言之父。这三人在计算机史上可是元老级别的人物，特别是 Ken Thompson ，是一手缔造了Unix和C语言计算机领域的上古大神，所以Go语言的设计哲学有着深深的Unix烙印：简单、模块化、正交、组合、pipe、功能短小且聚焦等；而令许多开发者青睐于Go的简洁、高效编程模式的原因，也正在于此。</p>

<h1 id="语言设计">语言设计</h1>

<ol>
<li><p>传统的面向过程的语言开发，编译器其中最最基础和原始的目标之一就是把一份代码里的函数名称，转化成一个相对内存地址，把调用这个函数的语句转换成一个jmp跳转指令。在程序开始运行时候，调用语句可以正确跳转到对应的函数地址。直白，但是。。。太死板了</p></li>

<li><p>我们希望灵活，于是需要开发面向对象的语言,c++在c的基础上增加了类的部分,就是让编译器多绕个弯，在严格的c编译器上增加一层类处理的机制，把一个函数限制在它处在的class环境里，每次请求一个函数调用，先找到它的对象, 其类型,返回值，参数等等，确定了这些后再jmp跳转到需要的函数。这样很多程序增加了灵活性同样一个函数调用会根据请求参数和类的环境返回完全不同的结果。增加类机制后，就模拟了现实世界的抽象模式，不同的对象有不同的属性和方法。同样的方法，不同的类有不同的行为,还是死板, 我们仍然叫c++是static language。</p></li>

<li><p>runtime环境注册所有全局的类，函数，变量等等信息等等，我们可以无限的为这个层增加必要的功能。调用函数时候，会先从这个运行时环境里检测所以可能的参数再做jmp跳转，这就是runtime。编译器开发起来比上面更加弯弯绕。但是这个层极大增加了程序的灵活性。</p></li>
</ol>

<p>尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime
包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。</p>

<p>runtime 主要由 C 语言编写（Go 1.5 开始自举），并且是每个 Go 包的最顶级包。你可以在目录
$GOROOT/src/runtime 中找到相关内容。</p>

<h1 id="基础语法">基础语法</h1>

<p>go语言的所有源代码都必须由unicode编码规范的UTF-8编码格式进行编码。下面是基础语法。</p>

<h2 id="变量">变量</h2>

<p>1.用关键字var来声明</p>

<p>2.可以类型判断</p>

<pre><code>var i = 10支持多返回值，改进了c中笨拙的语言风格
</code></pre>

<p>3.支持多重赋值</p>

<pre><code>var width, height int = 100, 50 // 声明多个变量
i，j = j，i这样就完成了交换。
</code></pre>

<p>4.可以直接用:=这个服务声明初始化，但必须不是声明过的。</p>

<pre><code>a := 10类似于
var i int
i = 10；
</code></pre>

<p>5.:= 符号不能使用在函数外，在函数外必须要var进行声明。</p>

<p>6.像err这种可以重复使用:=来定义，即使被声明过，但是要满足以下条件：</p>

<ul>
<li>该变量在一个作用域内</li>
<li>初始化中相应的值是可以赋给这个变量的</li>
<li>声明中至少有一个其他的变量是被声明的新的变量</li>
</ul>

<p>7.支持匿名变量</p>

<pre><code>func getname（）（firstname,lastname,nickname）{
}

调用可以用_来表达我们不想要的变量---&gt;_,_,nickname := getname();
</code></pre>

<h2 id="常量">常量</h2>

<p>1.iota 一个特殊的常量，出现一次自动加一，当出现const的时候会自动置零</p>

<pre><code>const (
    A = iota    //0
    B           //1
    C = &quot;a&quot;     //a
    D           //a
    E = iota    //4
    F           //5
)
</code></pre>

<p>2.常量不能使用 := 语法定义</p>

<p>3.枚举类型不需要enum</p>

<p>正常定义</p>

<pre><code>const（
    Sunday = iota
    monday
)
</code></pre>

<p>其中的大写字母开头的在包外可用，小写字母开头的包内私有</p>

<p>我们可以使用下划线跳过不想要的值。</p>

<pre><code>type AudioOutput int

const (
    OutMute AudioOutput = iota // 0
    OutMono                    // 1
    OutStereo                  // 2
    _
    _
    OutSurround                // 5
)
</code></pre>

<p>4.常量的定义格式:</p>

<pre><code>const identifier [type] = value
[type]类型可以省略,编译器可以根据变量的值来推断其类型.
 显示类型 const b string = &quot;abc&quot;
 隐式类型 const b = &quot;abc&quot;
</code></pre>

<h2 id="运算符">运算符</h2>

<p>Go 编程语言支持以下按位运算符：</p>

<pre><code>&amp;   bitwise AND
 |   bitwise OR
 ^   bitwise XOR
&amp;^   AND NOT
&lt;&lt;   left shift
&gt;&gt;   right shift
</code></pre>

<blockquote>
<p>&amp; 运算符</p>
</blockquote>

<p>在 Go 中， &amp; 运算符在两个整型操作数中执行按位 AND 操作。AND 操作具有以下属性，只要有一个失败就是false:</p>

<pre><code>func main() {
    var x uint8 = 0xAC    // x = 10101100
    x = x &amp; 0xF0          // x = 10100000
}
</code></pre>

<p>所有的位运算都支持简写的赋值形式。 例如，前面的例子可以重写为如下。</p>

<pre><code>func main() {
    var x uint8 = 0xAC    // x = 10101100
    x &amp;= 0xF0             // x = 10100000
}
</code></pre>

<p>另外一个巧妙的技巧是：你可以用 &amp; 操作去测试一个数字是奇数还是偶数。原因是当一个数字的二进制的最低位是 1 的时候，那他就是奇数。我们可以用一个数字和 1 进行 &amp; 操作，如果的到的结果是 1 ，那么这个原始的数字就是奇数</p>

<pre><code>import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
)
func main() {
    for x := 0; x &lt; 100; x+&gt;{
        num := rand.Int()
        if num&amp;1 == 1 {
            fmt.Printf(&quot;%d is odd\n&quot;, num)
        } else {
            fmt.Printf(&quot;%d is even\n&quot;, num)
        }
    }
}
</code></pre>

<blockquote>
<p>| 操作符</p>
</blockquote>

<p>| 对其整型操作数执行按位或操作。回想一下或（OR）操作符具备以下性质，只有有一个成立就是true：</p>

<pre><code>func main() {
    var a uint8 = 0
    a |= 196
    fmt.Printf(&quot;%b&quot;, a)
}

// 打印结果  11000100
</code></pre>

<p>在使用位掩码技术为给定的整型数字设置任意位时，或运算非常有用。</p>

<blockquote>
<p>位运算的配置用法</p>
</blockquote>

<p>我们可以结合使用 OR 和 AND 运算的方式来分别设置和读取某位的配置值。接下来的源码片段演示了这个操作。函数 procstr 会转换字符串的内容。它需要两个参数：第一个， str，是将要被转换的字符串，第二个， conf，是一个使用位掩码的方式指定多重转换配置的整数。</p>

<pre><code>const (
    UPPER  = 1 // 大写字符串
    LOWER  = 2 // 小写字符串
    CAP    = 4 // 字符串单词首字母大写
    REV    = 8 // 反转字符串
)

func main() {
    fmt.Println(procstr(&quot;HELLO PEOPLE!&quot;, LOWER|REV|CAP))
}

func procstr(str string, conf byte) string {
    // 反转字符串
    rev := func(s string) string {
        runes := []rune(s)
        n := len(runes)
        for i := 0; i &lt; n/2; i+&gt;{
            runes[i], runes[n-1-i] = runes[n-1-i], runes[i]
        }
        return string(runes)
    }

    // 查询配置中的位操作
    if (conf &amp; UPPER) != 0 {
        str = strings.ToUpper(str)
    }
    if (conf &amp; LOWER) != 0 {
        str = strings.ToLower(str)
    }
    if (conf &amp; CAP) != 0 {
        str = strings.Title(str)
    }
    if (conf &amp; REV) != 0 {
        str = rev(str)
    }
    return str
}
</code></pre>

<p>上面的 procstr(&ldquo;HELLO PEOPLE!&rdquo;, LOWER|REV|CAP) 方法会把字符串变成小写，然后反转字符串，最后把字符串里面的单词首字母变成大写。这个功能是通过设置 conf 里的第二，三，四位的值为 14 来完成的。然后代码使用连续的 if 语句块来获取这些位操作进行对应的字符串转换。</p>

<blockquote>
<p>^ 操作符</p>
</blockquote>

<p>在 Go 中 按位 异或 操作是用 ^ 来表示的。 异或运算符有如下的特点，相同为false，相异为true，也叫不进位加法：</p>

<pre><code>func main() {
    var a uint16 = 0xCEFF
    a ^= 0xFF00 // same a = a ^ 0xFF00
}

// a = 0xCEFF   (11001110 11111111)
// a ^=0xFF00   (11001110 11111111 + 1111111100000000 = 00110001 11111111)
</code></pre>

<p>在前面的代码片段中，与 1 进行异或的位被翻转（从 0 到 1 或从 1 到 0）。</p>

<p>异或 运算的一个实际用途，例如，可以利用 异或运算去比较两个数字的符号是否一样。当 (a ^ b) ≥ 0 （或相反符号的 (a ^ b) &lt; 0 ）为 true 的时候，两个整数 a，b 具有相同的符号，如下面的程序所示：</p>

<pre><code>func main() {
    a, b := -12, 25
    fmt.Println(&quot;a and b have same sign?&quot;, (a ^ b) &gt;= 0)
}
</code></pre>

<p>当执行上面这个程序的时候，将会打印出：a and b have same sign? false。</p>

<p>^ 作为取反位运算符 （非）</p>

<p>不像其他语言 （c/c++，Java，Python，Javascript等可能使用～取反）， Go 没有专门的一元取反位运算符。取而代之的是，XOR 运算符 ^，也可作为一元取反运算符作用于一个数字。对于给定位 x，在 Go 中 x = 1 ^ x 可以翻转该位。在以下的代码段中我们可以看到使用 ^a 获取变量 a 的取反值的操作。</p>

<pre><code>func main() {
    var a byte = 0x0F
    fmt.Printf(&quot;%08b\n&quot;, a)
    fmt.Printf(&quot;%08b\n&quot;, ^a)
}

// 打印结果
00001111     // var a
11110000     // ^a
</code></pre>

<blockquote>
<p>&amp;^ 操作符</p>
</blockquote>

<p>&amp;^ 操作符意为 与非，是 与 和 非 操作符的简写形式，也就是先与操作再非操作。</p>

<p>接下来的代码片段使用 AND NOT 操作符，将变量值 1010 1011 变为 1010 0000，清除了操作数上的低四位。</p>

<pre><code>func main() {
    var a byte = 0xAB
     fmt.Printf(&quot;%08b\n&quot;, a)
     a &amp;^= 0x0F
     fmt.Printf(&quot;%08b\n&quot;, a)
}

// 打印：
10101011
10100000
</code></pre>

<blockquote>
<p>&lt;&lt;和&gt;&gt; 操作符</p>
</blockquote>

<p>与其他 C 的衍生语言类似， Go 使用 &lt;&lt; 和 &gt;&gt; 来表示左移运算符和右移运算符，如下所示：</p>

<pre><code>Given integer operands a and n,
a &lt;&lt; n; shifts all bits in a to the left n times
a &gt;&gt; n; shifts all bits in a to the right n times
</code></pre>

<p>例如，在下面的代码片段中变量 a （00000011）的值将会左移位运算符分别移动三次。每次输出结果都是为了说明左移的目的。</p>

<pre><code>func main() {
    var a int8 = 3
    fmt.Printf(&quot;%08b\n&quot;, a)
    fmt.Printf(&quot;%08b\n&quot;, a&lt;&lt;1)
    fmt.Printf(&quot;%08b\n&quot;, a&lt;&lt;2)
    fmt.Printf(&quot;%08b\n&quot;, a&lt;&lt;3)
}

// 输出的结果:
00000011
00000110
00001100
00011000
</code></pre>

<p>注意每次移动都会将低位右侧补零。相对应，使用右移位操作符进行运算时，每个位均向右方移动，空出的高位补零，如下示例 （有符号数除外，参考下面的算术移位注释）。</p>

<pre><code>func main() {
 var a uint8 = 120
 fmt.Printf(&quot;%08b\n&quot;, a)
 fmt.Printf(&quot;%08b\n&quot;, a&gt;&gt;1)
 fmt.Printf(&quot;%08b\n&quot;, a&gt;&gt;2)
}

// 打印：
01111000
00111100
00011110
</code></pre>

<p>可以利用左移和右移运算中，每次移动都表示一个数的 2 次幂这个特性，来作为某些乘法和除法运算的小技巧。例如，如下代码中，我们可以使用右移运算将 200（存储在变量 a 中）除以 2 。</p>

<pre><code>func main() {
    a := 200
    fmt.Printf(&quot;%d\n&quot;, a&gt;&gt;1)
}

// 打印：
100
</code></pre>

<p>或是通过左移 2 位，将一个数乘以 4：</p>

<pre><code>func main() {
    a := 12
    fmt.Printf(&quot;%d\n&quot;, a&lt;&lt;2)
}
// 打印：

48
</code></pre>

<p>位移运算符提供了有趣的方式处理二进制值中特定位置的值。例如，下列的代码中，| 和 &lt;&lt; 用于设置变量 a 的第三个 bit 位。</p>

<pre><code>func main() {
    var a int8 = 8
    fmt.Printf(&quot;%08b\n&quot;, a)
    a = a | (1&lt;&lt;2)
    fmt.Printf(&quot;%08b\n&quot;, a)
}
// prints:
00001000
00001100
</code></pre>

<p>或者，您可以组合位移运算符和 &amp; 测试是否设置了第 n 位，如下面示例所示：</p>

<pre><code>func main() {
    var a int8 = 12
    if a&amp;(1&lt;&lt;2) != 0 {
        fmt.Println(&quot;take action&quot;)
    }
}

// 打印:
take action
</code></pre>

<p>使用 &amp;^ 和位移运算符，我们可以取消设置一个值的某个位。例如，下面的示例将变量 a 的第三位置为 0 ：</p>

<pre><code>func main() {
    var a int8 = 13
    fmt.Printf(&quot;%04b\n&quot;, a)
    a = a &amp;^ (1 &lt;&lt; 2)
    fmt.Printf(&quot;%04b\n&quot;, a)
}

// 打印:
1101
1001
</code></pre>

<p>当要位移的值（左操作数）是有符号值时，Go 自动应用算术位移。在右移操作期间，复制（或扩展）二进制补码符号位以填充位移的空隙。</p>

<blockquote>
<p>总结</p>
</blockquote>

<p>与其它现代运算符一样，Go 支持所有二进制位操作运算符。这篇文章仅仅提供了可以用这些操作符完成的各种黑科技示例。你可以在网络上找到很多文章，特别是 Sean Eron Anderson写的 Bit Twiddling Hacks。</p>

<h2 id="数组">数组</h2>

<p>数组其实是一段连续的内存，通过唯一索引下标（由于地址也是连续的，所以下标根据地址循序来就行，不需要存）来获取对应内存的值。</p>

<p>1、Go语言的数组不同于C语言或者其他语言的数组，C语言的数组变量是指向数组第一个元素的指针；而Go语言的数组是一个值，Go语言中的数组是值类型，一个数组变量就表示着整个数组，意味着Go语言的数组在传递的时候，传递的是原数组的拷贝。
重点是值类型，每次传参都是一个副本，要传址，需要用数组切片</p>

<p>2、遍历数组元素，除了用下标，也可以用关键字range，有两个返回值，一个是下标，一个是value,在对strings进行遍历的时候一个是下标，一个是ACSII</p>

<pre><code>var a [10]int  

var a = [10]int{0,1,2,3,4,5,6,7,8,9}  
var a = [...]int{0,1,2,3,4,5,6,7,8,9}  

var a = [2][2]int{[2]int{1,1}, [2]int{2,2}}  
var a = [2][2]int{{1,1}, {2,2}}  
</code></pre>

<p>3、Golang动态数组</p>

<p>数组申明</p>

<pre><code>var dynaArr []string
</code></pre>

<p>动态添加成员</p>

<pre><code>dynaArr = append(dynaArr, &quot;one&quot;)
</code></pre>

<p>这边讲解一下append</p>

<pre><code>就是将后面一个值拷贝一份到前面，如果是值就拷贝值，如果是地址就拷贝地址，所以当是地址的时候，源数据发现变化，append后的数据也会发生变化，变成重复的，所以传地址最好每次重新定义一个实例，或者就不要传输地址，定义一个实例就好。
</code></pre>

<p>实例</p>

<pre><code>package main

import  (
    &quot;fmt&quot;
)

func main() {

    var dynaArr []string

    dynaArr = append(dynaArr, &quot;one&quot;)
    dynaArr = append(dynaArr, &quot;two&quot;)
    dynaArr = append(dynaArr, &quot;three&quot;)

    fmt.Println(dynaArr)
}
</code></pre>

<p>下面这个输出是0，0，0，0，0，1，2，3,可见初始化的也是占空间的，所以赋值需要make</p>

<pre><code>func main() {
    s := make([]int, 5)
    s = append(s, 1, 2, 3)
    fmt.Println(s)
}
</code></pre>

<p>4、结构体数组</p>

<pre><code>package main

import  (
    &quot;fmt&quot;
)

type A struct{
    Path    string
    Length  int 
}


func main() {

    var dynaArr []A


    t := A{&quot;/tmp&quot;, 1023}

    dynaArr = append(dynaArr, t)
    dynaArr = append(dynaArr, A{&quot;~&quot;, 2048})
    t.Path, t.Length = &quot;/&quot;, 4096
    dynaArr = append(dynaArr, t)

    fmt.Println(dynaArr)
}
</code></pre>

<p>注意大小写，大写为公有，小写为私有</p>

<p>5、数组切片</p>

<p>切片是一个很小的对象，是对数组进行了抽象，并提供相关的操作方法。切片有三个属性字段：长度、容量和指向数组的指针。</p>

<p><img src="/media/golang/go/slice_1.png" alt="" /></p>

<p>上图中，ptr指的是指向array的pointer，len是指切片的长度, cap指的是切片的容量。现在，我想你对数组和切片有了一个本质的认识。</p>

<p>切片是数组的指针管理，数组就是存储数据的</p>

<pre><code>items := make([]interface{}, 0, len(proxyInfos))
</code></pre>

<p>items只是一个指针，当给他一个新地址的时候，就会指向新的空间，原来的对象在函数执行完以后，GC 就可以工作，把对象释放掉，但是如果像slice删除这种操作</p>

<pre><code>return append(slice[:i], slice[i+1:]...)
</code></pre>

<p>还是指向原来的数组的地址，就可以读取到这个地址下分配的所有空间，就会出现数据多余的情况，所以只要把slice当成指针就很好理解了。</p>

<p>切记：slice是一个指针</p>

<p>创建</p>

<pre><code>1、在一个数组的基础上用[:]来创建--golang slice对数组是址引用，同用一个地址空间，slice变化时，原数组是发生变化的。slice基于数组建立的也是一种引用，当slice改变的时候，原来的数组也会变化，但是当slice空间翻倍了，就会重新开辟一片空间，就不会互相影响变化了

2、直接用make函数创建

创建一个初始元素个数为5的数组切片，元素初始值为0：
    mySlice1 := make([] int, 5)
创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间：
    mySlice2 := make([] int, 5, 10)
直接创建并初始化包含5个元素的数组切片：
    mySlice3 := [] int{1, 2, 3, 4, 5}
</code></pre>

<p>求数组长度的函数区别</p>

<pre><code>cap():分配的空间
len()：所占的元素，实际数据的长度
copy()：复制，以小的为准
</code></pre>

<p>切片优点</p>

<p>可以动态增减元素，原始数组增减数据是要重新分配内存，然后将数据搬过去，这样比较消耗性能，但是数据切片则可以用cap（）知道分配的空间，然后充分利用，而后在内存不够会自动扩大内存。</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    a := make([]byte,2)
    b := make([]byte,4)

    c := []byte{1,2,3,4}
    b = c
    a = c

    fmt.Println(a,b,len(a),len(b),cap(a),cap(b))
}

$ go run slicedistribution.go
[1 2 3 4] [1 2 3 4] 4 4 4 4
</code></pre>

<p>通常我们我们还使用append，不用make来指定内存大小，直接在使用的时候就可以自动分配。</p>

<p>切片扩容请记住以下两条规则：</p>

<pre><code>如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。
如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。
</code></pre>

<p>实际上还有更加复杂的其他规则</p>

<pre><code>append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程，不足1024，双倍扩容，超过1024的，1.25倍扩容。
若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。
敲重点！！！！此外，以上两个分支得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况capmem，然后再进行capmem向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。
</code></pre>

<p>最大值</p>

<pre><code>slice的最大空间也是有限制的：The elements can be addressed by integer indices 0 through len(s)-1。这意味着 slice 的最大容量是目标版本上默认整数的大小。
</code></pre>

<p>关于切片的比较</p>

<pre><code>切片之间不允许比较。切片只能与nil值比较。
map之间不允许比较。map只能与nil值比较。
</code></pre>

<p>那怎么比较切片</p>

<pre><code>reflect比较的方法
func StringSliceReflectEqual(a, b []string) bool {
    return reflect.DeepEqual(a, b)
}

循环遍历比较的方法
func StringSliceEqual(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }

    if (a == nil) != (b == nil) {
        return false
    }

    for i, v := range a {
        if v != b[i] {
            return false
        }
    }

    return true
}
</code></pre>

<p>6、slice基本操作增删改查：</p>

<p>删除</p>

<pre><code>func remove(slice []interface{}, i int) []interface{} {
    //    copy(slice[i:], slice[i+1:])
    //    return slice[:len(slice)-1]
    return append(slice[:i], slice[i+1:]...)
}


获取新值的时候，必须使用append后的值来赋值，虽然slice是引用，原来的值删除是使用append，最后一个值还是存在的，这样就会出现最后的值一直重复，大小不变。
</code></pre>

<p>循环删除</p>

<pre><code>由于每次删除后对应的数组是变化的，并不是保持原来的遍历，所以最好不要使用range，使用i来控制，如下

chars := []string{&quot;a&quot;, &quot;a&quot;, &quot;b&quot;}

for i := 0; i &lt; len(chars); i+&gt;{
    if chars[i] == &quot;a&quot; {
        chars = append(chars[:i], chars[i+1:]...)
        i-- // form the remove item index to start iterate next item
    }
}

fmt.Printf(&quot;%+v&quot;, chars)
</code></pre>

<p>一个关于下标的问题</p>

<pre><code>当数据循环到最后一个数据的时候会不会out of range--不会


func main() {
    var a = [10]int{0,1,2,3,4,5,6,7,8,9}

    b := a[1:5]

    b[1] = 10


    fmt.Println(a)

    fmt.Println(b)

    c := append(a[:9],a[10:]...)
    fmt.Println(c)
    fmt.Println(a[10:])

}


chunyindeMacBook-Pro:test chunyinjiang$ go run array.go
[0 1 10 3 4 5 6 7 8 9]
[1 10 3 4]
[0 1 10 3 4 5 6 7 8]
[]

slice切片包含前面的下标不包含后面的指标，最大下标可以是数组的数量，也就是比下标大一，所以上面的a[10:]不会出错，但是a[10]是不对的，a[11:]也是不对的
</code></pre>

<p>新增</p>

<pre><code>func add(slice []interface{}, value interface{}) []interface{} {
    return append(slice, value)
}
</code></pre>

<p>插入</p>

<pre><code>func insert(slice *[]interface{}, index int, value interface{}) {
    rear := append([]interface{}{}, (*slice)[index:]...)
    *slice = append(append((*slice)[:index], value), rear...)
}
</code></pre>

<p>修改</p>

<pre><code>func update(slice []interface{}, index int, value interface{}) {
    slice[index] = value
}
</code></pre>

<p>查找</p>

<pre><code>func find(slice []interface{}, index int) interface{} {
    return slice[index]
}
</code></pre>

<p>清空slice</p>

<pre><code>func empty(slice *[]interface{}) {
    //    *slice = nil
    *slice = append([]interface{}{})
}
</code></pre>

<p>遍历</p>

<pre><code>func list(slice []interface{}) {
    for _, v := range slice {
        fmt.Printf(&quot;%d &quot;, v)
    }
}
</code></pre>

<p>range slice是会获取到cap slice的所有的值，所以在遍历删除slice中的元素的时候，不要使用range，使用for正常的循环</p>

<p>7、注意点</p>

<ol>
<li><p>b[1:4]就生成了一个新切片，切片元素范围为1,2,3，不包括4.</p></li>

<li><p>切片并不是值拷贝，而是引用拷贝。对切片的操作就会影响到原始数组中的值</p></li>

<li><p>切片和数组的下标都是重0开始的。</p></li>

<li><p>cannot use []int literal (type []int) as type int in append</p>

<p>他会告诉你 正常的使用应该是int 类型而不是[]int 类型</p>

<pre><code>test = append(test, []int{5, 6, 7})
//正确的玩法 切记记得加 3个点
test = append(test, []int{5, 6, 7}...)
</code></pre></li>

<li><p>slice的引用</p>

<p>slice是引用类型，在内存中并没有属于自己的内存空间，而是通过指针指向进行切片的队列。由于队列分配的内存空间是连续的，所以如果slice的最后一个元素不是list的最后一个元素，那么在append的时候，新追加的元素就会覆盖掉原数组的元素。而由于slice是指针组织的，所以这个list的所有slice都会被影响。如果切片末尾元素就是队列的末尾元素，返回的 slice 数组指针将指向这个空间，而原数组的内容将保持不变，其它引用此数组的 slice 则不受影响。</p>

<p>Slice是引用类型，指向的都是内存中的同一块内存，不过在实际应用中，有的时候却会发生“意外”，这种情况只有在像切片append元素的时候出现，Slice的处理机制是这样的，当Slice的容量还有空闲的时候，append进来的元素会直接使用空闲的容量空间，但是一旦append进来的元素个数超过了原来指定容量值的时候，内存管理器就是重新开辟一个更大的内存空间，用于存储多出来的元素，并且会将原来的元素复制一份，放到这块新开辟的内存空间。可以看到执行了append操作如果扩容后，内存地址发生了变化，说明已经不是引用传递。</p></li>
</ol>

<p>这边对引用类型做一个总结，golang中有哪些是引用类型</p>

<pre><code>切片（slice）
字典（map）
通道（channel）
接口（interface）
</code></pre>

<p>8、数组和切片的对比</p>

<p>数组</p>

<p>在Go中，</p>

<pre><code>数组是值。将一个数组赋值给另一个，会拷贝所有的元素。 
特别是，如果你给函数传递一个数组，其将收到一个数组的拷贝，而不是它的指针。
数组的大小是其类型的一部分。类型 [10]int 和 [20]int 是不同的。
</code></pre>

<p>切片</p>

<p>切片持有对底层数组的引用，如果你将一个切片赋值给另一个，二者都将引用同一个数组。如果函数接受 一个切片参数，那么其对切片的元素所做的改动，对于调用者是可见的，好比是传递了一个底层数组的指 针。</p>

<p>关于接收者对指针和值 的规则是这样的，值方法可以在指针和值上进行调用，而指针方法只能在指针上调用。这是因为指针方法 可以修改接收者;使用拷贝的值来调用它们，将会导致那些修改会被丢弃。</p>

<p>9、数组传递地址的方法（二维数组也是一样）</p>

<p>If you’re reading this post you’re probably searching on Google how to solve this problem: you’re passing a pointer to a slice or map in a function, and when referencing an item with *variable[0], you get that error.</p>

<p>How do I solve it?</p>

<pre><code>The solution is simple: instead of using

*variable[0]
use

(*variable)[0]
</code></pre>

<p>Why am I getting this weird error?</p>

<p>*variable[0] is interpreted by the Go compiler as *(variable[0]). So what you’re telling the compiler to do is, get the first element in the slice, or the map item with key 0, and dereference that pointer.</p>

<p>This explains the error: variable in that context is a pointer, not a value, so you cannot get the [0] item of a pointer to an address, you need to dereference it first to get the value, which is what I think you are trying to do in the first place.</p>

<p>10、真实空间</p>

<p>我们可以直接通过这个实例来看切片在数组上的建立和append的区别</p>

<pre><code>package main
import (
    &quot;fmt&quot;
)
func main() {
    str1 := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
    str2 := str1[1:]
    str2[1] = &quot;new&quot;
    fmt.Println(str1)
    str2 = append(str2, &quot;z&quot;, &quot;x&quot;, &quot;y&quot;)
    fmt.Println(str1)
}
</code></pre>

<p>结果</p>

<pre><code>[a b new]
[a b new]
</code></pre>

<p>可见，golang 中的切片底层其实使用的是数组。当使用str1[1:] 使，str2 和 str1 底层共享一个数组，这回导致 str2[1] = &ldquo;new&rdquo; 语句影响 str1。而 append 会导致底层数组扩容，生成新的数组，因此追加数据后的 str2 不会影响 str1。</p>

<p>11、数组只能与相同纬度长度以及类型的其他数组比较，切片之间不能直接比较。。</p>

<h2 id="map">map</h2>

<p>map就是k/v的映射，map持有对底层数据结构的引用。如果将map传递给函数，其对map的内容做了改 变，则这 些改变对于调用者是可见的。</p>

<p>定义申明</p>

<pre><code>map[key] = value
定义 var a map[string]value
</code></pre>

<p>比如</p>

<pre><code>// 先声明map
var m1 map[string]string
// 再使用make函数创建一个非nil的map，nil map不能赋值
m1 = make(map[string]string)
// 最后给已声明的map赋值
m1[&quot;a&quot;] = &quot;aa&quot;
m1[&quot;b&quot;] = &quot;bb&quot;
</code></pre>

<p>map元素查找</p>

<p>在Go语言中，map的查找功能设计得比较精巧。判断是否成功找到特定的键，不需要检查取到的值是否为nil，只需查看第二个返回值。要从map中查找一个特定的键，可以通过下面的代码来实现：</p>

<pre><code>value, ok := myMap[&quot;1234&quot;]
if ok{
    //处理找到的value
}
</code></pre>

<p>map不像array和基础类型在你定义就会给你初始化一个默认值,所以在使用map进行赋值的时候，必须先对map进行初始化：</p>

<pre><code>conf.Scripts = make(map[string]*Script)
tmpScript.Cmd = value.(string)
conf.Scripts[metric] = &amp;tmpScript
</code></pre>

<p>未初始化会报错</p>

<pre><code> assignment to entry in nil map
</code></pre>

<p>要删除一个map项，使用 delete 内建函数，其参数为map和要删除的key。即使key已经不在map中， 这样做也是安全的。</p>

<pre><code>delete(timeZone, &quot;PDT&quot;)  // Now on Standard Time
</code></pre>

<p>实现map的有序输出</p>

<p>就是人为的对key进行排序，然后遍历key，或者先遍历再排序。</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sort&quot;
)

func main() {
    /* 声明一个字符串切片，存储map的key值 */
    var Name []string
    Name = append(Name, &quot;Bob&quot;, &quot;Andy&quot;, &quot;Clark&quot;, &quot;David&quot;, &quot;Ella&quot;)

    /* 声明索引类型为字符串的map */
    var Person = make(map[string]string)
    Person[&quot;Bob&quot;] = &quot;B&quot;
    Person[&quot;Andy&quot;] = &quot;A&quot;
    Person[&quot;Clark&quot;] = &quot;C&quot;
    Person[&quot;David&quot;] = &quot;D&quot;
    Person[&quot;Ella&quot;] = &quot;E&quot;

    fmt.Println(&quot;未排序输出:&quot;)
    for key, value := range Person {
        fmt.Println(key, &quot;:&quot;, value)
    }

    /* 对slice数组进行排序，然后就可以根据key值顺序读取map */
    sort.Strings(Name)
    fmt.Println(&quot;排序输出:&quot;)
    for _, Key := range Name {
        /* 按顺序从MAP中取值输出 */
        if Value, ok := Person[Key]; ok {
            fmt.Println(Key, &quot;:&quot;, Value)
        }
    }

}
</code></pre>

<p>Go 原生的 map 数据类型是非并发安全的，在go1.9开始发布了sync.map是线程安全的。</p>

<p>sync.map</p>

<p>在golang1.9以前，我们都是使用sync.RWMutex枷锁来实现线程安全</p>

<p>实例</p>

<pre><code>package beego

import (
    &quot;sync&quot;
)



type BeeMap struct {
    lock *sync.RWMutex
    bm   map[interface{}]interface{}

}



func NewBeeMap() *BeeMap {
    return &amp;BeeMap{
        lock: new(sync.RWMutex),
        bm:   make(map[interface{}]interface{}),
    }
}



//Get from maps return the k's value
func (m *BeeMap) Get(k interface{}) interface{} {
    m.lock.RLock()
    defer m.lock.RUnlock()
    if val, ok := m.bm[k]; ok {
        return val
    }
    return nil
}



// Maps the given key and value. Returns false
// if the key is already in the map and changes nothing.
func (m *BeeMap) Set(k interface{}, v interface{}) bool {
    m.lock.Lock()
    defer m.lock.Unlock()
    if val, ok := m.bm[k]; !ok {
        m.bm[k] = v
    } else if val != v {
        m.bm[k] = v
    } else {
        return false
    }
    return true
}



// Returns true if k is exist in the map.
func (m *BeeMap) Check(k interface{}) bool {
    m.lock.RLock()
    defer m.lock.RUnlock()
    if _, ok := m.bm[k]; !ok {
        return false
    }
    return true
}



func (m *BeeMap) Delete(k interface{}) {
    m.lock.Lock()
    defer m.lock.Unlock()
    delete(m.bm, k)
}
</code></pre>

<p>我们在项目中还可以通过数组、map、sync.RWMutex来实现普通map的并发读写，采用map数组，把key hash到相应的map，每个map单独加锁以降低锁的粒度</p>

<p>那么golang sync.map是如何实现线程安全的呢？</p>

<p>简单总结就是使用了互斥量和原子操作，用空间换时间。使用无锁读和读写分离的方式，详细了解可以看<a href="/post/golang/go-map/">这里</a>。</p>

<h2 id="数据类型">数据类型</h2>

<p>下面是 Go 支持的基本类型：</p>

<ol>
<li><p>bool</p></li>

<li><p>数字类型</p>

<p>数字类型有很多</p>

<pre><code>int8, int16, int32, int64, int--有符号
int：根据不同的底层平台（Underlying Platform），表示 32 或 64 位整型。除非对整型的大小有特定的需求，否则你通常应该使用 int 表示整型。

uint8, uint16, uint32, uint64, uint--无符号
float32, float64
complex64, complex128
complex64：实部和虚部都是 float32 类型的的复数。
complex128：实部和虚部都是 float64 类型的的复数。

内建函数 complex 用于创建一个包含实部和虚部的复数。complex 函数的定义如下：

func complex(r, i FloatType) ComplexType
</code></pre></li>

<li><p>byte</p>

<p>byte 是 uint8 的别名。</p></li>

<li><p>rune</p>

<p>rune 是 int32 的别名。</p></li>

<li><p>string</p>

<p>Go 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换</p>

<p>比如在 C 语言中是完全合法的，然而在 Go 中，却是行不通的。i 的类型是 int ，而 j 的类型是 float64 ，我们正试图把两个不同类型的数相加，Go 不允许这样的操作。</p>

<p>数据类型转化</p>

<pre><code>func main() {  
    var e interface{}  
    e = 10  
    switch v := e.(type) {  
    case int:  
        fmt.Println(&quot;整型&quot;, v)    
        var s int  
        s = v  
        fmt.Println(s)  
    case string:  
        fmt.Println(&quot;字符串&quot;, v)  
    }  
}  
</code></pre>

<p>这边有一个重点，&rdquo;type&rdquo;只能用与interface，下面这个就是错误的</p>

<pre><code>func main() {
    i := GetValue()

    switch i.(type) {
    case int:
        println(&quot;int&quot;)
    case string:
        println(&quot;string&quot;)
    case interface{}:
        println(&quot;interface&quot;)
    default:
        println(&quot;unknown&quot;)
    }

}

func GetValue() int {
    return 1
}
</code></pre>

<p>golang 中字符串是不能赋值 nil 的，也不能跟 nil 比较。</p>

<p>字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。可以通过使用unsafe标准库来实现不拷贝来提高性能。</p></li>

<li><p>字符类型</p>

<p>在Go语言中支持两个字符类型，一个是 byte （实际上是 uint8 的别名），代表UTF-8字符串的单个字节的值；
另一个是 rune ，代表单个Unicode字符。出于简化语言的考虑，Go语言的多数API都假设字符串为UTF-8编码。
尽管Unicode字符在标准库中有支持，但实际上较少使用。</p></li>
</ol>

<h2 id="语句">语句</h2>

<ol>
<li><p>控制语句</p>

<p>顺序</p>

<p>选择</p>

<pre><code>if条件中初始化的变量可以在else中使用
switch可以获取接口变量的动态类型
</code></pre>

<p>循环</p>

<pre><code>支持for，不支持while和do_while
goto语句---&gt;跳到标志位
</code></pre></li>

<li><p>函数</p>

<p>1.关键字func、函数名、参数列表、返回值、函数体和返回语句。</p>

<pre><code>func Add(a int, b int) (ret int, err error) {
}
</code></pre>

<p>2.函数调用</p>

<p>需要先牢记这样的规则：小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用。调用模式如下：</p>

<pre><code>n, err := Foo(0)
if err != nil {
 // 错误处理
} else {
 // 使用返回值n
}
</code></pre>

<p>3.不定参数</p>

<p>传入参数的数量不定</p>

<p>语法糖：&hellip;type</p>

<pre><code>func myfunc(args ... int) {
}
如果是不同的类型则用interface{}
func myfunc(args ... interface{}) {
}
</code></pre>

<p>如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice&hellip;)。</p>

<pre><code>nums := []int{1, 2, 3, 4}
myfunc(noms…)
</code></pre>

<p>什么是可变参数函数？
可变参数函数即其参数数量是可变的 —— 0 个或多个。声明可变参数函数的方式是在其参数类型前带上省略符（三个点）前缀。也就是不定参数</p>

<p>原理：
可变参数函数会在其内部创建一个”新的切片”。事实上，可变参数是一个简化了切片类型参数传入的语法糖。</p>

<pre><code>names ...string-----&gt;names := []string{}
</code></pre>

<p>可变参数的使用场景</p>

<pre><code>避免创建仅作传入参数用的临时切片
当参数数量未知
传达你希望增加可读性的意图
</code></pre>

<p>使用</p>

<p>1.传入已有的切片</p>

<p>你可以通过向一个已有的切片添加可变参数运算符 ”…“ 后缀的方式将其传入可变参数函数。函数会在内部直接使用这个传入的切片，并不会创建一个的新的。</p>

<p>2.一些切片传入后的特异表现</p>

<p>传入的切片是会被改变的，源切片也同时被改变</p>

<p>这是因为，传入的切片和函数内部使用的切片共享同一个底层数组，因此在函数内部改变这个数组的值同样会影响到传入的切片：</p>

<p>3.返回传入的切片</p>

<p>返回值的类型不可以是可变参数的形式，但你可以将它作为一个切片返回：</p>

<p>你也可以像下面这样将数组转化成切片后传入可变参数函数：</p>

<pre><code>names := [2]string{&quot;carl&quot;, &quot;sagan&quot;}

toFullname(names[:]...)
</code></pre>

<p>[]string 和 …string 是不可互相替代的</p>

<p>可以通过将非可变参数置于可变参数前面的方式来混合使用它们，不能在可变参数之后再声明参数</p>

<p>4.支持多返回值，改进了c中笨拙的语言风格</p>

<p>Go 语言的函数支持多返回值有很多的作用，其中我们很常用的可以在返回接口把业务语义（业务返回值）和控制语义（出错返回值）区分开。Go 语言的很多函数都会返回 result、err 两个值，于是就有这样几点：</p>

<ul>
<li>参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰。</li>
<li>Go 语言中的错误参数如果要忽略，需要显式地忽略，用 _ 这样的变量来忽略。</li>
<li>如果返回的 error 是个接口（其中只有一个方法 Error()，返回一个 string ），所以你可以扩展自定义的错误处理。</li>

<li><p>如果一个函数返回了多个不同类型的 error，你也可以使用下面这样的方式，我们可以看到，Go 语言的错误处理的方式，本质上是返回值检查，但是它也兼顾了异常的一些好处——对错误的扩展。</p>

<pre><code>if err != nil {
    switch err.(type) {
        case *json.SyntaxError: ...
        case *ZeroDivisionError: ...
        case *NullPointerError: ...
        default: ...
    }
}
</code></pre></li>
</ul>

<p>5.支持在函数参数中给返回值命名</p>

<p>6.支持匿名函数</p>

<p>7.参数类型</p>

<p>Go语言的函数调用参数全部是传值的, 包括 slice/map/chan 在内所有类型, 没有传引用的说法.但是slice/map/chan是引用类型，因为在make的时候返回的就是指针，所以是变成了地址引用</p>

<p>8.传值和传指针&ndash;和c++一样</p>

<p>当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候， 调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。
为了验证我们上面的说法，我们来看一个例子</p>

<pre><code>package main import &quot;fmt&quot;
//简单的一个函数，实现了参数+1的操作 func add1(a int) int {
a = a+1 // 我们改变了a的值
return a //返回一个新值 }
func main() { x := 3
fmt.Println(&quot;x = &quot;, x) // 应该输出 &quot;x = 3&quot; x1 := add1(x) //调用add1(x)
fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出&quot;x+1 = 4&quot;
fmt.Println(&quot;x = &quot;, x) // 应该输出&quot;x = 3&quot; }
</code></pre>

<p>看到了吗?虽然我们调用了add1函数，并且在add1中执行a = a+1操作，但是上面例子中x变量的值没有发生变化 理由很简单:因为当我们调用add1的时候，add1接收的参数其实是x的copy，而不是x本身。 那你也许会问了，如果真的需要传这个x本身,该怎么办呢?
这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内 存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&amp;x传入函数，并将函数 的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只 是copy的是一个指针。请看下面的例子</p>

<pre><code>package main import &quot;fmt&quot;
//简单的一个函数，实现了参数+1的操作 func add1(a *int) int { // 请注意，
*a = *a+1 // 修改了a的值
return *a // 返回新值 }
func main() { x := 3
fmt.Println(&quot;x = &quot;, x) // 应该输出 &quot;x = 3&quot; x1 := add1(&amp;x) // 调用 add1(&amp;x) 传x的地址
fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出 &quot;x+1 = 4&quot;
fmt.Println(&quot;x = &quot;, x) // 应该输出 &quot;x = 4&quot; }
</code></pre>

<p>这样，我们就达到了修改x的目的。那么到底传指针有什么好处呢?</p>

<pre><code>传指针使得多个函数能操作同一个对象。
传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的 话, 在每次copy上面就会花费相对较多的系统开销(内存和时间)。所以当你要传递大的结构体的时候，用 指针是一个明智的选择。 Go语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递 指针。(注:若函数需改变slice的长度，则仍需要取地址传递指针)
</code></pre></li>

<li><p>错误处理</p>

<p>error接口</p>

<p>两个函数panic，recover&ndash;这是一个强大的工具，应该减少使用</p></li>

<li><p>关键字defer,panic,recover</p>

<p>1.defer 语句会延迟函数的执行直到上层函数返回。</p>

<p>2.defer要求获得一个函数的实例，return只需要类型定义。</p>

<p>3.defer 是后进先出。也就是最后的语句最先执行。</p>

<p>4.panic 需要等defer 结束后才会向上传递。 出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p>

<p>5.Defer调用的函数可以在返回语句执行后读取或修改命名的返回值.</p>

<p>6.defer语句用于延迟一个函数或者方法（或者当前所创建的匿名函数）的执行，它会在外围函数或者方法返回之前但是其返回值（如果有的话）计算之后执行。这样就有可能在一个被延迟执行的函数内部修改外围函数的命名返回值</p>

<p>7.recover方法只可以在defer方法中调用，这是因为panic链的方法中只有defer方法可以被执行。</p>

<p>8.如果recover方法被调用，但是没有任何的panic发生，recover方法只会返回nil。如果有panic发生，那么panic就停止并且给panic的赋值会被返回。</p>

<p>一个真实的panic 和 recover配合使用的用例可以参考标准库: json package. 它提供JSON格式的解码, 当 遇到非法格式的输入时会抛出panic异常, 然后panicking扩散到上一级调用者堆栈, 由上一级调用者通过recover捕获panic和错误信息(参考 decode.go 中的 &lsquo;error&rsquo; 和 &lsquo;unmarshal&rsquo;).</p>

<p>Go库的实现习惯: 即使在pkg内部使用了panic, 但是在导出API时会被转化为明确的错误值.</p>

<p>下面这个函数检查作为其参数的函数在执行时是否会产生panic:</p>

<pre><code>func throwsPanic(f func()) (b bool) {
    defer func() {
        if x := recover(); x != nil {
            b = true
        }
    }()

    f() //执行函数f，如果f中出现了panic，那么就可以恢复回来
    return
}
</code></pre></li>

<li><p>面向对象</p>

<p>很直接，没有隐藏this指针</p>

<pre><code>func (a Integer) Less(b Integer) bool { // 面向对象
return a &lt; b
}
func Integer_Less(a Integer, b Integer) bool { // 面向过程
return a &lt; b
}
a.Less(2) // 面向对象的用法
Integer_Less(a, 2) // 面向过程的用法
</code></pre></li>

<li><p>struct</p>

<ol>
<li><p>结构体与数组一样，是复合类型，无论是作为实参传递给函数时，还是赋值给其他变量，都是值传递，即复一个副本。</p></li>

<li><p>一个结构体，并没有包含自身，比如Member中的字段不能是Member类型，但却可能是*Member。</p>

<p>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等</p>

<pre><code>type tree struct {
    value       int
    left, right *tree
}

// Sort sorts values in place.
func Sort(values []int) {
    var root *tree
    for _, v := range values {
        root = add(root, v)
    }
    appendValues(values[:0], root)
}

// appendValues appends the elements of t to values in order
// and returns the resulting slice.
func appendValues(values []int, t *tree) []int {
    if t != nil {
        values = appendValues(values, t.left)
        values = append(values, t.value)
        values = appendValues(values, t.right)
    }
    return values
}

func add(t *tree, value int) *tree {
    if t == nil {
        // Equivalent to return &amp;tree{value: value}.
        t = new(tree)
        t.value = value
        return t
    }
    if value &lt; t.value {
        t.left = add(t.left, value)
    } else {
        t.right = add(t.right, value)
    }
    return t
}
</code></pre></li>

<li><p>STRUCT基本和c差不多，也有继承采取了组合的文法&ndash;通过结构体继承，没有private，public关键字来保护，而是通过字母大小写来处理</p>

<p>初始化常用方法：</p>

<pre><code>rect1 := new(Rect)
rect2 := &amp;Rect{}
rect3 := &amp;Rect{0, 0, 100, 200}
rect4 := &amp;Rect{width: 100, height: 200}
</code></pre>

<p>注意这几个变量全部为指向Rect结构的指针(指针变量)，因为使用了new()函数和&amp;操作符．而如果使用方法</p>

<pre><code>a := Rect{}
</code></pre>

<p>则表示这个是一个Rect{}类型．两者是不一样的．</p>

<p>未显式初始化的都是对应的零值</p>

<p>构造函数用一个全局函数NEWXXXX来表示</p>

<pre><code>func NewRect(x, y, width, height float64) *Rect {
    return &amp;Rect{x, y, width, height}
}
</code></pre>

<p>struct可以实现golang的面向对象编程，每个struct的对应的实现函数 ，就是相当于这个struct的成员函数，就像访问自己的成员一样。</p>

<p>继承也是使用struct的组合实现的</p>

<p>实例</p>

<pre><code>type Animal struct {
    Name   string  //名称
    Color  string  //颜色
    Height float32 //身高
    Weight float32 //体重
    Age    int     //年龄
}
//奔跑
func (a Animal)Run() {
    fmt.Println(a.Name &gt;&quot;is running&quot;)
}
//吃东西
func (a Animal)Eat() {
    fmt.Println(a.Name &gt;&quot;is eating&quot;)
}

type Cat struct {
    a Animal
}

func main() {
    var c = Cat{
        a: Animal{
            Name:   &quot;猫猫&quot;,
            Color:  &quot;橙色&quot;,
            Weight: 10,
            Height: 30,
            Age:    5,
        },
    }
    fmt.Println(c.a.Name)
    c.a.Run()
}
</code></pre>

<p>匿名组合，就是不使用变量名，Go语言支持直接将类型作为结构体的字段，而不需要取变量名，这种字段叫匿名字段</p>

<pre><code>type Lion struct {
    Animal //匿名字段
}

func main(){
    var lion = Lion{
        Animal{
            Name:  &quot;小狮子&quot;,
            Color: &quot;灰色&quot;,
        },
    }
    lion.Run()
    fmt.Println(lion.Name)
}
</code></pre></li>
</ol>

<p>go的内嵌和组合实现了go的继承和派生的作用。</p></li>

<li><p>关键字</p>

<p>golang中关键字</p>

<pre><code>break case chan const continue
default func defer go else goto fallthrough if
for import
interface map package range return
select struct switch type var
</code></pre>

<p>具体作用</p>

<pre><code>var和const Go语言基础里面的变量和常量申明
package和import 已经有过短暂的接触，就是包
func 用于定义函数和方法
return 用于从函数返回
defer 用于类似析构函数
go 用于并行
select 用于选择不同类型的通讯，监听
interface 用于定义接口
struct 用于定义抽象数据类型，
break、case、continue、for、fallthrough、else、if、switch、goto、default 这流程介绍里面
chan 用于channel通讯
type 用于声明自定义类型
map 用于声明map类型数据
range 用于读取slice、map、channel数据
</code></pre></li>
</ol>

<h2 id="go语言的三大核心">go语言的三大核心</h2>

<p><a href="/post/golang/go-goroutinechannel/">goroutine</a>和<a href="/post/golang/go-channel/">channel</a>是Go并发的两大基石，那么<a href="/post/golang/go-interface/">接口</a>是Go语言编程中数据类型的关键。</p>

<p>Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，即通信顺序进程模型。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据。</p>

<p>在Go语言的实际编程中，几乎所有的数据结构都围绕接口展开，接口是Go语言中所有数据结构的核心。</p>

<p>这三个可以说是go语言的核心所在，<a href="/post/golang/go-goroutinechannel/">goroutine</a>和<a href="/post/golang/go-channel/">channel</a>和<a href="/post/golang/go-interface/">interface</a>都单独成篇。</p>

<h1 id="零碎基础知识">零碎基础知识</h1>

<ol>
<li><p>golang是一门静态类型开发语言</p></li>

<li><p>每个 Go 程序都是由包组成的，程序运行的入口是包 <code>main</code>。</p></li>

<li><p>go自己的设计哲学：</p>

<p>1、不得包含源代码文件中没有用到的包</p>

<p>2、函数的左括号{位置</p>

<p>3、函数名大小写规则</p>

<p>4、不一定要用分号结束语句</p>

<p>5、package的名称必须和目录名保持一致</p></li>

<li><p>Go语言的工作空间结构：</p>

<p>Go语言的工作空间其实就是一个文件目录，目录中必须包含src、pkg、bin三个目录。</p>

<p>其中src目录用于存放Go源代码，pkg目录用于package对象，bin目录用于存放可执行对象</p></li>

<li><p>环境变量</p>

<p>go命名行用到了GOPATH环境变量，在这个目录下收索</p>

<pre><code>export GOPATH=你的工作空间路径

export PATH=$PATH:$GOPATH/bin----安装用这个路劲
</code></pre></li>

<li><p>go的初始化函数init是在main函数的之前执行的</p>

<p>Go里面有两个保留的函数:init函数(能够应用于所有的package)和main函数(只能应用于package main)。 这两个函数在定义时不能有任何的参数和返回值。虽然一个package里面可以写任意多个init函数，但这无论是对 于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。</p></li>

<li><p>全局唯一性操作</p>

<p>var once sync.Once</p></li>

<li><p>go环境变量：</p>

<p>GOROOT ：go的安装目录</p>

<p>GOPATH ：你自己开发go语言代码的目录，目录结构为bin,pkg,src，如果你有多个目录，那么使用分号分隔。</p></li>

<li><p>命名函数</p>

<p>我们给 fmt.Println 一个短名字的别名</p>

<pre><code>var p = fmt.Println
</code></pre></li>

<li><p>命令行参数</p>

<p>os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。</p></li>

<li><p>go提供了安装包，直接下载解压设置/etc/profile环境变量就可以使用go了，简单便捷</p>

<pre><code>export GOROOT=/home/test/Go/go—-源码安装路径

export PATH=$GOROOT/bin:$PATH——声明应用

export GOPATH=/home/test/Go/go-project—你的项目路劲
</code></pre></li>

<li><p>import</p>

<p>import &ldquo;fmt&rdquo;最常用的一种形式</p>

<p>import &ldquo;./test&rdquo;导入同一目录下test包中的内容</p>

<p>import f &ldquo;fmt&rdquo;导入fmt，并给他启别名ｆ</p>

<p>import . &ldquo;fmt&rdquo;，将fmt启用别名&rdquo;.&ldquo;，这样就可以直接使用其内容，而不用再添加ｆｍｔ，如fmt.Println可以直接写成Println</p>

<p>import  _ &ldquo;fmt&rdquo; 表示不使用该包，而是只是使用该包的init函数，并不显示的使用该包的其他内容。注意：这种形式的import，当import时就执行了fmt包中的init函数，而不能够使用该包的其他函数。</p></li>

<li><p>struct</p>

<p>定义：</p>

<pre><code>type person struct {
    name string
    age int
}   
</code></pre>

<p>初始化：</p>

<ol>
<li><p>直接初始化</p>

<pre><code>var P person  // P现在就是person类型的变量了
P.name = &quot;Astaxie&quot;  // 赋值&quot;Astaxie&quot;给P的name属性.
P.age = 25  // 赋值&quot;25&quot;给变量P的age属性
</code></pre></li>

<li><p>按照顺序提供初始化值</p>

<pre><code>P := person{&quot;Tom&quot;, 25}
</code></pre></li>

<li><p>通过field:value的方式初始化，这样可以任意顺序</p>

<pre><code>P := person{age:24, name:&quot;Tom&quot;}
</code></pre></li>
</ol>

<p>进行结构体比较时候，只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。结构体是相同的，但是结构体属性中有不可以比较的类型，如map,slice，还是不可比较的。</p>

<p>如果该结构属性都是可以比较的，那么就可以使用“==”进行比较操作。可以使用reflect.DeepEqual进行比较</p>

<p>struct内部的的成员一般需要给外部使用，不管是同一个文件还是几个文件，所以都是需要大写开头</p></li>

<li><p>错误</p>

<pre><code>Handler crashed with error runtime error: invalid memory address or nil pointer dereference
</code></pre>

<p>一般报这个错误原因</p>

<pre><code>值为nil
</code></pre>

<p>解决方法</p>

<pre><code>找到这个位置，值为nil 判断一下再输出或者赋值
</code></pre>

<p>nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。但是如果不特别指定的话，Go 语言不能识别类型，所以会报错。</p></li>

<li><p>goto</p>

<p>goto不能跳转到其他函数或者内层代码</p>

<p>在golang中同属于流程控制，和判断，循环一样。</p></li>

<li><p>Go 1.9 新特性</p>

<p>Alias and defintion</p>

<pre><code>基于一个类型创建一个新类型，称之为defintion；
基于一个类型创建一个别名，称之为alias。

defintion，虽然底层类型为int类型，但是不能直接赋值，需要强转；
alias，可以直接赋值。
</code></pre></li>

<li><p>命名</p>

<p>go提倡命名不使用下划线</p>

<p>if后不提倡使用括号</p>

<p>提出命名不带数据类型，不够简洁，而且现在ide功能也是很全面清晰</p></li>

<li><p>隐藏</p>

<pre><code>for k:= range labels {
        labelNames = append(labelNames, k)
    }
</code></pre>

<p>这边这个v不需要使用_就可以不写。</p>

<p>_代表空白标志符</p></li>

<li><p>range分配的变量</p>

<p>range对应的变量的地址是不变的，地址的上的数据是变化的，比如</p>

<pre><code>type student struct {
    Name string
    Age  int
}

func pase_student() {
    m := make(map[string]*student)
    stus := []student{
        {Name: &quot;zhou&quot;, Age: 24},
        {Name: &quot;li&quot;, Age: 23},
        {Name: &quot;wang&quot;, Age: 22},
    }
    for _, stu := range stus {
        m[stu.Name] = &amp;stu
    }
}
</code></pre>

<p>最后获取的m中value值是一样的，都是stu的地址，stu不会随着range重新分配变量，一直都是一个，所以内部的赋值一直都是stu的同一个地址，正常的写法是定义的时候不用地址</p>

<pre><code>type student struct {
    Name string
    Age  int
}

func pase_student() {
    m := make(map[string]student)
    stus := []student{
        {Name: &quot;zhou&quot;, Age: 24},
        {Name: &quot;li&quot;, Age: 23},
        {Name: &quot;wang&quot;, Age: 22},
    }
    for _, stu := range stus {
        m[stu.Name] = stu
    }
}
</code></pre>

<p>换一个角度，rang遍历数组，切片，map时，都是值拷贝，在循环中更改值不会影响原来的</p></li>

<li><p>变量声明</p>

<p>“:=”只能在声明“局部变量”的时候使用，而“var”没有这个限制。</p></li>

<li><p>运算符</p>

<p>在Go中 &ldquo;++&rdquo; 和 &ldquo;- -&rdquo; 只能作为语句而非表达式
示例代码：</p>

<pre><code>a := 1
a ++ // 注意：不能写成 ++a 或 -- a 必须放在右边使用
// b := a++// 此处为错误的用法，不能写在一行，要单独作为语句使用

fmt.Println(a) // 2
</code></pre></li>

<li><p>封装实例（deafulat）</p>

<p>go标准库中，经常这么做</p>

<p>定义了一个类型，提供了很多方法；为了方便使用，会实例化一个该类型的实例（通用），这样便可以直接使用该实例调用方法。比如：</p>

<ol>
<li><p>encoding/base64 中提供了 StdEncoding 和 URLEncoding 实例，使用时：base64.StdEncoding.Encode()</p></li>

<li><p>在 flag 包使用了有类似的方法，比如 CommandLine 实例，只不过 flag 进行了进一步封装：将 FlagSet 的方法都重新定义了一遍，也就是提供了一序列函数，而函数中只是简单的调用已经实例化好了的 FlagSet 实例：CommandLine 的方法。这样，使用者是这么调用：flag.Parse() 而不是 flag. CommandLine.Parse()。（Go 1.2 起，将 CommandLine 导出，之前是非导出的）</p></li>
</ol></li>

<li><p>map和slice遍历顺序问题</p>

<p>我理解为在range时为引用类型（slice，map，channel)创建索引，而map的索引是未被指定的，所以无序。</p>

<p>因此如果需要保证顺序输出，我是使用了slice。当然range 数组是有序的输出。</p></li>

<li><p>调用</p>

<p>当package无法调用对应的方法时，第一个看是否是大写，小写对外不公开，第二个看是否包名和变量名重复</p></li>

<li><p>无法修改map中的成员变量</p>

<p>在开始代码设计的时候想要将原struct中的成员变量进行修改或者替换。</p>

<pre><code>x = y 这种赋值的方式，你必须知道 x的地址，然后才能把值 y 赋给 x。
但 go 中的 map 的 value 本身是不可寻址的，因为 map 的扩容的时候，可能要做 key/val pair迁移
value 本身地址是会改变的
不支持寻址的话又怎么能赋值呢
</code></pre>

<p>代码示例如下</p>

<pre><code>package main

import &quot;fmt&quot;

var m = map[string]struct{ x, y int } {
    &quot;foo&quot;: {2, 3}
}

func main() {
    m[&quot;foo&quot;].x = 4
    fmt.Printf(&quot;result is : %+v&quot;, m)
}
</code></pre>

<p>本以为这个会将 m[“foo”] 中的 x 替换成 4， 从而打印出来的效果是</p>

<pre><code>result is : map[foo:{x:4 y:3}]
</code></pre>

<p>然而，并不是的，这段代码在保存后编译时提示</p>

<pre><code>cannot assign to struct field m[&quot;foo&quot;].x in map
</code></pre>

<p>这就尴尬了，无法在已经存在的key的节点中修改值，这是为什么？</p>

<p>m中已经存在”foo”这个节点了啊，</p>

<p>简单来说就是map不是一个并发安全的结构，所以，并不能修改他在结构体中的值。</p>

<p>这如果目前的形式不能修改的话，就面临两种选择，</p>

<p>1.修改原来的设计;</p>

<p>2.想办法让map中的成员变量可以修改，&mdash;-使用指针</p>

<p>因为懒得该这个结构体，就选择了方法2，</p>

<p>但是不支持这种方式传递值，应该如何进行修改现在已经存在在struct中的map的成员变量呢？</p>

<p>热心的网友们倒是提供了一种方式，示例如下：</p>

<pre><code>package main

import &quot;fmt&quot;

var m = map[string]struct{ x, y int } {
    &quot;foo&quot;: {2, 3}
}

func main() {
    tmp := m[&quot;foo&quot;]
    tmp.x = 4
    m[&quot;foo&quot;] = tmp
    fmt.Printf(&quot;result is : %+v&quot;, m)
}
</code></pre>

<p>果然和预期结果一致，不过，总是觉得有点怪怪的，</p>

<p>既然是使用了类似临时空间的方式，那我们用地址引用传值不也是一样的么&hellip;</p>

<p>于是，我们就使用了另外一种方式来处理这个东西，</p>

<p>示例如下：</p>

<pre><code>package main

import &quot;fmt&quot;

var m = map[string]*struct{ x, y int } {
    &quot;foo&quot;: &amp;{2, 3}
}

func main() {
   m[&quot;foo&quot;].x = 4
   fmt.Println(&quot;result is : %+v \n&quot;, m)
   fmt.Println(&quot;m's node is : %+v \n&quot;, *m[&quot;foo&quot;])
}
</code></pre>

<p>最后的展示结果为：</p>

<pre><code>result is : map[foo:0xc42000cff0]
m's node is : {4, 3}
</code></pre></li>

<li><p>代理</p>

<p>以前我一直以为只需要给git加代理就可以了，其实go命令本身就有proxy的。比如http_proxy=socks5://127.0.0.1:1080 go get -u -v github.com/gin-gonic/gin</p></li>

<li><p>执行原理</p>

<p>Go 的可执行文件都比相对应的源代码文件要大很多，这恰恰说明了 Go 的 runtime 嵌入到了每一个可执行文件当中。当然，在部署到数量巨大的集群时，较大的文件体积也是比较头疼的问题。但总得来说，Go 的部署工作还是要比 Java 和 Python 轻松得多。因为 Go 不需要依赖任何其它文件，它只需要一个单独的静态文件，这样你也不会像使用其它语言一样在各种不同版本的依赖文件之间混淆。</p></li>

<li><p>参数interface</p>

<p>接口interface作为返回参数，只要是实现了这个接口内的所有的方法的struct，都可以返回给这个参数</p>

<p>例如filebeat中filebeat的new函数的返回，就是把fileabeat的结构体返回给了beat.Beater接口interface</p>

<p>另外一方面也可以解释
    var a beat.Beater = &amp;Filebeat{}</p>

<p>可以把一个结构体赋值给一个接口</p></li>

<li><p>调用子进程</p>

<p>编程中遇到使用相对路径再配置文件中，调用process b的可以先获取当前进程运行的绝对路径，正常大部分都是使用绝对路径。</p></li>

<li><p>google开源的包</p>

<p>为什么gRPC-go在github的地址是&rdquo;<a href="https://github.com/grpc/grpc-go&quot;">https://github.com/grpc/grpc-go&quot;</a> , 但是为什么要用“google.golang.org/grpc”进行安装呢？应该grpc原本是google内部的项目，归属golang，就放在了google.golang.org下面了，后来对外开放，又将其迁移到github上面了，又因为golang比较坑爹的import路径规则，所以就都没有改路径名了。</p>

<p>但是这样就有个问题了。要如何去管理版本呢？这个目前我还没有什么比较好的方法，希望知道的朋友一起分享下。目前想到一个方法是手动下载某个版本，然后写个脚本统一修改代码中的import里面的路径.</p>

<p>google在github上也有一个账号<a href="https://github.com/google/，对应的google开源的项目在这个下面，由于google去get">https://github.com/google/，对应的google开源的项目在这个下面，由于google去get</a> 包不太友好，可以来这边来下载。</p>

<p>也有去一下专门下载包的第三方网站去下载，比如<a href="https://gopm.io/">https://gopm.io/</a></p></li>

<li><p>每一个可独立运行的Go程序，必定包含一个package main，在这个main包中必定包含一个入口函数main，而这 个函数既没有参数，也没有返回值。</p></li>

<li><p>求余</p>

<p>求余, B % A</p></li>

<li><p>hashcode</p>

<pre><code>package main

import (
        &quot;fmt&quot;
        &quot;hash/crc32&quot;
)

// String hashes a string to a unique hashcode.
//
// crc32 returns a uint32, but for our use we need
// and non negative integer. Here we cast to an integer
// and invert it if the result is negative.
func String(s string) int {
        v := int(crc32.ChecksumIEEE([]byte(s)))
        if v &gt;= 0 {
                return v
        }
        if -v &gt;= 0 {
                return -v
        }
        // v == MinInt
        return 0
}


func main(){
        str := &quot;123456abcd&quot;

        for i:=0; i&lt;3;i+&gt;{
                hc := String(str)
                fmt.Println(&quot;hashcode:&quot;, hc)

        }
}
</code></pre></li>

<li><p>gouroutine执行失败需要退出整个进程，可以使用panic</p></li>

<li><p>golang字符串去除空格和换行符</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    str := &quot;welcome to bai\ndu\n.com&quot;
    // 去除空格
    str = strings.Replace(str, &quot; &quot;, &quot;&quot;, -1)
    // 去除换行符
    str = strings.Replace(str, &quot;\n&quot;, &quot;&quot;, -1)
    fmt.Println(str)
}
</code></pre></li>

<li><p>range空的内容的时候</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    var res = []string {&quot;&quot;}
    var flag = true
    for _, value := range res {
        fmt.Println(&quot;have value:&quot;,value)
        flag = false

    }
    for i:=0;i&lt;len(res);i++{
        fmt.Println(&quot;have value:&quot;,res[i])
    }

    if !flag {
        fmt.Println(&quot;response array the number of row UnMatch&quot;)
    }
}
</code></pre>

<p>输出</p>

<pre><code>chunyindeMacBook-Pro:test chunyinjiang$ go run range.go
have value:
have value:
response array the number of row UnMatch
</code></pre></li>

<li><p>[]byte to string</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    data := [4]byte{0x31, 0x32, 0x33, 0x34}
    str := string(data[:])
    fmt.Println(str)
}
</code></pre></li>

<li><p>read内容的问题</p>

<pre><code>buf := make([]byte, 512)
_, err := conn.Read(buf)
input := string(buf)
</code></pre>

<p>如果接收的数据不够512bytes怎么办？会变成buf末尾跟了很多个0（make([]byte, 512)会把全部都初始化为0），虽然0在c里面代表字符串的结尾，但是go可不是哦。</p>

<p>所以，正确的代码应该是这样</p>

<pre><code>buf := make([]byte, 512)
for {
    n, err := conn.Read(buf) // n代表读取的数量。
    if err != nil {
        break
    }
    input := string(buf[:n])
}
</code></pre></li>

<li><p>获取字符的数值</p>

<pre><code>int('9' - '0')//9,所以这个用于获取正常的数值的方式
int('9')//49--ACSII
</code></pre></li>

<li><p>fmt打印结构体内容</p>

<p>fmt包内置的方法，本来就可以展示类似Json的形式，没必要自己瞎搞。把上面的输出代码改了：</p>

<pre><code>fmt.Printf(&quot;%+v\n&quot;, a)
</code></pre>

<p>实例</p>

<pre><code>package main

import (

        &quot;fmt&quot;
)


type Power struct{
        age int
        high int
        name string
}

func main() {

        var i Power = Power{age: 10, high: 178, name: &quot;NewMan&quot;}

        fmt.Printf(&quot;type:%T\n&quot;, i)
        fmt.Printf(&quot;value:%v\n&quot;, i)
        fmt.Printf(&quot;value+:%+v\n&quot;, i)
        fmt.Printf(&quot;value#:%#v\n&quot;, i)


        fmt.Println(&quot;========interface========&quot;)
        var interf interface{} = i
        fmt.Printf(&quot;%v\n&quot;, interf)
        fmt.Println(interf)
}
</code></pre>

<p>output:</p>

<pre><code>type:main.Power
value:{10 178 NewMan}
value+:{age:10 high:178 name:NewMan}
value#:main.Power{age:10, high:178, name:”NewMan”}
========interface========
{10 178 NewMan}
{10 178 NewMan}
</code></pre>

<p>还有</p>

<pre><code>fmt.Printf(&quot;metrics name buf : %s\n&quot;,ic.MetricNameBuf )
</code></pre>

<p>等价于</p>

<pre><code>fmt.Println(&quot;metrics name buf :&quot;,string(ic.MetricNameBuf) )
</code></pre></li>

<li><p>go可以通过gdb来调试</p>

<p>编译Go程序的时候需要注意以下几点</p>

<pre><code>1. 传递参数-ldflags &quot;-s&quot;，忽略debug的打印信息
2. 传递-gcflags &quot;-N -l&quot; 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调
   试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。
</code></pre>

<p>常用命令</p>

<p>GDB的一些常用命令如下所示</p>

<pre><code>list
简写命令l，用来显示源代码，默认显示十行代码，后面可以带上参数显示的具体行，例如:list 15，显示 十行代码，其中第15行在显示的十行里面的中间，如下所示。
10 time.Sleep(2 * time.Second)
11 c &lt;- i
12 }
13 close(c)
14 }
15
16 func main() {
17 18 19
break
msg := &quot;Starting main&quot; fmt.Println(msg)
bus := make(chan int)
简写命令 b,用来设置断点，后面跟上参数设置断点的行数，例如b 10在第十行设置断点。
delete 简写命令 d,用来删除断点，后面跟上断点设置的序号，这个序号可以通过info breakpoints获取
相应的设置的断点序号，如下是显示的设置断点序号。
Num Type Disp Enb Address What
2 breakpoint keep y 0x0000000000400dc3 in main.main at /home/xiemengjun/gdb.go:2 breakpoint already hit 1 time
backtrace
简写命令 bt,用来打印执行的代码过程，如下所示:
#0 main.main () at /home/xiemengjun/gdb.go:23
#1 0x000000000040d61e in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244 #2 0x000000000040d6c1 in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267 #3 0x0000000000000000 in ?? ()
231
3
info
info命令用来显示信息，后面有几种参数，我们常用的有如下几种:
print
info locals
显示当前执行的程序中的变量值
info breakpoints
显示当前设置的断点列表
info goroutines
显示当前执行的goroutine列表，如下代码所示,带*的表示当前执行的
* 1 running runtime.gosched
* 2 syscall runtime.entersyscall
3 waiting runtime.gosched 4 runnable runtime.gosched
简写命令p，用来打印变量或者其他信息，后面跟上需要打印的变量名，当然还有一些很有用的函数$len()和 $cap()，用来返回当前string、slices或者maps的长度和容量。
whatis
用来显示当前变量的类型，后面跟上变量名，例如whatis msg,显示如下: type = struct string
next
简写命令 n,用来单步调试，跳到下一步，当有断点之后，可以输入n跳转到下一步继续执行 coutinue
简称命令 c，用来跳出当前断点处，后面可以跟参数N，跳过多少次断点
set variable
该命令用来改变运行过程中的变量值，格式如:set variable &lt;var&gt;=&lt;value&gt;
</code></pre>

<p>调试过程</p>

<p>我们通过下面这个代码来演示如何通过GDB来调试Go程序，下面是将要演示的代码:</p>

<pre><code>package main
import ( &quot;fmt&quot;
&quot;time&quot; )
func counting(c chan&lt;- int) { for i := 0; i &lt; 10; i+&gt;{
time.Sleep(2
c &lt;- i }
close(c) }
func main() {
msg := &quot;Starting
fmt.Println(msg)
bus := make(chan
msg = &quot;starting a gofunc&quot; go counting(bus)
for count := range bus {
* time.Second)
main&quot;
int)
232

fmt.Println(&quot;count:&quot;, count) }
}
</code></pre>

<p>编译文件，生成可执行文件gdbfile:</p>

<pre><code>go build -gcflags &quot;-N -l&quot; -ldflags &quot;-s&quot; gdbfile.go
</code></pre>

<p>通过gdb命令启动调试:</p>

<pre><code>gdb gdbfile 启动之后首先看看这个程序是不是可以运行起来，只要输入run命令回车后程序就开始运行，程序正常的话可以看到
</code></pre>

<p>程序输出如下，和我们在命令行直接执行程序输出是一样的:</p>

<pre><code>(gdb) run
Starting
Starting
count: 0
count: 1
count: 2
count: 3
count: 4
count: 5
count: 6
count: 7
count: 8
count: 9
[LWP 2771 exited]
[Inferior 1 (process 2771) exited normally]
</code></pre>

<p>好了，现在我们已经知道怎么让程序跑起来了，接下来开始给代码设置断点:</p>

<pre><code>(gdb) b 23
Breakpoint 1 at 0x400d8d: file /home/xiemengjun/gdbfile.go, line 23. (gdb) run
Starting program: /home/xiemengjun/gdbfile
Starting main
[New LWP 3284]
[Switching to LWP 3284]
Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(&quot;count:&quot;, count)
</code></pre>

<p>上面例子b 23表示在第23行设置了断点，之后输入run开始运行程序。现在程序在前面设置断点的地方停住了，我们 需要查看断点相应上下文的源码，输入list就可以看到源码显示从当前停止行的前五行开始:</p>

<pre><code>(gdb) list
18 fmt.Println(msg)
19 bus := make(chan int)
20 msg = &quot;starting a gofunc&quot;
21 go counting(bus)
22 for count := range bus {
23 fmt.Println(&quot;count:&quot;, count)
24 }
25 }
</code></pre>

<p>现在GDB在运行当前的程序的环境中已经保留了一些有用的调试信息，我们只需打印出相应的变量，查看相应变量的类型及值:</p>

<pre><code>(gdb) info locals count = 0
bus = 0xf840001a50 (gdb) p count
$1 = 0
(gdb) p bus
$2 = (chan int) 0xf840001a50 (gdb) whatis bus
type = chan int
program: /home/xiemengjun/gdbfile main
</code></pre>

<p>接下来该让程序继续往下执行，请继续看下面的命令</p>

<pre><code>(gdb) c
Continuing.
count: 0
[New LWP 3303] [Switching to LWP 3303]
Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(&quot;count:&quot;, count)
(gdb) c
Continuing.
count: 1
[Switching to LWP 3302]
Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(&quot;count:&quot;, count)
</code></pre>

<p>每次输入c之后都会执行一次代码，又跳到下一次for循环，继续打印出来相应的信息。 设想目前需要改变上下文相关变量的信息，跳过一些过程，并继续执行下一步，得出修改后想要的结果:</p>

<pre><code>(gdb) info locals
count = 2
bus = 0xf840001a50
(gdb) set variable count=9 (gdb) info locals
count = 9
bus = 0xf840001a50 (gdb) c
Continuing.
count: 9
[Switching to LWP 3302]
Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(&quot;count:&quot;, count)
</code></pre>

<p>最后稍微思考一下，前面整个程序运行的过程中到底创建了多少个goroutine，每个goroutine都在做什么:</p>

<pre><code>(gdb) info goroutines
* 1 running runtime.gosched
* 2 syscall runtime.entersyscall
3 waiting runtime.gosched
4 runnable runtime.gosched
(gdb) goroutine 1 bt
#0 0x000000000040e33b in runtime.gosched () at /home/xiemengjun/go/src/pkg/runtime/proc.c:927 #1 0x0000000000403091 in runtime.chanrecv (c=void, ep=void, selected=void, received=void)
at /home/xiemengjun/go/src/pkg/runtime/chan.c:327
#2 0x000000000040316f in runtime.chanrecv2 (t=void, c=void)
at /home/xiemengjun/go/src/pkg/runtime/chan.c:420
#3 0x0000000000400d6f in main.main () at /home/xiemengjun/gdbfile.go:22
#4 0x000000000040d0c7 in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244
#5 0x000000000040d16a in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267
#6 0x0000000000000000 in ?? ()
</code></pre>

<p>通过查看goroutines的命令我们可以清楚地了解goruntine内部是怎么执行的，每个函数的调用顺序已经明明白白地显示出来了。</p></li>

<li><p>利用cpu多核来处理http请求，下面这个没有用go默认就是单核处理http的.</p>

<pre><code>runtime.GOMAXPROCS(runtime.NumCPU());
</code></pre></li>

<li><p>interface转化string</p>

<pre><code>var x interface{} = &quot;abc&quot;
str := fmt.Sprintf(&quot;%v&quot;, x)
</code></pre></li>

<li><p>golang中json中出现list该怎么定义</p>

<p>使用map进行struct定义</p>

<pre><code>{&quot;plugin_params&quot;: map&lt;string&gt;string,}
</code></pre></li>

<li><p>return</p>

<p>退出执行，不指定返回值</p>

<p>通常有两种情况不需要指定返回值退出函数执行过程。第一是：函数没有返回值；第二是：函数返回值有变量名，不需要显示的指定返回值。</p></li>

<li><p>Connection reset by peer</p>

<p>1.如果一端的Socket被关闭（或主动关闭，或因为异常退出而 引起的关闭），另一端仍发送数据，发送的第一个数据包引发该异常(Connect reset by peer)。</p>

<p>Socket默认连接60秒，60秒之内没有进行心跳交互，即读写数据，就会自动关闭连接。</p>

<p>2.一端退出，但退出时并未关闭该连接，另一端如果在从连接中读数据则抛出该异常（Connection reset）。</p></li>

<li><p>时间比较</p>

<pre><code>time1 := &quot;2015-03-20 08:50:29&quot;
time2 := &quot;2015-03-21 09:04:25&quot;
//先把时间字符串格式化成相同的时间类型
t1, err := time.Parse(&quot;2006-01-02 15:04:05&quot;, time1)
t2, err := time.Parse(&quot;2006-01-02 15:04:05&quot;, time2)
if err == nil &amp;&amp; t1.Before(t2) {
    //处理逻辑
    fmt.Println(&quot;true&quot;)
}
</code></pre></li>

<li><p>定时12点</p>

<pre><code>func startTimer(f func()) {
    go func() {
        for {
            f()
            now := time.Now()
            // 计算下一个零点
            next := now.Add(time.Hour * 24)
            next = time.Date(next.Year(), next.Month(), next.Day(), 0, 0, 0, 0, next.Location())
            t := time.NewTimer(next.Sub(now))
            &lt;-t.C
        }
    }()
}
</code></pre></li>

<li><p>golang中交换字符串中的字符，需要先转化为[]byte来转化</p>

<pre><code>func smallestStringWithSwaps(s string, pairs [][]int) string {
    n := len(s)
    res := make([]byte,n)
    for k,v := range s{
        res[k] = byte(v)
    }
    for _,v := range pairs{
        left := v[0]
        right := v[1]
        if left &lt; right {
            if res[left] &gt; res[right]{
                res[left],res[right] =  res[right],res[left]
            }
        }
    }
    return string(res)
}
</code></pre></li>
</ol>

<h1 id="常规使用">常规使用</h1>

<h2 id="go-内存和指针">go 内存和指针</h2>

<p>Go语言中的指针和C语言中在使用上几乎没有什么差别。</p>

<blockquote>
<p>make和new</p>
</blockquote>

<p>Go语言中有两个分配内存的机制，分别是内建的函数new和make。但是new和make并不能等同，他们所做的事情其实并不同，所应用到的类型也不相同。
 </p>

<pre><code>1、 new(T)函数是一个分配内存的内建函数，但是不同于其他语言中内建new函数所做的工作，在Go语言中，new只是将内存清零，并没有初始化内存。所以在Go语言中，new(T)所做的工作是为T类型分配了值为零的内存空间并返回其地址，即返回*T。也就是说，new(T)返回一个指向新分配的类型T的零值指针

内置函数 new 分配空间。传递给new 函数的是一个类型，不是一个值。返回值是 指向这个新分配的零值的指针。
即：var pInt *int = new(int) //*pInt = nil
 
2、 make(T, args)函数与new(T)函数的目的不同。make(T, args)仅用于创建切片、map和channel(消息管道)，make(T, args)返回类型T的一个被初始化了的实例。而new（T）返回指向类型T的零值指针。也就是说new函数返回的是*T的未初始化零值指针，而make函数返回的是T的初始化了的实例

内建函数 make 分配并且初始化 一个 slice, 或者 map 或者 chan 对象。 并且只能是这三种对象。 和 new 一样，第一个参数是 类型，不是一个值。 但是make 的返回值就是这个类型（即使一个引用类型），而不是指针。 具体的返回值，依赖具体传入的类型。
//创建一个初始元素个数为5的数组切片，元素初始值为0
a := make([]int, 5)  // len(a)=5
 
</code></pre>

<p>Go语言中出现new和make两个分配内存的函数，并且使用起来还有差异，主要原因是切片、map、channel这三种类型在使用前必须初始化相关的数据结构。例如，切片是一个有三项内容的数据类型，包括指向数据的指针（在一个数组内部进行切片）、长度和容量，在这三项内容被初始化之前，切片值为nil。换句话说：对于切片、map、channel，make(T, args)初始化了其内部的数据结构并为他们准备了将要使用的值</p>

<p>例如：make([]int, 10, 100); //分配一个整形数组，长度为10，容量为100，并返回其前10个数组的切片</p>

<p>所以，在为切片、map、channel这三种类型分配内存时，为了不必要的使问题复杂化，应该使用Go的内建make函数</p>

<p>记住 make 只用于map，slice和channel，并且不返回指针。要获得一个显式的指针，使用 new 进行分配，或者显式地使用一个变量的地址。</p>

<p>这些例子阐释了 new 和 make 之间的差别。</p>

<pre><code>var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints
// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)
// Idiomatic:
v := make([]int, 100)
</code></pre>

<blockquote>
<p>问题</p>
</blockquote>

<p>1.panic: runtime error: invalid memory address or nil pointer dereference</p>

<p>正常都是内存没有分配</p>

<p>2.routers/routers.go:14:61: cannot call pointer method on controllers.UserController literal</p>

<p>原因: 指针不能作为接收者, 需要需要定义指针变量来接送地址</p>

<p>实例</p>

<pre><code>type myTreeNode struct{
    node *tree.TreeNode
}

func (mynode *myTreeNode) postOrader(){
    if mynode==nil || mynode.node==nil{
        return
    }

    //错误的写法
    myTreeNode{mynode.node.Left}.postOrader()
    right := myTreeNode{mynode.node.Right}.postOrader()
    mynode.node.Print()

    //正确的写法
    left := myTreeNode{mynode.node.Left}
    left.postOrader()
    right := myTreeNode{mynode.node.Right}
    right.postOrader()
    mynode.node.Print()
}
</code></pre>

<h2 id="golang中-json-map-struct-之间的相互转化">GoLang中 json、map、struct 之间的相互转化</h2>

<blockquote>
<p>golang 中 json 转 struct</p>
</blockquote>

<p>使用 json.Unmarshal 时，结构体的每一项必须是导出项(import field)。也就是说结构体的 key 对应的首字母必须为大写。</p>

<p>请看下面的例子：</p>

<pre><code>import (
    &quot;testing&quot;
    &quot;encoding/json&quot;
)

type Person struct {
    name string
    age int
}

func TestStruct2Json(t *testing.T) {
    jsonStr := `
    {
        &quot;name&quot;:&quot;liangyongxing&quot;,
        &quot;age&quot;:12
    }
    `
    var person Person
    json.Unmarshal([]byte(jsonStr), &amp;person)
    t.Log(person)
}

输出的结果如下：

1
{ 0}
</code></pre>

<p>从结果可以看出，json 数据并没有写入 Person 结构体中。结构体 key 首字母大写的话就可以，修改后：</p>

<pre><code>import (
    &quot;testing&quot;
    &quot;encoding/json&quot;
)

type Person struct {
    Name string
    Age int
}

func TestStruct2Json(t *testing.T) {
    jsonStr := `
    {
        &quot;name&quot;:&quot;liangyongxing&quot;,
        &quot;age&quot;:12
    }
    `
    var person Person
    json.Unmarshal([]byte(jsonStr), &amp;person)
    t.Log(person)
}

打印结果如下：

1
{liangyongxing 12}
</code></pre>

<p>从以上结果我们可以发现一个很重要的信息，json 里面的 key 和 struct 里面的 key一个是小写一个是大写，即两者大小写并没有对上。从这里我们就可以得出一个结论，要想能够附上值需要结构体中的变量名首字母大写，而在转换的 json 串中大小写都可以，即在 json 传中字段名称大小写不敏感。那么经过验证发现，在 json 中如果写成如下方式：</p>

<pre><code>jsonStr :=
    {
        &quot;NaMe&quot;:&quot;liangyongxing&quot;,
        &quot;agE&quot;:12
    }
</code></pre>

<p>最终结果仍然是有值的，那么就验证了我们上面的结论，json 串中对字段名大小写不敏感(不一定是首字母，这点需要注意)</p>

<p>在结构体中是可以引入 tag 标签的，这样在匹配的时候 json 串对应的字段名需要与 tag 标签中定义的字段名匹配，当然在 tag 中定义的名称就不需要首字母大写了，且对应的 json 串中字段名称仍然大小写不敏感，和上面的结论一致。(注意：此时结构体中对应的字段名可以不用和匹配的一致，但是也必须首字母大写，只有大写的才是可对外提供访问的)</p>

<pre><code>import (
    &quot;testing&quot;
    &quot;encoding/json&quot;
)

//这里对应的 N 和 A 不能为小写，首字母必须为大写，这样才可对外提供访问，具体 json 匹配是通过后面的 tag 标签进行匹配的，与 N 和 A 没有关系
//tag 标签中 json 后面跟着的是字段名称，都是字符串类型，要求必须加上双引号，否则 golang 是无法识别它的类型
type Person struct {
    N string     `json:&quot;name&quot;`
    A int        `json:&quot;age&quot;`
}

func TestStruct2Json(t *testing.T) {
    jsonStr := `
    {
        &quot;name&quot;:&quot;liangyongxing&quot;,
        &quot;age&quot;:12
    }
    `
    var person Person
    json.Unmarshal([]byte(jsonStr), &amp;person)
    t.Log(person)
}
复制代码
这样输出的结果如下：

1
{liangyongxing 12}
</code></pre>

<p>当然，你也可以再做一个实验，验证 tag 标签中对应的字段名称大小写不敏感，这里就不做冗余介绍了。</p>

<blockquote>
<p>golang 中 struct 转 json 串</p>
</blockquote>

<p>直接使用Marshal</p>

<pre><code>package commontest

import (
    &quot;testing&quot;
    &quot;encoding/json&quot;
)

func TestStruct2Json(t *testing.T) {
    p := Person{
        Name: &quot;liangyongxing&quot;,
        Age: 29,
    }

    t.Logf(&quot;Person 结构体打印结果:%v&quot;, p)

    //Person 结构体转换为对应的 Json
    jsonBytes, err := json.Marshal(p)
    if err != nil {
        t.Fatal(err)
    }
    t.Logf(&quot;转换为 json 串打印结果:%s&quot;, string(jsonBytes))
}


打印结果如下所示：


/usr/local/go/bin/go test -v commontest -run ^TestStruct2Json$
    struct2json_test.go:14: Person 结构体打印结果:{liangyongxing 29}
    struct2json_test.go:21: 转换为 json 串打印结果:{&quot;name&quot;:&quot;liangyongxing&quot;,&quot;age&quot;:29}
ok      commontest  0.006s
</code></pre>

<blockquote>
<p>golang 中 json 转 map</p>
</blockquote>

<p>也是使用Unmarshal</p>

<pre><code>package commontest

import (
    &quot;testing&quot;
    &quot;encoding/json&quot;
)

func TestJson2Map(t *testing.T) {
    jsonStr := `
    {
        &quot;name&quot;:&quot;liangyongxing&quot;,
        &quot;age&quot;:12
    }
    `
    var mapResult map[string]interface{}
    //使用 json.Unmarshal(data []byte, v interface{})进行转换,返回 error 信息
    if err := json.Unmarshal([]byte(jsonStr), &amp;mapResult); err != nil {
        t.Fatal(err)
    }
    t.Log(mapResult)
}

打印结果信息如下：


/usr/local/go/bin/go test -v commontest -run ^TestJson2Map$
    json2map_test.go:19: map[name:liangyongxing age:12]
ok      commontest  0.007s
</code></pre>

<blockquote>
<p>golang 中 map 转 json 串</p>
</blockquote>

<p>也是使用Marshal</p>

<pre><code>import (
    &quot;testing&quot;
    &quot;encoding/json&quot;
)

func TestMap2Json(t *testing.T) {
    mapInstance := make(map[string]interface{})
    mapInstance[&quot;Name&quot;] = &quot;liang637210&quot;
    mapInstance[&quot;Age&quot;] = 28
    mapInstance[&quot;Address&quot;] = &quot;北京昌平区&quot;

    jsonStr, err := json.Marshal(mapInstance)

    if err != nil {
        t.Fatal(err)
    }

    t.Logf(&quot;Map2Json 得到 json 字符串内容:%s&quot;, jsonStr)
}


/usr/local/go/bin/go test -v commontest -run ^TestMap2Json$
    map2json_test.go:20: Map2Json 得到 json 字符串内容:{&quot;Address&quot;:&quot;北京昌平区&quot;,&quot;Age&quot;:28,&quot;Name&quot;:&quot;liang637210&quot;}
ok      commontest  0.008s
</code></pre>

<blockquote>
<p>golang中map转 struct</p>
</blockquote>

<p>其实在map和struct之间的转化完全可以通过上面的两次转换来完成，就是比较消耗资源，可以通过下列方法一次完成相互转换。</p>

<p>这个转换网上有比较完整的项目，已经上传到对应的 github 上了，需要下载之后使用：</p>

<pre><code>$ go get github.com/goinggo/mapstructure
</code></pre>

<p>之后我们就可以直接使用它提供的方法将 map 转换为 struct，让我们直接上代码吧</p>

<pre><code>import (
    &quot;testing&quot;
    &quot;github.com/goinggo/mapstructure&quot;
)

func TestMap2Struct(t *testing.T) {
    mapInstance := make(map[string]interface{})
    mapInstance[&quot;Name&quot;] = &quot;liang637210&quot;
    mapInstance[&quot;Age&quot;] = 28

    var person Person
    //将 map 转换为指定的结构体
    if err := mapstructure.Decode(mapInstance, &amp;person); err != nil {
        t.Fatal(err)
    }
    t.Logf(&quot;map2struct后得到的 struct 内容为:%v&quot;, person)
}

/usr/local/go/bin/go test -v commontest -run ^TestMap2Struct$
    map2struct_test.go:18: map2struct后得到的 struct 内容为:{liang637210 28}
ok      commontest  0.009s
</code></pre>

<blockquote>
<p>golang 中 struct 转 map</p>
</blockquote>

<p>使用reflect</p>

<pre><code>package commontest

import (
    &quot;testing&quot;
    &quot;reflect&quot;
)

type User struct {
    Id        int    `json:&quot;id&quot;`
    Username    string    `json:&quot;username&quot;`
    Password    string    `json:&quot;password&quot;`
}

func Struct2Map(obj interface{}) map[string]interface{} {
    t := reflect.TypeOf(obj)
    v := reflect.ValueOf(obj)

    var data = make(map[string]interface{})
    for i := 0; i &lt; t.NumField(); i+&gt;{
        data[t.Field(i).Name] = v.Field(i).Interface()
    }
    return data
}

func TestStruct2Map(t *testing.T) {
    user := User{5, &quot;zhangsan&quot;, &quot;password&quot;}
    data := Struct2Map(user)
    t.Logf(&quot;struct2map得到的map内容为:%v&quot;, data)
}



打印结果如下：

/usr/local/go/bin/go test -v commontest -run ^TestStruct2Map$
    struct2map_test.go:28: struct2map得到的map内容为:map[Id:5 Username:zhangsan Password:password]
ok      commontest  0.007s
</code></pre>

<p>关于<a href="#reflect">relflect</a>的使用可以参考标准库。</p>

<h2 id="优雅重启升级">优雅重启升级</h2>

<p>使用 Go 语言实现优雅的服务器重启</p>

<pre><code>1、不关闭现有连接：例如我们不希望关掉已部署的运行中的程序。但又想不受限制地随时升级服务。
2、socket连接要随时响应用户请求：任何时刻socket的关闭可能使用户返回'连接被拒绝'的消息，而这是不可取的。
3、新的进程要能够启动并替换掉旧的。
</code></pre>

<p>实现</p>

<p>在基于Unix的操作系统中，signal(信号)是与长时间运行的进程交互的常用方法.</p>

<pre><code>SIGTERM: 优雅地停止进程
SIGHUP: 重启/重新加载进程 (例如: nginx, sshd, apache)
</code></pre>

<p>如果收到SIGHUP信号，优雅地重启进程需要以下几个步骤:</p>

<pre><code>1、服务器要拒绝新的连接请求，但要保持已有的连接。
2、启用新版本的进程
3、将socket“交给”新进程，新进程开始接受新连接请求
4、旧进程处理完毕后立即停止。
</code></pre>

<h2 id="错误处理-函数式编程">错误处理（函数式编程）</h2>

<p>if err !=nil 的代码在golang编码过程中经常会大量出现，我们可以通过函数式编程解决一部分问题，如下</p>

<pre><code>func parse(r io.Reader) (*Point, error) {

    var p Point

    if err := binary.Read(r, binary.BigEndian, &amp;p.Longitude); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &amp;p.Latitude); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &amp;p.Distance); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &amp;p.ElevationGain); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &amp;p.ElevationLoss); err != nil {
        return nil, err
    }
}
</code></pre>

<p>可见上面出现了大量的if err !=nil 的代码，我们可以优化成下面的代码</p>

<pre><code>func parse(r io.Reader) (*Point, error) {
    var p Point
    var err error
    read := func(data interface{}) {
        if err != nil {
            return
        }
        err = binary.Read(r, binary.BigEndian, data)
    }

    read(&amp;p.Longitude)
    read(&amp;p.Latitude)
    read(&amp;p.Distance)
    read(&amp;p.ElevationGain)
    read(&amp;p.ElevationLoss)

    if err != nil {
        return &amp;p, err
    }
    return &amp;p, nil
}
</code></pre>

<p>可见将if err != nil的代码函数化，可以大量的错误处理代码，这是处理错误代码的一种方式，但是也是有针对性。</p>

<h1 id="标准库-常用">标准库（常用）</h1>

<p>标准库：<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/</a></p>

<p>直接去网页版查询，经常使用，方可记住，没事也可以看看，可以根据实例巩固，golang的标准库是相当的丰富，足够我们实现很多功能。</p>

<h2 id="reflect">reflect</h2>

<p><a href="/post/golang/go-reflect/">relflect</a>就是动态运行时的状态，对自己行为的描述（self-representation）和监测（examination）。</p>

<h2 id="io">io</h2>

<p><a href="/post/golang/go-io/">io</a>是所有需要交互的输入输出模式的基础。</p>

<h2 id="ioutil">ioutil</h2>

<p><a href="/post/golang/go-ioutil/">ioutil</a>主要是提供了一些常用、方便的IO操作函数。</p>

<h2 id="fmt">fmt</h2>

<p><a href="/post/golang/go-fmt/">fmt</a>是实现了格式化的I/O函数，这点类似Ｃ语言中的printf和scanf，但是更加简单。</p>

<h2 id="strconv">strconv</h2>

<p><a href="/post/golang/go-strconv/">strconv</a>包实现了基本数据类型和其字符串表示的相互转换。</p>

<h2 id="time">time</h2>

<p><a href="/post/golang/go-time/">time</a>包中包括两类时间：时间点（某一时刻）和时长（某一段时间）的基本操作。</p>

<h2 id="sync">sync</h2>

<p><a href="/post/golang/go-sync/">sync</a>包提供了基本的同步基元，包括底层的原子级内存操作。</p>

<h2 id="runtime包">runtime包</h2>

<p><a href="/post/golang/go-runtime/">runtime</a>包提供和go运行时环境的互操作，如控制go协程的函数。</p>

<h2 id="math-rand">math/rand</h2>

<p><a href="/post/golang/go-math/">math</a>包实现的就是数学函数计算。</p>

<h2 id="strings">strings</h2>

<p><a href="/post/golang/go-strings/">strings</a>包实现的就是字符串的操作。</p>

<h2 id="flag">flag</h2>

<p><a href="/post/golang/go-flag/">flag</a>包实现的就是命令行参数设置解析，一般我们会选择一个我们会针对不同的功能需求选用不同的命令行解析包。</p>

<h2 id="sort">sort</h2>

<p><a href="/post/golang/go-sort/">sort</a>包实现的就是排序算法。</p>

<h2 id="archive">archive</h2>

<p><a href="/post/golang/go-archive/">archive</a>就是使用tar和zip两种方式对文档进行归档。</p>

<h2 id="builtin">builtin</h2>

<p><a href="/post/golang/go-builtin/">builtin</a>包是go的预声明定义，包括go语言中常用的各种类型和方法声明，包括变量和常量两部分。</p>

<h2 id="compress">compress</h2>

<p><a href="/post/golang/go-compress/">compress</a>一般用于压缩。</p>

<h2 id="bytes">bytes</h2>

<p><a href="/post/golang/go-bytes/">bytes</a>该包定义了一些操作 byte slice 的便利操作。</p>

<h2 id="context">context</h2>

<p><a href="/post/golang/go-context">context</a>控制并发。</p>

<h2 id="http">http</h2>

<p><a href="/post/golang/go-net-http">http</a>实现基本http请求。</p>

<h2 id="pprof">pprof</h2>

<p><a href="/post/golang/go-net-http-pporf">pprof</a>性能调优的工具。</p>

<h2 id="interface">interface</h2>

<p><a href="/post/golang/go-interface">interface</a>实现接口。</p>

<h1 id="技术栈">技术栈</h1>

<p>技术栈就是我们开发中经常使用的框架，golang标准库非常丰富，一般我们开发直接可以使用标准库就可以，但是也有一些比较好的技术栈可以直接使用开发，减少重复找轮子的代价，golang开发主要在两个方面：服务器和云计算</p>

<h2 id="服务器">服务器</h2>

<p>后端服务我们主要使用的是golang的高并发能力和简单的<a href="/post/golang/frame/frame/">开发框架</a>。</p>

<h2 id="云计算">云计算</h2>

<p>云计算目前主要即使<a href="/post/cloud/cncf/">k8s以及其生态建设</a>。</p>

<h1 id="开发工具">开发工具</h1>

<blockquote>
<p>sublime text</p>
</blockquote>

<p>尝试了liteide和sublime text，感觉还是sublime text比较好，它支持源码的查看的跳转，编译执行，而liteide在跳转上有点问题，不能跳转到自定义的函数，不知道是不是我配置的问题（基本上就是在查看选项设定了go环境变量），所以自己开发的时候决定用sublime</p>

<p>sublime text go环境搭建</p>

<ol>
<li><p>在mac上安装go并设置好环境变量</p></li>

<li><p>安装一个Package Control，这个应该是一个插件管理工具，用于安装很多其他插件的，只要用ctrl&gt;` 打开命令行输入执行命令</p>

<pre><code>import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' &gt;'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.Net/' &gt;pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)
</code></pre>

<p>安装好后可以在preferences中找到这个插件。</p></li>

<li><p>安装go插件gosublime</p>

<p>我们点击Package Control插件或者用shift+ctrl+p来打开，输入pcip（Package Control:Install Package的缩写）也就是安装插件的意思。然后输入gosublime就会自动安装了，安装好了依旧可以在preferences下找到这个gosublime插件。</p></li>

<li><p>然后就可以在gopath下建src，src下建对应的项目，使用sublime进行编码，查看，按command+b进入到shell模式进行编译执行。</p></li>
</ol>

<p>sublime text只能做一个简单的文本编辑器，不算一个完整的IDE,放弃用于golang编程，用于简单的文本编辑器，使用goland编码。</p>

<blockquote>
<p>goland</p>
</blockquote>

<p>一款类似于idea的IDE，同一个公司出品，目前正在使用，比较好用，目前主打开发工具。</p>

<blockquote>
<p>vscode</p>
</blockquote>

<p>使用的人也是比较多的，功能强大，主要是占用内存很小只有几十M，相比于goland的几个G来说，好很多</p>

<h1 id="go-谚语">Go 谚语</h1>

<p>本文译自go-proverbs, 脱胎于 Rob Pike 振奋人心的演讲视频 talk at Gopherfest SV 2015 (bilibili).</p>

<ol>
<li><p>不要通过共享内存进行通信, 通过通信共享内存 (Don&rsquo;t communicate by sharing memory, share memory by communicating)，</p>

<ol>
<li><p>传统的线程模型（通常在编写 Java, C++和 Python 程序时使用）要求程序员使用共享内存在线程之间进行通信. 通常, 共享数据结构受锁保护, 线程将争夺这些锁访问数据, 在某些情况下, 通过使用 Python 的 Queue 等线程安全的数据结构可以使这变得更容易.</p></li>

<li><p>Go 的并发原语 (goroutines 和 channels) 为构造并发软件提供了一种优雅而独特的手段. (这些概念有一个有趣的历史, 要从 C.A.R.Hoare 的通信顺序进程说起.) Go 鼓励使用 channels 在 goroutines 之间传递对数据的引用, 而不是显式地使用锁来调解对共享数据的访问. 这种方法确保只有一个 goroutine 可以在给定的时间访问数据. 这个概念总结在 Effective Go 文档中 (任何 Go 程序员都必须阅读).</p></li>
</ol>

<p>Go 官方博客中有一篇文章对该谚语解读, 可以参见原文.</p></li>

<li><p>并发不是并行 (Concurrency is not parallelism)</p>

<p>当人们听到 并发 这个词的时候, 他们经常会想到并行, 这是一个相关的, 但非常独特的概念. 在编程中, 并发是独立执行的进程的组成, 而并行则是 (可能相关的) 计算的同时执行. 并发是一次处理很多事情. 并行是一次做很多事情.</p></li>

<li><p>Channels 重排序; 互斥量串行化 (Channels orchestrate; mutexes serialize)</p>

<p>这个看中文（翻译待商榷）是不是一脸懵 (虽然英文也看不懂) ? 其实分号前后说的是一个意思, 该谚语按我的个人理解可以用 go 程序 (来自 go tour) 解释成如下:</p>

<pre><code>package main

import &quot;fmt&quot;

func sum(s []int, c chan int) {
    sum := 0
    for _, v := range s {
        sum += v
    }
    c &lt;- sum // 此处如果改成互斥量一样可以做到
}

func main() {
    s := []int{7, 2, 8, -9, 4, 0}

    c := make(chan int)
    go sum(s[:len(s)/2], c)
    go sum(s[len(s)/2:], c)
    x, y := &lt;-c, &lt;-c

    fmt.Println(x, y, x+y)
}
</code></pre></li>

<li><p>接口越大, 抽象越弱 (The bigger the interface, the weaker the abstraction)</p>

<p>接口背后的概念是通过将对象的行为抽象为简单的契约来允许重用性. 虽然接口不是 Go 专有的, 但由于 Go 接口通常趋向于小型化, Go 程序员才广泛使用它们. 通常情况下, 一个接口只限于一到两个方法.</p></li>

<li><p>Go io 包接口就是典型的例子.</p>

<p>充分利用零值 (Make the zero value useful)</p>

<p>零值的典型例子如 bytes.Buffer 和 sync.Mutex:</p>

<pre><code>var buf bytes.Buffer
buf.Write([]byte(&quot;hello&quot;))
fmt.Println(buf.String())

var mu sync.Mutex
mu.Lock()
mu.Unlock()
</code></pre>

<p>这样看起来是不是感觉一点用没有 ? 如果这样呢 ?</p>

<pre><code>type Map struct {
    mu sync.RWMutex
    // ...
}

func (m *Map) Set(k, v interface{}) {
    m.mu.Lock()
    defer m.mu.Unlock()
    if m.m == nil {
        m.m = make(map[interface{}]interface{})
    }
    m.m[k] = v
}
</code></pre></li>

<li><p>interface{} 言之无物 (interface{} says nothing)</p>

<p>该谚语不是说 interface {} 不代表任何东西, 而是说该类型无静态检查以及调用时保证, 比如你的 func 接收一个 interface{} 类型, 你写的时候是可用的, 但是某个时间你进行了代码重构可能坏掉了.</p></li>

<li><p>Gofmt 的风格没有人喜欢, 但是 gofmt 是每个人的最爱 (Gofmt&rsquo;s style is no one&rsquo;s favorite, yet gofmt is everyone&rsquo;s favorite)</p>

<p>该谚语告诉我们少些风格之争, 用这些时间多写代码.</p></li>

<li><p>小复制好过小依赖 (A little copying is better than a little dependency)</p>

<p>简单说就是如果你可以手动撸小快代码就不要导入一个库去做, 比如 UUID:</p>

<pre><code>// see: https://groups.google.com/d/msg/golang-nuts/d0nF_k4dSx4/rPGgfXv6QCoJ
package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    f, _ := os.Open(&quot;/dev/urandom&quot;) // 演示用忽略 errcheck
    b := make([]byte, 16)
    f.Read(b)
    f.Close()
    uuid := fmt.Sprintf(&quot;%x-%x-%x-%x-%x&quot;, b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
    fmt.Println(uuid)
}
</code></pre>

<p>虽然有一堆写好的 UUID 库, 当你仅仅需要一个 UUID v4 实现.</p></li>

<li><p>系统调用必须始终使用构建标签保证 (Syscall must always be guarded with build tags)</p>

<p>不同的系统 (*NIX, Windows) 调用导致你同一个 func (实现并不一样) 可能需要在不同的系统上构建才能得到你想要的结果. 简单说就是系统调用不可移植才这么干. 示例可参见 Go 标准库 syscall.</p></li>

<li><p>Cgo 必须始终使用构建标签保证 (Cgo must always be guarded with build tags)</p>

<p>基本上原因同上一条.</p>

<p>Cgo 不是 Go (Cgo is not Go)</p>

<p>如果可能不要用 Cgo.</p></li>

<li><p>unsafe 包无保证 (With the unsafe package there are no guarantees)</p>

<p>包如其名, 不安全. 你可以使用 unsafe 包如果你准备好了有一天它会坏掉.</p></li>

<li><p>清晰好过聪明 (Clear is better than clever)</p>

<p>Rob Pike 在他与别人合著的 &lt;程序设计实践&gt; 中写到: &ldquo;写清晰的代码, 不要写聪明的代码&rdquo;.</p></li>

<li><p>反射永远不是清晰的 (Reflection is never clear)</p>

<p>很多人在 Stackoverflow 上抱怨 Go 的反射不工作, 因为那不是为你准备的! 只有很少很少的人应该用反射这个非常强大而又非常难的特性. 新手应该远离反射和 interface{}.</p></li>

<li><p>错误也是一种值 (Errors are values)</p>

<p>值可以被编程, 并且由于错误是值, 所以错误可以被编程. Go 官方博客有对此的解读.</p>

<p>不要止步于检查错误而要优雅的处理 (Don&rsquo;t just check errors, handle them gracefully)</p>

<p>Dave Cheney 有篇博客详细解读了该谚语.</p></li>

<li><p>设计架构, 命名组件, 记录细节 (Design the architecture, name the components, document the details)</p>

<p>当你写一个大型系统的时候, 你把它设计成一种结构化的东西. 想象组件的每一个部分并行工作, 为不同的组件起好的名字, 因为这些名字会出现在稿纸上.</p>

<p>拿 Go 程序来说, 如果名字不错, 组件就好理解, 那么程序的结构设计就会清晰, 程序会感觉很自然.</p>

<p>但是还有很多东西你需要解释, 所以这些是你需要解释的细节. 但是命名会帮助你解释很大一部分设计. 细节只是填补材料的缺口可能用来为用户打印工程图解文档.</p></li>

<li><p>文档是针对用户的 (Documentation is for users)</p>

<p>很多人写文档表明某个 func 是做什么的, 但是他们不想想这个 func 是为谁而写. 这有很大的不同. 你知道这个 func 返回什么是对的, 但是它为什么返回了你使用的时候不一样的结果?</p>

<p>把自己当成使用者而不是写它的人, 那么 godoc 上的文档就是对用户有用的. 这对于其他语言一样适用.</p></li>

<li><p>不要慌 (Don&rsquo;t panic)</p>

<p>不要使用 panic 进行正常的错误处理. 使用错误 (error) 和多个返回值.</p></li>

<li><p>协程调度是很轻的操作，这当然没错。但他们都没有告诉你更重要的一点：协程调度反复高频出现没有goroutine可供调度的代价在Go的当前实现里是显著的。</p></li>

<li><p>好的习惯是，稍大的类型存到map都存储指针而不是值。</p></li>

<li><p>定义数据结构的时候，减少后面使用的转换</p></li>

<li><p>defer是性能杀手，我的原则是能不用尽量避开。</p></li>

<li><p>能不在循环内部做的，就不要在循环内存处理</p></li>

<li><p>减少内存的频繁分配，减少使用全局锁的可能</p></li>
</ol>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="https://kingjcy.github.io/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go/">https://kingjcy.github.io/post/golang/go/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/language/">
                            <i class="fa fa-tags"></i>
                            language
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/go-channel/">Golang使用系列---- channel</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年08月24日)</span></li><li id="li-rels"><a href="/post/golang/go-goroutinechannel/">Golang使用系列---- Goroutine</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年05月24日)</span></li><li id="li-rels"><a href="/post/golang/go-net-http-pporf/">golang使用系列---- net/http/pprof</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月26日)</span></li><li id="li-rels"><a href="/post/golang/go-net-http/">Golang使用系列---- Net/Http 应用层</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年09月26日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">Golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-runtime/">Golang使用系列---- Runtime</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月13日)</span></li><li id="li-rels"><a href="/post/golang/go-concurrence/">Golang使用系列---- Concurrence</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月26日)</span></li><li id="li-rels"><a href="/post/golang/go-map/">Golang使用系列---- Map</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年02月28日)</span></li><li id="li-rels"><a href="/post/golang/go-sync/">Golang使用系列---- Sync</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年02月28日)</span></li><li id="li-rels"><a href="/post/golang/go-mutex/">Golang使用系列---- mutex</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年02月28日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/golang/go-concurrence/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/monitor/metrics/prometheus/cluster/remotestore/m3db/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#为什么使用go">为什么使用go？</a></li>
<li><a href="#语言设计">语言设计</a></li>
<li><a href="#基础语法">基础语法</a>
<ul>
<li><a href="#变量">变量</a></li>
<li><a href="#常量">常量</a></li>
<li><a href="#运算符">运算符</a></li>
<li><a href="#数组">数组</a></li>
<li><a href="#map">map</a></li>
<li><a href="#数据类型">数据类型</a></li>
<li><a href="#语句">语句</a></li>
<li><a href="#go语言的三大核心">go语言的三大核心</a></li>
</ul></li>
<li><a href="#零碎基础知识">零碎基础知识</a></li>
<li><a href="#常规使用">常规使用</a>
<ul>
<li><a href="#go-内存和指针">go 内存和指针</a></li>
<li><a href="#golang中-json-map-struct-之间的相互转化">GoLang中 json、map、struct 之间的相互转化</a></li>
<li><a href="#优雅重启升级">优雅重启升级</a></li>
<li><a href="#错误处理-函数式编程">错误处理（函数式编程）</a></li>
</ul></li>
<li><a href="#标准库-常用">标准库（常用）</a>
<ul>
<li><a href="#reflect">reflect</a></li>
<li><a href="#io">io</a></li>
<li><a href="#ioutil">ioutil</a></li>
<li><a href="#fmt">fmt</a></li>
<li><a href="#strconv">strconv</a></li>
<li><a href="#time">time</a></li>
<li><a href="#sync">sync</a></li>
<li><a href="#runtime包">runtime包</a></li>
<li><a href="#math-rand">math/rand</a></li>
<li><a href="#strings">strings</a></li>
<li><a href="#flag">flag</a></li>
<li><a href="#sort">sort</a></li>
<li><a href="#archive">archive</a></li>
<li><a href="#builtin">builtin</a></li>
<li><a href="#compress">compress</a></li>
<li><a href="#bytes">bytes</a></li>
<li><a href="#context">context</a></li>
<li><a href="#http">http</a></li>
<li><a href="#pprof">pprof</a></li>
<li><a href="#interface">interface</a></li>
</ul></li>
<li><a href="#技术栈">技术栈</a>
<ul>
<li><a href="#服务器">服务器</a></li>
<li><a href="#云计算">云计算</a></li>
</ul></li>
<li><a href="#开发工具">开发工具</a></li>
<li><a href="#go-谚语">Go 谚语</a></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2021  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

