<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="mux 是一个用来执行http请求的路由和分发的第三方扩展包。

mux 其名称来源于HTTP request multiplexer，类似于官方包http.ServeMux，mux.Router将会定义一个路由列表，其中每一个路由都会定义对应的请求url，及其处理方法。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Go Mux - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Go Mux
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2016年08月16日 
                </div>
                <h1 class="post-title">Go Mux</h1>
            </header>

            <div class="post-content">
                <p>mux 是一个用来执行http请求的路由和分发的第三方扩展包。</p>

<p>mux 其名称来源于HTTP request multiplexer，类似于官方包http.ServeMux，mux.Router将会定义一个路由列表，其中每一个路由都会定义对应的请求url，及其处理方法。</p>

<p>常用方法介绍</p>

<p>其中使用的正则表达式和其他的有所不同</p>

<p>正则表达式</p>

<p>路由中支持以正则表达式的方式进行匹配，表达式以大括号包含，内部以冒号分隔， 前半部分为变量的名称，后半部分为变量可匹配类型的正则表达式。</p>

<p>最后都会被转化为标准的正则表达式</p>

<pre><code>/posts/{id:\\d+} // 将被转换成 /posts/(?P&lt;id&gt;\\d+)
/posts/{:\\d+}   // 将被转换成 /posts/\\d+
</code></pre>

<p>若路由字符串中，所有的正则表达式都只有名称部分（没有冒号及之后的内容）， 则会被转换成命名参数，因为不需要作正则验证，性能会比较正则稍微好上一些。 命名参数匹配所有字符。</p>

<pre><code>/posts/{id}.html                  // 匹配 /posts/1.html
/posts-{id}-{page}.html           // 匹配 /posts-1-10.html
</code></pre>

<p>在路由字符串中若是以命名参数结尾的，则表示可以匹配之后的任意字符。</p>

<pre><code>/blog/assets/{path}
/blog/{tags:\\w+}/{path}
/blog/assets{path}
</code></pre>

<p>可能会出现多条记录与同一请求都匹配的情况，这种情况下， 系统会找到一条认为最匹配的路由来处理，判断规则如下：</p>

<ol>
<li>普通路由优先于正则路由；</li>

<li><p>正则路由优先于命名路由；</p>

<p>/posts/{id}.html              // 1
/posts/{id:\d+}.html         // 2
/posts/1.html                 // 3</p>

<p>/posts/1.html      // 匹配 3
/posts/11.html     // 匹配 2
/posts/index.html  // 匹配 1</p></li>
</ol>

<p>如果路由以非 / 开头，则自动将第一个 / 之前的判定为域名，并对其进行域名限定。 比如以下格式：</p>

<pre><code>example.com/html/{id}.html   // 匹配 example.com/html/1.html
*.example.com/html/{id}.html // 支持泛域名，匹配 s1.example.com/html/1.html
</code></pre>

<p>通过正则表达式匹配的路由，其中带命名的参数可通过 Params() 获取：</p>

<pre><code>params := Params(r)

id, err := params.Int(&quot;id&quot;)
// 或是
id := params.MustInt(&quot;id&quot;, 0) // 0 表示在无法获取 id 参数的默认值
</code></pre>

<p>初始化路由</p>

<pre><code>r := mux.NewRouter()
</code></pre>

<p>路由注册</p>

<p>最简单的路由注册：</p>

<pre><code>r.HandleFunc(&quot;/&quot;, HomeHandler)
</code></pre>

<p>其中代码中的第一个参数为请求url，第二个参数为请求的处理函数，该函数可简单的定义为以下代码：</p>

<pre><code>func HomeHandler(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, &quot;this is home&quot;)
}
</code></pre>

<p>带有变量的url路由注册</p>

<p>They are defined using the format {name} or {name:pattern}. If a regular expression pattern is not defined, the matched variable will be anything until the next slash.</p>

<p>使用方式：{name} or {name:pattern}</p>

<p>其中参数可使用正则表达式匹配</p>

<pre><code>r.HandleFunc(&quot;/articles/{category}/{id:[0-9]+}&quot;, ArticleHandler)
</code></pre>

<p>变量可以通过mux.Vars()来获取</p>

<pre><code>func ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, &quot;Category: %v\n&quot;, vars[&quot;category&quot;])
}
</code></pre>

<p>指定Host：</p>

<pre><code>r.Host(&quot;www.example.com&quot;)
</code></pre>

<p>指定http方法：</p>

<pre><code>r.Methods(&quot;GET&quot;, &quot;POST&quot;)
</code></pre>

<p>指定URL安全策略：</p>

<pre><code>r.Schemes(&quot;https&quot;)
</code></pre>

<p>增加URL前缀：</p>

<pre><code>r.PathPrefix(&quot;/products/&quot;)
</code></pre>

<p>添加请求头：</p>

<pre><code>r.Headers(&quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;)
</code></pre>

<p>添加请求参数：</p>

<pre><code>r.Queries(&quot;key&quot;, &quot;value&quot;)
</code></pre>

<p>组合使用：</p>

<pre><code>r.HandleFunc(&quot;/products&quot;, ProductsHandler).
  Host(&quot;www.example.com&quot;).
  Methods(&quot;GET&quot;).
  Schemes(&quot;http&quot;)
</code></pre>

<p>子路由的使用：</p>

<pre><code>r := mux.NewRouter()
s := r.PathPrefix(&quot;/products&quot;).Subrouter()
// &quot;/products/&quot;
s.HandleFunc(&quot;/&quot;, ProductsHandler)
// &quot;/products/{key}/&quot;
s.HandleFunc(&quot;/{key}/&quot;, ProductHandler)
// &quot;/products/{key}/details&quot;
s.HandleFunc(&quot;/{key}/details&quot;, ProductDetailsHandler)
</code></pre>

<p>定义路由别名：</p>

<pre><code>r.HandleFunc(&quot;/articles/{category}/{id:[0-9]+}&quot;, ArticleHandler).Name(&quot;article&quot;)
</code></pre>

<p>静态文件路由：</p>

<pre><code>flag.StringVar(&amp;dir, &quot;dir&quot;, &quot;.&quot;, &quot;the directory to serve files from. Defaults to the current dir&quot;)
flag.Parse()
r := mux.NewRouter()

// This will serve files under http://localhost:8000/static/&lt;filename&gt;
r.PathPrefix(&quot;/static/&quot;).Handler(http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(dir))))
</code></pre>

<p>生成已注册的URL:</p>

<p>生成已注册的url需要用到路由的别名，代码如下：</p>

<pre><code>url, err := r.Get(&quot;router_name&quot;).URL(&quot;key1&quot;, &quot;val1&quot;, &quot;key2&quot;, &quot;val2&quot;)
</code></pre>

<p>例如：</p>

<pre><code>r := mux.NewRouter()
r.Host(&quot;{subdomain}.domain.com&quot;).
  Path(&quot;/articles/{category}/{id:[0-9]+}&quot;).
  Queries(&quot;filter&quot;, &quot;{filter}&quot;).
  HandlerFunc(ArticleHandler).
  Name(&quot;article&quot;)

// url.String() will be &quot;http://news.domain.com/articles/technology/42?filter=gorilla&quot;
url, err := r.Get(&quot;article&quot;).URL(&quot;subdomain&quot;, &quot;news&quot;,
                                 &quot;category&quot;, &quot;technology&quot;,
                                 &quot;id&quot;, &quot;42&quot;,
                                 &quot;filter&quot;, &quot;gorilla&quot;)
</code></pre>

<p>Walk方法：</p>

<p>walk方法可以遍历访问所有已注册的路由，例如以下代码：</p>

<pre><code>func main() {
    r := mux.NewRouter()
    r.HandleFunc(&quot;/&quot;, handler)
    r.HandleFunc(&quot;/products&quot;, handler).Methods(&quot;POST&quot;)
    r.HandleFunc(&quot;/articles&quot;, handler).Methods(&quot;GET&quot;)
    r.HandleFunc(&quot;/articles/{id}&quot;, handler).Methods(&quot;GET&quot;, &quot;PUT&quot;)
    r.HandleFunc(&quot;/authors&quot;, handler).Queries(&quot;surname&quot;, &quot;{surname}&quot;)
    err := r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
        pathTemplate, err := route.GetPathTemplate()
        if err == nil {
            fmt.Println(&quot;ROUTE:&quot;, pathTemplate)
        }
        pathRegexp, err := route.GetPathRegexp()
        if err == nil {
            fmt.Println(&quot;Path regexp:&quot;, pathRegexp)
        }
        queriesTemplates, err := route.GetQueriesTemplates()
        if err == nil {
            fmt.Println(&quot;Queries templates:&quot;, strings.Join(queriesTemplates, &quot;,&quot;))
        }
        queriesRegexps, err := route.GetQueriesRegexp()
        if err == nil {
            fmt.Println(&quot;Queries regexps:&quot;, strings.Join(queriesRegexps, &quot;,&quot;))
        }
        methods, err := route.GetMethods()
        if err == nil {
            fmt.Println(&quot;Methods:&quot;, strings.Join(methods, &quot;,&quot;))
        }
        fmt.Println()
        return nil
    })

    if err != nil {
        fmt.Println(err)
    }

    http.Handle(&quot;/&quot;, r)
}
</code></pre>

<p>Middleware 中间件</p>

<p>mux同样也支持为路由添加中间件。</p>

<p>最简单的中间件定义：</p>

<pre><code>func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Do stuff here
        log.Println(r.RequestURI)
        // Call the next handler, which can be another middleware in the chain, or the final handler.
        next.ServeHTTP(w, r)
    })
}
</code></pre>

<p>中间件使用：</p>

<pre><code>r := mux.NewRouter()
r.HandleFunc(&quot;/&quot;, handler)
r.Use(loggingMiddleware)
</code></pre>

<p>综合示例</p>

<pre><code>package th_mux

import(
    &quot;strings&quot;
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;github.com/gorilla/mux&quot;
)

func Run(){
    var dir string
    flag.StringVar(&amp;dir, &quot;dir&quot;, &quot;.&quot;, &quot;the directory to serve files from. Defaults to the current dir&quot;)
    flag.Parse()
    // 初始化Router
    r := mux.NewRouter()
    // 静态文件路由
    r.PathPrefix(&quot;/static/&quot;).Handler(http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(dir))))
    // 普通路由
    r.HandleFunc(&quot;/&quot;, HomeHandler)
    // 指定host
    r.HandleFunc(&quot;/host&quot;, HostHandler).Host(&quot;localhost&quot;)
    // 带变量的url路由
    r.HandleFunc(&quot;/users/{id}&quot;, GetUserHandler).Methods(&quot;Get&quot;).Name(&quot;user&quot;)

    url, _ := r.Get(&quot;user&quot;).URL(&quot;id&quot;, &quot;5&quot;)
    fmt.Println(&quot;user url: &quot;, url.String())

    // 遍历已注册的路由
    r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
        pathTemplate, err := route.GetPathTemplate()
        if err == nil {
            fmt.Println(&quot;ROUTE:&quot;, pathTemplate)
        }
        pathRegexp, err := route.GetPathRegexp()
        if err == nil {
            fmt.Println(&quot;Path regexp:&quot;, pathRegexp)
        }
        queriesTemplates, err := route.GetQueriesTemplates()
        if err == nil {
            fmt.Println(&quot;Queries templates:&quot;, strings.Join(queriesTemplates, &quot;,&quot;))
        }
        queriesRegexps, err := route.GetQueriesRegexp()
        if err == nil {
            fmt.Println(&quot;Queries regexps:&quot;, strings.Join(queriesRegexps, &quot;,&quot;))
        }
        methods, err := route.GetMethods()
        if err == nil {
            fmt.Println(&quot;Methods:&quot;, strings.Join(methods, &quot;,&quot;))
        }
        fmt.Println()
        return nil
    })

    r.Use(TestMiddleware)
    http.ListenAndServe(&quot;:3000&quot;, r)
}

func HomeHandler(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, &quot;this is home&quot;)
}

func HostHandler(w http.ResponseWriter, r *http.Request){
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, &quot;the host is localhost&quot;)
}

func GetUserHandler(w http.ResponseWriter, r *http.Request){
    vars := mux.Vars(r)
    w.WriteHeader(http.StatusOK)

    fmt.Fprint(w, &quot;this is get user, and the user id is &quot;, vars[&quot;id&quot;])
}


func TestMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Do stuff here
        fmt.Println(&quot;middleware print: &quot;, r.RequestURI)
        // Call the next handler, which can be another middleware in the chain, or the final handler.
        next.ServeHTTP(w, r)
    })
}
</code></pre>

<p>简单的使用</p>

<p>所需的包：github.com/gorilla/mux</p>

<p>我们在启动http服务时设置一下路由的配置方法</p>

<pre><code>func startHttp() {
    if err := http.ListenAndServe(&quot;:9090&quot;, api.NewAPIMux()); err != nil {
        log.Fatal(&quot;ListenAndServe: &quot;, err)
    }
}
</code></pre>

<p>配置方法</p>

<p>api包路由的配置方法有两种，一种是api的配置，另一种的静态资源的配置（不需要为静态资源再开一台nginx）</p>

<pre><code>func NewAPIMux() *mux.Router {
    r := mux.NewRouter()
    s := r.PathPrefix(&quot;/api&quot;).Subrouter()
    initUserApi(s)

    r.PathPrefix(&quot;/&quot;).Handler(http.StripPrefix(&quot;/&quot;, http.FileServer(http.Dir(&quot;web/&quot;))))
    return r
}
</code></pre>

<p>api配置</p>

<p>这里的api配置，是通过mux的前缀功能，把/api开头的的请求都认为是api请求，并且引出子路由，这是用mux最大的目的</p>

<p>我们来看看userapi的初始化的方法里都做什么，当然最好单独一个文件写userapi的代码，比如user.go</p>

<p>func initUserApi(r *mux.Router) {
    s := r.PathPrefix(&ldquo;/user&rdquo;).Subrouter()
    s.HandleFunc(&ldquo;/list&rdquo;, UserListHandler)
    s.HandleFunc(&ldquo;/add&rdquo;, UserAddHandler)
}</p>

<p>func UserListHandler(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(&ldquo;user list&rdquo;))
}</p>

<p>func UserAddHandler(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(&ldquo;user add&rdquo;))
}</p>

<p>简单精炼，匹配了/api/user下的所有请求，并单独处理/api/user/list和/api/user/add</p>

<p>同理，一样的product，order都可以这么写，代码会非常清晰，简单精炼,</p>

<p>静态文件配置</p>

<pre><code>r.PathPrefix(&quot;/&quot;).Handler(http.StripPrefix(&quot;/&quot;, http.FileServer(http.Dir(&quot;web/&quot;))))
</code></pre>

<p>嗯，就这么简单的一句，将除了api之外的所有请求导入到web目录下，以静态文件的方式处理，不再需要启动nginx，apache之类的去处理</p>

<p>这就是我喜欢golang的地方，更多去操作业务本身，而不是一直敲重复的代码</p>

<p>使用mux包实现一个web服务</p>

<ol>
<li><p>调用 ListenAndServe 方法后启动 HTTP 服务器：</p>

<p>http.ListenAndServe(&rdquo;:8888&rdquo;, nil) // args: port &amp; router</p></li>
</ol>

<p>第二个参数 nil 意味着 DefaultServeMux 用于请求路由。</p>

<p>gorilla/mux 库包含 mux.Router 类型，可替代 DefaultServeMux 或自定义请求多路复用器。 在 ListenAndServe 调用中，mux.Router 实例将代替 nil 作为第二个参数。</p>

<ol>
<li><p>参考这个实例进行解析</p>

<p>package main
import (
   &ldquo;gorilla/mux&rdquo;
   &ldquo;net/http&rdquo;
   &ldquo;fmt&rdquo;
   &ldquo;strconv&rdquo;
)
const GETALL string = &ldquo;GETALL&rdquo;
const GETONE string = &ldquo;GETONE&rdquo;
const POST string   = &ldquo;POST&rdquo;
const PUT string    = &ldquo;PUT&rdquo;
const DELETE string = &ldquo;DELETE&rdquo;
type clichePair struct {
   Id      int
   Cliche  string
   Counter string
}
// Message sent to goroutine that accesses the requested resource.
type crudRequest struct {
   verb     string
   cp       *clichePair
   id       int
   cliche   string
   counter  string
   confirm  chan string
}
var clichesList = []*clichePair{}
var masterId = 1
var crudRequests chan *crudRequest
// GET /
// GET /cliches
func ClichesAll(res http.ResponseWriter, req *http.Request) {
   cr := &amp;crudRequest{verb: GETALL, confirm: make(chan string)}
   completeRequest(cr, res, &ldquo;read all&rdquo;)
}
// GET /cliches/id
func ClichesOne(res http.ResponseWriter, req *http.Request) {
   id := getIdFromRequest(req)
   cr := &amp;crudRequest{verb: GETONE, id: id, confirm: make(chan string)}
   completeRequest(cr, res, &ldquo;read one&rdquo;)
}
// POST /cliches
func ClichesCreate(res http.ResponseWriter, req *http.Request) {
   cliche, counter := getDataFromRequest(req)
   cp := new(clichePair)
   cp.Cliche = cliche
   cp.Counter = counter
   cr := &amp;crudRequest{verb: POST, cp: cp, confirm: make(chan string)}
   completeRequest(cr, res, &ldquo;create&rdquo;)
}
// PUT /cliches/id
func ClichesEdit(res http.ResponseWriter, req *http.Request) {
   id := getIdFromRequest(req)
   cliche, counter := getDataFromRequest(req)
   cr := &amp;crudRequest{verb: PUT, id: id, cliche: cliche, counter: counter, confirm: make(chan string)}
   completeRequest(cr, res, &ldquo;edit&rdquo;)
}
// DELETE /cliches/id
func ClichesDelete(res http.ResponseWriter, req *http.Request) {
   id := getIdFromRequest(req)
   cr := &amp;crudRequest{verb: DELETE, id: id, confirm: make(chan string)}
   completeRequest(cr, res, &ldquo;delete&rdquo;)
}
func completeRequest(cr *crudRequest, res http.ResponseWriter, logMsg string) {
   crudRequests&lt;-cr
   msg := &lt;-cr.confirm
   res.Write([]byte(msg))
   logIt(logMsg)
}
func main() {
   populateClichesList()
   // From now on, this gorountine alone accesses the clichesList.
   crudRequests = make(chan *crudRequest, 8)
   go func() { // resource manager
      for {
         select {
         case req := &lt;-crudRequests:
         if req.verb == GETALL {
            req.confirm&lt;-readAll()
         } else if req.verb == GETONE {
            req.confirm&lt;-readOne(req.id)
         } else if req.verb == POST {
            req.confirm&lt;-addPair(req.cp)
         } else if req.verb == PUT {
            req.confirm&lt;-editPair(req.id, req.cliche, req.counter)
         } else if req.verb == DELETE {
            req.confirm&lt;-deletePair(req.id)
         }
      }
   }()
   startServer()
}
func startServer() {
   router := mux.NewRouter()
   // Dispatch map for CRUD operations.
   router.HandleFunc(&ldquo;/&rdquo;, ClichesAll).Methods(&ldquo;GET&rdquo;)
   router.HandleFunc(&ldquo;/cliches&rdquo;, ClichesAll).Methods(&ldquo;GET&rdquo;)
   router.HandleFunc(&ldquo;/cliches/{id:[0-9]+}&ldquo;, ClichesOne).Methods(&ldquo;GET&rdquo;)
   router.HandleFunc(&ldquo;/cliches&rdquo;, ClichesCreate).Methods(&ldquo;POST&rdquo;)
   router.HandleFunc(&ldquo;/cliches/{id:[0-9]+}&ldquo;, ClichesEdit).Methods(&ldquo;PUT&rdquo;)
   router.HandleFunc(&ldquo;/cliches/{id:[0-9]+}&ldquo;, ClichesDelete).Methods(&ldquo;DELETE&rdquo;)
   http.Handle(&ldquo;/&rdquo;, router) // enable the router
   // Start the server.
   port := &ldquo;:8888&rdquo;
   fmt.Println(&rdquo;\nListening on port &ldquo; + port)
   http.ListenAndServe(port, router); // mux.Router now in play
}
// Return entire list to requester.
func readAll() string {
   msg := &ldquo;\n&rdquo;
   for _, cliche := range clichesList {
      next := strconv.Itoa(cliche.Id) + &ldquo;: &ldquo; + cliche.Cliche + &rdquo;  &ldquo; + cliche.Counter + &ldquo;\n&rdquo;
      msg += next
   }
   return msg
}
// Return specified clichePair to requester.
func readOne(id int) string {
   msg := &ldquo;\n&rdquo; + &ldquo;Bad Id: &ldquo; + strconv.Itoa(id) + &ldquo;\n&rdquo;
   index := findCliche(id)
   if index &gt;= 0 {
      cliche := clichesList[index]
      msg = &ldquo;\n&rdquo; + strconv.Itoa(id) + &ldquo;: &ldquo; + cliche.Cliche + &rdquo;  &ldquo; + cliche.Counter + &ldquo;\n&rdquo;
   }
   return msg
}
// Create a new clichePair and add to list
func addPair(cp *clichePair) string {
   cp.Id = masterId
   masterId++
   clichesList = append(clichesList, cp)
   return &ldquo;\nCreated: &ldquo; + cp.Cliche + &rdquo; &ldquo; + cp.Counter + &ldquo;\n&rdquo;
}
// Edit an existing clichePair
func editPair(id int, cliche string, counter string) string {
   msg := &ldquo;\n&rdquo; + &ldquo;Bad Id: &ldquo; + strconv.Itoa(id) + &ldquo;\n&rdquo;
   index := findCliche(id)
   if index &gt;= 0 {
      clichesList[index].Cliche = cliche
      clichesList[index].Counter = counter
      msg = &ldquo;\nCliche edited: &ldquo; + cliche + &rdquo; &ldquo; + counter + &ldquo;\n&rdquo;
   }
   return msg
}
// Delete a clichePair
func deletePair(id int) string {
   idStr := strconv.Itoa(id)
   msg := &ldquo;\n&rdquo; + &ldquo;Bad Id: &ldquo; + idStr + &ldquo;\n&rdquo;
   index := findCliche(id)
   if index &gt;= 0 {
      clichesList = append(clichesList[:index], clichesList[index + 1:]&hellip;)
      msg = &ldquo;\nCliche &ldquo; + idStr + &rdquo; deleted\n&rdquo;
   }
   return msg
}
//*** utility functions
func findCliche(id int) int {
   for i := 0; i &lt; len(clichesList); i++ {
      if id == clichesList[i].Id {
         return i;
      }
   }
   return -1 // not found
}
func getIdFromRequest(req *http.Request) int {
   vars := mux.Vars(req)
   id, _ := strconv.Atoi(vars[&ldquo;id&rdquo;])
   return id
}
func getDataFromRequest(req *http.Request) (string, string) {
   // Extract the user-provided data for the new clichePair
   req.ParseForm()
   form := req.Form
   cliche := form[&ldquo;cliche&rdquo;][0]    // 1st and only member of a list
   counter := form[&ldquo;counter&rdquo;][0]  // ditto
   return cliche, counter
}
func logIt(msg string) {
   fmt.Println(msg)
}
func populateClichesList() {
   var cliches = []string {
      &ldquo;Out of sight, out of mind.&rdquo;,
      &ldquo;A penny saved is a penny earned.&rdquo;,
      &ldquo;He who hesitates is lost.&rdquo;,
   }
   var counterCliches = []string {
      &ldquo;Absence makes the heart grow fonder.&rdquo;,
      &ldquo;Penny-wise and dollar-foolish.&rdquo;,
      &ldquo;Look before you leap.&rdquo;,
   }
   for i := 0; i &lt; len(cliches); i++ {
      cp := new(clichePair)
      cp.Id = masterId
      masterId++
      cp.Cliche = cliches[i]
      cp.Counter = counterCliches[i]
      clichesList = append(clichesList, cp)
   }
}</p></li>
</ol>

<p>支持四种 CRUD（创建/读取/更新/删除）操作，它们分别对应四种 HTTP 请求方法：POST、GET、PUT 和 DELETE。</p>

<ol>
<li>mux.Router 扩展了 REST 风格的路由，它赋给 HTTP 方法（例如，GET）和 URL 末尾的 URI 或路径（例如 /cliches）相同的权重。 URI 用作 HTTP 动词（方法）的名词。</li>
</ol>

<p>例如，在HTTP请求中有一个起始行，例如：</p>

<pre><code>GET /cliches
</code></pre>

<p>意味着得到所有的数据，而一个起始线，如：</p>

<pre><code>POST /cliches
</code></pre>

<p>意味着从 HTTP 正文中的数据创建一个数据。</p>

<p>在 CRUD web 应用程序中，有五个函数充当 HTTP 请求的五种变体的请求处理程序：</p>

<pre><code>ClichesAll(...)    # GET: 获取所有的数据
ClichesOne(...)    # GET: 获取指定的数据
ClichesCreate(...) # POST: 创建新的数据
ClichesEdit(...)   # PUT: 编辑现有的数据
ClichesDelete(...) # DELETE: 删除指定的数据
</code></pre>

<p>每个函数都有两个参数：一个 http.ResponseWriter 用于向请求者发送一个响应，一个指向 http.Request 的指针，该指针封装了底层 HTTP 请求的信息。 使用 gorilla/mux 包可以轻松地将这些请求处理程序注册到Web服务器，并执行基于正则表达式的验证。</p>

<ol>
<li><p>CRUD 应用程序中的 startServer 函数注册请求处理程序。 考虑这对注册，router 作为 mux.Router 实例：</p>

<p>router.HandleFunc(&ldquo;/&rdquo;, ClichesAll).Methods(&ldquo;GET&rdquo;)
router.HandleFunc(&ldquo;/cliches&rdquo;, ClichesAll).Methods(&ldquo;GET&rdquo;)</p></li>
</ol>

<p>这些语句意味着对单斜线 / 或 /cliches 的 GET 请求应该路由到 ClichesAll 函数，然后处理请求。 例如，curl 请求（使用 ％ 作为命令行提示符）：</p>

<pre><code>% curl --request GET localhost:8888/
</code></pre>

<p>会产生如下结果：</p>

<p>1: Out of sight, out of mind.  Absence makes the heart grow fonder.
2: A penny saved is a penny earned.  Penny-wise and dollar-foolish.
3: He who hesitates is lost.  Look before you leap.</p>

<p>这三个数据是 CRUD 应用程序中的初始数据。</p>

<ol>
<li><p>在这句注册语句中：</p>

<p>router.HandleFunc(&ldquo;/cliches&rdquo;, ClichesAll).Methods(&ldquo;GET&rdquo;)
router.HandleFunc(&ldquo;/cliches&rdquo;, ClichesCreate).Methods(&ldquo;POST&rdquo;)</p></li>
</ol>

<p>URI 是相同的（/cliches），但动词不同：第一种情况下为 GET 请求，第二种情况下为 POST 请求。 此注册举例说明了 REST 样式的路由，因为仅动词的不同就足以将请求分派给两个不同的处理程序。</p>

<p>注册中允许多个 HTTP 方法，尽管这会影响 REST 风格路由的精髓：</p>

<p>router.HandleFunc(&ldquo;/cliches&rdquo;, DoItAll).Methods(&ldquo;POST&rdquo;, &ldquo;GET&rdquo;)
除了动词和 URI 之外，还可以在功能上路由 HTTP 请求。 例如，注册</p>

<p>router.HandleFunc(&ldquo;/cliches&rdquo;, ClichesCreate).Schemes(&ldquo;https&rdquo;).Methods(&ldquo;POST&rdquo;)
要求对 POST 请求进行 HTTPS 访问以创建新的数据。以类似的方式，注册可能需要具有指定的 HTTP 头元素（例如，认证凭证）的请求。</p>

<ol>
<li>Request validation</li>
</ol>

<p>gorilla/mux 包采用简单，直观的方法通过正则表达式进行请求验证。 考虑此请求处理程序以获取一个操作：</p>

<pre><code>router.HandleFunc(&quot;/cliches/{id:[0-9]+}&quot;, ClichesOne).Methods(&quot;GET&quot;)
</code></pre>

<p>此注册排除了 HTTP 请求，例如：</p>

<pre><code>% curl --request GET localhost:8888/cliches/foo
</code></pre>

<p>因为 foo 不是十进制数字。该请求导致熟悉的 404（未找到）状态码。 在此处理程序注册中包含正则表达式模式可确保仅在请求 URI 以十进制整数值结束时才调用 ClichesOne 函数来处理请求：</p>

<pre><code>% curl --request GET localhost:8888/cliches/3  # ok
</code></pre>

<p>另一个例子，请求如下：</p>

<pre><code>% curl --request PUT --data &quot;...&quot; localhost:8888/cliches
</code></pre>

<p>此请求导致状态代码为 405（错误方法），因为 /cliches URI 在 CRUD 应用程序中仅在 GET 和 POST 请求中注册。 像 GET 请求一样，PUT 请求必须在 URI 的末尾包含一个数字 id：</p>

<pre><code>router.HandleFunc(&quot;/cliches/{id:[0-9]+}&quot;, ClichesEdit).Methods(&quot;PUT&quot;)
</code></pre>

<ol>
<li>并发问题</li>
</ol>

<p>gorilla/mux 路由器作为单独的 Go 协程执行对已注册的请求处理程序的每次调用，这意味着并发性被内置于包中。 例如，如果有十个同时发出的请求，例如</p>

<pre><code>% curl --request POST --data &quot;...&quot; localhost:8888/cliches
</code></pre>

<p>然后 mux.Router 启动十个 Go 协程来执行 ClichesCreate 处理程序。</p>

<p>GET all、GET one、POST、PUT 和 DELETE 中的五个请求操作中，最后三个改变了所请求的资源，即包含数据的共享 clichesList。 因此，CRUD app 需要通过协调对 clichesList 的访问来保证安全的并发性。 在不同但等效的术语中，CRUD app 必须防止 clichesList 上的竞争条件。 在生产环境中，可以使用数据库系统来存储诸如 clichesList 之类的资源，然后可以通过数据库事务来管理安全并发。</p>

<p>CRUD 应用程序采用推荐的Go方法来实现安全并发：</p>

<p>只有一个 Go 协程，资源管理器在 CRUD app startServer 函数中启动，一旦 Web 服务器开始侦听请求，就可以访问 clichesList。
诸如 ClichesCreate 和 ClichesAll 之类的请求处理程序向 Go 通道发送（指向）crudRequest 实例（默认情况下是线程安全的），并且资源管理器单独从该通道读取。 然后，资源管理器对 clichesList 执行请求的操作。</p>

<p>安全并发体系结构绘制如下：</p>

<pre><code>        crudRequest                读/写
</code></pre>

<p>请求处理程序 &mdash;&mdash;&mdash;&mdash;-&gt; 资源托管者 &mdash;&mdash;&mdash;&mdash;&gt; 套话列表、</p>

<p>在这种架构中，不需要显式锁定 clichesList，因为一旦 CRUD 请求开始进入，只有一个 Go 协程（资源管理器）访问 clichesList。</p>

<p>为了使 CRUD 应用程序尽可能保持并发，在一方请求处理程序与另一方的单一资源管理器之间进行有效的分工至关重要。 在这里，为了审查，是 ClichesCreate 请求处理程序：</p>

<pre><code>func ClichesCreate(res http.ResponseWriter, req *http.Request) {
   cliche, counter := getDataFromRequest(req)
   cp := new(clichePair)
   cp.Cliche = cliche
   cp.Counter = counter
   cr := &amp;crudRequest{verb: POST, cp: cp, confirm: make(chan string)}
   completeRequest(cr, res, &quot;create&quot;)
}
</code></pre>

<p>ClichesCreate 调用实用函数 getDataFromRequest，它从 POST 请求中提取新的套话和反套话。 然后 ClichesCreate 函数创建一个新的 ClichePair，设置两个字段，并创建一个 crudRequest 发送给单个资源管理器。 此请求包括一个确认通道，资源管理器使用该通道将信息返回给请求处理程序。 所有设置工作都可以在不涉及资源管理器的情况下完成，因为尚未访问 clichesList。</p>

<p>请求处理程序调用实用程序函数，该函数从 POST 请求中提取新的套话和反套话。 然后，该函数创建一个新的，设置两个字段，并创建一个 crudRequest 发送到单个资源管理器。 此请求包括一个确认通道，资源管理器使用该通道将信息返回给请求处理程序。 所有设置工作都可以在不涉及资源管理器的情况下完成，因为尚未访问它。</p>

<p>completeRequest 实用程序函数在 ClichesCreate 函数和其他请求处理程序的末尾调用：</p>

<pre><code>completeRequest(cr, res, &quot;create&quot;) // shown above
</code></pre>

<p>通过将 crudRequest 放入 crudRequests 频道，使资源管理器发挥作用：</p>

<pre><code>func completeRequest(cr *crudRequest, res http.ResponseWriter, logMsg string) {
   crudRequests&lt;-cr          // 向资源托管者发送请求
   msg := &lt;-cr.confirm       // 等待确认
   res.Write([]byte(msg))    // 向请求方发送确认
   logIt(logMsg)             // 打印到标准输出
}
</code></pre>

<p>对于 POST 请求，资源管理器调用实用程序函数 addPair，它会更改 clichesList 资源：</p>

<pre><code>func addPair(cp *clichePair) string {
   cp.Id = masterId  // 分配一个唯一的 ID 
   masterId++        // 更新 ID 计数器
   clichesList = append(clichesList, cp) // 更新列表
   return &quot;\nCreated: &quot; + cp.Cliche + &quot; &quot; + cp.Counter + &quot;\n&quot;
}
</code></pre>

<p>资源管理器为其他 CRUD 操作调用类似的实用程序函数。 值得重复的是，一旦 Web 服务器开始接受请求，资源管理器就是唯一可以读取或写入 clichesList 的 goroutine。</p>

<p>对于任何类型的 Web 应用程序，gorilla/mux 包在简单直观的 API 中提供请求路由、请求验证和相关服务。 CRUD web 应用程序突出了软件包的主要功能。</p>

<p>相同的url不同的method，可以自动路由到对应的方法上。比如下面这个写法就可以路由</p>

<pre><code>s.HandleFunc(&quot;/{uid:[0-9]+}/hosts/{host}&quot;,host.Post).Methods(&quot;POST&quot;)
s.HandleFunc(&quot;/{uid:[0-9]+}/hosts&quot;,host.Get).Methods(&quot;GET&quot;)
s.HandleFunc(&quot;/{uid:[0-9]+}/hosts/{host}&quot;,host.Put).Methods(&quot;PUT&quot;)
s.HandleFunc(&quot;/{uid:[0-9]+}/hosts/{host}&quot;,host.Delete).Methods(&quot;DELETE&quot;)
</code></pre>

<p>基于 GO 实现I/O多路复用&mdash;直接查看yamux篇</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-mux/">https://kingjcy.github.io/post/golang/go-mux/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/mux/">
                            <i class="fa fa-tags"></i>
                            mux
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/golang/go-script/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/golang/go-io/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

