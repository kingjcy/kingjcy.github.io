<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Go 语言使用 error 类型来返回函数执行过程中遇到的错误，如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Go Error - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Go Error
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2016年08月29日 
                </div>
                <h1 class="post-title">Go Error</h1>
            </header>

            <div class="post-content">
                <p>Go 语言使用 error 类型来返回函数执行过程中遇到的错误，如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。</p>

<h3 id="error">error</h3>

<p>其实 error 只是一个接口，定义如下：</p>

<pre><code>type error interface {
    Error() string
}
</code></pre>

<p>你可以用任何类型去实现它（只要添加一个 Error() 方法即可），也就是说，error 可以是任何类型，这意味着，函数返回的 error 值实际可以包含任意信息，不一定是字符串（当然字符串是必须的）。</p>

<p>error 不一定表示一个错误，它可以表示任何信息，比如 io 包中就用 error 类型的 io.EOF 表示数据读取结束，而不是遇到了什么错误。再比如 path/filepath 包中用 error 类型的 filepath.SkipDir 表示跳过当前目录，继续遍历下一个目录，而不是遇到了什么错误。</p>

<h3 id="errors">errors</h3>

<p>　　
errors 包实现了一个最简单的 error 类型，只包含一个字符串，它可以记录大多数情况下遇到的错误信息。errors 包的用法也很简单，只有一个 New 函数，用于生成一个最简单的 error 对象：</p>

<pre><code>// 将字符串 text 包装成一个 error 对象返回
func New(text string) error



// 示例
func SomeFunc() error {
    if 遇到错误 {
        return errors.New(&quot;遇到了某某错误&quot;)
    }
    return nil
}
</code></pre>

<p>如果你的程序需要记录更多的错误信息，比如时间、数值等信息，可以声明一个自定义的 error 类型。</p>

<p>示例</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

type myError struct {
    err   string
    time  time.Time
    count int
}

//接口重写
func (m *myError) Error() string {
    return fmt.Sprintf(&quot;%s %d 次。时间：%v&quot;, m.err, m.count, m.time)
}

func newErr(s string, i int) *myError {
    return &amp;myError{
        err:   s,
        time:  time.Now(),
        count: i,
    }
}

var count int

func SomeFunc() error {
    if true {
        count++
        return newErr(&quot;遇到某某情况&quot;, count)
    }
    return nil
}

func main() {
    for i := 0; i &lt; 5; i++ {
        if err := SomeFunc(); err != nil {
            fmt.Println(err)
        }
    }
}
</code></pre>

<p>所以重写error接口的基本使用方法就是</p>

<p>结构体</p>

<pre><code>type errorString struct {
    s string
}
</code></pre>

<p>方法</p>

<pre><code>func New(text string) error {
    return &amp;errorString{text}
}
</code></pre>

<p>然后重写error接口</p>

<pre><code>func (e *errorString) Error() string {
    return e.s
}
</code></pre>

<p>使用字符串创建一个错误,请类比fmt包的Errorf方法，差不多可以认为是New(fmt.Sprintf(&hellip;))。</p>

<p>go语言中一般有三种错误处理策略：</p>

<ol>
<li>返回和检查错误值：通过特定值表示成功和不同的错误，上层代码检查错误的值，来判断被调用func的执行状态</li>
<li>自定义错误类型：通过自定义的错误类型来表示特定的错误，上层代码通过类型断言判断错误的类型</li>
<li>隐藏内部细节的错误处理：假设上层代码不知道被调用函数返回的错误任何细节，直接再向上返回错误</li>
</ol>

<h1 id="异常和错误">异常和错误</h1>

<p>错误指的是可能出现问题的地方出现了问题，比如打开一个文件时失败，这种情况在人们的意料之中 ；</p>

<p>异常指的是不应该出现问题的地方出现了问题，比如引用了空指针，这种情况在人们的意料之外。</p>

<p>可见，错误是业务过程的一部分，而异常不是 。异常比错误更加严重</p>

<p>Golang错误和异常是可以互相转换的：</p>

<p>错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。
异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。</p>

<p>在这个启示下，我们给出异常处理的作用域（场景）：</p>

<p>空指针引用
下标越界
除数为0
不应该出现的分支，比如default
输入不应该引起函数错误</p>

<p>其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。</p>

<p>Golang错误处理方式一直是很多人诟病的地方，有些人吐槽说一半的代码都是&rdquo;if err != nil { / 打印 &amp;&amp; 错误处理 / }&ldquo;，严重影响正常的处理逻辑。当我们区分错误和异常，根据规则设计函数，就会大大提高可读性和可维护性。</p>

<ol>
<li>直接进行匹配</li>
</ol>

<p>就是直接全局变量奖对应的错误定义好，然后直接使用</p>

<p>var ErrRecordNotFound = errors.New(&ldquo;record not found&rdquo;)</p>

<p>这个貌似没有什么好的处理方式，其实每个语言都有这么一段错误检查，所以错误要规范使用，正确姿势，可以减少很多问题</p>

<p>下面是正常的使用</p>

<p>错误使用</p>

<ol>
<li><p>失败的原因只有一个时，不使用error，使用bool</p>

<p>func (self *AgentContext) CheckHostType(host_type string) error {
    switch host_type {
    case &ldquo;virtual_machine&rdquo;:
        return nil
    case &ldquo;bare_metal&rdquo;:
        return nil
    }
    return errors.New(&ldquo;CheckHostType ERROR:&rdquo; + host_type)
}</p></li>
</ol>

<p>我们可以看出，该函数失败的原因只有一个，所以返回值的类型应该为bool，而不是error，重构一下代码：</p>

<pre><code>func (self *AgentContext) IsValidHostType(hostType string) bool {
    return hostType == &quot;virtual_machine&quot; || hostType == &quot;bare_metal&quot;
}
</code></pre>

<ol>
<li>没有失败时，不使用error</li>
</ol>

<p>error在Golang中是如此的流行，以至于很多人设计函数时不管三七二十一都使用error，即使没有一个失败原因。</p>

<p>我们看一下示例代码：</p>

<pre><code>func (self *CniParam) setTenantId() error {
    self.TenantId = self.PodNs
    return nil
}
</code></pre>

<p>对于上面的函数设计，就会有下面的调用代码：</p>

<pre><code>err := self.setTenantId()
if err != nil {
    // log
    // free resource
    return errors.New(...)
}
</code></pre>

<p>根据我们的正确姿势，重构一下代码：</p>

<pre><code>func (self *CniParam) setTenantId() {
    self.TenantId = self.PodNs
}
</code></pre>

<p>于是调用代码变为：</p>

<pre><code>self.setTenantId()
</code></pre>

<ol>
<li><p>error应放在返回值类型列表的最后</p></li>

<li><p>错误值统一定义，而不是跟着感觉走</p></li>
</ol>

<p>var ERR_EOF = errors.New(&ldquo;EOF&rdquo;)
var ERR_CLOSED_PIPE = errors.New(&ldquo;io: read/write on closed pipe&rdquo;)
var ERR_NO_PROGRESS = errors.New(&ldquo;multiple Read calls return no data or error&rdquo;)
var ERR_SHORT_BUFFER = errors.New(&ldquo;short buffer&rdquo;)
var ERR_SHORT_WRITE = errors.New(&ldquo;short write&rdquo;)
var ERR_UNEXPECTED_EOF = errors.New(&ldquo;unexpected EOF&rdquo;)</p>

<p>5，错误逐层传递时，层层都加日志</p>

<ol>
<li><p>错误处理使用defer</p>

<p>func deferDemo() error {
    err := createResource1()
    if err != nil {
        return ERR_CREATE_RESOURCE1_FAILED
    }
    err = createResource2()
    if err != nil {
        destroyResource1()
        return ERR_CREATE_RESOURCE2_FAILED
    }</p>

<pre><code>err = createResource3()
if err != nil {
    destroyResource1()
    destroyResource2()
    return ERR_CREATE_RESOURCE3_FAILED
}

err = createResource4()
if err != nil {
    destroyResource1()
    destroyResource2()
    destroyResource3()
    return ERR_CREATE_RESOURCE4_FAILED
}
return nil
</code></pre>

<p>}</p></li>
</ol>

<p>当Golang的代码执行时，如果遇到defer的闭包调用，则压入堆栈。当函数返回时，会按照后进先出的顺序调用闭包。
对于闭包的参数是值传递，而对于外部变量却是引用传递，所以闭包中的外部变量err的值就变成外部函数返回时最新的err值。
根据这个结论，我们重构上面的示例代码：</p>

<pre><code>func deferDemo() error {
    err := createResource1()
    if err != nil {
        return ERR_CREATE_RESOURCE1_FAILED
    }
    defer func() {
        if err != nil {
            destroyResource1()
        }
    }()
    err = createResource2()
    if err != nil {
        return ERR_CREATE_RESOURCE2_FAILED
    }
    defer func() {
        if err != nil {
            destroyResource2()
        }
    }()

    err = createResource3()
    if err != nil {
        return ERR_CREATE_RESOURCE3_FAILED
    }
    defer func() {
        if err != nil {
            destroyResource3()
        }
    }()

    err = createResource4()
    if err != nil {
        return ERR_CREATE_RESOURCE4_FAILED
    }
    return nil
}
</code></pre>

<p>7.当尝试几次可以避免失败时，不要立即返回错误</p>

<ol>
<li>当上层函数不关心错误时，建议不返回error</li>
</ol>

<p>9.当发生错误时，不忽略有用的返回值</p>

<p>异常</p>

<p>1.在程序开发阶段，坚持速错</p>

<ol>
<li><p>在程序部署后，应恢复异常避免程序终止</p></li>

<li><p>对于不应该出现的分支，使用异常处理</p>

<p>switch s := suit(drawCard()); s {
    case &ldquo;Spades&rdquo;:
    // &hellip;
    case &ldquo;Hearts&rdquo;:
    // &hellip;
    case &ldquo;Diamonds&rdquo;:
    // &hellip;
    case &ldquo;Clubs&rdquo;:
    // &hellip;
    default:
        panic(fmt.Sprintf(&ldquo;invalid suit %v&rdquo;, s))
}</p></li>

<li><p>针对入参不应该有问题的函数，使用panic设计</p></li>
</ol>

<h1 id="使用switch来出来不同的err">使用switch来出来不同的err</h1>

<pre><code>func Error(rw http.ResponseWriter, err error) {
    rw.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)

    var res ErrResponse
    switch v := err.(type) {
    case errors.Error:
        res.Error = v.Error()
        rw.WriteHeader(v.Code())
    default:
        res.Error = err.Error()
        rw.WriteHeader(500)
    }
    buf, _ := json.Marshal(&amp;res)
    rw.Write(buf)
}
</code></pre>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-error/">https://kingjcy.github.io/post/golang/go-error/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/error/">
                            <i class="fa fa-tags"></i>
                            error
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/architecture/sso/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/golang/go-script/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#error">error</a></li>
<li><a href="#errors">errors</a></li>
</ul></li>
</ul></li>
<li><a href="#异常和错误">异常和错误</a></li>
<li><a href="#使用switch来出来不同的err">使用switch来出来不同的err</a></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

