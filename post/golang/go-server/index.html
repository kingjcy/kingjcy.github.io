<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="基于go-net的http协议和go-rpc的协议实现服务器框架">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Go Server - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Go Server
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2018年02月26日 
                </div>
                <h1 class="post-title">Go Server</h1>
            </header>

            <div class="post-content">
                <p>基于go-net的http协议和go-rpc的协议实现服务器框架</p>

<p>Go语言类库中，有两个官方的服务器框架，也就是标准库，一个HTTP，一个是RPC。使用这个两个框架，已经能解决大部分的问题，但是，也有一些需求，这些框架是不够的，这篇文章，我们先分析一下HTTP 和 RPC服务器的特点, 然后结合这两个服务器的特点，我实现了一个新的服务器，这个服务器非常适合客户端和服务器端有大量交互的情况。</p>

<p>HTTP服务器的特点：</p>

<p>HTTP的请求 和 响应的周期如下：</p>

<p>对于一个HTTP 长连接，一个请求必须等到一个响应完成后，才能进行下一个请求。这就是http协议最本质的特点，是串行化的。而这个特点保证了http协议的简洁性，一个请求中间不会插入其他的请求干扰，这样不需要去对应请求和响应。但是，同时也有个弱点，那就是不适合做大量的请求。举个实际中我们遇到的例子，我们要把大量的中国客户的订单送入英国的交易所，交易所的接口是http协议的，从中国到英国，一次http的请求到响应至少需要 300ms左右，这样一秒一个连只能发送3个，就算是开十个线程发送（接口对线程总数是有限制的），1s 也只能是30个。而最高峰的时候，我们可能1s 要发送1万个订单，那采用http协议就不能满足我们的要求了（这个可以通过fix协议解决）。</p>

<p>当然，http可以解决批量提交的需求，只要增加一个批量提交的接口就可以了。但是，这样的实现方式不够自然，而且增加了额外的接口。</p>

<p>这个只是说正对http长连接的一种描述，但是net/http并不是这个原理，net是可以并发的，来一个请求，就是开启一个goroutine来处理这个请求，然后继续监听，但是goroutine是一个for循环体，没有控制，容易造成内存等各种问题，所以不适合高并发。具体可以参考go-net来看http的原理，和go-concurrence来看大批量并发的处理，</p>

<p>RPC服务的特点：</p>

<p>PRC服务器克服了http服务器串流模型，可以并发的提交请求。请求响应的周期图如下：</p>

<p>RPC服务，已经可以克服http服务器的串流的劣势，可以批量提交大量的数据。在局域网的中测试，1s钟可以实现3万次左右的请求。而相同的条件下，http在局域网中，只能实现1500次左右的请求，真实环境下面，延时严重，http性能会急剧下降。在两个不同的机房中，有百兆带宽相连，实际测试rpc请求是两万次左右，http是 500次左右，而且http占用很多头部的带宽。</p>

<p>RPC的一个核心特点是类似一次函数调用。这样一个请求 只能 对应于 一个响应。在某些情下，这似乎是不够的。举个实际的例子，我要获取一个报价的行情数据，这个时候，类似一个MessageQueue，服务器会不断的push数据给客户端。也就是一次请求，会有多次返回，持续不断的返回。</p>

<p>当然，RPC的一个非常重要的优势是，你不需要知道怎么去解析数据，你可以当做网络是空气，完全像写本地调用函数一样去调用rpc的函数。</p>

<p>rpc有很多优秀的框架，比如比较熟悉的grpc，可以参考grpc篇</p>

<p>什么时候使用</p>

<ol>
<li><p>http API（提倡设计成restful）</p></li>

<li><p>rpc，为什么现在流行rpc框架，最主要的是提供了本地化调用的方式，很方便内部通信</p></li>
</ol>

<p>所以一般对外是http api（restful）接口</p>

<p>而在模块（组件）内部使用rpc比较好，方便开发，还能实现批量处理。</p>

<p>异步服务器：</p>

<p>这个服务器的特点类似一个界面程序的消息体系。我们不断的吧鼠标键盘等各种事件提交给界面程序，界面程序根据消息的类型，参数做出相应的处理。所以，我们就叫做异步服务器吧。经典的金融服务器都是异步服务器，处理机制都类似界面的消息循环机制，比如国内期货最常用的ctp交易系统，还有就是银行间，交易所和银行之间，经常用的一个协议叫做 fix，也是这样的架构。请求是一种消息，响应也是一种消息。</p>

<p>比如</p>

<p>msg1 请求之后，有两个响应，Resp1 ， resp2，</p>

<p>msg2 有一个响应 resp3.</p>

<p>借鉴了rpc的特点，请求和响应都自动编码，写服务器不再为编码而烦恼，同时也不需要为是否要压缩而头痛。现在提供三种方式，gob , json, protocolbuffer. 并且可以 设置是否启用压缩的，以及压缩的格式。我们把客户端和服务器的交互抽象为一个消息系统，先来看看客户端客户端调用：</p>

<pre><code>client, err := NewClient(&quot;http://localhost:8080&quot;, jar, &quot;gob&quot;, &quot;gzip&quot;)
if err != nil {
    log.Println(err)
    return
}
defer client.Close()
req := NewRequest(&quot;hello&quot;, &quot;jack&quot;, func(call *Call, status int) {
    log.Println(call, call.Resp, status)
})
client.Go(req)
req2 := NewRequest(&quot;hello&quot;, &quot;fuck&quot;, func(call *Call, status int) {
    log.Println(call, call.Resp, status)
})
client.Go(req2)
//wait for all req is done
client.Wait()
</code></pre>

<p>1-6行，我们建立了一个到服务器的连接，注意，我们这个服务器底层是用http包实现的。jar 是用来管理session的，这里暂时忽略，gob是编码，gzip是压缩格式。可以动态设置各种编码和压缩格式。</p>

<p>7-13行，NewRequest 的第一个参数是消息的类型（我建议再后面的版本中，改成NewMessage， Client.GO 改成 client.Send），叫做hello, 详细类型为了方便查看也打印，我采用字符串的格式。后面是消息的参数，可以是任何的go的结构，变量。每个请求对应一个回调函数，处理响应的消息，响应的消息保存在 call.Resp 里面，如果status == StatusDone ， 表示请求结束了，服务器不会响应任何消息了，status == StatusUpdate ，说明，还会有下一个消息过来。</p>

<p>16行 Wait函数，其实就是一个消息循环函数，不断的从服务器端读取消息，对应到某个请求的回调函数里面。类似event loop</p>

<p>我们在Client里面加入心跳函数，保证能检查到链接损坏的情况，如果连接损坏，会自动结束消息循环，错误处理是一个服务器非常重要的一环。</p>

<p>然后我们再来看看服务器端的实现：</p>

<pre><code>func helloWorld(w *ResponseWriter, r *Request) {
    resp := w.Resp
    resp.MsgType = MsgTString
    //表示我已经没有其他数据包了，这个请求已经结束了
    resp.Done = true
    //向客户端发送请求
    w.WriteResponse(resp, &quot;hello: &quot; + r.GetBody().(string))
}
</code></pre>

<p>第7行中，r.GetBody() 获取的到是上面NewRequest 中的第二个参数。</p>

<p>这样就是一个最简单的hello world 程序。要实现一个实战有用的服务器，的细节当然还有很多，主要的是流量控制。比如，一个用户写错程序了，错误的发起了10万个请求，服务器端不能开个10万个go进行处理，这样的话，会直接拖垮服务器，我们给每个用户设置了一个并发处理数目，最多这个用户可以并发处理多少个请求。还有一个比较重要的，对服务器来说，就是服务器服务的量的限制。我们会实时监控 cpu 内存，io的使用情况，当发现使用到某个限额的时候，服务会拒绝接受连接（事先要对性能进行测试）这些都是为了防止服务器过载 ，而实际中的服务器，这个问题其实是很常见的。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-server/">https://kingjcy.github.io/post/golang/go-server/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/webserver/">
                            <i class="fa fa-tags"></i>
                            webserver
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/rpc/">
                            <i class="fa fa-tags"></i>
                            rpc
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/http/">
                            <i class="fa fa-tags"></i>
                            http
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-container-heap/">golang使用系列---- heap</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/architecture/microservices/microservices/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/middleware/network/application-netprotocol/rpc/grpc/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

