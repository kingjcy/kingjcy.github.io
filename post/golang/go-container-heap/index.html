<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="堆（Heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="golang使用系列---- heap - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    golang使用系列---- heap
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年10月11日 
                </div>
                <h1 class="post-title">golang使用系列---- heap</h1>
            </header>

            <div class="post-content">
                <p>堆（Heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>

<h1 id="基本概念">基本概念</h1>

<p>逻辑定义：n个元素序列{k1, k2… ki…kn},当且仅当满足下列关系时称之为堆：</p>

<pre><code>(ki &lt;= k2i, ki &lt;= k2i+1)或者(ki &gt;= k2i, ki &gt;= k2i+1), (i = 1, 2, 3, 4... n/2)
</code></pre>

<p>堆具有以下特性：</p>

<pre><code>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。
堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。
</code></pre>

<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>

<p>由于堆是完全二叉树，所以可以用顺序数组来表示，如下图。</p>

<p><img src="/media/golang/container/heap.svg" alt="" /></p>

<h1 id="container-heap">container/heap</h1>

<p>了解了堆是什么以后，再来看看container/heap包。</p>

<p>heap包为实现了heap.Interface的类型提供了堆方法：</p>

<pre><code>type Interface interface {
    sort.Interface
    Push(x interface{}) // add x as element Len()，就是在数组的最后追加一个数字，给heap包的Push使用，构建堆在原始函数中实现
    Pop() interface{}   // remove and return element Len() - 1.和push一样，就是在数组的最后删除一个数字
}
</code></pre>

<p>可以看出，这个堆结构继承自sort.Interface, 而sort.Interface，需要实现三个方法：Len() int /   Less(i, j int) bool  /  Swap(i, j int) 再加上堆接口定义的两个方法：Push(x interface{})   /  Pop() interface{}。故只要实现了这五个方法，变定义了一个堆。</p>

<p>less方法很重要，可以决定你返回的是最大堆(&gt;)还是最小堆(&lt;)</p>

<p>任何实现了本接口的类型都可以用于构建最小堆。最小堆可以通过heap.Init建立，数据是递增顺序或者空的话也是最小堆。最小堆的约束条件是：</p>

<pre><code>!h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len()
</code></pre>

<p>注意接口的Push和Pop方法是供heap包调用的，请使用heap.Push和heap.Pop来向一个堆添加或者删除元素。</p>

<pre><code>func Fix(h Interface, i int)  //  在修改第i个元素后，调用本函数修复堆，比删除第i个元素后插入新元素更有效率。复杂度O(log(n))，其中n等于h.Len()。
func Init(h Interface)  //初始化一个堆。一个堆在使用任何堆操作之前应先初始化。Init函数对于堆的约束性是幂等的（多次执行无意义），并可能在任何时候堆的约束性被破坏时被调用。本函数复杂度为O(n)，其中n等于h.Len()。
func Pop(h Interface) interface{}  //删除并返回堆h中的最小元素（不影响约束性）。复杂度O(log(n))，其中n等于h.Len()。该函数等价于Remove(h, 0)。
func Push(h Interface, x interface{})  //向堆h中插入元素x，并保持堆的约束性。复杂度O(log(n))，其中n等于h.Len()。
func Remove(h Interface, i int) interface{}  //删除堆中的第i个元素，并保持堆的约束性。复杂度O(log(n))，其中n等于h.Len()。
</code></pre>

<p>实例</p>

<p>go src的priority queue为例。</p>

<p>定义PriorityQueue类型。</p>

<pre><code>// An Item is something we manage in a priority queue.
type Item struct {
    value    string // The value of the item; arbitrary.
    priority int    // The priority of the item in the queue.
    // The index is needed by update and is maintained by the heap.Interface methods.
    index int // The index of the item in the heap.
}

// A PriorityQueue implements heap.Interface and holds Items.
type PriorityQueue []*Item

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    // We want Pop to give us the highest, not lowest, priority so we use greater than here.
    return pq[i].priority &gt; pq[j].priority
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
    pq[i].index = i
    pq[j].index = j
}

func (pq *PriorityQueue) Push(x interface{}) {
    n := len(*pq)
    item := x.(*Item)
    item.index = n
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    item.index = -1 // for safety
    *pq = old[0 : n-1]
    return item
}

// update modifies the priority and value of an Item in the queue.
func (pq *PriorityQueue) update(item *Item, value string, priority int) {
    item.value = value
    item.priority = priority
    heap.Fix(pq, item.index)
}
</code></pre>

<p>PriorityQueue本质上是个 *Item 数组，其Len/Less/Swap是比较常见的数组用来sort需要定义的函数，而Push、Pop则是使用数组来插入、的方法。PriorityQueue还提供了update方法。注意由于通常希望优先级队列Pop出来的是优先级最高的元素，所以Less方法是反着写的。</p>

<p>定义了以上方法以后，PriorityQueue就具备了使用container/heap包的条件。</p>

<p>如下代码，先从items map出发定义了一个pq数组，长度为hash的size，并调用heap.Init初始化pq数组；之后向队列中增加了一个优先级为1的元素，并更新该元素的队列；最后从队列中依此Pop，可见元素在Pop时是依照优先级排序的。</p>

<pre><code>// This example creates a PriorityQueue with some items, adds and manipulates an item,
// and then removes the items in priority order.
func Example_priorityQueue() {
    // Some items and their priorities.
    items := map[string]int{
        &quot;banana&quot;: 3, &quot;apple&quot;: 2, &quot;pear&quot;: 4,
    }

    // Create a priority queue, put the items in it, and
    // establish the priority queue (heap) invariants.
    pq := make(PriorityQueue, len(items))
    i := 0
    for value, priority := range items {
        pq[i] = &amp;Item{
            value:    value,
            priority: priority,
            index:    i,
        }
        i++
    }
    heap.Init(&amp;pq)

    // Insert a new item and then modify its priority.
    item := &amp;Item{
        value:    &quot;orange&quot;,
        priority: 1,
    }
    heap.Push(&amp;pq, item)
    pq.update(item, item.value, 5)

    // Take the items out; they arrive in decreasing priority order.
    for pq.Len() &gt; 0 {
        item := heap.Pop(&amp;pq).(*Item)
        fmt.Printf(&quot;%.2d:%s &quot;, item.priority, item.value)
    }
    // Output:
    // 05:orange 04:pear 03:banana 02:apple
}
</code></pre>

<h1 id="源码分析">源码分析</h1>

<blockquote>
<p>heap.Init</p>
</blockquote>

<p>先来看看heap.Init函数。</p>

<pre><code>// A heap must be initialized before any of the heap operations
// can be used. Init is idempotent with respect to the heap invariants
// and may be called whenever the heap invariants may have been invalidated.
// Its complexity is O(n) where n = h.Len().
//
func Init(h Interface) {
    // heapify
    n := h.Len()
    for i := n/2 - 1; i &gt;= 0; i-- {
        down(h, i, n)
    }
}
</code></pre>

<p>n/2-1代表树的倒数第二层，它的子节点2k，2k+1（k是重1开始的）如果比根节点小，就进行交换，当然交换后如果子节点由树还是需要进行对比交换，直到满足堆的特性，由底想上，最后最小的就在根。也就是在数组的第一个元素</p>

<p>关键点在于down函数，也就是下沉的操作。</p>

<pre><code>func down(h Interface, i0, n int) bool {
    i := i0
    for {
        j1 := 2*i + 1
        if j1 &gt;= n || j1 &lt; 0 { // j1 &lt; 0 after int overflow
            break
        }
        j := j1 // left child
        if j2 := j1 + 1; j2 &lt; n &amp;&amp; h.Less(j2, j1) {
            j = j2 // = 2*i + 2  // right child
        }
        if !h.Less(j, i) {
            break
        }
        h.Swap(i, j)
        i = j
    }
    return i &gt; i0
}
</code></pre>

<p>down函数的功能非常简单：给定类型，需要down（下沉）的元素在数组中的索引，heap的长度，将该元素下沉到该元素对应的子树合适的位置，从而满足该子树为最小堆的要求。</p>

<p>还记得前面的那张顺序数组表示堆的图吗？结合down函数的实现：任选一个元素 i ，将其与它的子节点 2i+1 和 2i+2（这个i是重0开始的）比较，如果元素 i 比它的子节点小，则将元素 i 与两个子节点中较小的节点交换（j），从而保证满足最小树的要求（第一次down）；子节点 j 可能也有它的子节点，继续比较、交换，直到数组末尾，或者元素 i 比它的两个子节点都小，跳出循环（）。</p>

<p>为什么元素 i 比它的两个子节点都小，就可以跳出循环，不再继续下去呢？这是由于，在Init函数中，第一个开始down（下沉）的元素是第 n/2 - 1 个，可以保证总是从最后一棵子树开始down（如前图，n=8或者n=9, n/2-1总是为4），因此可以保证Init-&gt;down时，如果元素 i 比它的两个子节点都小，那么该元素对应的子树，就是最小堆。</p>

<p>Init在遍历完毕后，可以保证，待Init的数组是一个最小堆。</p>

<blockquote>
<p>heap.Push</p>
</blockquote>

<p>再来看看heap.Push是怎么保证插入新元素时，顺序数组仍然是一个最小堆。</p>

<pre><code>// Push pushes the element x onto the heap. The complexity is
// O(log(n)) where n = h.Len().
func Push(h Interface, x interface{}) {
    h.Push(x)//这边就是我们自己实现的数组追加数据的
    up(h, h.Len()-1)//up上浮构建最小堆
}
</code></pre>

<p>首先调用h.Push将元素推入用户定义的类型，即前述的PriorityQueue。数组append，没什么好说的。由于是将该元素插入到了数组的末尾位置，所以需要调用up函数来“上浮”。</p>

<p>来看看up是怎么上浮的。</p>

<pre><code>func up(h Interface, j int) {
    for {
        i := (j - 1) / 2 // parent
        if i == j || !h.Less(j, i) {
            break
        }
        h.Swap(i, j)
        j = i
    }
}
</code></pre>

<p>很简单，依此查找元素 j 的父节点（i），如果元素 j 比父节点 i 要小，则交换这两个节点，并继续向再上一级的父节点比较，直到根节点，或者元素 j 大于 父节点 i。</p>

<p>如此，可以保证插入新元素的顺序数组在up之后，仍然是一个最小堆。</p>

<blockquote>
<p>heap.Pop</p>
</blockquote>

<pre><code>// Pop removes the minimum element (according to Less) from the heap
// and returns it. The complexity is O(log(n)) where n = h.Len().
// It is equivalent to Remove(h, 0).
func Pop(h Interface) interface{} {
    n := h.Len() - 1
    h.Swap(0, n)
    down(h, 0, n)
    return h.Pop()
}
</code></pre>

<p>前面PriorityQueue的Pop函数，实际是取了顺序数组的 :n-1 子数组，因此heap.Pop的目的就是将根节点（0）与末尾节点的元素交换，并将新的根节点的元素down（下沉）到合适的位置，满足最小堆的要求；最后再调用PriorityQueue的Pop函数获取最后一个元素即可。</p>

<blockquote>
<p>heap.Fix</p>
</blockquote>

<p>PriorityQueue的update函数在修改元素优先级的时候，实际是靠heap.Fix完成的。</p>

<pre><code>// Fix re-establishes the heap ordering after the element at index i has changed its value.
// Changing the value of the element at index i and then calling Fix is equivalent to,
// but less expensive than, calling Remove(h, i) followed by a Push of the new value.
// The complexity is O(log(n)) where n = h.Len().
func Fix(h Interface, i int) {
    if !down(h, i, h.Len()) {
        up(h, i)
    }
}
</code></pre>

<p>代码比较清晰：如果能下沉，则下沉，否则上浮。down的返回值可以表达是否有下沉过（即是否有swap过）。</p>

<blockquote>
<p>heap.Remove</p>
</blockquote>

<p>优先级队列的示例中没有使用Remove函数，直接来看代码。</p>

<pre><code>// Remove removes the element at index i from the heap.
// The complexity is O(log(n)) where n = h.Len().
//
func Remove(h Interface, i int) interface{} {
    n := h.Len() - 1
    if n != i {
        h.Swap(i, n)
        if !down(h, i, n) {
            up(h, i)
        }
    }
    return h.Pop()
}
</code></pre>

<p>先将要删除的节点 i 与末尾节点 n 交换，然后将新的节点 i 下沉或上浮到合适的位置。这块逻辑跟Fix是类似的，但注意不能直接调用heap.Fix，最后一个元素是要被删除的，不能参与Fix。</p>

<h1 id="堆排序">堆排序</h1>

<p>所以所谓的堆排序，就是将堆顶一个个拿出来，就是一个有序的数组</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/golang/go-container-heap/">https://kingjcy.github.io/post/golang/go-container-heap/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/heap/">
                            <i class="fa fa-tags"></i>
                            heap
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/golang/">
                            <i class="fa fa-tags"></i>
                            golang
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/benchmark/">golang使用系列---- Benchmark</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年01月10日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto-tls/">Golang使用系列---- Crypto/Tls</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月19日)</span></li><li id="li-rels"><a href="/post/golang/go-web-safe/">Golang web系列---- Safe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-rate/">Golang使用系列---- Rate</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年11月10日)</span></li><li id="li-rels"><a href="/post/golang/go-container-list/">golang使用系列---- List</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月11日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/golang/go-gc/">golang使用系列---- Gc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年08月27日)</span></li><li id="li-rels"><a href="/post/golang/go-encode/">Golang使用系列---- encode</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月17日)</span></li><li id="li-rels"><a href="/post/golang/go-crypto/">golang使用系列---- Crypto</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年06月06日)</span></li><li id="li-rels"><a href="/post/golang/go-threadsafety/">Go Threadsafety</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月04日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/golang/go-container-list/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/computerbase/datastruct/linklist/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#基本概念">基本概念</a></li>
<li><a href="#container-heap">container/heap</a></li>
<li><a href="#源码分析">源码分析</a></li>
<li><a href="#堆排序">堆排序</a></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

