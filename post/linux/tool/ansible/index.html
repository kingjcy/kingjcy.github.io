<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Ansible is Simple IT Automation：简单的自动化IT工具">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Ansible - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Ansible
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年04月17日 
                </div>
                <h1 class="post-title">Ansible</h1>
            </header>

            <div class="post-content">
                <p>Ansible is Simple IT Automation：简单的自动化IT工具</p>

<p>Fabric，以及我们基于Fabric开发的自动化应用部署的工具： Essay 。都是做了这么个事——批量的在远程服务器上执行命令 。Ansible也是如此。</p>

<p>他们都是基于 paramiko 开发的。这个paramiko是什么呢？它是一个纯Python实现的ssh协议库。因此fabric和ansible还有一个共同点就是不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。</p>

<ol>
<li><p>特性
(1)、no agents：不需要在被管控主机上安装任何客户端；
(2)、no server：无服务器端，使用时直接运行命令即可；
(3)、modules in any languages：基于模块工作，可使用任意语言开发模块；
(4)、yaml，not code：使用yaml语言定制剧本playbook；
(5)、ssh by default：基于SSH工作；
(6)、strong multi-tier solution：可实现多级指挥。</p></li>

<li><p>优点
(1)、轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；
(2)、批量任务执行可以写成脚本，而且不用分发到远程就可以执行；
(3)、使用python编写，维护更简单，ruby语法过于复杂；
(4)、支持sudo。</p></li>
</ol>

<p>安装</p>

<p>因为ansible是python开发的，因此可以这么安装:</p>

<pre><code>sudo esay_install ansible
# 或者
sudo pip install ansible
</code></pre>

<p>你也可以从github上clone最新版本，然后安装。</p>

<p>另外需要注意的是，控制服务器（Master）需要安装Python2.6/7，windows上无法使用ansible。被管理的服务器（Managed Node）需要安装Python2.4以上的版本，如果低于2.5，需要安装python-simplejson。</p>

<p>因为生产机器都是不可能联网的，所以需要离线安装，需要下载基本安装包</p>

<pre><code>ansible-2.4.2.0-2.el7.noarch.rpm
python2-jmespath-0.9.0-3.el7.noarch.rpm
python-httplib2-0.9.2-1.el7.noarch.rpm
python-paramiko-2.1.1-9.el7.noarch.rpm
python-passlib-1.6.5-2.el7.noarch.rpm
</code></pre>

<p>这个是我下载的安装包和依赖包，使用yum localinstall -y安装，能够解决游戏依赖问题，就安装好了</p>

<p>使用</p>

<ol>
<li><p>免密</p></li>

<li><p>ansible命令的使用</p>

<p>Usage: ansible <host-pattern> [options]</p>

<p>Options:
-a MODULE_ARGS, &ndash;args=MODULE_ARGS                 #制定调用的模块（ansible-doc查看模块）
module arguments
&ndash;ask-vault-pass      ask for vault password         #加密文件
-B SECONDS, &ndash;background=SECONDS              #后台等待多少秒
run asynchronously, failing after X seconds
(default=N/A)
-C, &ndash;check           don&rsquo;t make any changes; instead, try to predict some      #不执行命令，值执行命令检查
of the changes that may occur
-D, &ndash;diff            when changing (small) files and templates, show the
differences in those files; works great with &ndash;check
-e EXTRA_VARS, &ndash;extra-vars=EXTRA_VARS                                  #调用外部变量
set additional variables as key=value or YAML/JSON
-f FORKS, &ndash;forks=FORKS                                        #一次执行并发的连接数
specify number of parallel processes to use
(default=5)
-h, &ndash;help            show this help message and exit
-i INVENTORY, &ndash;inventory-file=INVENTORY                                #调用的hosts文件
specify inventory host path
(default=/etc/ansible/hosts) or comma separated host
list.
-l SUBSET, &ndash;limit=SUBSET                                      #限定主机列表中的某台主机执行
further limit selected hosts to an additional pattern
&ndash;list-hosts          outputs a list of matching hosts; does not execute        #列出直接列表中主机
anything else
-m MODULE_NAME, &ndash;module-name=MODULE_NAME                              #调用执行模块
module name to execute (default=command)
-M MODULE_PATH, &ndash;module-path=MODULE_PATH
specify path(s) to module library (default=None)
&ndash;new-vault-password-file=NEW_VAULT_PASSWORD_FILE
new vault password file for rekey
-o, &ndash;one-line        condense output
&ndash;output=OUTPUT_FILE  output file name for encrypt or decrypt; use - for
stdout
-P POLL_INTERVAL, &ndash;poll=POLL_INTERVAL
set the poll interval if using -B (default=15)
&ndash;syntax-check        perform a syntax check on the playbook, but do not
execute it
-t TREE, &ndash;tree=TREE  log output to this directory
&ndash;vault-password-file=VAULT_PASSWORD_FILE
vault password file
-v, &ndash;verbose         verbose mode (-vvv for more, -vvvv to enable          #命令输出详细输出
connection debugging)
&ndash;version             show program&rsquo;s version number and exit</p>

<p>Connection Options:
control as whom and how to connect to hosts</p>

<p>-k, &ndash;ask-pass      ask for connection password                          #需要安装sshpass  输入密码
&ndash;private-key=PRIVATE_KEY_FILE, &ndash;key-file=PRIVATE_KEY_FILE
use this file to authenticate the connection
-u REMOTE_USER, &ndash;user=REMOTE_USER                                       #ssh执行命令的用户，默认为当前执行ansible的用户
connect as this user (default=None)
-c CONNECTION, &ndash;connection=CONNECTION
connection type to use (default=smart)
-T TIMEOUT, &ndash;timeout=TIMEOUT                                      #执行命令的超时时间 (default=10)
override the connection timeout in seconds
(default=10)
&ndash;ssh-common-args=SSH_COMMON_ARGS
specify common arguments to pass to sftp/scp/ssh (e.g.
ProxyCommand)
&ndash;sftp-extra-args=SFTP_EXTRA_ARGS
specify extra arguments to pass to sftp only (e.g. -f,
-l)
&ndash;scp-extra-args=SCP_EXTRA_ARGS
specify extra arguments to pass to scp only (e.g. -l)
&ndash;ssh-extra-args=SSH_EXTRA_ARGS
specify extra arguments to pass to ssh only (e.g. -R)</p>

<p>Privilege Escalation Options:
control how and which user you become as on target hosts</p>

<p>-s, &ndash;sudo          run operations with sudo (nopasswd) (deprecated, use
become)            #sudo
-U SUDO_USER, &ndash;sudo-user=SUDO_USER      #sudo
desired sudo user (default=root) (deprecated, use
become)
-S, &ndash;su            run operations with su (deprecated, use become)
-R SU_USER, &ndash;su-user=SU_USER                                       #su 的时候切换到那个用户
run operations with su as this user (default=root)
(deprecated, use become)</p></li>
</ol>

<p>配置相关配置文件</p>

<p>首先配置设置ansible.cfg来指定对应的inventory等配置，文件在/etc/ansible/ansible.cfg</p>

<p>inventory =/etc/ansible/hosts             #定义资源清单inventory文件的位置，一般保持默认
library =/usr/share/my_modules/           #library指向ansible模块的目录，一般保持默认
forks =10                                 #设置多少个进程同时工作
sudo_user=root                            #设置默认执行命令的用户，也可在playbook中重新设置此参数
remote_port=22                            #制定连接被管理的管理端口，默认为22
timeout =10                               #设置SSH连接的超时时间间隔，单位为秒</p>

<p>然后设置操作的机器/etc/ansible/hosts</p>

<p>[agent]
10.47.210.30
10.47.210.31
10.47.210.94</p>

<p>然后就可以操作agent来操作这些机器了</p>

<p>这边必须要介绍一下inventory</p>

<p>在大规模的配置管理工作中我们需要管理不同业务的机器，这些机器的信息都存放在ansible的inventory组件里。在我们工作中配置部署针对的主机必须先存放在inventory里，这样才能使用ansible对它进行操作。默认ansible的inventory是一个静态的ini文件/etc/ansible/hosts。亦可通过ANSIBLE_HOSTS环境变量指定或者命令运行时用-i参数临时设置。</p>

<p>参考示例：</p>

<p>定义主机和主机组</p>

<pre><code>1、100.0.0.1 ansible_ssh_pass='123456'
2、100.0.0.2 ansible_ssh_pass='123456'
3、[docker]
4、100.0.0.1[1:3]
5、[docker:vars]
6、ansible_ssh_pass='123456'
7、[ansible:children]
8、docker
</code></pre>

<p>第一、二行定义一个主机，指定ssh登录密码</p>

<p>第三行定义了一个叫docker的组</p>

<p>第四行定义了docker组下面四个主机从100.0.0.11-100.0.0.13</p>

<p>第五、六行定义了docker组的ssh登录密码</p>

<p>第七、八行定义了ansible组，ansible组包含docker组</p>

<p>2.inventory内置参数</p>

<pre><code>参考  解释  例子
ansible_ssh_host    将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.   ansible_ssh_host=192.169.1.123
ansible_ssh_port    ssh端口号.如果不是默认的端口号,通过此变量设置.  ansible_ssh_port=5000
ansible_ssh_user    默认的 ssh 用户名 ansible_ssh_user=cxpadmin
ansible_ssh_pass    ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)   ansible_ssh_pass=’123456’
ansible_sudo_pass   sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)  ansible_sudo_pass=’123456’
ansible_sudo_exe    sudo 命令路径(适用于1.8及以上版本)  ansible_sudo_exe=/usr/bin/sudo
ansible_connection  与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 'smart','smart' 方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行.   ansible_connection=local
ansible_ssh_private_key_file    ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.  ansible_ssh_private_key_file=/root/key
ansible_shell_type  目标系统的shell类型.默认情况下,命令的执行使用 'sh' 语法,可设置为 'csh' 或 'fish'. ansible_shell_type=zsh
ansible_python_interpreter  目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如 \*BSD, 或者 /usr/bin/python
不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26). ansible_python_interpreter=/usr/bin/python2.6
ansible_*_interpreter   定义其他语言解释器   ansible_*_interpreter=/usr/bin/ruby
ansible_sudo    定义sudo用户    ansible_sudo=cxpadmin
</code></pre>

<p>注：从ansible2.0开始， ansible_ssh_user, ansible_ssh_host, ansible_ssh_port已经改变为ansible_user, ansible_host, ansible_port。具体参考官网</p>

<p>命令行使用</p>

<p>ansible agent -m command -a &ldquo;touch /tmp/aaa&rdquo; -vvv
#-m  使用command模块  -a 使用command里面支持的命令参数 -vvv 查看详细过程</p>

<p>ansible模块较多，对应可以查看相关文档，此处列出一下日常工作中常用的模块</p>

<p>ping模块
ping模块的作用与其名相同，即判断远程主机的网络是否畅通
示例：ansible agent -m ping</p>

<p>command模块</p>

<p>command 模块用于运行系统命令。不支持管道符和变量等（&rdquo;&lt;&ldquo;, &ldquo;&gt;&rdquo;, &ldquo;|&rdquo;, and &ldquo;&amp;&ldquo;等），如果要使用这些，那么可以使用shell模块。在使用ansible中的时候，默认的模块是-m command，从而模块的参数不需要填写，直接使用即可。</p>

<pre><code>常用参数
参数  是否必须    默认值 选项  说明
chdir   no          运行command命令前先cd到这个目录
creates no          如果这个参数对应的文件存在，就不运行command
executable  no          将shell切换为command执行，这里的所有命令需要使用绝对路径
removes no          如果这个参数对应的文件不存在，就不运行command
</code></pre>

<p>【copy】模块
ansible agent -m copy -a &ldquo;src=/root/test.sh dest=/tmp&rdquo;</p>

<pre><code>参数名 是否必须    默认值 选项  说明
src no          用于定位ansible执行的机器上的文件，需要绝对路径。如果拷贝的是文件夹，那么文件夹会整体拷贝，如果结尾是”/”,那么只有文件夹内的东西被考过去。一切的感觉很像rsync
content no          用来替代src，用于将指定文件的内容，拷贝到远程文件内
dest    yes         用于定位远程节点上的文件，需要绝对路径。如果src指向的是文件夹，这个参数也必须是指向文件夹
backup  no  no  yes/no  备份远程节点上的原始文件，在拷贝之前。如果发生什么意外，原始文件还能使用。
directory_mode  no          这个参数只能用于拷贝文件夹时候，这个设定后，文件夹内新建的文件会被拷贝。而老旧的不会被拷贝
follow  no  no  yes/no  当拷贝的文件夹内有link存在的时候，那么拷贝过去的也会有link
force   no  yes yes/no  默认为yes,会覆盖远程的内容不一样的文件（可能文件名一样）。如果是no，就不会拷贝文件，如果远程有这个文件
group   no          设定一个群组拥有拷贝到远程节点的文件权限
mode    no          等同于chmod，参数可以为“u+rwx or u=rw,g=r,o=r”
owner   no          设定一个用户拥有拷贝到远程节点的文件权限
</code></pre>

<p>直接复制文件，目录不存在，不会自动创建，会报错，复制目录，则会自动创建。</p>

<p>【file】
调用-s 参数，需要客户端能够无密码使用sudo命令；
ansible agent -m file -a &ldquo;dest=/tmp/test.sh mode=755 owner=root group=root&rdquo; -s
【script】
ansible agent -m script -a &ldquo;/tmp/test.sh&rdquo;
【shell】创建用户
ansible agent -m shell -a &ldquo;/tmp/test.sh&rdquo;</p>

<pre><code>常用参数
参数  是否必须    默认值 选项  说明
chdir   no          跟command一样的，运行shell之前cd到某个目录
creates no          跟command一样的，如果某个文件存在则不运行shell
removes no          跟command一样的，如果某个文件不存在则不运行shell
</code></pre>

<p>【group】创建组
ansible agent -m group -a &ldquo;name=test1 state=present&rdquo; -s
【user】
ansible agent -m user -a &ldquo;name=xuel home=/home/xuel state=present&rdquo; -s
【yum】
可以提供的status：absent,present,installed,removed,latest
ansible agent -m yum -a &ldquo;name=httpd state=latest&rdquo; -s
【server】
可以提供的status：running,started,stopped,restarted,reloaded
【cron】
ansible agent -m cron -a &lsquo;name=&ldquo;my job&rdquo; minute=<em>/1 hour=</em> day=* month=* weekday=* job=&ldquo;/usr/sbin/ntpdate time1.aliyun.com&rdquo;&rsquo;
【get_url】
ansible agent -m get_url -a &ldquo;url=<a href="http://mirrors.sohu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm">http://mirrors.sohu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm</a> dest=/tmp&rdquo;
【synchronize】需要安装rsync
ansible agent -m synchronize -a &ldquo;src=/root/test.file dest=/tmp&rdquo;
模块默认使用的为推送push，如果想使用pull功能需添加mode=pull
ansible agent -m synchronize -a &ldquo;mode=pull src=/tmp/test.file dest=/root/&rdquo;
【ini_file】
ansible agent -m ini_file -a &ldquo;dest=/tmp/test.ini section=Mongo option=Host value=127.0.0.1&rdquo;
该模块Python需要安装ConfigParser</p>

<p>具体一些使用参数可以使用的时候查找。</p>

<p>ansible ad-hoc命令</p>

<p>我们经常会通过命令行的形式使用ansible模块，ansible自带很多模块，可以直接使用这些模块。目前ansible已经自带了200+个模块，我们可以使用ansible-doc -l显示所有自带模块，还可以使用ansible-doc 模块名，查看模块的介绍以及案例。需要注意的是，如果使用ad-hoc命令，ansible的一些插件功能就无法使用，比如loop facts功能等。</p>

<p>核心模块playbook</p>

<p>核心组件</p>

<pre><code>Hosts：运行执行任务（task）的目标主机
remote_user：在远程主机上执行任务的用户
tasks：任务列表
handlers：任务，与tasks不同的是只有在接受到通知时才会被触发
templates：使用模板语言的文本文件，使用jinja2语法。
variables：变量，变量替换{{ variable_name }}
Roles：角色
</code></pre>

<p>hosts和users介绍</p>

<p>在playbook中的每一个play都可以选择在哪些服务器和以什么用户完成，hosts一行可以是一个主机组、主机、多个主机，中间以冒号分隔，可使用通配模式。其中remote_user表示执行的用户账号。</p>

<pre><code>---
- hosts: abc               #指定主机组，可以是一个或多个组。
remote_user: root                #指定远程主机执行的用户名
</code></pre>

<p>指定远程主机sudo切换用</p>

<pre><code># vim ping.yml
---
- hosts: abc
    remote_user: root            
    become: yes                #2.6版本以后的参数，之前是sudo，意思为切换用户运行
    become_user: mysql          #指定sudo用户为mysql
</code></pre>

<p>执行playbook</p>

<pre><code>ansible-playbook ping.yml -K
</code></pre>

<p>Tasks list 和action介绍
1：Play的主体部分是task列表，task列表中的各任务按次序逐个在hosts中指定的主机上执行，即在所有主机上完成第一个任务后再开始第二个任务。
在运行playbook时（从上到下执行），如果一个host执行task失败，整个tasks都会回滚，请修正playbook 中的错误，然后重新执行即可。
Task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量，模块执行时幂等的，这意味着多次执行是安全的，因为其结果一致。
2：每一个task必须有一个名称name，这样在运行playbook时，从其输出的任务执行信息中可以很好的辨别出是属于哪一个task的。如果没有定义name，‘action’的值将会用作输出信息中标记特定的task。
3：定义一个task，常见的格式:”module: options” 例如：yum: name=httpd
4：ansible的自带模块中，command模块和shell模块无需使用key=value格式</p>

<p>常用命令</p>

<pre><code>ansible-playbook [yaml文件名、也可以yml结尾]
</code></pre>

<p>例如：ansible-playbook a.yml</p>

<p>参数：</p>

<pre><code>-k(–ask-pass) 用来交互输入ssh密码
-K(-ask-become-pass) 用来交互输入sudo密码
-u 指定用户

# ansible-playbook a.yml --syntax-check    #检查yaml文件的语法是否正确
# ansible-playbook a.yml --list-task       #检查tasks任务
# ansible-playbook a.yml --list-hosts      #检查生效的主机
# ansible-playbook a.yml --start-at-task='Copy Nginx.conf'     #指定从某个task开始运行
</code></pre>

<p>示例</p>

<pre><code># vim a.yml
---
- hosts: 192.168.200.129                  //指定主机
    remote_user: root                         //指定在被管理的主机上执行任务的用户
    tasks:                                            //任务列表↓
     - name: disable selinux                //任务名关闭防火墙
       command: '/sbin/setenforce 0'    //调用command模块 执行关闭防火墙命令
     - name: start httpd                         //任务名 开启httpd
       service: name=httpd state=started         //调用service模块 开启httpd 服务
# ansible-playbook a.yml --syntax-check    #检查yaml文件的语法是否正确
# ansible-playbook a.yml
</code></pre>

<p>play中只要执行命令的返回值不为0，就会报错，tasks停止，可以添加下面</p>

<p>ignore_errors: True #忽略错误，强制返回成功</p>

<pre><code>    tasks:                                            //任务列表↓
     - name: disable selinux                //任务名关闭防火墙
       command: '/sbin/setenforce 0'    //调用command模块 执行关闭防火墙命令
       ignore_errors: True 
</code></pre>

<p>这样执行错误就忽略</p>

<p>Handlers介绍</p>

<p>handlers也是一些task的列表，和一般的task并没有什么区别。
是由通知者进行的notify，如果没有被notify，则Handlers不会执行，假如被notify了，则Handlers被执行
不管有多少个通知者进行了notify，等到play中的所有task执行完成之后，handlers也只会被执行一次
     
    - hosts: websrvs
      remote_user: root
      tasks:
      - name: INSTALL HTTPD SERVER
        yum: name=httpd state=present
      - name: INSTALL HTTPD CONFIG
        copy: src=/files/httpd.conf dest=/etc/httpd/conf/
        notify: RESTART HTTPD  #
      - name: START HTTPD
        service: name=httpd state=started
      handlers:
      - name: RESTART HTTPD  #
        service: name=httpd state=restarted</p>

<p>引用变量</p>

<p>直接使用：vars: 添加变量</p>

<pre><code>- hosts: all
 remote_user: root
 vars:
 - username: testuser1
 - groupname: testgroup
 tasks:
 - name: create group
   group: name=\{\{ groupname \}\} state=present
 - name: create user
   user: name= state=present
</code></pre>

<p>直接引用Ansible变量</p>

<p>比如 ansible_all_ipv4_addresses 获取IP</p>

<p>引用主机变量</p>

<p>在组的主机后面添加变量</p>

<p>vim /etc/ansible/hosts</p>

<p>在这个文件中定义的变量都是可以直接使用,比如{{port}}</p>

<p>条件判断</p>

<p>when的值是一个条件表达式，如果条件判断成立，这个task就执行，如果判断不成立，则task不执行</p>

<p>如果需要根据变量、facts（setup）或此前任务的执行结果来作为某task执行与否的前提时要用到条件测试，在Playbook中条件测试使用when子句。</p>

<p>在task后添加when子句即可使用条件测试：when子句支持jinjia2表达式或语法，例如：</p>

<p>when: a=b放在task中</p>

<p>支持多条件和组合or和自定义条件的查询</p>

<p>迭代</p>

<p>有需要重复性执行的任务时，可以使用迭代机制。其使用格式为将需要迭代的内容定义为item变量引用，并通过with_items语句指明迭代的元素列表即可。</p>

<pre><code>- hosts: all
 remote_user: root
 vars:
 - username: testuser1
 - groupname: testgroup
 tasks:
 - name: create group
   group: name=\{\{ groupname \}\} state=present
 - name: create user
   user: name={{item}} state=present
   with_items:
     - httpd
     - php
</code></pre>

<p>Templates介绍</p>

<p>Jinja是基于Python的模板引擎。template类是Jinja的另一个重要组件，可以看作一个编译过的模块文件，用来生产目标文本，传递Python的变量给模板去替换模板中的标记。</p>

<pre><code># scp root@192.168.175.130:/etc/httpd/conf/httpd.conf ./templates      //复制被管理端的配置文件到本地
# vim templates/httpd.conf      //在管理端讲配置文件要修改的地方定义变量
Listen {{http_port}}
ServerName {{server_name}}
MaxClients {{access_num}}
</code></pre>

<p>在/etc/ansible/hosts 添加变量</p>

<pre><code># vim /etc/ansible/hosts
[abc]
192.168.200.129 http_port=192.168.200.129:80 access_num=100 server_name=&quot;www.yun.com:80&quot;



# vim apache.yml
# ansible-playbook apache.yml    #然后执行脚本  然后去abc组的主机上查看下配置文件是否已经改了
</code></pre>

<p>Tags介绍
在一个playbook中，我们一般会定义很多个task，如果我们只想执行其中的某一个task或多个task时就可以使用tags标签功能了</p>

<p>命令</p>

<p>用法：</p>

<pre><code>ansible-playbook &lt;filename.yml&gt; ... [options]

  &lt;filename.yml&gt;:yaml格式的playbook文件路径，必须指明
  [options]: 选项
    -C, --check：并不在远程主机上执行，只是测试。
    -i PATH, --inventory=PATH：资产的文件路径
    --flush-cache：清楚fact缓存
    --list-hosts：列出匹配的远程主机，并不执行任何动作
    -t, TAGS, --tags=TAGS：运行指定的标签任务
    --skip-tags:跳过指定的notify，后面详细介绍。






Usage: ansible-playbook playbook.yml
ansible-playbook test1.yml             #执行剧本
ansible-vault encrypt test1.yml         #加密剧本
ansible-vault decrypt test1.yml         #加密剧本
ansible-vault view test1.yml            #加密剧本 
</code></pre>

<p>正常使用步骤</p>

<p>测试执行：# ansible-playbook &ndash;check nginx.yaml</p>

<p>列出运行任务的主机：# ansible-playbook &ndash;list-hosts nginx.yaml</p>

<p>运行：# ansible-playbook nginx.yaml</p>

<p>这边以一个例子简单介绍一下playbook。</p>

<p>示例目的：指定一个主机名，对这个主机进行配置操作。</p>

<p>先展示目录结构</p>

<pre><code>config-ansible
    |___config_hosts.yml
    |___roles
             |___config_hosts
                        |___tasks
                                |___main.yml
                                |___config.yml
</code></pre>

<p>总共3个YAML文件，其中config_hosts.yml为总入口，在这个文件里调用roles/config_hosts/tasks目录下的脚本。执行命令ansible-playbook config_hosts.yml 运行剧本。</p>

<p>config_hosts.yml内容为</p>

<pre><code>1. ---
2. - hosts: node1
3. roles:
4. - config_hosts
</code></pre>

<p>第1行表示该文件是YAML文件，非必须。</p>

<p>第2行定义该playbook针对的目标主机。</p>

<p>第3、4行指定角色目录，具体操作在角色中定义。</p>

<p>main.yml的内容为</p>

<pre><code>1. ---
2. - include: config.yml
</code></pre>

<p>第2行指定此roles要导入的task文件。</p>

<pre><code>config.yml的内容为
---
- name: copy test.file
copy:
src: /home/test.file
dest: /home/test.file
owner: root
group: root
mode: 0777
force: yes

 - name: exec hello world script
 script: /home/helloworld.sh

- name: rm test.file
 file: path=/home/test.file state=absent
</code></pre>

<p>config.yml文件内的代码才是真正执行的任务代码。总共有3个任务，第一个把/home目录的test.file文件拷贝到目标主机的相同路径下，第二个在目标主机执行/home目录下的helloworld.sh，helloworld.sh的内容就是打印一条helloworld信息，第三个任务是使用file模块把目标主机的/home/test.file文件删除。</p>

<p>同类工具对比</p>

<p>目前比较流行的就是ansible和salt了，网上有很多对比的方面，总体来说，就是salt速度快，并发高，适用于大规模的部署，1000以上的，ansible使用简单，关注高，适用于小规模使用。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/linux/tool/ansible/">https://kingjcy.github.io/post/linux/tool/ansible/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/ansible/">
                            <i class="fa fa-tags"></i>
                            Ansible
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/linux/tool/kickstart/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/linux/tool/ops-tool/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

