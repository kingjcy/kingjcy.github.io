<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="这里主要是一些平时linux c/c&#43;&#43;下编程时遇到的一些注意点，记录下来便于学习和备忘。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="Linuxc - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    Linuxc
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2015年03月14日 
                </div>
                <h1 class="post-title">Linuxc</h1>
            </header>

            <div class="post-content">
                <p>这里主要是一些平时linux c/c++下编程时遇到的一些注意点，记录下来便于学习和备忘。</p>

<h2 id="c-c-库">c/c++库</h2>

<p>在我们编程过程中经常需要用到别人封装好的库（库是一种用于快速开发，迅速上手，不必重复造轮子，任何一个产品都需要一个库文件提供api，让我们接入使用），在调用的时候，分为静态库和动态库。</p>

<p>linux下静态库和共享库：库文件名必须以lib开头</p>

<p>静态库是.a文件，编译时会包含在可执行文件中，可执行文件运行时是不需要该静态库的，这样会使可执行文件变大，占用内存和磁盘空间，ar rcs 库名 。o文件名</p>

<p>动态库是.so .sa文件，这个是在可执行文件中保存一个地址列表，程序运行时用到才会去调用，不然加载到内存中共享，节省资源，现在比较实用的方法   gcc -shared -fPIC.o文件名 库名.so</p>

<p>编译搜索路径：</p>

<ol>
<li>-L,-I指定的路劲下</li>
<li>环境变量下指定路劲，libarypath ,LD_LIBRARY_PATH</li>
<li>系统指定的路劲，usr/include,usr/lib,usr/local/inlude,usr/local/lib</li>
</ol>

<p>动态库的优先级高于静态库</p>

<p>在一个程序运行时是不需要静态库的，但是需要链接动态库，所以一个可执行文件运行环境改变时，需要将其对应的动态库一并复制到新环境中，这些动态库是可以共享的</p>

<p>我们可以使用ldd 可执行文件名，来查看对应的动态库是否找到了</p>

<p>如果没有找到，则需要增加对应的动态库：</p>

<ol>
<li><p>往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf文件的，但是添加完后需要调用下ldconfig，不然添加的library会找不到。</p></li>

<li><p>如果添加的library不在/lib和/usr/lib里面的话，就一定要修改/etc/ld.so.conf文件，往该文件追加library所在的路径，然后也需要重新调用下ldconfig命令。比如在安装MySQL的时候，其库文件/usr/local/mysql/lib，就需要追加到/etc/ld.so.conf文件中。命令如下：</p>

<p>$echo &ldquo;/usr/local/mysql/lib&rdquo; &gt;&gt; /etc/ld.so.conf
$ldconfig</p></li>

<li><p>如果添加的library不在/lib或/usr/lib下，但是却没有权限操作写/etc/ld.so.conf文件的话，这时就需要往export里写一个全局变量LD_LIBRARY_PATH，就可以了。</p></li>
</ol>

<h3 id="ace">ACE</h3>

<p>ACE可以说是在网络编程中比较著名的了，自适配通信环境（ADAPTIVE Communication Environment）是一个比较重量级的家伙，有大约二十万行代码，一堆的设计模式，很多架构，支持跨平台。ACE提供了一组丰富的可复用C++ Wrapper Facade（包装外观）和框架组件，可跨越多种平台完成通用的通信软件任务，其中包括：事件多路分离和事件处理器分派、信号处理、服务初始化、进程间通信、共享内存管理、消息路由、分布式服务动态（重）配置、并发执行和同步，等等。ACE的目标用户是高性能和实时通信服务和应用的开发者。它简化了使用进程间通信、事件多路分离、显式动态链接和并发的OO网络应用和服务的开发。此外，通过服务在运行时与应用的动态链接，ACE还使系统的配置和重配置得以自动化</p>

<ol>
<li><em>ACE_DLL</em></li>
</ol>

<p>ACE_DLL封装了操作系统对dll(动态链接库Dynamic Link Library)的操作，因为Windows和*nix对dll操作的接口不一致，如Windows使用LoadLibrary/GetProcAddress/FreeLibrary这三个函数来显示地加载dll，从dll中找到函数地址以及关闭dll，而Linux则使用dlopen/dlsym/dlclose做同样的事情，ACE要使得程序具有良好的跨平台特性就需要屏蔽这些平台的差异性，而向上呈现出统一的接口。</p>

<p>下面这个例子展示了如何使用ACE_DLL类来操作dll。</p>

<p>dll_impl.h</p>

<pre><code>`
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

//向外暴露这个接口，使用&quot; extern &quot;C&quot; &quot;来声明之，否则待会儿调用symbol来获取本函数的地址时就必须填全名
extern &quot;C&quot; person create_person(const string&amp; name, unsigned int age);

class person
{

public:
    person(const string&amp; name, unsigned int age);

    ~person();

    string get_person_name() const;

    private:
        string m_name;
        unsigned int m_age;
};
`
</code></pre>

<p>dll_impl.cpp</p>

<pre><code>`
#include &quot;dll_impl.h&quot;

person::person(const string&amp; name, unsigned int age) : m_name(name), m_age(age)
{
    cout &lt;&lt; m_name &lt;&lt; &quot; say hello!&quot; &lt;&lt; endl;
}

person::~person() 
{
    cout &lt;&lt; m_name &lt;&lt; &quot; say byebye!&quot; &lt;&lt; endl;
}

string person::get_person_name() const {
    return m_name;
}

person create_person(const string&amp; name, unsigned int age){
    return person(name, age);
}
`
</code></pre>

<p>dll_test.cpp</p>

<pre><code>`
#include &quot;ace/Log_Msg.h&quot;
#include &quot;ace/DLL.h&quot; 
#include &quot;ace/ACE.h&quot;

#include &quot;dll_impl.h&quot;

int main()
{
    ACE_DLL dll;

    int retval = dll.open(&quot;libperson.so&quot;, ACE_DEFAULT_SHLIB_MODE, 1);  

    if (retval != 0) {
        return -1;
    }else{
        ACE_DEBUG((LM_DEBUG, &quot;open the dll successfully!!!\n&quot;));
    }

    //声明一个函数指针类型
    typedef person (*person_factory)(const string&amp; name, unsigned int age);

    person_factory fac=(person_factory)dll.symbol(&quot;create_person&quot;);

    if(fac == NULL)
    {
        cout &lt;&lt; &quot;get symbol failed!&quot; &lt;&lt; endl;
        return -1;
    }

    person per = fac(&quot;ecy&quot;, 24);

    cout &lt;&lt; per.get_person_name() &lt;&lt; endl;

    dll.close();

    return 0;
 }
`
</code></pre>

<p>编译过程如下：</p>

<p>1、首先生成动态链接库</p>

<pre><code>g++ -shared -o libperson.so dll_impl.cpp
</code></pre>

<p>2、生成测试程序</p>

<pre><code>g++ -g -o dll_test dll_test.cpp -L. -lperson -lACE
</code></pre>

<p>3、设置LD_LIBRARY_PATH</p>

<p>测试程序运行结果如下：</p>

<pre><code>ecy@ecy-geek:~/ACE/ace_dll$ ./dll_test 
open the dll successfully!!!
ecy say hello!
ecy
ecy say byebye!
</code></pre>

<h2 id="对象编程和结构编程">对象编程和结构编程</h2>

<p>面向结构（c）就好比一个游戏中的怪物，我把这个怪物的各个方面分解成许多小的代码实现相应的动作最后共同实现，至此只这一个怪物，如果想要生成多个怪物，只需要重复编写相同的代码.</p>

<p>面向对象（c++）就好比我把这个怪物封装为一个模型，然后生成多个对象，只对此对象进行在操作，这样每个对象的状态都可以是不一样的</p>

<p>我觉得这个是对对象编程和结构编程一种比较好对描述。所以在很多过程中把c/c++结合起来实用比较好。</p>

<h3 id="c">c++</h3>

<ol>
<li><p>private类成员不能在类以外直接访问，可以通过类的public方法来访问，当然类本身也可以访问</p></li>

<li><p>类对象 是 在内存栈中使用构造函数开辟的一块内存空间&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-复制则将内存中的数据复制过去，但是本身对象地址不会改变</p>

<p>类指针 是 在内存堆中使用new开辟出来的一个内存地址（nwe都是在内存堆上）,但是指针本身存储在栈上&mdash;&mdash;&ndash;复制则将改变了指针的地址，那么就都不一样了</p></li>

<li><p>定义指针时，包括上面的类指针，一定要new（malloc（size））出一片内存空间来给这个指针赋值，这个时候才能调用构造函数来初始化这个类，才使得类的内存空间初始化完成，后才能调用内部的成员变量和成员函数，但是定义对象时会自动调用构造函数，完成类的空间分配。</p></li>

<li><p>容器</p>

<pre><code>顺序容器vector   类模板 (list, deque)
声明：vector&lt;int&gt; ivec;
初始化：vector&lt;T&gt; v1/v2(v1)/v1(n,i)/v1(n)值初始化
操作：empty(),size()--&gt;size_type,push_back(),begin(),end()，c[n]=c.at(n),push_front(),front(),back()，push_insert()，删除erase(),clear() pop_back()，pop_front() ，swap()交换,assign()重置，capacity()容量，reserve（）剩余存储空间                        
下标：从0开始
迭代器iterator：--&gt;const_iterator 只读不写,迭代器循环一直到最后一个位置的下一位
      for(vector&lt;int&gt;::iterator iter=iter.begin()，iter!=iter.end(),++iter) 
      *iter=0;
类型：size_type,iterator,const_iterator....
string： 
操作：substr()---&gt;s.substr(pos,n)   返回s中从下标pos开始的n个字符,replace()，append()追加,find(),compare(),getline().
容器适配器：
    stack:empty(),top(),pop(),size(),push()---&gt;FILO
    queue:empty(),front(),back(),push(),size(),pop()
    priority_queue:push(),top()




关联容器
类型：
pair:声明            初始化                                   成员
操作:pair&lt;t1,t2&gt;p1,pair&lt;t1,t2&gt;p1(v1,v2)--&gt;make_pair(v1,v2) p.first,p.second
map :
map&lt;k,v&gt;m;     m.instert(make_pair(v1,v2)),m.insert(map(string,int)::value_type(v1,v2))----&gt;value_type与pair&lt;const k,v&gt;是一样的

map[key] = value的两种插入存储代码：
        1、mapReconFtpCfg[key] = v_RecondCfgList[i];


        2、mapProductCumulateCfg.insert( make_pair( g_ProductCumulateCfg[i].m_nPRODUCT_CODE, g_ProductCumulateCfg[i] ) );

count(),find(),erase()       
set 
multimap的find，equal_range查找，find返回的是一直指向第一个key（value）的指针，equal_range返回是一对指针（pair），first指向的是第一个key（value），second指向的是最后一个key（value）的下一个位置，如果要用其中的数据，就可以遍历，用迭代器，前面的指针就是迭代器，只要++（被重载过，就相当于指针指向下一个）就可以一个个数据遍历然后就可以用了还可以用count()
</code></pre></li>

<li><p>string的find</p>

<p>////find函数返回类型 size_type<br />
 string s(&ldquo;1a2b3c4d5e6f7g8h9i1a2b3c4d5e6f7g8ha9i&rdquo;);<br />
 string flag;<br />
 string::size_type position;</p>

<p>//find 函数 返回jk 在s 中的下标位置<br />
 position = s.find(&ldquo;jk&rdquo;);<br />
 if (position != s.npos)  //如果没找到，返回一个特别的标志c++中用npos表示，我这里npos取值是4294967295,它表示string结束的地方，相当于char*中的\0
     {<br />
       cout &lt;&lt; &ldquo;position is : &ldquo; &lt;&lt; position &lt;&lt; endl;<br />
     }</p></li>

<li><p>数据转换</p></li>
</ol>

<p>(long)-1  直接转化-1为long</p>

<p>nvl(pool_id，0) 如果pool_id值不存在就为0，这个是在sql中实用</p>

<p>lexical_cast</p>

<p>XXXX_cast&lt;类型&gt;（数据）&mdash;&mdash;&mdash;-数据本身类型不变，产生一个临时数据</p>

<ol>
<li>fork</li>
</ol>

<p>fork,创建子进程，重fork向下是父进程和子进程同时执行，调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p>

<pre><code>1）在父进程中，fork返回新创建子进程的进程ID；也就是说大于0的是父进程

2）在子进程中，fork返回0；等于0的是子进程

3）如果出现错误，fork返回一个负值；小于0出错
</code></pre>

<p>8.extern</p>

<p>在源文件A里定义的函数，在其它源文件里是看不见的（即不能访问）。为了在源文件B里能调用这个函数，应该在B的头部加上一个外部声明：</p>

<pre><code> extern   函数原型；   
</code></pre>

<p>这样，在源文件B里也可以调用那个函数了。</p>

<ol>
<li>启动参数</li>
</ol>

<p>argc表示启动参数的个数，argv代表启动参数的值 ，argv[0] 进程名，argv[1]第一个参数</p>

<ol>
<li><p>makefile基础</p>

<p>MakeFile:
tt:tt.o
    g++ -o tt tt.o</p>

<p>tt.o:tt.cpp
    g++ -c -o tt.o tt.cpp</p></li>

<li><p>typedef int nnn 别名，用nnn代表int</p></li>

<li><p>include</p></li>
</ol>

<p>include 只是一个占位符，是把对应的文件都替代过来，到最后的一个大文件里是没有include的；</p>

<ol>
<li>传参</li>
</ol>

<p>string 是一个类：一般使用引用，减少资源利用</p>

<pre><code>const string &amp;cValueStr 这个对同一块内存空间进行了const修饰，所以这块内存空间是不会变化的

string &amp;cValueStr  既是传入的一般还要有相应的返回，引用和原来变量是公用的同一块内存，当cValueStr  变化了，原来的变量也就变化了

string cValueStr  直接把变量赋给了cValueStr  ，开辟了两块空间内存，如果变量较大改用引用就不浪费资源了
</code></pre>

<p>long是基本类型：</p>

<pre><code>一般不要使用引用。但是需要改变值就要引用

对于返回参数来说，必须要引用，不然是值传递，不能起到传递的作用，要用long &amp;n  就是想第二种说的string &amp;cValueStr  既是传入的一般还要有相应的返回，改变的是变量的指针，即指向的地址



#include 
using namespace std;
void swap(int &amp;a,int &amp;b)   //引用传递
{
int temp;
temp =a;
a = b;
b = temp;
}
void swap(int *a,int *b)  //地址传递      指针变量存放地址---指针
{
int temp;
temp = *a;
*a = *b;
*b =temp;
}
void swap1(int p,int q) //值传递 
{
int temp = p;
p = q;
q = temp;
}
int main()
{
int x =20;
int y =24;
int m =10;
int n =11;
swap(&amp;x,&amp;y);   /*地址传递*/
swap(m,n);     /*引用传递*/
int i =20;
int j =24;
swap1(i,j);    /*只改变栈中的值，主程序中的值并未改变*/
}
</code></pre>

<p>大家发现没有，值传递和引用传递函数内部几乎都是一样的，引用传递相对值传递和地址传递的好处在于在不需要另外开辟一块内存空间，而地址传递和值传递都需要另外开辟空间，从效率上来讲，引用传递的效率比另外两个都要高，对于值传递，它只改变栈内的值，主程序中的值其实并未改变，大家使用的的时候要多加小心。</p>

<p>&amp;a 取地址</p>

<p>*a 取内容</p>

<pre><code>int i = 2,*p=&amp;i;
</code></pre>

<p>这中定义的方式很经典的概括了*和&amp;，这边是定义指针p为int*，并且初始化为i的地址。</p>

<pre><code>char *p  ======char p[]--------------------这个就是动态数组，需要在堆上开辟内存
char p[10]--------------这个是固定大小的数组，也不等价于*p
</code></pre>

<ol>
<li>重载</li>
</ol>

<p>运算符重载：实际上就相当于一个运算符就是一个函数，根据参数来识别，未重载之前是基本符号，相当于一个汇编指令</p>

<p>重载就是为了重复使用相同函数名的函数，符号也一样。是类和运算结合的产物。</p>

<ol>
<li>模版</li>
</ol>

<p>函数模板：&mdash;-第一个参数推演出类型template <class T>  函数类型  函数名{}</p>

<p>类模板：&mdash;&ndash;需要对象声明类型&mdash;temolate <class T> class A {}；   A<int> a;&mdash;&mdash;&mdash;&ndash;演化成什么类型就是什么类型，后面直接替代就好，都是在全局声明。</p>

<p>模板类是不能单独写成cpp文件的，那样编译器无法识别模板是什么类型，就便不过去，如果不是模板类则可以的</p>

<ol>
<li><p>c_str()函数是指转为c风格的字符串c-string，在编程中减少for循环的实用可以提高性能</p>

<p>m_nCityId = atol(s_cityId.c_str());
c_str()是c_string就是转化为C语言的string类型也就是char *，string是在c++中被封装成类的。</p>

<p>m_NowDate.getSysDate();
LOG_DEBUG(g_logger, &ldquo;m_NowDate:&rdquo; &lt;&lt; m_NowDate.str());
.str（）是指把对象m_NowDate中的成员变量显示出来string</p></li>

<li><p>类对象实例化成员和容器中的成员：</p>

<p>CNGReconBankCtrlDT dt;
dt.m_nCITY_ID = v_RecondCfgList[i].m_nCITY_ID;
这个是成员变量，可以直接赋值</p>

<p>vector<CNGReconBankCtrlDT> dtlist;
dtlist[0].m_nCITY_ID 这个可以当常量使用，但是不可以赋值改变</p></li>

<li><p>纯虚函数 virtual void 函数名（） = 0;</p></li>
</ol>

<p>含纯虚函数 的是抽象类，抽象类只有用指针或者引用，不允许有对象</p>

<ol>
<li><p>标准库抛出的异常，都可以用exception类，里面有一个what（）函数，可以显示异常信息</p></li>

<li><p>一般传入参数是数组字符的没有说明元素个数的，都会以null结尾的</p></li>
</ol>

<p>1、返回指针函数，正常返回一个非空指针，出错返回NULL；</p>

<p>2、返回整数函数，正常返回非负整数，一般是0，出错返回一个负数，一般为-1</p>

<p>3、xxx_t   整数</p>

<ol>
<li><p>时间系统：
内核&mdash;&mdash;-time（NULL）&mdash;&mdash;&ndash;&gt;time_t t&mdash;&mdash;&ndash;localtime（&amp;t）&mdash;&ndash;&gt;tm *P&mdash;&mdash;&mdash;&mdash;strftime（地址。。。）&mdash;&mdash;-char buf[]</p></li>

<li><p>exec系列函数，用新函数覆盖子进程函数&mdash;&mdash;&mdash;-execvp（进程名，argv）execlp（进程名，数组）</p></li>

<li><p>精灵进程（守护进程，后台进程）：daemon   1、fork父进程结束  2、函数setsid（）3、函数umask（）4、close（fd）</p></li>

<li><p>文件描述符</p>

<p>0  标准输入stdin
1  标准输出stdout
2  标准出错输出stderr
这些都是文件</p></li>

<li><p>signal</p></li>
</ol>

<p>信号捕捉函数singal，当产生SIGTERM信号时触发函数cGiSigHandler</p>

<p>信号捕获：函数signal（）    信号传递kill -信号名  pid</p>

<p>signal()函数理解</p>

<p>在<signal.h> 这个头文件中。</p>

<p>signal（参数1，参数2）；</p>

<p>参数1：我们要进行处理的信号。系统的信号我们可以再终端键入 kill -l查看(共64个)。其实这些信号时系统定义的宏。</p>

<p>参数2：我们处理的方式（是系统默认还是忽略还是捕获）。</p>

<p>一般有3中方式进行操作。</p>

<p>(1)eg: signal(SIGINT ,SIG_ING );</p>

<p>SIG_ING 代表忽略SIGINT信号，SIGINT信号代表由InterruptKey产生，通常是CTRL +C 或者是DELETE 。发送给所有ForeGround Group的进程。</p>

<p>(2)eg: signal(SIGINT ,SIG_DFL );</p>

<p>SIG_DFL代表执行系统默认操作，其实对于大多数信号的系统默认动作时终止该进程。这与不写此处理函数是一样的。</p>

<p>(3)void ( <em>signal( int sig, void (</em> handler)( int )))( int );</p>

<pre><code>int (*p)();
</code></pre>

<p>这是一个函数指针, p所指向的函数是一个不带任何参数, 并且返回值为int的一个函数.</p>

<pre><code>int (*fun())();
</code></pre>

<p>这个式子与上面式子的区别在于用fun()代替了p,而fun()是一个函数,所以说就可以看成是fun()这个函数执行之后,它的返回值是一个函数指针,这个函数指针(其实就是上面的p)所指向的函数是一个不带任何参数,并且返回值为int的一个函数.</p>

<p>void (*signal(int signo, void (*handler)(int)))(int);就可以看成是signal()函数(它自己是带两个参数,一个为整型,一个为函数指针的函数),而这个signal()函数的返回值也为一个函数指针,这个函数指针指向一个带一个整型参数,并且返回值为void的一个函数.</p>

<p>在写信号处理函数时对于信号处理的函数也是void sig_fun(int signo);这种类型,恰好与上面signal()函数所返回的函数指针所指向的函数是一样的.void ( *signal() )( int );</p>

<p>signal是一个函数, 它返回一个函数指针, 后者所指向的函数接受一个整型参数 且没有返回值, 仔细看, 是不是siganal( int signo, void (*handler)(int) )的第2个参数了,对了,其实他所返回的就是 signal的第2个信号处理函数,指向信号处理函数,就可以执行函数了( signal内部时, signal把信号做为参数传递给handler信号处理函数,接着 signal函数返回指针, 并且又指向信号处理函数, 就开始执行它)</p>

<p>那么，signal函数的参数又是如何呢？signal函数接受两个参数：一个整型的信号编号，以及一个指向用户定义的信号处理函数的指针。我们此前已经定义了指向用户定义的信号处理函数的指针sfp：</p>

<p>void (*sfp)(int);</p>

<p>sfp 的类型可以通过将上面的声明中的sfp去掉而得到，即void (*)(int)。此外，signal函数的返回值是一个指向调用前的用户定义信号处理函数的指针，这个指针的类型与sfp指针类型一致。因此，我们可以如下声明signal函数：</p>

<p>void (<em>signal(int, void(</em>)(int)))(int);</p>

<p>同样地，使用typedef可以简化上面的函数声明：</p>

<p>typedef void (*HANDLER)(int);
HANDLER signal(int, HANDLER);</p>

<ol>
<li>include</li>
</ol>

<p>自定义下的头文件只能用双引号去include</p>

<ol>
<li>static</li>
</ol>

<p>static的作用主要有两种:</p>

<p>第一个作用是限定作用域；第二个作用是保持变量内容持久化；</p>

<p>c语言中static的用法：</p>

<p>1、全局静态变量：</p>

<p>　　用法：在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。 static int temp；</p>

<p>　　内存中的位置：静态存储区，在初始化的时候就会开辟一块区域，只加载一次，在整个程序运行期间一直存在。</p>

<p>　　初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>

<p>　　作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>

<p>2、局部静态变量：</p>

<p>　　在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>

<p>　　内存中的位置：静态存储区</p>

<p>　　初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>

<p>　　作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>

<p>3、静态函数：</p>

<p>　　在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；</p>

<p>多线程的锁</p>

<p>互斥量-互斥锁：
pthread_mutex_t 互斥量类型</p>

<p>函数
1）初始化互斥锁
pthread_mutex_init
函数原型：int  pthread_mutex_init(pthread_mutex_t *mp, const pthread_mutexattr_t *mattr)
参数说明：mp 互斥锁地址    mattr  属性 通常默认 null
初始化互斥锁之前，必须将其所在的内存清零。
如果互斥锁已初始化，则它会处于未锁定状态。互斥锁可以位于进程之间共享的内存中或者某个进程的专用内存中。</p>

<p>pthread_mutex_destory
5）销毁互斥锁
函数原型：
int pthread_mutex_destroy(pthread_mutex_t <em>mp); #include <pthread.h> pthread_mutex_t mp; int ret; ret = pthread_mutex_destroy(&amp;mp); /</em> mutex is destroyed */请注意，没有释放用来存储互斥锁的空间。
返回值：
pthread_mutex_destroy() 在成功完成之后会返回零。其他任何返回值都表示出现了错误。如果出现以下任一情况，该函数将失败并返回对应的值。
EINVAL: mp 指定的值不会引用已初始化的互斥锁对象。</p>

<p>pthread_mutex_lock()</p>

<p>函数原型：
int pthread_mutex_lock(pthread_mutex_t <em>mutex); #include <pthread.h> pthread_mutex<em>t mutex; int ret; ret = pthread</em> mutex_lock(&amp;mp); /</em> acquire the mutex */
函数说明：
当 pthread_mutex_lock() 返回时，该互斥锁已被锁定。调用线程是该互斥锁的属主。如果该互斥锁已被另一个线程锁定和拥有，则调用线程将阻塞，直到该互斥锁变为可用为止。
如果互斥锁类型为 PTHREAD_MUTEX_NORMAL，则不提供死锁检测。尝试重新锁定互斥锁会导致死锁。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或未锁定，则将产生不确定的行为。
如果互斥锁类型为 PTHREAD_MUTEX_ERRORCHECK，则会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。
如果互斥锁类型为 PTHREAD_MUTEX_RECURSIVE，则该互斥锁会保留锁定计数这一概念。线程首次成功获取互斥锁时，锁定计数会设置为 1。线程每重新锁定该互斥锁一次，锁定计数就增加 1。线程每解除锁定该互斥锁一次，锁定计数就减小 1。 锁定计数达到 0 时，该互斥锁即可供其他线程获取。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。
如果互斥锁类型是 PTHREAD_MUTEX_DEFAULT，则尝试以递归方式锁定该互斥锁将产生不确定的行为。对于不是由调用线程锁定的互斥锁，如果尝试解除对它的锁定，则会产生不确定的行为。如果尝试解除锁定尚未锁定的互斥锁，则会产生不确定的行为。
返回值：
pthread_mutex_lock() 在成功完成之后会返回零。其他任何返回值都表示出现了错误。如果出现以下任一情况，该函数将失败并返回对应的值。
EAGAIN：由于已超出了互斥锁递归锁定的最大次数，因此无法获取该互斥锁。
EDEADLK：当前线程已经拥有互斥锁。
延生信号量也可以完成互斥量的工作</p>

<p>pthread_mutex_unlock()</p>

<p>函数原型：
int pthread_mutex_unlock(pthread_mutex_t <em>mutex); #include <pthread.h> pthread_mutex_t mutex; int ret; ret = pthread_mutex_unlock(&amp;mutex); /</em> release the mutex */
函数说明：pthread_mutex_unlock() 可释放 mutex 引用的互斥锁对象。互斥锁的释放方式取决于互斥锁的类型属性。如果调用 pthread_mutex_unlock() 时有多个线程被 mutex 对象阻塞，则互斥锁变为可用时调度策略可确定获取该互斥锁的线程。对于 PTHREAD_MUTEX_RECURSIVE 类型的互斥锁，当计数达到零并且调用线程不再对该互斥锁进行任何锁定时，该互斥锁将变为可用。
返回值：pthread_mutex_unlock() 在成功完成之后会返回零。
其他任何返回值都表示出现了错误。如果出现以下情况，该函数将失败并返回对应的值。
EPERM :当前线程不拥有互斥锁。</p>

<p>函数原型：
int pthread_mutex_trylock(pthread_mutex_t <em>mutex); #include <pthread.h> pthread_mutex_t mutex; int ret; ret = pthread_mutex_trylock(&amp;mutex); /</em> try to lock the mutex */
函数说明：pthread_mutex_trylock() 是 pthread_mutex_lock() 的非阻塞版本。如果 mutex 所引用的互斥对象当前被任何线程（包括当前线程）锁定，则将立即返回该调用。否则，该互斥锁将处于锁定状态，调用线程是其属主。
返回值：pthread_mutex_trylock() 在成功完成之后会返回零。其他任何返回值都表示出现了错误。如果出现以下任一情况，该函数将失败并返回对应的值。
EBUSY :
由于 mutex 所指向的互斥锁已锁定，因此无法获取该互斥锁。
EAGAIN：描述:
由于已超出了 mutex 的递归锁定最大次数，因此无法获取该互斥锁。</p>

<p>4．饥饿和死锁的情形
当一个互斥量已经被别的线程锁定后，另一个线程调用pthread_mutex_lock()函数去锁定它时，会挂起自己的线程等待这个互斥量被解锁。可能出现以下两种情况：
“饥饿状态”：这个互斥量一直没有被解锁，等待锁定它的线程将一直被挂着，即它请求某个资源，但永远得不到它。用户必须在程序中努力避免这种“饥饿”状态出现。Pthread函数库不会自动处理这种情况。
“死锁”：一组线程中的所有线程都在等待被同组中另外一些线程占用的资源，这时，所有线程都因等待互斥量而被挂起，它们中的任何一个都不可能恢复运行，程序无法继续运行下去。这时就产生了死锁。Pthread函数库可以跟踪这种情形，最后一个线程试图调用pthread_mutex_lock()时会失败，并返回类型为EDEADLK的错误。</p>

<p>延生一下信号量也可以完成互斥量的任务
信号量：
信号量的使用主要是用来保护共享资源，使得资源在一个时刻只有一个进程（线程）所拥有。信号量的值为正的时候，说明它空闲。所测试的线程可以锁定而使用它。若为0，说明它被占用，测试的线程要进入睡眠队列中，等待被唤醒。</p>

<p>分类：
（1） 内核信号量，由内核控制路径使用&mdash;&ndash;一般内核使用，一样的锁进程和等待机制，重点在进程使用信号量
（2） 用户态进程使用的信号量，这种信号量又分为POSIX信号量和SYSTEM V信号量。
POSIX信号量又分为有名信号量和无名信号量。
有名信号量，其值保存在文件中, 所以它可以用于线程也可以用于进程间的同步。无名信号量，其值保存在内存中。</p>

<p>POSIX信号量：
sem_t   数据类型</p>

<p>无名信号量：
#include <semaphore.h><br />
int sem_init(sem_t *sem, int pshared,unsigned value);  &mdash;&ndash;pshsred = 1表示共享的
                                                 //成功返回0，出错返回错误号</p>

<p>#include <semaphore.h><br />
int sem_destroy(sem_t *sem);<br />
                                   //成功返回0，出错返回错误号</p>

<p>int sem_getvalue(sem_t *sem, int *sval);
取回信号量sem的当前值，把该值保存到sval中。</p>

<p>sem_wait(或sem_trywait)相当于P操作，即申请资源。
int sem_wait(sem_t *sem); // 这是一个阻塞的函数
测试所指定信号量的值,它的操作是原子的。
若sem&gt;0，那么它减1并立即返回。
若sem==0，则睡眠直到sem&gt;0，此时立即减1，然后返回。
int sem_trywait(sem_t *sem); // 非阻塞的函数
其他的行为和sem_wait一样，除了：
若sem==0，不是睡眠，而是返回一个错误EAGAIN。
sem_post相当于V操作，释放资源。
int sem_post(sem_t *sem);
把指定的信号量sem的值加1;
呼醒正在等待该信号量的任意线程。</p>

<p>有名信号量：&mdash;是存储在文件中的，对于文件就决定这个用途广泛&ndash;可以用于多线程，多进程，甚至不相干的进程</p>

<p>sem_t *sem_open(const char *name, int oflag, mode_t mode , int value);
name是文件的路径名；sem都是创建在/dev/shm目录下。你可以将name写成“/mysem”或“mysem”，创建出来的文件都是“/dev/shm/sem.mysem”，千万不要写路径。
Oflag 有O_CREAT或O_CREAT|EXCL两个取值；
mode_t控制新的信号量的访问权限；
Value指定信号量的初始化值。</p>

<p>#include <semaphore.h><br />
int sem_close(sem_t *sem);<br />
                                   //成功返回0，出错返回错误编号</p>

<p>#include <semaphore.h><br />
int sem_unlink(const char *name);<br />
                                   //成功返回0，出错返回-1</p>

<p>删除这个很重要。
在做这个之前，要确定所有对这个有名信号量的引用都已经通过sem_close（）函数
关闭了，然后只需在退出或是退出处理函数中调用sem_unlink()去删除系统中的信号量，
注意如果有任何的处理器或是线程引用这个信号量，sem_unlink()函数不会起到任何的作
用。</p>

<p>SYSTEM V 信号量：</p>

<p>两个结构很重要：</p>

<p>内核为每个信号量集维护一个信号量结构体，可在<sys/sem.h>找到该定义：
struct semid_ds {
struct ipc_perm sem_perm; /* 信号量集的操作许可权限 */
struct sem <em>sem_base; /</em> 某个信号量sem结构数组的指针，当前信号量集
中的每个信号量对应其中一个数组元素 <em>/
ushort sem_nsems; /</em> sem_base 数组的个数 <em>/
time_t sem_otime; /</em> 最后一次成功修改信号量数组的时间 <em>/
time_t sem_ctime; /</em> 成功创建时间 <em>/
};
struct sem {
ushort semval; /</em> 信号量的当前值 <em>/
short sempid; /</em> 最后一次返回该信号量的进程ID 号 <em>/
ushort semncnt; /</em> 等待semval大于当前值的进程个数 <em>/
ushort semzcnt; /</em> 等待semval变成0的进程个数 */
};</p>

<p>数据类型：KEY_T</p>

<p>创建和打开信号量
int semget(key_t key, int nsems, int oflag)&mdash;-重点key，可以是用系统关键字IPC_PRIVATE，也可以自己定义一个公用的
(1) nsems&gt;0 : 创建一个信的信号量集，指定集合中信号量的数量，一旦创建就不能更改。
(2) nsems==0 : 访问一个已存在的集合
(3) 返回的是一个称为信号量标识符的整数，semop和semctl函数将使用它。</p>

<p>pv操作：
int semop(int semid, struct sembuf *opsptr, size_t nops);
(1) semid： 是semget返回的semid
(2)opsptr： 指向信号量操作结构数组
(3) nops ： opsptr所指向的数组中的sembuf结构体的个数
struct sembuf {
short sem_num; // 要操作的信号量在信号量集里的编号，
short sem_op; // 信号量操作
short sem_flg; // 操作表示符
};
(4) 若sem_op 是正数，其值就加到semval上，即释放信号量控制的资源&mdash;释放
若sem_op 是0，那么调用者希望等到semval变为0，如果semval是0就返回;&mdash;
若sem_op 是负数，那么调用者希望等待semval变为大于或等于sem_op的绝对值&mdash;请求
（5）sem_flag
SEM_UNDO 由进程自动释放信号量
IPC_NOWAIT 不阻塞</p>

<p>对信号集实行控制操作（semval的赋值等）
int semctl(int semid, int semum, int cmd, ../* union semun arg */);
semid是信号量集合；
semnum是信号在集合中的序号；
semum是一个必须由用户自定义的结构体，在这里我们务必弄清楚该结构体的组成：
union semun
{
int val; // cmd == SETVAL
struct semid_ds *buf // cmd == IPC_SET或者 cmd == IPC_STAT
ushort *array; // cmd == SETALL，或 cmd = GETALL
};
val只有cmd ==SETVAL时才有用，此时指定的semval = arg.val。
注意：当cmd == GETVAL时，semctl函数返回的值就是我们想要的semval。千万不要以为指定的semval被返回到arg.val中</p>

<p>cmd == IPC_RMID还是比较有用的。&ndash;删除</p>

<p>pv原语
P（S）：①将信号量S的值减1，即S=S-1；
           ②如果S&gt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。&mdash;&ndash;申请资源
    V（S）：①将信号量S的值加1，即S=S+1；
           ②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。&mdash;&mdash;释放资源</p>

<p>&mdash;-system v的进程间通信的三大方式：消息队列，共享内存，信号量</p>

<p>读写锁:读写锁比起mutex具有更高的适用性，具有更高的并行性，可以有多个线程同时占用读模式的读写锁，但是只能有一个线程占用写模式的读写锁，&mdash;&ndash;
场景：
一种是访问必须是排它行的，就是独占的意思，这称作写操作；另一种情况就是访问方式可以是共享的，就是说可以有多个线程同时去访问某个资源，这种就称作读操作。这个问题模型是从对文件的读写操作中引申出来的。</p>

<p>状态：
读写锁的三种状态：
1.当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞
2.当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程将会被阻塞
3.当读写锁在读模式的锁状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求则长期阻塞。</p>

<p>pthread_rwlock_t 读写锁的数据类型</p>

<p>初始化：
#include <pthread.h>
int pthread_rwlock_init(pthread_rwlock_t *rwptr, const pthread_rwlockattr_t *attr);&mdash;-初始化也可以用宏定义常值PTHREAD_RWLOCK_INITIALIZER赋值来初始化
int pthread_rwlock_destroy(pthread_rwlock_t *rwptr);
这两个函数如果执行成功均返回0，如果出错则返回错误码。
在释放某个读写锁占用的内存之前，要先通过pthread_rwlock_destroy对读写锁进行清理，释放由pthread_rwlock_init所分配的资源。</p>

<p>#include <pthread.h>
int pthread_rwlock_rdlock(pthread_rwlock_t *rwptr);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwptr);
int pthread_rwlock_unlock(pthread_rwlock_t *rwptr);
这三个函数若调用成功则返回0，失败就返回错误码。要注意的是其中获取锁的两个函数的操作都是阻塞操作，也就是说获取不到锁的话，那么调用线程不是立即返回，而是阻塞执行。有写情况下，这种阻塞式的获取所得方式可能不是很适用，所以，接下来引入两个采用非阻塞方式获取读写锁的函数pthread_rwlock_tryrdlock()和pthread_rwlock_trywrlock(),非阻塞方式下获取锁的时候，如果不能马上获取到，就会立即返回一个EBUSY错误，而不是把调用线程投入到睡眠等待。函数原型如下：
#include <pthread.h>
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwptr);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwptr);
同样地，这两个函数调用成功返回0，失败返回错误码。</p>

<p>条件变量：条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用
伴随着全局变量的变化</p>

<p>条件变量使我们可以睡眠等待某种条件出现。
    条件变量是利用线程间共享的全局变量进行同步的机制，主要包括两个动作：
    &gt;: 一个线程等待&rdquo;条件变量的条件成立&rdquo;而挂起；
    &gt;: 另一个线程使&rdquo;条件成立&rdquo;（给出条件成立信号）。可能是一个进程的输出是另一
       个的输入呗～</p>

<p>pthread_cond_t 条件变量类型</p>

<p>初始化：
和互斥变量一样，使用条件变量之前要先进行初始化，也有2方法：
    1.静态：pthead_cond_t     condition = PTHREAD_COND_INITIALIZER
    2.动态：pthread_cond_init</p>

<p>#include <pthread.h>
    int pthread_cond_init( thread_cond_t * cond, pthread_condattr_t * attr );
    参数：
    cond  条件变量
    attr      条件变量属性
    成功返回0，出错返回错误编号。</p>

<p>销毁：
 #include <pthread.h>
    int pthread_cond_destroy( pthread_cond_t * cond );
    成功返回0，出错返回错误编号。</p>

<pre><code>注意：摧毁所指定的条件变量，同时将会释放所给它分配的资源。调用该函数的
        进程也并不要求等待在参数所指定的条件变量上。
</code></pre>

<p>等待函数：
#include <pthread.h><br />
    int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);当调用这个函数时，线程挂起，打开已经锁定的互斥锁mutex，当收到signal信号时重新唤起，再次锁住mutex
   一般使用全局变量对线程同步进行控制。
    int pthread_cond_timedwait(pthread_cond_t *cond,pthread_mutex_t *
    mytex,const struct timespec *abstime);</p>

<pre><code>参数：
    cond 条件变量
    mutex 互斥锁
</code></pre>

<p>唤醒函数：
#include <pthread.h>
    int pthread_cond_signal( pthread_cond_t * cond );
    int pthread_cond_broadcast( pthread_cond_t * cond );
    参数：cond        条件变量
    成功返回0，出错返回错误编号。</p>

<pre><code>pthread_cond_signal:只唤醒一个线程
pthread_cond_broadcast:唤醒所有线程
</code></pre>

<p>autotools使用流程
autotools 是一系列工具，它包含了aclocal,autoconf,autoheader和automake这些工具，使用autotools主要就是利用各个工具来生成最后的makefile文件。其具体流程如下图:</p>

<p>image</p>

<p>如果你的系统安装了autoreconf，则上面的工具调用可以通过autoreconf这一个命令来完成，如果有哪个源文件更新，autoreconf会检测到并重新调用上面的工具来生成新的Makefile. 命令如下：</p>

<p>autoreconf &ndash;install &ndash;force</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/linux/c&#43;&#43;/linuxc/">https://kingjcy.github.io/post/linux/c&#43;&#43;/linuxc/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags//">
                            <i class="fa fa-tags"></i>
                            
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/golang/go-unsafe/">Go Unsafe</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-text/">Go Text</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-plugin/">Go Plugin</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-mine/">Go Mine</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-internal/">Go Internal</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-index/">Go Index</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-image/">Go Image</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-html/">Go Html</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-hash/">Go Hash</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li><li id="li-rels"><a href="/post/golang/go-go/">Go Go</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年12月25日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/middleware/network/proxy/nginx/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/linux/c&#43;&#43;/tool/gdb/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#c-c-库">c/c++库</a>
<ul>
<li><a href="#ace">ACE</a></li>
</ul></li>
<li><a href="#对象编程和结构编程">对象编程和结构编程</a>
<ul>
<li><a href="#c">c++</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

