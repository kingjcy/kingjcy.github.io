<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="system v的进程间通信的三大方式：消息队列，共享内存，信号量。

posix标志的进程间通信：消息队列，共享内存，信号量，互斥锁，条件变量，基于文件的读写锁

system v的ipc是老版本，实现相对复杂，POSIX是新版本，实现容易。posix是现在大部分linux的标准接口，目前也比较兼容system v的api，而system v是sun公司主要推行的版本。所以现在大部分以posix为准。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="计算机网络系列---- Process Communication - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    计算机网络系列---- Process Communication
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2015年04月28日 
                </div>
                <h1 class="post-title">计算机网络系列---- Process Communication</h1>
            </header>

            <div class="post-content">
                <p>system v的进程间通信的三大方式：消息队列，共享内存，信号量。</p>

<p>posix标志的进程间通信：消息队列，共享内存，信号量，互斥锁，条件变量，基于文件的读写锁</p>

<p>system v的ipc是老版本，实现相对复杂，POSIX是新版本，实现容易。posix是现在大部分linux的标准接口，目前也比较兼容system v的api，而system v是sun公司主要推行的版本。所以现在大部分以posix为准。</p>

<h2 id="信号量">信号量</h2>

<p>信号量的使用主要是用来保护共享资源，使得资源在一个时刻只有一个进程（线程）所拥有。信号量的值为正的时候，说明它空闲。所测试的线程可以锁定而使用它。若为0，说明它被占用，测试的线程要进入睡眠队列中，等待被唤醒。</p>

<p>所有信号量的核心就是在于通过对应的函数实现量pv操作，完成了对资源的控制</p>

<p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>

<p>分类：</p>

<p>（1） 内核信号量，由内核控制路径使用&mdash;&ndash;一般内核使用，一样的锁进程和等待机制，重点在进程使用信号量</p>

<p>（2） 用户态进程使用的信号量，这种信号量又分为POSIX信号量和SYSTEM V信号量。</p>

<pre><code>    1. 对POSIX来说，信号量是个非负整数。常用于线程间同步。而SYSTEM V信号量则是一个或多个信号量的集合，它对应的是一个信号量结构体，这个结构体是为SYSTEM V IPC服务的，信号量只不过是它的一部分。常用于进程间同步。

    2．POSIX信号量的引用头文件是“&lt;semaphore.h&gt;”，而SYSTEM V信号量的引用头文件是“&lt;sys/sem.h&gt;”。

    3．从使用的角度，System V信号量是复杂的，而Posix信号量是简单。比如，POSIX信号量的创建和初始化或PV操作就很非常方便。
</code></pre>

<h3 id="内核信号量">内核信号量</h3>

<p>内核信号量类似于自旋锁，因为当锁关闭着时，它不允许内核控制路径继续进行。然而，当内核控制路径试图获取内核信号量锁保护的忙资源时，相应的进程就被挂起。只有在资源被释放时，进程才再次变为可运行。</p>

<p>只有可以睡眠的函数才能获取内核信号量；中断处理程序和可延迟函数都不能使用内核信号量。</p>

<p>内核信号量是struct semaphore类型的对象，它在<asm/semaphore.h>中定义：</p>

<pre><code>struct semaphore{
    atomic_t count;
    int sleepers;
    wait_queue_head_t wait;
}
count：相当于信号量的值，大于0，资源空闲；等于0，资源忙，但没有进程等待这个保护的资源；小于0，资源不可用，并至少有一个进程等待资源。
wait：存放等待队列链表的地址，当前等待资源的所有睡眠进程都会放在这个链表中。
sleepers：存放一个标志，表示是否有一些进程在信号量上睡眠。
</code></pre>

<p>内核信号量中的等待队列,上面已经提到了内核信号量使用了等待队列wait_queue来实现阻塞操作。当某任务由于没有某种条件没有得到满足时，它就被挂到等待队列中睡眠。当条件得到满足
时，该任务就被移出等待队列，此时并不意味着该任务就被马上执行，因为它又被移进工作队列中等待CPU资源，在适当的时机被调度。内核信号量是在内部使用等待队列的，也就是说该等待队列对用户是隐藏的，无须用户干涉。由用户真正使用的等待队列我们将在另外的篇章进行详解。</p>

<p>内核信号量的相关函数</p>

<pre><code>初始化：
void sema_init (struct semaphore *sem, int val);
void init_MUTEX (struct semaphore *sem); //将sem的值置为1，表示资源空闲
void init_MUTEX_LOCKED (struct semaphore *sem); //将sem的值置为0，表示资源忙

申请内核信号量所保护的资源：
void down(struct semaphore * sem); // 可引起睡眠
int down_interruptible(struct semaphore * sem); // down_interruptible能被信号打断
int down_trylock(struct semaphore * sem); // 非阻塞函数，不会睡眠。无法锁定资源则马上返回

释放内核信号量所保护的资源：
void up(struct semaphore * sem);
</code></pre>

<p>在驱动程序中，当多个线程同时访问相同的资源时（驱动中的全局变量时一种典型的共享资源），可能会引发“竞态“，因此我们必须对共享资源进行并发控制。Linux内核中解决并发控制的最常用方法是自旋锁与信号量（绝大多数时候作为互斥锁使用）。</p>

<pre><code>ssize_t globalvar_write(struct file *filp, const char *buf, size_t len, loff_t *off)
{
　//获得信号量
　if (down_interruptible(&amp;sem))
　{
　　return - ERESTARTSYS;
　}
　//将用户空间的数据复制到内核空间的global_var
　if (copy_from_user(&amp;global_var, buf, sizeof(int)))
　{
　　up(&amp;sem);
　　return - EFAULT;
　}
　//释放信号量
　up(&amp;sem);
　return sizeof(int);
}
</code></pre>

<h3 id="system-v信号量">system v信号量</h3>

<p>两个结构很重要：</p>

<p>内核为每个信号量集维护一个信号量结构体，可在<sys/sem.h>找到该定义：</p>

<pre><code>struct semid_ds {
    struct ipc_perm sem_perm; /* 信号量集的操作许可权限 */
    struct sem *sem_base; /* 某个信号量sem结构数组的指针，当前信号量集
    中的每个信号量对应其中一个数组元素 */
    ushort sem_nsems; /* sem_base 数组的个数 */
    time_t sem_otime; /* 最后一次成功修改信号量数组的时间 */
    time_t sem_ctime; /* 成功创建时间 */
};
struct sem {
    ushort semval; /* 信号量的当前值 */
    short sempid; /* 最后一次返回该信号量的进程ID 号 */
    ushort semncnt; /* 等待semval大于当前值的进程个数 */
    ushort semzcnt; /* 等待semval变成0的进程个数 */
};
</code></pre>

<p>数据类型：KEY_T</p>

<p>创建和打开信号量</p>

<pre><code>int semget(key_t key, int nsems, int oflag)----重点key，可以是用系统关键字IPC_PRIVATE，也可以自己定义一个自己定义的，比如下面例子中的1234
(1) nsems&gt;0: 创建一个信的信号量集，指定集合中信号量的数量，一旦创建就不能更改。
(2) nsems==0 : 访问一个已存在的集合
(3) 返回的是一个称为信号量标识符的整数,其实是和key是一样的sem_id，semop和semctl函数将使用它。
(4) oflag是一组标志，比如在下面的例子中当创建信号量时，用IPC_CREAT|0666，就是创建一个0666权限的信号量
</code></pre>

<p>pv操作：</p>

<pre><code>int semop(int semid, struct sembuf *opsptr, size_t nops);
(1) semid： 是semget返回的semid
(2)opsptr： 指向信号量操作结构数组
(3) nops ： opsptr所指向的数组中的sembuf结构体的个数
struct sembuf {
    short sem_num; // 要操作的信号量在信号量集里的编号，
    short sem_op; // 信号量操作
    short sem_flg; // 操作表示符
};
(4) 若sem_op 是正数，其值就加到semval上，即释放信号量控制的资源---释放
    若sem_op 是0，那么调用者希望等到semval变为0，如果semval是0就返回;---
    若sem_op 是负数，那么调用者希望等待semval变为大于或等于sem_op的绝对值---请求
(5) sem_flag
    SEM_UNDO 由进程自动释放信号量
    IPC_NOWAIT 不阻塞
</code></pre>

<p>对信号集实行控制操作（semval的赋值等）</p>

<pre><code>int semctl(int semid, int semum, int cmd, ../* union semun arg */);
semid是信号量集合；
semnum是信号在集合中的序号；
semum是一个必须由用户自定义的结构体，在这里我们务必弄清楚该结构体的组成：
union semun
{
    int val; // cmd == SETVAL
    struct semid_ds *buf // cmd == IPC_SET或者 cmd == IPC_STAT
    ushort *array; // cmd == SETALL，或 cmd = GETALL
};
val只有cmd ==SETVAL时才有用，此时指定的semval = arg.val。
注意：当cmd == GETVAL时，semctl函数返回的值就是我们想要的semval。千万不要以为指定的semval被返回到arg.val中。
cmd == IPC_RMID还是比较有用的。--删除
</code></pre>

<p>pv原语</p>

<pre><code>P（S）：将信号量S的值减1，即S=S-1；
        如果S&gt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。-----申请资源
V（S）：将信号量S的值加1，即S=S+1；
        如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。------释放资源
</code></pre>

<p>就是用这个原理在多个进程或者线程共同使用同一个信号量的时候可以对资源进行控制</p>

<p>举例</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/sem.h&gt;      信号量头文件

union semun               自定义结构体
{
    int val;
    struct semid_ds *buf;
    unsigned short *arry;
};

static int sem_id = 0;

static int set_semvalue();          这些函数对操作进行封装
static void del_semvalue();
static int semaphore_p();
static int semaphore_v();

int main(int argc, char *argv[])
{
char message = 'X';
int i = 0;

//创建信号量
sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);

if(argc &gt; 1)
{
    //程序第一次被调用，初始化信号量
    if(!set_semvalue())
    {
        fprintf(stderr, &quot;Failed to initialize semaphore\n&quot;);
        exit(EXIT_FAILURE);
    }
    //设置要输出到屏幕中的信息，即其参数的第一个字符
    message = argv[1][0];
    sleep(2);
}
for(i = 0; i &lt; 10; ++i)
{
    //进入临界区
    if(!semaphore_p())
        exit(EXIT_FAILURE);
    //向屏幕中输出数据
    printf(&quot;%c&quot;, message);
    //清理缓冲区，然后休眠随机时间
    fflush(stdout);
    sleep(rand() % 3);
    //离开临界区前再一次向屏幕输出数据
    printf(&quot;%c&quot;, message);
    fflush(stdout);
    //离开临界区，休眠随机时间后继续循环
    if(!semaphore_v())
    exit(EXIT_FAILURE);
    sleep(rand() % 2);
}

sleep(10);
printf(&quot;\n%d - finished\n&quot;, getpid());

if(argc &gt; 1)
{
    //如果程序是第一次被调用，则在退出前删除信号量
    sleep(3);
    del_semvalue();
}
    exit(EXIT_SUCCESS);
}

static int set_semvalue()
{
    //用于初始化信号量，在使用信号量前必须这样做
    union semun sem_union;

    sem_union.val = 1;
    if(semctl(sem_id, 0, SETVAL, sem_union) == -1)
        return 0;
    return 1;
}

static void del_semvalue()
{
    //删除信号量
    union semun sem_union;

    if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1)
        fprintf(stderr, &quot;Failed to delete semaphore\n&quot;);
}

static int semaphore_p()
{
    //对信号量做减1操作，即等待P（sv）
    struct sembuf sem_b;
    sem_b.sem_num = 0;
    sem_b.sem_op = -1;//P()
    sem_b.sem_flg = SEM_UNDO;
    if(semop(sem_id, &amp;sem_b, 1) == -1)
    {
        fprintf(stderr, &quot;semaphore_p failed\n&quot;);
        return 0;
    }
    return 1;
}

static int semaphore_v()
{
    //这是一个释放操作，它使信号量变为可用，即发送信号V（sv）
    struct sembuf sem_b;
    sem_b.sem_num = 0;
    sem_b.sem_op = 1;//V()
    sem_b.sem_flg = SEM_UNDO;
    if(semop(sem_id, &amp;sem_b, 1) == -1)
    {
        fprintf(stderr, &quot;semaphore_v failed\n&quot;);
        return 0;
    }
    return 1;
}
</code></pre>

<h3 id="posix-信号量">POSIX 信号量</h3>

<p>POSIX信号量又分为有名信号量和无名信号量。</p>

<p>有名信号量，其值保存在文件中, 所以它可以用于线程也可以用于进程间的同步。无名信号量，其值保存在内存中。</p>

<p>无名信号量</p>

<p>定义很简单就和定义变量一样，数据类型是sem_t</p>

<pre><code>sem_t sem_id
</code></pre>

<p>然后对其进行初始化就能使用了</p>

<p>初始化函数</p>

<pre><code>int sem_init(sem_t *sem, int pshared, unsigned int value);
1)pshared=0 用于同一多线程的同步；
2)若pshared=1 用于多个相关进程间的同步（即由fork产生的），表示共享的
3)value就是信号量的值，成功返回0，出错返回错误码
</code></pre>

<p>删除函数</p>

<pre><code>int sem_destroy(sem_t *sem);
成功返回0，出错返回错误号 
</code></pre>

<p>获取信号量</p>

<pre><code>int sem_getvalue(sem_t *sem, int *sval);
取回信号量sem的当前值，把该值保存到sval中。若有1个或更多的线程或进程调用sem_wait阻塞在该信号量上，该函数返回两种值：
1) 返回0
2) 返回阻塞在该信号量上的进程或线程数目
linux采用返回0的策略
</code></pre>

<p>PV操作，即申请释放资源。</p>

<pre><code>int sem_wait(sem_t *sem); // 这是一个阻塞的函数
若sem&gt;0，那么它减1并立即返回。
若sem==0，则睡眠直到sem&gt;0，此时立即减1，然后返回。

int sem_trywait(sem_t *sem); // 非阻塞的函数
其他的行为和sem_wait一样，除了：
若sem==0，不是睡眠，而是返回一个错误EAGAIN。

sem_post相当于V操作，释放资源。
int sem_post(sem_t *sem);
把指定的信号量sem的值加1;
呼醒正在等待该信号量的任意线程。
注意：在这些函数中，只有sem_post是信号安全的函数，它是可重入函数
</code></pre>

<p>这些函数的头文件都是<semaphore.h></p>

<p>举例</p>

<pre><code>#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int number; // 被保护的全局变量
sem_t sem_id1, sem_id2;
void* thread_one_fun(void *arg)
{
sem_wait(&amp;sem_id1);
printf(&quot;thread_one have the semaphore\n&quot;);
number++;
printf(&quot;number = %d\n&quot;,number);
sem_post(&amp;sem_id2);
}
void* thread_two_fun(void *arg)
{
sem_wait(&amp;sem_id2);
printf(&quot;thread_two have the semaphore \n&quot;);
number--;
printf(&quot;number = %d\n&quot;,number);
sem_post(&amp;sem_id1);
}
int main(int argc,char *argv[])
{
number = 1;
pthread_t id1, id2;
sem_init(&amp;sem_id1, 0, 1); // 空闲的
sem_init(&amp;sem_id2, 0, 0); // 忙的
pthread_create(&amp;id1,NULL,thread_one_fun, NULL);
pthread_create(&amp;id2,NULL,thread_two_fun, NULL);
pthread_join(id1,NULL);
pthread_join(id2,NULL);
printf(&quot;main,,,\n&quot;);
return 0;
}
</code></pre>

<p>无名信号量常用于多线程间的同步，同时也用于相关进程间的同步。也就是说，无名信号量必须是多个进程（线程）的共享变量，无名信号量要保护的变量也必须是多个进程（线程）的共享变量，这两个条件是缺一不可的。</p>

<p>有名信号量</p>

<p>有名信号量的特点是把信号量的值保存在文件中。这决定了它的用途非常广：既可以用于线程，也可以用于相关进程间，甚至是不相关进程。由于有名信号量的值是保存在文件中的，所以对于相关进程来说，子进程是继承了父进程的文件描述符，那么子进程所继承的文件描述符所指向的文件是和父进程一样的，当然文件里面保存的有名信号量值就共享了。</p>

<p>打开或者创建有名信号量</p>

<pre><code>sem_t *sem_open(const char *name, int oflag, mode_t mode , int value);
name是文件的路径名；文件都是在/dev/shm下，所以直接写文件名，比如mysem，则就是指/dev/shm/sem.mysem
Oflag 有O_CREAT或O_CREAT|EXCL两个取值；第一个就是打开信号量不存在就创建一个，如果存在，就打开，下面两个参数就无所谓；后面一个只创建，如果已经存在就报错
mode_t控制新的信号量的访问权限；
Value指定信号量的初始化值。
</code></pre>

<p>删除信号量</p>

<pre><code>#include &lt;semaphore.h&gt;  
int sem_close(sem_t *sem);  
                                   //成功返回0，出错返回错误编号


#include &lt;semaphore.h&gt;  
int sem_unlink(const char *name);  
                               //成功返回0，出错返回-1 
</code></pre>

<p>删除用法很重要。
在做这个之前，要确定所有对这个有名信号量的引用都已经通过sem_close（）函数关闭了，然后只需在退出或是退出处理函数中调用sem_unlink()去删除系统中的信号量，注意如果有任何的处理器或是线程引用这个信号量，sem_unlink()函数不会起到任何的作用。</p>

<p>然后对信号量对使用就是和无名信号量一样，sem_wait，sem_post</p>

<h2 id="消息队列">消息队列</h2>

<p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>

<p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。  每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>

<p>Linux用宏MSGMAX和MSGMNB来限制一条消息的最大长度和一个队列的最大长度。</p>

<p>system v的ipc是老版本，实现相对复杂，POSIX是新版本，实现容易。</p>

<p>原理：</p>

<p>消息队列是链表队列，它通过内核提供一个struct msqid_ds *msgque[MSGMNI]向量维护内核的一个消息队列列表，因此linux系统支持的最大消息队列数由msgque数组大小来决定，每一个msqid_ds表示一个消息队列，并通过msqid_ds.msg_first、msg_last维护一个先进先出的msg链表队列，当发送一个消息到该消息队列时，把发送的消息构造成一个msg结构对象，并添加到msqid_ds.msg_first、msg_last维护的链表队列，同样，接收消息的时候也是从msg链表队列尾部查找到一个msg_type匹配的msg节点，从链表队列中删除该msg节点，并修改msqid_ds结构对象的数据。</p>

<p>msgque[MSGMNI]是一个msqid_ds结构的指针数组，每个msqid_ds结构指针代表一个系统消息队列，msgque[MSGMNI]的大小为MSGMNI=128，也就是说系统最多有MSGMNI=128个消息队列。</p>

<p>每一个消息结构都有一个标识，也就是我们创建消息队列时的key</p>

<p>system v</p>

<p>函数</p>

<pre><code>1.根据关键字生成标识符。
    key_t ftok(const char *pathname, int proj_id);
2.打开或创建消息队列
    int msgget(key_t key, int msgflg);
    其中 key 可以通过 ftok 和 IPC_PRIVATE 设定!key为ftok的返回值，
    msgflg用来设置消息队列的权限。它可以取下面的几个值：
        IPC_CREAT ：如果消息队列对象不存在，则创建之，否则则进行打开操作;
        IPC_EXCL：   和IPC_CREAT 一起使用（用”|”连接），如果消息对象不存在则创建之，否则产生一个错误并返回。
3.消息队列的属性控制。
    int msgctl(int msgid, int command, struct msgid_ds *buf);

    command是将要采取的动作，它可以取3个值，
    IPC_STAT：把msgid_ds结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖msgid_ds的值。
    IPC_SET：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值
    IPC_RMID：删除消息队列

    buf是指向msgid_ds结构的指针，它指向消息队列模式和访问权限的结构。msgid_ds结构至少包括以下成员：
        struct msgid_ds    
        {    
            uid_t shm_perm.uid;    
            uid_t shm_perm.gid;    
            mode_t shm_perm.mode;    
        };


4.发送信息到消息队列。
    int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); 
    msgid就是上面的key标志，msg_ptr是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针msg_ptr所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：

        struct my_message{    
            long int message_type;    
            /* The data you wish to transfer*/    
        };

    msg_sz是msg_ptr指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说msg_sz是不包括长整型消息类型成员变量
    msgflg用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。如果调用成功，消息数据的一分副本将被放到消息队列中，并返回0，失败时返回-1.

5.从消息队列中接收信息。
    int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg); 

    msgtype可以实现一种简单的接收优先级。如果msgtype为0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于msgtype的绝对值的第一个消息。
    msgflg用于控制当队列中没有相应类型的消息可以接收时将发生的事情。调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由msg_ptr指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回-1.
</code></pre>

<p>举例：</p>

<p>send.c</p>

<pre><code>#include &lt;stdio.h&gt;   
#include &lt;sys/types.h&gt;   
#include &lt;sys/ipc.h&gt;   
#include &lt;sys/msg.h&gt;   
#include &lt;errno.h&gt;   

#define MSGKEY 1024   

struct msgstru  
{  
    long msgtype;  
    char msgtext[2048];   
};  

main()  
{  
    struct msgstru msgs;  
    int msg_type;  
    char str[256];  
    int ret_value;  
    int msqid;  

    msqid=msgget(MSGKEY,IPC_EXCL);  /*检查消息队列是否存在*/  
    if(msqid &lt; 0){  
        msqid = msgget(MSGKEY,IPC_CREAT|0666);/*创建消息队列*/  
        if(msqid &lt;0){  
            printf(&quot;failed to create msq | errno=%d [%s]\n&quot;,errno,strerror(errno));  
            exit(-1);  
        }  
    }   

    while (1){  
        printf(&quot;input message type(end:0):&quot;);  
        scanf(&quot;%d&quot;,&amp;msg_type);  
        if (msg_type == 0)  
            break;  
        printf(&quot;input message to be sent:&quot;);  
        scanf (&quot;%s&quot;,str);  
        msgs.msgtype = msg_type;  
        strcpy(msgs.msgtext, str);  
        /* 发送消息队列 */  
        ret_value = msgsnd(msqid,&amp;msgs,sizeof(struct msgstru),IPC_NOWAIT);  
        if ( ret_value &lt; 0 ) {  
             printf(&quot;msgsnd() write msg failed,errno=%d[%s]\n&quot;,errno,strerror(errno));  
             exit(-1);  
        }  
    }  
    msgctl(msqid,IPC_RMID,0); //删除消息队列   
}
</code></pre>

<p>recv.c</p>

<pre><code>#include &lt;stdio.h&gt;   
#include &lt;sys/types.h&gt;   
#include &lt;sys/ipc.h&gt;   
#include &lt;sys/msg.h&gt;   
#include &lt;errno.h&gt;   

#define MSGKEY 1024   

struct msgstru  
{  
    long msgtype;  
    char msgtext[2048];  
};  

/*子进程，监听消息队列*/  
void childproc(){  
    struct msgstru msgs;  
    int msgid,ret_value;  
    char str[512];  

while(1){  
msgid = msgget(MSGKEY,IPC_EXCL );/*检查消息队列是否存在 */  
if(msgid &lt; 0){  
    printf(&quot;msq not existed! errno=%d [%s]\n&quot;,errno,strerror(errno));  
    sleep(2);  
    continue;  
}  
 /*接收消息队列*/  
 ret_value = msgrcv(msgid,&amp;msgs,sizeof(struct msgstru),0,0);  
 printf(&quot;text=[%s] pid=[%d]\n&quot;,msgs.msgtext,getpid());  
}  
return;  
}  

void main()  
{  
    int i,cpid;  

    /* create 5 child process */  
    for (i=0;i&lt;5;i++){  
        cpid = fork();  
        if (cpid &lt; 0)  
            printf(&quot;fork failed\n&quot;);  
        else if (cpid ==0) /*child process*/  
            childproc();  
    }
}
</code></pre>

<p>posix</p>

<p>函数</p>

<pre><code>mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);
</code></pre>

<p>创建消息队列</p>

<pre><code>第4个参数为 mq_attr 指针
 struct mq_attr{ 
    long mq_flags;    
    long mq_maxmsg;    
    long mq_msgsize;    
    long mq_curmsgs; }
</code></pre>

<p>当第四个参数为空指针时，就使用默认属性。</p>

<p>当指向mq_attr结构的指针作为参数时，允许我们在该函数的实际操作时创建一个新队列时，给它指定mq_maxmsg和mq_msgsize属性.mq_open忽略该结构的另外两个成员.</p>

<pre><code>（1）attr.mq_maxmsg 不能超过文件 /proc/sys/fs/mqueue/msg_max 中的数值；
（2）attr.mq_msgsize不能超过 /proc/sys/fs/mqueue/msgsize_max 的数值；
（3）消息队列名称前面必须加上斜杆。
</code></pre>

<p>在POSIX消息队列中 msg_max 默认为 10 ，msgsize_max 默认为8192 ，否则会报错！！！</p>

<p>可以在 /proc/sys/fs/mqueue# cat msg_max        /proc/sys/fs/mqueue# cat msgsize_max 查看</p>

<p>修改的话，要使用：echo 1000 &gt; /proc/sys/fs/mqueue/msg_max往里面写。</p>

<pre><code>mqd_t mq_getattr(mqd_t mqdes, struct mq_attr *attr);
</code></pre>

<p>获取消息队列属性</p>

<p>Mqdes：打开消息队列时获取的描述符。</p>

<p>Attr：指向结构struct mq_attr的指针，用来获取消息队列的四个属性</p>

<pre><code>struct mq_attr { 
long mq_flags;    // 0或者O_NONBLOCK 
long mq_maxmsg; //队列中包含的消息数的最大限制数  
long mq_msgsize; //每个消息大小的最大限制数
long mq_curmsgs;  //当前队列中的消息数 
} 


mqd_t mq_setattr(mqd_t mqdes, struct mq_attr *newattr, struct mq_attr *oldattr); 
</code></pre>

<p>设置消息队列的属性</p>

<p>Mqdes：打开消息队列时获取的描述符。</p>

<p>Attr：指向结构struct mq_attr的指针，用来获取消息队列的最大消息个数和最大消息长度。放到数据结构的mq_maxmsg和mq_msgsize中。</p>

<pre><code>struct mq_attr { 
long mq_flags;    // 0或者O_NONBLOCK，只能设置这个
long mq_maxmsg; //队列中包含的消息数的最大限制数 
long mq_msgsize; //每个消息大小的最大限制数   
long mq_curmsgs;  //当前队列中的消息数
} 
</code></pre>

<p>oldattr：用来保存设置之前的attr值，可以为NULL.</p>

<pre><code>int mq_send(mqd_t mqdes, const char *ptr, size_t len, unsigned int prio); 
</code></pre>

<p>发送消息</p>

<p>mqdes: 打开消息队列时获得的描述符。</p>

<p>ptr: 指向发送缓冲区的指针，发送缓冲区存放了要发送的数据。</p>

<p>Len: 要发送的数据的长度。</p>

<p>prio ：消息的优先级；它是一个小于 MQ_PRIO_MAX 的数，数值越大，优先级越高。 POSIX 消息队列在调用 mq_receive 时总是返回队列中 最高优先级的最早消息 。如果消息不需要设定优先级，那么可以在 mq_send 是置 prio 为 0 ， mq_receive 的 prio 置为 NULL 。  返回值：发送成功，返回0，失败，返回-1.</p>

<pre><code>ssize_t mq_receive(mqd_t mqdes, char *ptr, size_t len, unsigned int *prio);
</code></pre>

<p>接受函数</p>

<p>mqdes: 打开消息队列时获得的描述符。</p>

<p>ptr: 指向接收缓冲区的指针。接收缓冲区用来存放收到的消息。</p>

<p>Len: 接收缓冲区的长度。 len不能小于mq_msgsize，否则会返回EMSGSIZE</p>

<p>prio ：消息的优先级；它是一个小于 MQ_PRIO_MAX 的数，数值越大，优先级越高。 POSIX 消息队列在调用 mq_receive 时总是返回队列中 最高优先级的最早消息 。如果消息不需要设定优先级，那么可以在 mq_send 是置 prio 为 0 ， mq_receive 的 prio 置为 NULL 。 返回值：  接收成功，返回0，失败，返回-1.</p>

<pre><code>mqd_t mq_close(mqd_t mqdes); 
</code></pre>

<p>关闭消息队列，但不能删除它 成功返回0，失败返回-1</p>

<pre><code>mqd_t mq_unlink(const char *name); 成功返回0，失败返回-1 
</code></pre>

<p>当某个进程还没有关闭此消息队列时，调用mq_unlink时，不会马上删除队列，当最后一个进程关闭队列时，该队列被删除</p>

<h2 id="共享内存">共享内存</h2>

<p>共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效快速的方式，经过很少的系统调用。但是共享内存并不提供提供同步机制，所以需要其他机制进行控制，比如锁机制。</p>

<p>每个共享内存区, 内核都为其维护一个如下的数据结构, 它定义在头文件<sys/shm.h>中:</p>

<pre><code>struct shmid_ds{
struct ipc_perm; //操作的权限
size_t shm_segsz; //共享内存的大小
pid_t shm_lpid; //上一次操作时的pid
pid_t shm_cpid; //创建者的pid
shmatt_t shm_nattch;//当前附接数
shmatt_t shm_cnattch;//内核的附接数
time_t shm_atime; //最后一次附接的时间
time_t shm_dtime; //最后一次脱接的时间
time_t shm_ctime; //最后一次改变该结构的时间
};
</code></pre>

<p>system V</p>

<pre><code>int shmget(key_t key, size_t size, int oflag);
</code></pre>

<p>当创建或者访问一个已经存在的共享内存时, 我们用shmget函数, 该函数返回一个共享内存标识符, 这里我认为有几点需要注意:</p>

<ol>
<li>如果是创建一个共享内存区, 则size必须时一个大于0的整数, 如果是访问一个已经存在的共享内存区则size一定得为0;size是共享内存的大小</li>
<li>函数的第一个参数key可以是一个整型, 也可以是IPC_PRIVATE.</li>
<li>oflag可以指定为IPC_CREAT或者IPC_CREAT | IPC_EXCL,二者的区别在于第二个在该共享内存不存在时不仅创建它, 而且还会提供检测功能, 即在该共享内存存在的时候,提示错误, 但二者是一个原子操作.</li>

<li><p>用该函数创建或打开一个共享内存区时, 调用成功返回一个内存标识符, 表明该共享内存已经存在, 同时相应的数据结构已经被初始化.只不过还没有将该共享内存区挂接到进程的相应地址空间. 因而暂时还不能访问该共享内存区.</p>

<p>void <em>shmat(int shmid, const void</em> shmaddr, int flag);</p></li>
</ol>

<p>创建或打开一个新的共享内存后,只有经过shmat函数将共享内存区附接到进程的地址空间后, 才可以访问该共享内存,对其进行各种操作.</p>

<ol>
<li><p>该函数的返回值是所指定的共享内存区在调用进程内的起始地址.如果shmaddr是一个空指针, 则系统替调用者选择一个地址, 这种方式通常是提倡的方法. 如果shmaddr不是一个空指针, 则返回地址取决于调用者是否给flag指定了SHM_RND值,如果没有指定, 那么相应的共享内存区附接到由shmaddr指定的地址, 反之,附接到由shmaddr指定的地址向下舍入一个SHMLBA常值.flag通常为0</p>

<p>int shmdt(const void *shmaddr);</p></li>
</ol>

<p>当某个进程完成对一个共享内存的操作时,就可以通过这个函数断接和共享内存的链接</p>

<p>1.成功使用该函数后, 并没有删除共享内存区, 只是解除了进程和共享内存的一种链接关系.通过重新建立附接关系, 仍然可以访问该共享内存区.</p>

<p>2.当一个进程终止时, 它当前附接的所有共享内存区都自动断接掉,但该共享内存区还存在, 只不过需要重新建立这种附接关系.</p>

<pre><code>int shmctl(int shmid, int cmd, struct shmid_ds *buff);
</code></pre>

<p>该函数对共享内存区提供了多种操作,设置cmd参数就好 具体如下:</p>

<ol>
<li>当我们想将一个共享内存区交给系统回收时, 以便可以将其分配给其他进程使用时, 我们可以调用shmctl函数, 这时只需指定其参数为IPC_RMID即可删除该共享内存区.</li>
<li>当我们要用到共享内存区数据结构shmid_ds种的某些字段时, 我们只需将函数参数设置成IPC_STAT即可.</li>
<li>有时候需要设置共享内存区shmid_ds的一下三个成员: shm_perm.uid, shm_perm.gid, shm_perm.mode, 他们的值来自buff参数指向的结构的相应成员.shm_ctime的值也用当前时间替换.我们使用IPC_SET.</li>
</ol>

<p>举例</p>

<p>shmdata.h</p>

<pre><code>#ifndef _SHMDATA_H_HEADER
#define _SHMDATA_H_HEADER

#define TEXT_SZ 2048

struct shared_use_st
{
int written;//作为一个标志，非0：表示可读，0表示可写
char text[TEXT_SZ];//记录写入和读取的文本
};

#endif
</code></pre>

<p>shmwrite.c</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/shm.h&gt;
#include &quot;shmdata.h&quot;

int main()
{
int running = 1;
void *shm = NULL;
struct shared_use_st *shared = NULL;
char buffer[BUFSIZ + 1];//用于保存输入的文本
int shmid;
//创建共享内存
shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);
if(shmid == -1)
{
fprintf(stderr, &quot;shmget failed\n&quot;);
exit(EXIT_FAILURE);
}
//将共享内存连接到当前进程的地址空间
shm = shmat(shmid, (void*)0, 0);
if(shm == (void*)-1)
{
fprintf(stderr, &quot;shmat failed\n&quot;);
exit(EXIT_FAILURE);
}
printf(&quot;Memory attached at %X\n&quot;, (int)shm);
//设置共享内存
shared = (struct shared_use_st*)shm;
while(running)//向共享内存中写数据
{
//数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本
while(shared-&gt;written == 1)
{
sleep(1);
printf(&quot;Waiting...\n&quot;);
}
//向共享内存中写入数据
printf(&quot;Enter some text: &quot;);
fgets(buffer, BUFSIZ, stdin);
strncpy(shared-&gt;text, buffer, TEXT_SZ);
//写完数据，设置written使共享内存段可读
shared-&gt;written = 1;
//输入了end，退出循环（程序）
if(strncmp(buffer, &quot;end&quot;, 3) == 0)
running = 0;
}
//把共享内存从当前进程中分离
if(shmdt(shm) == -1)
{
fprintf(stderr, &quot;shmdt failed\n&quot;);
exit(EXIT_FAILURE);
}
sleep(2);
exit(EXIT_SUCCESS);
}
</code></pre>

<p>shmread.c</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/shm.h&gt;
#include &quot;shmdata.h&quot;

int main()
{
int running = 1;//程序是否继续运行的标志
void *shm = NULL;//分配的共享内存的原始首地址
struct shared_use_st *shared;//指向shm
int shmid;//共享内存标识符
//创建共享内存
shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);
if(shmid == -1)
{
fprintf(stderr, &quot;shmget failed\n&quot;);
exit(EXIT_FAILURE);
}
//将共享内存连接到当前进程的地址空间
shm = shmat(shmid, 0, 0);
if(shm == (void*)-1)
{
fprintf(stderr, &quot;shmat failed\n&quot;);
exit(EXIT_FAILURE);
}
printf(&quot;\nMemory attached at %X\n&quot;, (int)shm);
//设置共享内存
shared = (struct shared_use_st*)shm;
shared-&gt;written = 0;
while(running)//读取共享内存中的数据
{
//没有进程向共享内存定数据有数据可读取
if(shared-&gt;written != 0)
{
printf(&quot;You wrote: %s&quot;, shared-&gt;text);
sleep(rand() % 3);
//读取完数据，设置written使共享内存段可写
shared-&gt;written = 0;
//输入了end，退出循环（程序）
if(strncmp(shared-&gt;text, &quot;end&quot;, 3) == 0)
running = 0;
}
else//有其他进程在写数据，不能读取数据
sleep(1);
}
//把共享内存从当前进程中分离
if(shmdt(shm) == -1)
{
fprintf(stderr, &quot;shmdt failed\n&quot;);
exit(EXIT_FAILURE);
}
//删除共享内存
if(shmctl(shmid, IPC_RMID, 0) == -1)
{
fprintf(stderr, &quot;shmctl(IPC_RMID) failed\n&quot;);
exit(EXIT_FAILURE);
}
exit(EXIT_SUCCESS);
}
</code></pre>

<p>posix</p>

<pre><code>#include &lt;fcntl.h&gt;      // Defines 0_* constants
#include &lt;sys/stat.h&gt;   // Defines mode constants
#include &lt;sys/mman.h&gt;

int shm_open(const char *name, int oflag, mode_t mode);
</code></pre>

<p>创建一个新的共享区域或者附加在已有的共享区域上.区域被其名字标识,函数返回各文件的描述符.</p>

<p>name 标志</p>

<p>flag</p>

<pre><code>oflag      作用
O_CREAT对象不存在的时候创建
O_EXCL与O_CREATE互斥地创建对象
O_RDONLY打开只读访问
O_RDWR打开读写访问
O_TRUNC将对象长度截断为0
</code></pre>

<p>mode 权限，在不创建新对象时需要将这个参数指定为0。</p>

<pre><code>#include &lt;sys/mman.h&gt;

// returns 0 on success, or -1 on error
int shm_unlink(const char *name);
</code></pre>

<p>shm_unlink:类似于unlink系统调用对文件进行操作,直到所有的进程不再引用该内存区后才对其进行释放.</p>

<pre><code>#include &lt;sys/mman.h&gt;  
void *mmap(void *start, size_t len, int prot, int flags, int fd, off_t offset);  
               //成功返回映射到进程地址空间的起始地址，失败返回MAP_FAILED  
</code></pre>

<p>mmap:用于将一个文件映射到某一内存区中,其中也使用了shm_open函数返回的文件描述符.</p>

<pre><code>start：指定描述符fd应被映射到的进程地址空间内的起始地址，它通常被设置为空指针NULL，这告诉内核自动选择起始地址，该函数的返回值即为fd映射到内存区的起始地址。
len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0。
prot：内存映射区的保护由该参数来设定，通常由以下几个值组合而成：
    PROT_READ：数据可读；
    PROT_WRITE：数据可写；
    PROT_EXEC：数据可执行；
    PROT_NONE：数据不可访问；
flags：设置内存映射区的类型标志，POSIX标志定义了以下三个标志：
    MAP_SHARED：该标志表示，调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象（一个文件对象或是一个共享内存区对象）。
    MAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象。
    MAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志。
fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1；
offset：相对文件的起始偏移。


#include &lt;sys/mman.h&gt;  
int munmap(void *start, size_t len);  
                           //成功返回0，出错返回-1  
</code></pre>

<p>munmap:用于释放mmap所映射的内存区域.</p>

<pre><code>start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址。
len：映射区的大小。


#include &lt;sys/mman.h&gt;  
int msync(void *start, size_t len, int flags);  
                      //成功返回0，出错返回-1  
</code></pre>

<p>msync:同步存取一个映射区域并将高速缓存的数据回写到物理内存中,以便其他进程可以监听这些改变.</p>

<pre><code>start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址。
len：映射区的大小。
flags：同步标志，有一下三个标志：
    MS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；
    MS_SYNC：同步写，要等到写操作完成后才返回。
    MS_INVALIDATE：使该文件的其他内存映射的副本全部失效。
</code></pre>

<p>下面三个锁机制大多数用户线程间的互相通信。</p>

<h2 id="互斥锁">互斥锁</h2>

<p>pthread_mutex_t 互斥量类型</p>

<p>函数</p>

<p>初始化互斥锁pthread_mutex_init</p>

<p>函数原型：int  pthread_mutex_init(pthread_mutex_t *mp, const pthread_mutexattr_t *mattr)</p>

<pre><code>参数说明：mp 互斥锁地址    mattr  属性 通常默认 null
初始化互斥锁之前，必须将其所在的内存清零。
如果互斥锁已初始化，则它会处于未锁定状态。互斥锁可以位于进程之间共享的内存中或者某个进程的专用内存中。
</code></pre>

<p>pthread_mutex_destory销毁互斥锁</p>

<p>函数原型：</p>

<pre><code>int pthread_mutex_destroy(pthread_mutex_t *mp); 
#include &lt;pthread.h&gt; 
pthread_mutex_t mp; 
int ret; 
ret = pthread_mutex_destroy(&amp;mp); /* mutex is destroyed */请注意，没有释放用来存储互斥锁的空间。
</code></pre>

<p>返回值：</p>

<p>pthread_mutex_destroy() 在成功完成之后会返回零。其他任何返回值都表示出现了错误。如果出现以下任一情况，该函数将失败并返回对应的值。</p>

<pre><code>EINVAL: mp 指定的值不会引用已初始化的互斥锁对象。
</code></pre>

<p>pthread_mutex_lock()</p>

<p>函数原型：</p>

<pre><code>int pthread_mutex_lock(pthread_mutex_t *mutex); 
#include &lt;pthread.h&gt; 
pthread_mutex_t mutex; 
int ret; 
ret = pthread_ mutex_lock(&amp;mp); /* acquire the mutex */
</code></pre>

<p>函数说明：</p>

<p>当 pthread_mutex_lock() 返回时，该互斥锁已被锁定。调用线程是该互斥锁的属主。如果该互斥锁已被另一个线程锁定和拥有，则调用线程将阻塞，直到该互斥锁变为可用为止。</p>

<pre><code>如果互斥锁类型为 PTHREAD_MUTEX_NORMAL，则不提供死锁检测。尝试重新锁定互斥锁会导致死锁。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或未锁定，则将产生不确定的行为。
如果互斥锁类型为 PTHREAD_MUTEX_ERRORCHECK，则会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。
如果互斥锁类型为 PTHREAD_MUTEX_RECURSIVE，则该互斥锁会保留锁定计数这一概念。线程首次成功获取互斥锁时，锁定计数会设置为 1。线程每重新锁定该互斥锁一次，锁定计数就增加 1。线程每解除锁定该互斥锁一次，锁定计数就减小 1。 锁定计数达到 0 时，该互斥锁即可供其他线程获取。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。
如果互斥锁类型是 PTHREAD_MUTEX_DEFAULT，则尝试以递归方式锁定该互斥锁将产生不确定的行为。对于不是由调用线程锁定的互斥锁，如果尝试解除对它的锁定，则会产生不确定的行为。如果尝试解除锁定尚未锁定的互斥锁，则会产生不确定的行为。
</code></pre>

<p>返回值：</p>

<p>pthread_mutex_lock() 在成功完成之后会返回零。其他任何返回值都表示出现了错误。如果出现以下任一情况，该函数将失败并返回对应的值。</p>

<pre><code>EAGAIN：由于已超出了互斥锁递归锁定的最大次数，因此无法获取该互斥锁。
EDEADLK：当前线程已经拥有互斥锁。
</code></pre>

<p>pthread_mutex_unlock()</p>

<p>函数原型：</p>

<pre><code>int pthread_mutex_unlock(pthread_mutex_t *mutex); 
#include &lt;pthread.h&gt; 
pthread_mutex_t mutex; 
int ret; 
ret = pthread_mutex_unlock(&amp;mutex); /* release the mutex */
</code></pre>

<p>函数说明：pthread_mutex_unlock() 可释放 mutex 引用的互斥锁对象。互斥锁的释放方式取决于互斥锁的类型属性。如果调用 pthread_mutex_unlock() 时有多个线程被 mutex 对象阻塞，则互斥锁变为可用时调度策略可确定获取该互斥锁的线程。对于 PTHREAD_MUTEX_RECURSIVE 类型的互斥锁，当计数达到零并且调用线程不再对该互斥锁进行任何锁定时，该互斥锁将变为可用。</p>

<p>返回值：pthread_mutex_unlock() 在成功完成之后会返回零。</p>

<p>其他任何返回值都表示出现了错误。如果出现以下情况，该函数将失败并返回对应的值。</p>

<pre><code>EPERM :当前线程不拥有互斥锁。
</code></pre>

<p>函数原型：</p>

<pre><code>int pthread_mutex_trylock(pthread_mutex_t *mutex); 
#include &lt;pthread.h&gt; 
pthread_mutex_t mutex; 
int ret; 
ret = pthread_mutex_trylock(&amp;mutex); /* try to lock the mutex */
</code></pre>

<p>数说明：pthread_mutex_trylock() 是 pthread_mutex_lock() 的非阻塞版本。如果 mutex 所引用的互斥对象当前被任何线程（包括当前线程）锁定，则将立即返回该调用。否则，该互斥锁将处于锁定状态，调用线程是其属主。</p>

<p>返回值：pthread_mutex_trylock() 在成功完成之后会返回零。其他任何返回值都表示出现了错误。如果出现以下任一情况，该函数将失败并返回对应的值。</p>

<pre><code>EBUSY :
由于 mutex 所指向的互斥锁已锁定，因此无法获取该互斥锁。
EAGAIN：描述:
由于已超出了 mutex 的递归锁定最大次数，因此无法获取该互斥锁。
</code></pre>

<p>饿死和死锁问题</p>

<p>当一个互斥量已经被别的线程锁定后，另一个线程调用pthread_mutex_lock()函数去锁定它时，会挂起自己的线程等待这个互斥量被解锁。可能出现以下两种情况：
“饥饿状态”：这个互斥量一直没有被解锁，等待锁定它的线程将一直被挂着，即它请求某个资源，但永远得不到它。用户必须在程序中努力避免这种“饥饿”状态出现。Pthread函数库不会自动处理这种情况。
“死锁”：一组线程中的所有线程都在等待被同组中另外一些线程占用的资源，形成循环等待。这时，所有线程都因等待互斥量而被挂起，它们中的任何一个都不可能恢复运行，程序无法继续运行下去。这时就产生了死锁。Pthread函数库可以跟踪这种情形，最后一个线程试图调用pthread_mutex_lock()时会失败，并返回类型为EDEADLK的错误。</p>

<p>信号量也能完成互斥量的要求</p>

<h2 id="读写锁">读写锁</h2>

<p>读写锁比起mutex具有更高的适用性，具有更高的并行性，可以有多个线程同时占用读模式的读写锁，但是只能有一个线程占用写模式的读写锁。</p>

<p>场景：
一种是访问必须是排它行的，就是独占的意思，这称作写操作；另一种情况就是访问方式可以是共享的，就是说可以有多个线程同时去访问某个资源，这种就称作读操作。这个问题模型是从对文件的读写操作中引申出来的.</p>

<p>读写锁的三种状态：</p>

<ol>
<li>当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞</li>
<li>当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程将会被阻塞</li>
<li>当读写锁在读模式的锁状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求则长期阻塞。</li>
</ol>

<p>函数</p>

<p>pthread_rwlock_t 读写锁的数据类型</p>

<p>初始化：</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_rwlock_init(pthread_rwlock_t *rwptr, const pthread_rwlockattr_t *attr);----初始化也可以用宏定义常值PTHREAD_RWLOCK_INITIALIZER赋值来初始化
int pthread_rwlock_destroy(pthread_rwlock_t *rwptr);
</code></pre>

<p>这两个函数如果执行成功均返回0，如果出错则返回错误码。</p>

<p>在释放某个读写锁占用的内存之前，要先通过pthread_rwlock_destroy对读写锁进行清理，释放由pthread_rwlock_init所分配的资源。</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_rwlock_rdlock(pthread_rwlock_t *rwptr);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwptr);
int pthread_rwlock_unlock(pthread_rwlock_t *rwptr);
</code></pre>

<p>这三个函数若调用成功则返回0，失败就返回错误码。要注意的是其中获取锁的两个函数的操作都是阻塞操作，也就是说获取不到锁的话，那么调用线程不是立即返回，而是阻塞执行。有写情况下，这种阻塞式的获取所得方式可能不是很适用，所以，接下来引入两个采用非阻塞方式获取读写锁的函数pthread_rwlock_tryrdlock()和pthread_rwlock_trywrlock(),非阻塞方式下获取锁的时候，如果不能马上获取到，就会立即返回一个EBUSY错误，而不是把调用线程投入到睡眠等待。函数原型如下：</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwptr);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwptr);
</code></pre>

<p>同样地，这两个函数调用成功返回0，失败返回错误码。</p>

<h2 id="条件变量">条件变量</h2>

<p>条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用，伴随着全局变量的变化。</p>

<p>条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的机制，主要包括两个动作：</p>

<ol>
<li>一个线程等待&rdquo;条件变量的条件成立&rdquo;而挂起；</li>
<li>另一个线程使&rdquo;条件成立&rdquo;（给出条件成立信号）。可能是一个进程的输出是另一个的输入</li>
</ol>

<p>函数</p>

<p>pthread_cond_t 条件变量类型</p>

<p>初始化：</p>

<p>和互斥变量一样，使用条件变量之前要先进行初始化，也有2方法：</p>

<ol>
<li>静态：pthead_cond_t     condition = PTHREAD_COND_INITIALIZER</li>

<li><p>动态：pthread_cond_init</p>

<p>#include <pthread.h>
int pthread_cond_init( thread_cond_t * cond, pthread_condattr_t * attr );</p>

<p>参数：
cond  条件变量
attr      条件变量属性</p></li>
</ol>

<p>成功返回0，出错返回错误编号。</p>

<p>销毁：</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_cond_destroy( pthread_cond_t * cond );
</code></pre>

<p>成功返回0，出错返回错误编号。</p>

<p>注意：摧毁所指定的条件变量，同时将会释放所给它分配的资源。调用该函数的进程也并不要求等待在参数所指定的条件变量上。</p>

<p>等待函数：</p>

<pre><code>#include &lt;pthread.h&gt;   
int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);当调用这个函数时，线程挂起，打开已经锁定的互斥锁mutex，当收到signal信号时重新唤起，再次锁住mutex,一般使用全局变量对线程同步进行控制。

int pthread_cond_timedwait(pthread_cond_t *cond,pthread_mutex_t *mytex,const struct timespec *abstime);

参数：
cond 条件变量
mutex 互斥锁
</code></pre>

<p>唤醒函数：</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_cond_signal( pthread_cond_t * cond );
int pthread_cond_broadcast( pthread_cond_t * cond );
参数：cond        条件变量
</code></pre>

<p>成功返回0，出错返回错误编号。</p>

<pre><code>pthread_cond_signal:只唤醒一个线程
pthread_cond_broadcast:唤醒所有线程
</code></pre>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/linux/c&#43;&#43;/process-communication/">https://kingjcy.github.io/post/linux/c&#43;&#43;/process-communication/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/process-communication/">
                            <i class="fa fa-tags"></i>
                            Process Communication
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/network/">
                            <i class="fa fa-tags"></i>
                            network
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/middleware/network/ip/">计算机网络系列---- Ip</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年09月19日)</span></li><li id="li-rels"><a href="/post/middleware/network/tcp/">计算机网络系列---- tcp/ip</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年06月13日)</span></li><li id="li-rels"><a href="/post/middleware/network/http/">计算机网络系列---- Http/https</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年06月13日)</span></li><li id="li-rels"><a href="/post/middleware/io/netcomminicate/">计算机网络系列---- 网络通信</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2015年04月28日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/linux/c&#43;&#43;/thread-lock/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/middleware/io/netcomminicate/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#信号量">信号量</a>
<ul>
<li><a href="#内核信号量">内核信号量</a></li>
<li><a href="#system-v信号量">system v信号量</a></li>
<li><a href="#posix-信号量">POSIX 信号量</a></li>
</ul></li>
<li><a href="#消息队列">消息队列</a></li>
<li><a href="#共享内存">共享内存</a></li>
<li><a href="#互斥锁">互斥锁</a></li>
<li><a href="#读写锁">读写锁</a></li>
<li><a href="#条件变量">条件变量</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

