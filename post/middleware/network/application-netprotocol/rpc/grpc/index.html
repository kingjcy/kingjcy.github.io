<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。 它允许程序调用另一个进程上（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="计算机网络系列---- Grpc - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    计算机网络系列---- Grpc
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2018年02月19日 
                </div>
                <h1 class="post-title">计算机网络系列---- Grpc</h1>
            </header>

            <div class="post-content">
                <p>RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。 它允许程序调用另一个进程上（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>

<p>RPC主要来解决三件事情：</p>

<pre><code>1. 进程间通讯
2. 提供和本地方法调用一样的调用机制
3. 屏蔽程序员对远程调用的细节实现
</code></pre>

<p>首先是进程间的通信问题，对于分布式环境，rpc能够帮助我们解决不同服务器之间的通信及数据传输问题，即<strong>做好方法调用到数据的转换，然后借助网络进行数据传递；</strong>rpc客户端向rpc服务端发起远程服务调用，通过请求的封装，参数的封装，序列化、编码、约定协议传输、解析请求、处理请求、封装返回消息数据、在进行返回数据的序列化、编码、在通过网络返回给客户端。</p>

<p>再者是提供和本地方法调用一样的调用机制，为什么这么说，对于业务系统来说，我们更多的关注点在于如何解决实际的业务需求问题，而不想花更多的时间和心思在诸如上述过程中关于网络传输及编解码过程，因此对于rpc来说，需要将这些编解码、协议约定、网络传输等进行一个整体的封装，然后只向业务系统提供最简单的调用方式。</p>

<p>最后一个屏蔽程序员对远程调用的细节实现，其实也就是第二点中提到的那些功能的封装，我们不用去关系rpc到底是如何实现的，也不用关心它是如何运作的，对于业务开发人员来说，通过约定的方式进行类似于本地方法调用的形式来调用远程服务接口就可以了。</p>

<p>那么如何实现透明化的远程调用呢？什么样的内部封装才能让我们觉得像以本地调用方式调用远程服务呢？</p>

<p>对于java来说就是使用代理。java代理有两种方式：1） jdk 动态代理（接口代理）；2）cglib代理（子类代理）。尽管字节码生成方式实现的代理更为强大和高效，但代码不易维护，大部分公司实现RPC框架时还是选择动态代理方式。这部分也将会在后续的章节中展开来说。</p>

<p>RPC基本原理</p>

<p>rpc需要对一些远程调用的内部实现进行以下几点封装：</p>

<pre><code>序列化
编解码
协议
网络
</code></pre>

<p>从发起远程调用到接收到数据返回结果，大致过程是：</p>

<pre><code>1）服务消费方（client）调用以本地调用方式调用服务；
2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3）client stub找到服务地址，并将消息发送到服务端；
4）server stub收到消息后进行解码；
5）server stub根据解码结果调用本地的服务；
6）本地服务执行并将结果返回给server stub；
7）server stub将返回结果打包成消息并发送至消费方；
8）client stub接收到消息，并进行解码；
9）服务消费方得到最终结果。
</code></pre>

<p>那么rpc就相当于将step2-step8的步骤进行了封装。</p>

<p>RPC模型</p>

<p>如图</p>

<p><img src="/media/netprotocol/rpc/20180219.png" alt="" /></p>

<p>RPC 服务端通过 RpcServer 去暴露服务接口，而客户端通过 RpcClient 去获取服务接口。客户端像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 RpcProxy。代理封装调用信息并将调用转交给 RpcInvoker 去实际执行。在客户端的 RpcInvoker 通过连接器 RpcConnector 去维持与服务端的通道 RpcChannel，并使用 RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务端。RPC 服务端接收器 RpcAcceptor接收客户端的调用请求，同样使用 RpcProtocol 执行协议解码（decode）。
解码后的调用信息传递给 RpcProcessor 去控制处理调用过程，最后再委托调用给 RpcInvoker 去实际执行并返回调用结果。
通过上述分析可知，这里面包括以下核心组件：</p>

<pre><code>用于暴露服务接口的RpcServer
用于发现服务接口的RpcClient
远程接口的代理实现RpcProxy
负责协议编解码的RpcProtocol（实际的rpc框架中一般会提供多种不同的实现）
网络连接器
（之前看过一篇文章说9个组件，对于咱们这个来说，部分模块可以集成在client和server中）
</code></pre>

<p>常见的RPC框架</p>

<p>目前常见的分布式RPC框架有以下几个：</p>

<pre><code>dubbo
阿里巴巴公司开源的一个Java高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成

motan
新浪微博开源的一个Java 框架。它诞生的比较晚，起于2013年，2016年5月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。

rpcx
Go语言生态圈的Dubbo， 比Dubbo更轻量，实现了Dubbo的许多特性，借助于Go语言优秀的并发特性和简洁语法，可以使用较少的代码实现分布式的RPC服务。

gRPC
Google开发的高性能、通用的开源RPC框架，主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。

thrift
Apache的一个跨语言的高性能的服务框架
</code></pre>

<p>这边主要是研究Gprc框架</p>

<p>Google gRPC</p>

<p>gRPC是一个高性能、通用的开源RPC框架，其由Google 2015年主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。gRPC提供了一种简单的方法来精确地定义服务和为iOS、Android和后台支持服务自动生成可靠性很强的客户端功能库。客户端充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用、电池寿命。</p>

<p>gprc是基于ProtoBuf的，我们需要先了解一下ProtoBuf</p>

<p>ProtoBuf</p>

<pre><code>其由Google 2001年设计，2008年开源。
Google内部的服务几乎都是用的PB协议
久经考验、充分验证、良好实现 
使用ProtoBuf: Google、Hadoop、ActiveMQ、Netty
协议 BSD
Protobuf支持生成代码的语言包括Java、Python、C++、Go、JavaNano、Ruby、C#
</code></pre>

<p>ProtoBuf(Protocol Buffers)是一种灵活，高效，自动化的机制，用于序列化结构化数据 - 类似于XML，但更小，更快，更简单。您可以定义数据的结构化结构，然后使用工具生成的源代码轻松地将结构化数据写入和读取各种数据流，并使用各种语言。您甚至可以更新数据结构，而不会破坏根据“旧”格式编译的已部署程序。</p>

<p>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。所以是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式</p>

<p>工作原理</p>

<p>可以通过在.proto文件中定义ProtoBuf(Protocol Buffers)消息类型来指定您希望如何构建序列化信息。每个ProtoBuf(Protocol Buffers)消息都是一个小的逻辑信息记录，包含一系列name-value 对。以下.proto是定义包含有关人员信息的消息的文件的一个非常基本的示例：</p>

<pre><code>message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
</code></pre>

<p>解析</p>

<ol>
<li>指定字段类型</li>
</ol>

<p>在上面的例子中，所有字段都是标量类型：整型，string类型。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。目前常规的语言类型都支持</p>

<ol>
<li>分配标识号</li>
</ol>

<p>正如上述文件格式，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>

<p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。</p>

<ol>
<li>指定字段规则</li>
</ol>

<p>所指定的消息字段修饰符必须是如下之一：</p>

<pre><code>required：一个格式良好的消息一定要含有1个这种字段。表示该值是必须要设置的；
optional：消息格式中该字段可以有0个或1个值（不超过1个）。可以设置默认值，比如optional PhoneType type = 2 [default = HOME];
repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。表示该值可以重复，相当于java中的List。
</code></pre>

<ol>
<li><p>向.proto文件添加注释，可以使用C/C++/java风格的双斜杠（//） 语法格式，</p></li>

<li><p>消息中可以嵌套message，也可以支持枚举定义</p></li>
</ol>

<p>编译</p>

<p>当用protocolbuffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>

<p>下面重点讲解gprc的使用</p>

<h3 id="创建服务端">创建服务端</h3>

<p>一.定义服务（使用ProtoBuf ）</p>

<p>1.在一个后缀名为.proto的文件内定义服务。
2.用protocol buffer编辑器生成服务端和客户端代码。
3.使用gRPC的Go API实现客户端与服务端代码。</p>

<p>gRPC允许您定义四种服务方法：</p>

<p>1.一个简单的RPC，客户端使用存根向服务器发送请求并等待响应返回，就像正常的函数调用一样。</p>

<p>这个用于远程调用，客户端查询服务端数据就想查询本地数据一样，一个请求一个响应</p>

<pre><code>// Obtains the feature at a given position.

rpc GetFeature(Point) returns (Feature) {}
</code></pre>

<p>2.服务器端流RPC，其中客户端发送请求到服务器，并获得一个流中读取消息的序列后面。客户端从返回的流中读取，直到没有更多消息。正如您在我们的示例中所看到的，您通过将stream 关键字放在响应类型之前来指定服务器端流式方法。</p>

<p>这个用于远程调用，客户端查询服务端数据就想查询本地数据一样，并且是一股数据流</p>

<pre><code>// Obtains the Features available within the given Rectangle.  Results are
// streamed rather than returned at once (e.g. in a response message with a
// repeated field), as the rectangle may cover a large area and contain a
// huge number of features.

rpc ListFeatures(Rectangle) returns (stream Feature) {}
</code></pre>

<p>3.客户端流传输的RPC，其中客户端将消息写入的序列，并且将它们发送到服务器，再次使用提供的流。一旦客户端写完消息，它就等待服务器全部读取它们并返回它的响应。您可以通过stream在请求类型之前放置关键字来指定客户端流方法。</p>

<p>这个用于传输数据，使用流的方式</p>

<pre><code>// Accepts a stream of Points on a route being traversed, returning a
// RouteSummary when traversal is completed.
rpc RecordRoute(stream Point) returns (RouteSummary) {}
</code></pre>

<p>4.一个双向流动的RPC双方都派出使用读写流的消息序列。这两个流独立运行，因此客户端和服务器可以按照自己喜欢的顺序进行读写：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替地读取消息然后写入消息，或者其他一些读写组合。保留每个流中的消息顺序。您可以通过stream 在请求和响应之前放置关键字来指定此类方法。</p>

<p>这个用于传输读取双向方式，都是数据流，可以控制</p>

<pre><code>// Accepts a stream of RouteNotes sent while a route is being traversed,
// while receiving other RouteNotes (e.g. from other users).
rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
</code></pre>

<p>二、定义消息类型</p>

<pre><code>message UserInfoResponse {
    string name     = 1; // 用户姓名
    uint32 age      = 2; // 用户年龄
    uint32 sex      = 3; // 用户性别
    uint32 count    = 4; // 账户余额
}
</code></pre>

<p>如上例子每个字段每个字段都有唯一的一个数字标识符，这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。</p>

<p>注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>

<p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。</p>

<p>三.从.proto服务定义生成gRPC客户端和服务器接口</p>

<p>直接使用protoc工具生成</p>

<pre><code> protoc -I routeguide/ routeguide/route_guide.proto --go_out=plugins=grpc:routeguide
</code></pre>

<p>运行此命令会routeguide在route_guide示例目录下的目录中生成以下文件：route_guide.pb.go</p>

<pre><code>-I PATH：specify the directory in which to search for imports. May be specified multiple times; directories will be searched in order. If not given, the current working directory is used.
--go_out：指定输出go代码
plugins=grpc：.proto中的service是grpc扩展的功能，需要使用grpc插件进行解析才能生成对应的接口定义代码。
</code></pre>

<p>这包含：</p>

<pre><code>所有协议缓冲区代码用于填充，序列化和检索我们的请求和响应消息类型
客户端使用服务中定义的方法调用的接口类型（或存根）RouteGuide。
服务器要实现的接口类型，也包括RouteGuide服务中定义的方法。
</code></pre>

<p>这个时候就生成了对应的序列化函数和服务接口</p>

<p>实战</p>

<p>我们举例说明前几步，首先创建一个proto文件，包含服务和数据类型。名字为friday.proto</p>

<pre><code>syntax = &quot;proto3&quot;;

package friday;

// 请求用户信息
message UserInfoRequest {
    int64 uid = 1; // 用户ID
}

// 请求用户信息的结果
message UserInfoResponse {
    string name     = 1; // 用户姓名
    uint32 age      = 2; // 用户年龄
    uint32 sex      = 3; // 用户性别
    uint32 count    = 4; // 账户余额
}

service Data {
    //简单Rpc
    // 获取用户数据
    rpc GetUserInfo(UserInfoRequest) returns (UserInfoResponse){}

    //  修改用户 双向流模式
    rpc ChangeUserInfo(stream UserInfoResponse) returns (stream UserInfoResponse){}

}
</code></pre>

<p>然后使用工具就可以生成客户端和服务端代码</p>

<p>protoc -I rpc/ rpc/friday.proto &ndash;go_out=plugins=grpc:rpc&ndash;最后这个是目录</p>

<p>然后就可以生成一个friday.pb.go的文件，打开文件我们就可以看到该文件中定义了客户端与服务端的方法，这里就不详细的说明了，下面我们就开始动手实现。</p>

<p>服务端的接口实现是需要我们自己来处理的</p>

<p>/<em>服务端的方法</em>/
package response</p>

<p>import (
    &ldquo;golang.org/x/net/context&rdquo;
    pb &ldquo;rpcTest/rpcbuild/rpcbuild/friday&rdquo;
    &ldquo;fmt&rdquo;
    &ldquo;io&rdquo;
)</p>

<p>type Server struct{
    routeNotes    []*pb.UserInfoResponse
}</p>

<p>//简单模式
func (this *Server)GetUserInfo(ctx context.Context, in *pb.UserInfoRequest)(*pb.UserInfoResponse,error){
    uid := in.GetUid()
    fmt.Println(&ldquo;The uid is &ldquo;,uid)
    return &amp;pb.UserInfoResponse{
        Name : &ldquo;Jim&rdquo;,
        Age  : 18,
        Sex : 0,
        Count:1000,
    },nil
}</p>

<p>//双向流模式
func (this *Server) ChangeUserInfo(stream pb.Data_ChangeUserInfoServer)(error){
    for {
        in, err := stream.Recv()
        if err == io.EOF {
            fmt.Println(&ldquo;read done&rdquo;)
            return nil
        }
        if err != nil {
            fmt.Println(&ldquo;ERR&rdquo;,err)
            return err
        }
        fmt.Println(&ldquo;userinfo &ldquo;,in)
        for _, note := range this.routeNotes{
            if err := stream.Send(note); err != nil {
                return err
            }
        }
    }</p>

<h2 id="toc_1">}</h2>

<p>package main</p>

<p>import (
    &ldquo;net&rdquo;
    &ldquo;google.golang.org/grpc&rdquo;
    pb &ldquo;rpcTest/rpcbuild/rpcbuild/friday&rdquo;
    &ldquo;rpcTest/rpcbuild/response&rdquo;
    &ldquo;log&rdquo;</p>

<p>)</p>

<p>const (
    PORT = &ldquo;:10023&rdquo;
)</p>

<p>func main() {
    lis, err := net.Listen(&ldquo;tcp&rdquo;, PORT)
    if err != nil {
        log.Fatalf(&ldquo;failed to listen: %v&rdquo;, err)
    }
    s := grpc.NewServer()
    pb.RegisterDataServer(s, &amp;response.Server{})
    s.Serve(lis)</p>

<h2 id="toc_2">}</h2>

<p>下面可以直接使用客户端进行操作，结构体已经定义好，函数也已经实现，不需要重写，但是可以封装，其实最终客户端调用的就是服务我们写的函数。如下</p>

<pre><code>package main

import (
    &quot;google.golang.org/grpc&quot;
    pb &quot;rpcTest/rpcbuild/rpcbuild/friday&quot;
    &quot;rpcTest/rpcbuild/connect&quot;
    &quot;fmt&quot;
    &quot;sync&quot;
)

const (
    address = &quot;127.0.0.1:10023&quot;
)

func main(){
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        fmt.Println(&quot;did not connect: %v&quot;, err)
    }
    defer conn.Close()

    // 创建连接
    factory := func() (interface{}, error) {
        return pb.NewDataClient(conn),nil
    }
    // 关闭链接，此处只是定义不需要调用了因为上面有defer conn.Close()，定义的目的在于初始化链接池。
    close := func(v interface{}) error { return conn.Close()}

    //初始化链接池
    p,err := connect.InitThread(10,30,factory)
    if err != nil{
        fmt.Println(&quot;init error&quot;)
        return
    }

    var wg sync.WaitGroup
    for i := 0;i &lt; 50;i++ {
        wg.Add(1)
        go func(){
            defer wg.Done()
            //获取连接
            v,_ := p.Get()
            client := v.(pb.DataClient)
            info := &amp;pb.UserInfoRequest{
                Uid:10012,
            }
            connect.GetUserInfo(client,info)
            //归还链接
            p.Put(v)
        }()
        wg.Wait()
    }

    for i := 0;i &lt; 50;i++ {
        wg.Add(1)
        go func(){
            defer wg.Done()
            //获取连接
            v,_ := p.Get()
            client := v.(pb.DataClient)
            connect.ChangeUserInfo(client)
            //归还链接
            p.Put(v)
        }()
        wg.Wait()
    }
    //获取链接池大小
    current := p.Len()
    fmt.Println(&quot;len=&quot;, current)
}
</code></pre>

<hr />

<p>package connect</p>

<p>import (
    &ldquo;github.com/silenceper/pool&rdquo;
    &ldquo;fmt&rdquo;
    &ldquo;time&rdquo;
    &ldquo;net&rdquo;
)</p>

<p>/*
    初始化
    min // 最小链接数
    max // 最大链接数
    factory func() (interface{}, error) //创建链接的方法
    close func(v interface{}) error //关闭链接的方法
*/
func InitThread(min,max int,factory func() (interface{}, error)，close func(v interface{}) error)(pool.Pool,error){</p>

<pre><code>poolConfig := &amp;pool.PoolConfig{
    InitialCap: min,
    MaxCap:     max,
    Factory:    factory,
    Close:      close,
    //链接最大空闲时间，超过该时间的链接 将会关闭，可避免空闲时链接EOF，自动失效的问题
    IdleTimeout: 15 * time.Second,
}
p, err := pool.NewChannelPool(poolConfig)
if err != nil {
    fmt.Println(&quot;Init err=&quot;, err)
    return nil,err
}
return p,nil
</code></pre>

<h2 id="toc_3">}</h2>

<p>/<em>客户端方法</em>/
package connect</p>

<p>import (
    &ldquo;golang.org/x/net/context&rdquo;
    pb &ldquo;rpcTest/rpcbuild/rpcbuild/friday&rdquo;
    &ldquo;fmt&rdquo;
    &ldquo;io&rdquo;
)</p>

<p>//简单模式
func GetUserInfo(client pb.DataClient, info *pb.UserInfoRequest)  {
    req, err := client.GetUserInfo(context.Background(),info)
    if err != nil {
        fmt.Println(&ldquo;Could not create Customer: %v&rdquo;, err)
    }
    fmt.Println(&ldquo;userinfo is &ldquo;,req.GetAge(),req.GetCount(),req.GetName(),req.GetSex())
}</p>

<p>//双向流模式
func ChangeUserInfo(client pb.DataClient){
    notes := []*pb.UserInfoResponse{
        {Name:&ldquo;jim&rdquo;,Age:18,Sex:2,Count:100},
        {Name:&ldquo;Tom&rdquo;,Age:20,Sex:1,Count:666},
    }
    stream, err := client.ChangeUserInfo(context.Background())
    if err != nil {
        fmt.Println(&ldquo;%v.RouteChat(_) = _, %v&rdquo;, client, err)
    }
    waitc := make(chan struct{})
    go func() {
        for {
            in, err := stream.Recv()
            if err == io.EOF {
                // read done.
                fmt.Println(&ldquo;read done &ldquo;)
                close(waitc)
                return
            }
            if err != nil {
                fmt.Println(&ldquo;Failed to receive a note : %v&rdquo;, err)
            }
            fmt.Println(&ldquo;Got message %s at point(%d, %d)&rdquo;,in.Count,in.Sex,in.Age,in.Name)
        }
    }()
    fmt.Println(&ldquo;notes&rdquo;,notes)
    for _, note := range notes {
        if err := stream.Send(note); err != nil {
            fmt.Println(&ldquo;Failed to send a note: %v&rdquo;, err)
        }
    }
    stream.CloseSend()
    &lt;-waitc</p>

<h2 id="toc_4">}</h2>

<p>还有单向流式</p>

<p>客户端流式传输实例</p>

<p>先定义数据和接口</p>

<p>helloworld.proto</p>

<pre><code>    // Copyright 2015 gRPC authors.
    //
    // Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
    // you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = &quot;proto3&quot;;

option java_multiple_files = true;
option java_package = &quot;io.grpc.examples.helloworld&quot;;
option java_outer_classname = &quot;HelloWorldProto&quot;;

package helloworld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (stream HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre>

<p>使用proto的工具生成这些文件定义中的数据的结构体定义以及使用这些结构体的接口的具体定义，还包含一些描述和序列化的函数</p>

<p>然后就可以开发对应的服务端和客户端</p>

<p>服务端</p>

<p>server.go</p>

<pre><code>import (
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;strings&quot;
    &quot;time&quot;

    &quot;google.golang.org/grpc&quot;
    pb &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;
)

const (
    port = &quot;:50051&quot;
)

// server is used to implement helloworld.GreeterServer.
type server struct{}

// SayHello implements helloworld.GreeterServer
func (s *server) SayHello(stream pb.Greeter_SayHelloServer) ( error) {
    time.Sleep(1*time.Second)
    var names []string
    i := 0
    for {

        in, err := stream.Recv()
        if err == io.EOF {
            stream.SendAndClose(&amp;pb.HelloReply{Message: &quot;Hello &quot; + strings.Join(names, &quot;,&quot;)})
            return nil
        }
        if err != nil {
            log.Printf(&quot;failed to recv: %v&quot;, err)
            return err
        }

        names = append(names, in.Name)

        i++
        log.Printf(&quot;Received: %v,%d&quot;, in.Name,i)
    }
}

func main() {
    lis, err := net.Listen(&quot;tcp&quot;, port)
    if err != nil {
        log.Fatalf(&quot;failed to listen: %v&quot;, err)
    }
    s := grpc.NewServer()
    pb.RegisterGreeterServer(s, &amp;server{})
    if err := s.Serve(lis); err != nil {
        log.Fatalf(&quot;failed to serve: %v&quot;, err)
    }
}
</code></pre>

<p>客户端</p>

<p>client.go</p>

<pre><code>import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;sync&quot;
    &quot;time&quot;

    &quot;google.golang.org/grpc&quot;
    pb &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;
)

const (
    address     = &quot;localhost:50051&quot;
    defaultName = &quot;world&quot;
)

var wg sync.WaitGroup

func main() {
    // Set up a connection to the server.
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        log.Fatalf(&quot;did not connect: %v&quot;, err)
    }
    defer conn.Close()
    c := pb.NewGreeterClient(conn)

    // Contact the server and print out its response.
    //name := defaultName
    //if len(os.Args) &gt; 1 {
    //  name = os.Args[1]
    //}

    wg.Add(1000)
    start := time.Now()
    for i := 0;i &lt; 1000;i++ {
        go getData(c)

    }
    wg.Wait()
    log.Println(&quot;used time : &quot;,time.Now().Sub(start))
}


func getData(c pb.GreeterClient){
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    stream, err := c.SayHello(ctx)
    if err != nil {
        log.Fatalf(&quot;could not greet: %v&quot;, err)
    }

    for i := 0;i &lt; 100;i++ {
        stream.Send(&amp;pb.HelloRequest{Name: defaultName})
    }

    r, err := stream.CloseAndRecv()
    if err != nil {
        fmt.Printf(&quot;failed to recv: %v&quot;, err)
    }

    log.Printf(&quot;Greeting: %s&quot;, r.Message)
    wg.Done()
}
</code></pre>

<p>这样就能完成客户端批量发送数据的作用</p>

<p>还有服务端流式方式，用于批量响应</p>

<p>比如下面简单介绍一下</p>

<p>proto文件</p>

<pre><code>syntax = &quot;proto3&quot;;
package pb;
import &quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;;
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello1 (HelloRequest) returns (stream HelloReply) {}
}
// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}
// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre>

<p>服务端函数</p>

<pre><code>func (s *server) SayHello1(in *pb.HelloRequest, gs pb.Greeter_SayHello1Server) error {
    name := in.Name
    for i := 0; i &lt; 100; i++ {
        gs.Send(&amp;pb.HelloReply{Message: &quot;Hello &quot; + name + strconv.Itoa(i)})
    }
    return nil
}
</code></pre>

<p>客户端接受</p>

<pre><code> conn, err := grpc.Dial(*address, grpc.WithInsecure())
   if err != nil {
    log.Fatalf(&quot;faild to connect: %v&quot;, err)
   }
   defer conn.Close()
   c := pb.NewGreeterClient(conn)
stream, err := c.SayHello1(context.Background(), &amp;pb.HelloRequest{Name: *name})
if err != nil {
    log.Fatalf(&quot;could not greet: %v&quot;, err)
}
for {
    reply, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        log.Printf(&quot;failed to recv: %v&quot;, err)
    }
    log.Printf(&quot;Greeting: %s&quot;, reply.Message)
}
</code></pre>

<p>几种基本情况的使用大体都包含到了，下面我们继续总结</p>

<p>三.创建服务器</p>

<p>主要工作</p>

<pre><code>实现从我们的服务定义生成的服务接口：执行我们服务的实际“工作”。
运行gRPC服务器以侦听来自客户端的请求并将其分派给正确的服务实现。
</code></pre>

<p>自己定义一个结构体，然后在这个结构体上实现我们定义的接口的具体实现</p>

<p>比如我们定义一个结构体</p>

<p>type routeGuideServer struct{}</p>

<p>实现对应的函数接口</p>

<p>简单的RPC</p>

<p>routeGuideServer实现我们所有的服务方法。让我们先看一下最简单的类型GetFeature，它只是Point从客户端获取一个并从其数据库中返回相应的特征信息Feature。</p>

<pre><code>func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) {
    for _, feature := range s.savedFeatures {
        if proto.Equal(feature.Location, point) {
            return feature, nil
        }
    }
    // No feature was found, return an unnamed feature
    return &amp;pb.Feature{&quot;&quot;, point}, nil
}
</code></pre>

<p>该方法传递RPC的上下文对象和客户端的Point 协议缓冲请求。它返回一个Feature协议缓冲区对象，其中包含响应信息和error。在方法中，我们Feature 使用适当的信息填充，然后return它与nil错误一起告诉gRPC我们已经完成了RPC的处理并且Feature可以返回到客户端。</p>

<p>服务器端流式RPC</p>

<p>现在让我们看一下我们的流式RPC。ListFeatures是一个服务器端流式RPC，所以我们需要将多个Features 发回给我们的客户端。</p>

<pre><code>func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error {
    for _, feature := range s.savedFeatures {
        if inRange(feature.Location, rect) {
            if err := stream.Send(feature); err != nil {
                return err
            }
        }
    }
    return nil
}
</code></pre>

<p>正如您所看到的，我们不是在方法参数中获取简单的请求和响应对象，而是这次我们得到一个请求对象（Rectangle我们的客户端想要在其中找到Features）和一个特殊的 RouteGuide_ListFeaturesServer对象来编写我们的响应。</p>

<p>在该方法中，我们填充了Feature我们需要返回的对象，将它们写入RouteGuide_ListFeaturesServer使用其Send()方法。最后，就像在我们简单的RPC中一样，我们返回一个nil错误告诉gRPC我们已经完成了写入响应。如果在此调用中发生任何错误，我们将返回非nil错误; gRPC层会将其转换为适当的RPC状态，以便在线路上发送。</p>

<p>客户端流式RPC</p>

<p>现在让我们看一些更复杂的东西：客户端流式传输方法RecordRoute，我们Point从客户端获取s 流并返回一个RouteSummary包含其行程信息的单个流。如您所见，这次该方法根本没有请求参数。相反，它获取一个RouteGuide_RecordRouteServer流，服务器可以使用它来读取和写入消息 - 它可以使用其Recv()方法接收客户端消息并使用其方法返回其单个响应SendAndClose() 。</p>

<pre><code>func (s *routeGuideServer) RecordRoute(stream pb.RouteGuide_RecordRouteServer) error {
    var pointCount, featureCount, distance int32
    var lastPoint *pb.Point
    startTime := time.Now()
    for {
        point, err := stream.Recv()
        if err == io.EOF {
            endTime := time.Now()
            return stream.SendAndClose(&amp;pb.RouteSummary{
                PointCount:   pointCount,
                FeatureCount: featureCount,
                Distance:     distance,
                ElapsedTime:  int32(endTime.Sub(startTime).Seconds()),
            })
        }
        if err != nil {
            return err
        }
        pointCount++
        for _, feature := range s.savedFeatures {
            if proto.Equal(feature.Location, point) {
                featureCount++
            }
        }
        if lastPoint != nil {
            distance += calcDistance(lastPoint, point)
        }
        lastPoint = point
    }
}
</code></pre>

<p>在方法体中，我们使用RouteGuide_RecordRouteServer的Recv()方法在我们的客户机的请求的请求对象反复读取（在这种情况下 Point），直到没有更多的消息：服务器需要检查从返回的错误Read()每次通话后。如果是这样nil，流仍然很好，它可以继续阅读; 如果它是io.EOF消息流已经结束并且服务器可以返回它RouteSummary。如果它有任何其他值，我们将“按原样”返回错误，以便gRPC层将其转换为RPC状态。</p>

<p>双向流式RPC</p>

<p>最后，我们来看看我们的双向流式RPC RouteChat()。</p>

<pre><code>func (s *routeGuideServer) RouteChat(stream pb.RouteGuide_RouteChatServer) error {
    for {
        in, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        key := serialize(in.Location)
                ... // look for notes to be sent to client
        for _, note := range s.routeNotes[key] {
            if err := stream.Send(note); err != nil {
                return err
            }
        }
    }
}
</code></pre>

<p>这次我们得到一个RouteGuide_RouteChatServer流，就像我们的客户端流示例一样，可用于读取和写入消息。但是，这次我们通过方法的流返回值，而客户端仍在向其消息流写入消息。</p>

<p>这里的读写语法与我们的客户端流方法非常相似，只是服务器使用流的Send()方法而不是 SendAndClose()因为它正在编写多个响应。尽管每一方都会按照编写顺序获取对方的消息，但客户端和服务器都可以按任何顺序进行读写 - 这些流完全独立运行。</p>

<p>四.启动服务器</p>

<p>一旦我们实现了所有方法，我们还需要启动一个gRPC服务器，以便客户端可以实际使用我们的服务。以下代码段显示了我们如何为我们的RouteGuide服务执行此操作：</p>

<pre><code>flag.Parse()
lis, err := net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;:%d&quot;, *port))
if err != nil {
        log.Fatalf(&quot;failed to listen: %v&quot;, err)
}
grpcServer := grpc.NewServer()
pb.RegisterRouteGuideServer(grpcServer, &amp;routeGuideServer{})
... // determine whether to use TLS
grpcServer.Serve(lis)
</code></pre>

<p>要构建和启动服务器，我们：</p>

<pre><code>指定我们要用于侦听客户端请求的端口lis, err := net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;:%d&quot;, *port))。
使用创建gRPC服务器的实例grpc.NewServer()。
使用gRPC服务器注册我们的服务实现。
Serve()使用我们的端口详细信息调用服务器以执行阻塞等待，直到进程被终止或被Stop()调用。
</code></pre>

<p>要编译和运行服务器，假设您在文件夹中 $GOPATH/src/google.golang.org/grpc/examples/route_guide，只需：</p>

<pre><code>$ go run server/server.go
</code></pre>

<h3 id="创建客户端">创建客户端</h3>

<p>首先需要创建一个gRPC 通道来与服务器通信。我们通过传递服务器地址和端口号来创建它， grpc.Dial()如下所示：</p>

<pre><code>conn, err := grpc.Dial(*serverAddr)
if err != nil {
    ...
}
defer conn.Close()
</code></pre>

<p>如果您请求的服务需要，您可以使用DialOptions设置身份验证凭据（例如，TL​​S，GCE凭据，JWT凭证）grpc.Dial- 但是，我们不需要为我们的RouteGuide服务执行此操作。</p>

<p>设置gRPC 通道后，我们需要一个客户端来执行RPC。我们使用从.proto生成NewRouteGuideClient的pb包中提供的方法得到这个。</p>

<pre><code>client := pb.NewRouteGuideClient(conn)
</code></pre>

<p>调用服务方法</p>

<p>现在让我们来看看我们如何调用我们的服务方法。请注意，在gRPC-Go中，RPC以阻塞/同步模式运行，这意味着RPC调用等待服务器响应，并将返回响应或错误。</p>

<p>简单的RPC</p>

<p>调用简单的RPC GetFeature几乎与调用本地方法一样简单。</p>

<pre><code>feature, err := client.GetFeature(context.Background(), &amp;pb.Point{409146138, -746188906})
if err != nil {
        ...
}
log.Println(feature)
</code></pre>

<p>如您所见，我们在之前获得的存根上调用该方法。在我们的方法参数中，我们创建并填充请求协议缓冲区对象（在我们的例子中 Point）。我们还传递了一个context.Context对象，它允许我们在必要时更改RPC的行为，例如超时/取消正在运行的RPC。如果调用没有返回错误，那么我们可以从第一个返回值中读取服务器的响应信息。</p>

<p>服务器端流式RPC</p>

<p>这里我们称之为服务器端流方法ListFeatures，它返回地理流Feature。如果您已经阅读过创建服务器，其中一些可能看起来非常熟悉 - 流式RPC在双方都以类似的方式实现。</p>

<pre><code>rect := &amp;pb.Rectangle{ ... }  // initialize a pb.Rectangle
stream, err := client.ListFeatures(context.Background(), rect)
if err != nil {
    ...
}
for {
    feature, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        log.Fatalf(&quot;%v.ListFeatures(_) = _, %v&quot;, client, err)
    }
    log.Println(feature)
}
</code></pre>

<p>与简单的RPC一样，我们将方法传递给上下文和请求。但是，我们不再获取响应对象，而是返回一个实例 RouteGuide_ListFeaturesClient。客户端可以使用 RouteGuide_ListFeaturesClient流来读取服务器的响应。</p>

<p>我们使用RouteGuide_ListFeaturesClient的Recv()方法重复读取服务器对响应协议缓冲区对象（在本例中为a Feature）的响应， 直到没有更多消息：客户端需要检查每次调用后err返回的错误 Recv()。如果nil，流仍然很好，它可以继续阅读; 如果是，io.EOF那么消息流已经结束; 否则必须有一个RPC错误，它会被传递通过err。</p>

<p>客户端流式RPC</p>

<p>客户端流方法RecordRoute类似于服务器端方法，除了我们只传递方法一个上下文并获得一个 RouteGuide_RecordRouteClient流，我们可以用它来写和 读消息。</p>

<pre><code>// Create a random number of random points
r := rand.New(rand.NewSource(time.Now().UnixNano()))
pointCount := int(r.Int31n(100)) + 2 // Traverse at least two points
var points []*pb.Point
for i := 0; i &lt; pointCount; i++ {
    points = append(points, randomPoint(r))
}
log.Printf(&quot;Traversing %d points.&quot;, len(points))
stream, err := client.RecordRoute(context.Background())
if err != nil {
    log.Fatalf(&quot;%v.RecordRoute(_) = _, %v&quot;, client, err)
}
for _, point := range points {
    if err := stream.Send(point); err != nil {
        if err == io.EOF {
            break
        }
        log.Fatalf(&quot;%v.Send(%v) = %v&quot;, stream, point, err)
    }
}
reply, err := stream.CloseAndRecv()
if err != nil {
    log.Fatalf(&quot;%v.CloseAndRecv() got error %v, want %v&quot;, stream, err, nil)
}
log.Printf(&quot;Route summary: %v&quot;, reply)
</code></pre>

<p>该RouteGuide_RecordRouteClient有一个Send()，我们可以用它来发送请求到服务器的方法。一旦我们使用完成了客户端对流的请求Send()，我们需要调用CloseAndRecv()流来让gRPC知道我们已完成写入并期望收到响应。我们从err返回的中获取RPC状态CloseAndRecv()。如果状态为nil，则第一个返回值CloseAndRecv()将是有效的服务器响应。</p>

<p>双向流式RPC</p>

<p>最后，我们来看看我们的双向流式RPC RouteChat()。在这种情况下RecordRoute，我们只传递方法一个上下文对象并获取一个我们可用于写入和读取消息的流。但是，这次我们通过方法的流返回值，而服务器仍在向其消息流写入消息。</p>

<pre><code>stream, err := client.RouteChat(context.Background())
waitc := make(chan struct{})
go func() {
    for {
        in, err := stream.Recv()
        if err == io.EOF {
            // read done.
            close(waitc)
            return
        }
        if err != nil {
            log.Fatalf(&quot;Failed to receive a note : %v&quot;, err)
        }
        log.Printf(&quot;Got message %s at point(%d, %d)&quot;, in.Message, in.Location.Latitude, in.Location.Longitude)
    }
}()
for _, note := range notes {
    if err := stream.Send(note); err != nil {
        log.Fatalf(&quot;Failed to send a note: %v&quot;, err)
    }
}
stream.CloseSend()
&lt;-waitc
</code></pre>

<p>这里的读写语法与我们的客户端流方法非常相似，只是在CloseSend()我们完成调用后使用流的方法。尽管每一方都会按照编写顺序获取对方的消息，但客户端和服务器都可以按任何顺序进行读写 - 这些流完全独立运行。</p>

<p>启动客户端</p>

<pre><code>$ go run client/client.go
</code></pre>

<p>到这边基本就完成基本使用了</p>

<p>rpc原理</p>

<p>Server端接收到客户端建立的连接后，使用一个goroutine专门处理此客户端的连接(即一个tcp连接或者说一个http2连接)，所以同一个grpc客户端连接上服务端后，后续的请求都是通过同一个tcp连接。</p>

<p>客户端和服务端的连接在应用层由Transport抽象(类似通常多路复用实现中的封装的channel)，在客户端是ClientTransport，在服务端是ServerTransport。Server端接收到一个客户端的http2请求后即打开一个新的流，ClientTransport和ServerTransport之间使用这个新打开的流以http2帧的形式交换数据。</p>

<p>客户端的每个http2请求会打开一个新的流。流可以从两边关闭，对于单次请求来说，客户端会主动关闭流，对于流式请求客户端不会主动关闭(即使使用了CloseSend也只是发送了数据发送结束的标识，还是由服务端关闭)。</p>

<p>gRPC-Go中的单次方法和流式方法</p>

<p>无论是单次方法还是流式方法，服务端在调用完用户的处理逻辑函数返回后，都会关闭流(这也是为什么ServerStream不需要实现CloseSend的原因)。区别只是对于服务端的流式方法来说，可循环多次读取这个流中的帧数据并处理，以此”复用”这个流。</p>

<p>客户端如果是流式方法，需要显示调用CloseSend，表示数据发送的结束</p>

<p>rpc的调用服务端是使用了workpool，不管是正常的请求，还是流式调用，每个request或者stream就是一个work，其实流式就是相当于有很长的传参或者返回参数，原理都是一样的，stream就是批量处理的概念。具体实现应该是封装好了，需要去查看源码。</p>

<h2 id="使用总结">使用总结</h2>

<p>为什么要使用grpc？</p>

<pre><code>1. 支持多种语言。完成不同语言之间的调用，还能自动生成代码。
2. 二进制的数据可以加快传输速度
3. 基于http2的多路复用可以减少服务之间的连接次数，也天然的支持了TLS和流控。
4. 和函数一样的调用方式也有效的提升了开发效率。
5. 支持流式调用方式

6. 使用 protobuf 作为序列化库， 专门的 IDL 语法也使得接口定义更加简洁规范了，protobuf 内置支持兼容性处理，proto3 支持 json 序列化，更容易和其它系统交互；
7. 底层数据传输基于 HTTP/2，所以也会带来 flow control, header compression 等 HTTP/2 特性，数据传输还支持压缩、加密、重试（支持 Backoff）等，性能相应该会有一定提升（没有做测试）；
8. 很多大型项目在用，比如etcd v3 和 docker containerd，k8s，tidb
</code></pre>

<p>缺点：</p>

<pre><code>1. 开发调试就不像 REST 接口那样有很多现成的命令行或图形界面工具可以使用，grpc 的数据通信传输的是二进制的 protobuf 数据，不利于调试，而且 grpc 的 cli 还不够完善，所以我们测试基本上都是通过写代码进行的；
</code></pre>

<p>rpc和http</p>

<p>http 和 rpc 并不是一个并行概念。</p>

<p>rpc是远端调用协议, 包含传输协议和编码协议。传输协议包含: 如著名的 <a href="grpc / grpc.io">gRPC</a> 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。编码协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf binpack 等。</p>

<p>把一个http server容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。所以为什么要用rpc调用？因为良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。</p>

<p>http1.1 和2.0</p>

<p>相对http1.1协议，http2.0协议已经优化编码效率问题，grpc这种rpc库使用的就是http2.0协议。</p>

<pre><code>1. http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。
2. 要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，
</code></pre>

<p>http1.1和tcp</p>

<p>通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下</p>

<pre><code>HTTP/1.0 200 OK 
Content-Type: text/plain 
Content-Length: 137582 
Expires: Thu, 05 Dec 1997 16:00:00 GMT 
Last-Modified: Wed, 5 August 1996 15:55:28 GMT 
Server: Apache 0.84 

&lt;html&gt; 
  &lt;body&gt;Hello World&lt;/body&gt; 
&lt;/html&gt; 
</code></pre>

<p>即使编码协议也就是body是使用二进制编码协议，报文元数据也就是header头的键值对却用了文本编码，非常占字节数。如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。那么假如我们使用自定义tcp协议的报文报头占用的字节数也就只有16个byte，极大地精简了传输内容。这也就是为什么后端进程间通常会采用自定义tcp协议的rpc来进行通信的原因。</p>

<p>rpc和rest也不是一个概念</p>

<p>rest是一种规范，一种资源抽象的设计思想。是靠原生的http api实现的，rpc是对http的一种封装，（最重要的是实现了批量操作和本地化调用方式）有大量已经开发的框架，能够直接使用，算的上一种上层协议。</p>

<p>gprc控制并发</p>

<pre><code>func runServer() error {
  ...
  srv := grpc.NewServer(grpc.Creds(tlsCreds),
    ServerInterceptor(),
    grpc.MaxConcurrentStreams(64),
    grpc.InTapHandle(NewTap().Handler))
  rpc.RegisterCacheServer(srv, NewCacheService(accounts))
  l, err := net.Listen(&quot;tcp&quot;, &quot;localhost:5051&quot;)
  if err != nil {
    return err
  }
  l = netutil.LimitListener(l, 1024)
  return srv.Serve(l)
}
</code></pre>

<p>这里使用了 netutil.LimitListener(l, 1024) 控制了总共可以有多少个连接</p>

<p>然后用 grpc.MaxConcurrentStreams(64) 指定了每个 grpc 的连接可以有多少个并发流(stream)。一个链接可以传输多个流，比如我们可以使用一个链接来传输jvm和call的流</p>

<p>这两个结合起来基本控制了并发的总数。</p>

<p>拦截器 Interceptor</p>

<p>grpc服务端和客户端都提供了interceptor功能，功能类似middleware，很适合在这里处理验证、日志等流程。</p>

<p>在自定义Token认证的示例中，认证信息是由每个服务中的方法处理并认证的，如果有大量的接口方法，这种姿势就太不优雅了，每个接口实现都要先处理认证信息。这个时候interceptor就可以用来解决了这个问题，在请求被转到具体接口之前处理认证信息，一处认证，到处无忧。</p>

<p>可以在服务端接收到请求后，先对请求中的数据做一些处理后再转交给指定的服务处理并响应，常见的如权限校验、日志、接口调用延迟等，这里简单打印下客户端的 IP 地址。</p>

<p>获取IP</p>

<p>gRPC 服务和客户端之间是通过 http2 进行交互，其中包含了客户端的地址信息，</p>

<p>在 gRPC 源码 peer/peer.go 中包含了创建的上下文信息，其中就记录的远端地址；而且在 gRPC 请求中默认都会含有 Context 值，这样就可以通过如下方法获取。</p>

<pre><code>func getClietIP(ctx context.Context) (string, error) {
    pr, ok := peer.FromContext(ctx)
    if !ok {
        return &quot;&quot;, fmt.Errorf(&quot;getClinetIP, invoke FromContext() failed&quot;)
    }
    if pr.Addr == net.Addr(nil) {
        return &quot;&quot;, fmt.Errorf(&quot;getClientIP, peer.Addr is nil&quot;)
    }
    addSlice := strings.Split(pr.Addr.String(), &quot;:&quot;)
    return addSlice[0], nil
}

注意：在使用 stream 方式时 context 值可以直接从 stream 中获取，也就是 stream.Context() 。
</code></pre>

<p>这边也有端口相关信息</p>

<p>增加拦截器</p>

<p>在注册之前加入对应函数的参数</p>

<pre><code>package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;net&quot;

        pb &quot;./proto/helloworld&quot;
        &quot;golang.org/x/net/context&quot;
        &quot;google.golang.org/grpc&quot;
        &quot;google.golang.org/grpc/peer&quot;
        &quot;google.golang.org/grpc/reflection&quot;
)

const (
        port = &quot;:50051&quot;
)

// server is used to implement helloworld.GreeterServer.
type server struct{}

// SayHello implements helloworld.GreeterServer
func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
        return &amp;pb.HelloReply{Message: &quot;Hello &quot; + in.Name}, nil
}

func getClietIP(ctx context.Context) (string, error) {
        pr, ok := peer.FromContext(ctx)
        if !ok {
                return &quot;&quot;, fmt.Errorf(&quot;getClinetIP, invoke FromContext() failed&quot;)
        }
        if pr.Addr == net.Addr(nil) {
                return &quot;&quot;, fmt.Errorf(&quot;getClientIP, peer.Addr is nil&quot;)
        }

        return pr.Addr.String(), nil
}

func main() {
        lis, err := net.Listen(&quot;tcp&quot;, port)
        if err != nil {
                log.Fatalf(&quot;failed to listen: %v&quot;, err)
        }

        var opts []grpc.ServerOption

        // Register interceptor
        var interceptor grpc.UnaryServerInterceptor
        interceptor = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo,
            handler grpc.UnaryHandler) (resp interface{}, err error) {
                cli, err := getClietIP(ctx)
                if err != nil {
                        log.Println(&quot;Failed to get client address&quot;)
                }
                log.Println(&quot;Client address is&quot;, cli)
                return handler(ctx, req)
        }
        opts = append(opts, grpc.UnaryInterceptor(interceptor))

        s := grpc.NewServer(opts...)
        pb.RegisterGreeterServer(s, &amp;server{})
        // Register reflection service on gRPC server.
        reflection.Register(s)
        if err := s.Serve(lis); err != nil {
                log.Fatalf(&quot;failed to serve: %v&quot;, err)
        }
}
</code></pre>

<p>负载均衡</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/middleware/network/application-netprotocol/rpc/grpc/">https://kingjcy.github.io/post/middleware/network/application-netprotocol/rpc/grpc/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/rpc/">
                            <i class="fa fa-tags"></i>
                            rpc
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/grpc/">
                            <i class="fa fa-tags"></i>
                            grpc
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/middleware/network/application-netprotocol/webserver/">Webserver</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月06日)</span></li><li id="li-rels"><a href="/post/golang/go-server/">Go Server</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年02月26日)</span></li><li id="li-rels"><a href="/post/golang/go-rpc/">golang使用系列---- Rpc</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年12月08日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/golang/go-server/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/architecture/server/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#创建服务端">创建服务端</a></li>
</ul></li>
<li><a href="#toc_1">}</a></li>
<li><a href="#toc_2">}</a></li>
<li><a href="#toc_3">}</a></li>
<li><a href="#toc_4">}</a>
<ul>
<li><a href="#创建客户端">创建客户端</a></li>
</ul></li>
<li><a href="#使用总结">使用总结</a></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

