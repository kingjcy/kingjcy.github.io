<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Nginx（&rdquo;engine-x&rdquo;）是一款轻量级的Web服务器、反向代理服务器(http,tcp)，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="网络代理系列---- Nginx - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    网络代理系列---- Nginx
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2015年03月15日 
                </div>
                <h1 class="post-title">网络代理系列---- Nginx</h1>
            </header>

            <div class="post-content">
                <p>Nginx（&rdquo;engine-x&rdquo;）是一款轻量级的Web服务器、反向代理服务器(http,tcp)，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用</p>

<h1 id="proxy">proxy</h1>

<p>代理分为反向代理和正向代理</p>

<p>正向代理，就是我们一般说的vpn，需要客户端来配置，一般来说我们会通过浏览器或者操作系统提供的工具或者界面来配置。这个时候，代理对客户端不是透明的，客户端需要知道代理的地址并且手动配置。配置了代理，浏览器在发送请求的时候会对报文做特殊的修改。</p>

<p>反向代理对客户端是透明的，也就是说客户端一般不知道代理的存在，认为自己是直接和服务器通信。我们大部分访问的网站就是反向代理服务器，反向代理服务器会转发到真正的服务器，一般在反向代理这一层实现负载均衡和高可用的功能。而且这里也可以看到，客户端是不会知道真正服务器端的 ip 地址和端口的，这在一定程度上起到了安全保护的作用。</p>

<p>换一种现实中我们的使用的说明方式</p>

<p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理“代理”的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</p>

<p>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。</p>

<h1 id="nginx">nginx</h1>

<p>Nginx 是少数几个可以解决 C10K 问题的服务器之一。不同于传统服务器，它使用可扩展的时间驱动（异步）架构替代线程来处理请求。尤为重要的是，该架构占用负载下的内存小，且可预测。即便不需要同时处理数千的网络请求，你仍然能从Nginx 的高性能和低内存占用中受益。从最小的VPS到大型集群服务器，Nginx 都能适用。</p>

<p>Nginx 还有一个商业版 Nginx Plus，功能更加丰富。</p>

<h2 id="安装">安装</h2>

<p>Nginx 的官方下载地址为：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>

<p>编译安装</p>

<p>1.需要安装c环境相关的库</p>

<pre><code>yum -y install gcc gcc-c++ automake pcre pcre-devel zlib zlib-devel open openssl-devel
</code></pre>

<p>2.解压软件包得到一下内容</p>

<pre><code>src 目录存放了 Nginx软件的所有源代码。
man 目录中存放了Nginx 软件的帮助文档，Nginx 安装完成后，使用 man 命令可以查看。
html 目录中存放了l 两个后缀名为.html的静态网页文件。这两个文件与 Nginx服务器的运行相关。
conf 目录存放的是Nginx 服务器的配置文件，包含 Nginx服务器的基本配置文件和对部分特性的配置文件。
auto 目录中存放了大量脚本文件，和configure脚本程序有关。

configure文件是 Nginx软件的自动脚本程序。运行 configure自动脚本一般会完成两项工作：一是检查环境，根据环境检查结果生成 C 代码；二是生成编译代码需要的Makefile 文件。
</code></pre>

<p>3.生成makefile</p>

<pre><code>[root@localhost nginx-1.6.3]# ./configure --prefix=/app/nginx/nginx-1.6.3

--prefix 指定了Nginx软件的安装路径。
</code></pre>

<p>4.然后编译安装</p>

<pre><code>make
make install
</code></pre>

<p>编译配置的时候有很多参数可以设置，这边简单了解一下</p>

<p>nginx配置编译参数</p>

<pre><code>--prefix= 指向安装目录
--sbin-path 指向（执行）程序文件（nginx）
--conf-path= 指向配置文件（nginx.conf）
--error-log-path= 指向错误日志目录
--pid-path= 指向pid文件（nginx.pid）
--lock-path= 指向lock文件（nginx.lock）（安装文件锁定，防止安装文件被别人利用，或自己误操作。）
--user= 指定程序运行时的非特权用户
--group= 指定程序运行时的非特权用户组
--builddir= 指向编译目录
--with-rtsig_module 启用rtsig模块支持（实时信号）
--with-select_module 启用select模块支持（一种轮询模式,不推荐在高载环境下使用）禁用：--without-select_module
--with-poll_module 启用poll模块支持（功能与select相同，与select特性相同，为一种轮询模式,不推荐在高载环境下使用）
--with-file-aio 启用file aio支持（一种APL文件传输格式）
--with-ipv6 启用ipv6支持

--with-http_ssl_module 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）


--with-http_realip_module 启用ngx_http_realip_module支持（这个模块允许从请求标头更改客户端的IP地址值，默认为关）


--with-http_addition_module 启用ngx_http_addition_module支持（作为一个输出过滤器，支持不完全缓冲，分部分响应请求）
--with-http_xslt_module 启用ngx_http_xslt_module支持（过滤转换XML请求）
--with-http_image_filter_module 启用ngx_http_image_filter_module支持（传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）
--with-http_geoip_module 启用ngx_http_geoip_module支持（该模块创建基于与MaxMind GeoIP二进制文件相配的客户端IP地址的ngx_http_geoip_module变量）
--with-http_sub_module 启用ngx_http_sub_module支持（允许用一些其他文本替换nginx响应中的一些文本）
--with-http_dav_module 启用ngx_http_dav_module支持（增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法）默认情况下为关闭，需编译开启
--with-http_flv_module 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）
--with-http_gzip_static_module 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）
--with-http_random_index_module 启用ngx_http_random_index_module支持（从目录中随机挑选一个目录索引）
--with-http_secure_link_module 启用ngx_http_secure_link_module支持（计算和检查要求所需的安全链接网址）
--with-http_degradation_module  启用ngx_http_degradation_module支持（允许在内存不足的情况下返回204或444码）

--with-http_stub_status_module 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）

--without-http_charset_module 禁用ngx_http_charset_module支持（重新编码web页面，但只能是一个方向--服务器端到客户端，并且只有一个字节的编码可以被重新编码）
--without-http_gzip_module 禁用ngx_http_gzip_module支持（该模块同-with-http_gzip_static_module功能一样）
--without-http_ssi_module 禁用ngx_http_ssi_module支持（该模块提供了一个在输入端处理处理服务器包含文件（SSI）的过滤器，目前支持SSI命令的列表是不完整的）
--without-http_userid_module 禁用ngx_http_userid_module支持（该模块用来处理用来确定客户端后续请求的cookies）
--without-http_access_module 禁用ngx_http_access_module支持（该模块提供了一个简单的基于主机的访问控制。允许/拒绝基于ip地址）
--without-http_auth_basic_module禁用ngx_http_auth_basic_module（该模块是可以使用用户名和密码基于http基本认证方法来保护你的站点或其部分内容）
--without-http_autoindex_module 禁用disable ngx_http_autoindex_module支持（该模块用于自动生成目录列表，只在ngx_http_index_module模块未找到索引文件时发出请求。）
--without-http_geo_module 禁用ngx_http_geo_module支持（创建一些变量，其值依赖于客户端的IP地址）
--without-http_map_module 禁用ngx_http_map_module支持（使用任意的键/值对设置配置变量）
--without-http_split_clients_module 禁用ngx_http_split_clients_module支持（该模块用来基于某些条件划分用户。条件如：ip地址、报头、cookies等等）
--without-http_referer_module 禁用disable ngx_http_referer_module支持（该模块用来过滤请求，拒绝报头中Referer值不正确的请求）
--without-http_rewrite_module 禁用ngx_http_rewrite_module支持（该模块允许使用正则表达式改变URI，并且根据变量来转向以及选择配置。如果在server级别设置该选项，那么他们将在 location之前生效。如果在location还有更进一步的重写规则，location部分的规则依然会被执行。如果这个URI重写是因为location部分的规则造成的，那么 location部分会再次被执行作为新的URI。 这个循环会执行10次，然后Nginx会返回一个500错误。）
--without-http_proxy_module 禁用ngx_http_proxy_module支持（有关代理服务器）
--without-http_fastcgi_module 禁用ngx_http_fastcgi_module支持（该模块允许Nginx 与FastCGI 进程交互，并通过传递参数来控制FastCGI 进程工作。 ）FastCGI一个常驻型的公共网关接口。
--without-http_uwsgi_module 禁用ngx_http_uwsgi_module支持（该模块用来医用uwsgi协议，uWSGI服务器相关）
--without-http_scgi_module 禁用ngx_http_scgi_module支持（该模块用来启用SCGI协议支持，SCGI协议是CGI协议的替代。它是一种应用程序与HTTP服务接口标准。它有些像FastCGI但他的设计 更容易实现。）
--without-http_memcached_module 禁用ngx_http_memcached_module支持（该模块用来提供简单的缓存，以提高系统效率）
-without-http_limit_zone_module 禁用ngx_http_limit_zone_module支持（该模块可以针对条件，进行会话的并发连接数控制）
--without-http_limit_req_module 禁用ngx_http_limit_req_module支持（该模块允许你对于一个地址进行请求数量的限制用一个给定的session或一个特定的事件）
--without-http_empty_gif_module 禁用ngx_http_empty_gif_module支持（该模块在内存中常驻了一个1*1的透明GIF图像，可以被非常快速的调用）
--without-http_browser_module 禁用ngx_http_browser_module支持（该模块用来创建依赖于请求报头的值。如果浏览器为modern ，则$modern_browser等于modern_browser_value指令分配的值；如 果浏览器为old，则$ancient_browser等于 ancient_browser_value指令分配的值；如果浏览器为 MSIE中的任意版本，则 $msie等于1）
--without-http_upstream_ip_hash_module 禁用ngx_http_upstream_ip_hash_module支持（该模块用于简单的负载均衡）
--with-http_perl_module 启用ngx_http_perl_module支持（该模块使nginx可以直接使用perl或通过ssi调用perl）
--with-perl_modules_path= 设定perl模块路径
--with-perl= 设定perl库文件路径
--http-log-path= 设定access log路径
--http-client-body-temp-path= 设定http客户端请求临时文件路径
--http-proxy-temp-path= 设定http代理临时文件路径
--http-fastcgi-temp-path= 设定http fastcgi临时文件路径
--http-uwsgi-temp-path= 设定http uwsgi临时文件路径
--http-scgi-temp-path= 设定http scgi临时文件路径
-without-http 禁用http server功能
--without-http-cache 禁用http cache功能
--with-mail 启用POP3/IMAP4/SMTP代理模块支持
--with-mail_ssl_module 启用ngx_mail_ssl_module支持
--without-mail_pop3_module 禁用pop3协议（POP3即邮局协议的第3个版本,它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。是因特网电子邮件的第一个离线协议标 准,POP3协议允许用户从服务器上把邮件存储到本地主机上,同时根据客户端的操作删除或保存在邮件服务器上的邮件。POP3协议是TCP/IP协议族中的一员，主要用于 支持使用客户端远程管理在服务器上的电子邮件）
--without-mail_imap_module 禁用imap协议（一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP协议运行在TCP/IP协议之上， 使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。）
--without-mail_smtp_module 禁用smtp协议（SMTP即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议族，它帮助每台计算机在发送或中转信件时找到下一个目的地。）
--with-google_perftools_module 启用ngx_google_perftools_module支持（调试用，剖析程序性能瓶颈）
--with-cpp_test_module 启用ngx_cpp_test_module支持

--add-module= 启用外部模块支持


--with-cc= 指向C编译器路径
--with-cpp= 指向C预处理路径
--with-cc-opt= 设置C编译器参数（PCRE库，需要指定–with-cc-opt=”-I /usr/local/include”，如果使用select()函数则需要同时增加文件描述符数量，可以通过–with-cc- opt=”-D FD_SETSIZE=2048”指定。）
--with-ld-opt= 设置连接文件参数。（PCRE库，需要指定–with-ld-opt=”-L /usr/local/lib”。）
--with-cpu-opt= 指定编译的CPU，可用的值为: pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64
--without-pcre 禁用pcre库
--with-pcre 启用pcre库
--with-pcre= 指向pcre库文件目录
--with-pcre-opt= 在编译时为pcre库设置附加参数
--with-md5= 指向md5库文件目录（消息摘要算法第五版，用以提供消息的完整性保护）
--with-md5-opt= 在编译时为md5库设置附加参数
--with-md5-asm 使用md5汇编源
--with-sha1= 指向sha1库目录（数字签名算法，主要用于数字签名）
--with-sha1-opt= 在编译时为sha1库设置附加参数
--with-sha1-asm 使用sha1汇编源
--with-zlib= 指向zlib库目录
--with-zlib-opt= 在编译时为zlib设置附加参数
--with-zlib-asm= 为指定的CPU使用zlib汇编源进行优化，CPU类型为pentium, pentiumpro
--with-libatomic 为原子内存的更新操作的实现提供一个架构
--with-libatomic= 指向libatomic_ops安装目录
--with-openssl= 指向openssl安装目录
--with-openssl-opt 在编译时为openssl设置附加参数
--with-debug 启用debug日志
</code></pre>

<p>5.到上面指定的安装路径下</p>

<pre><code>conf 目录存放了所有配置文件。其中，nginx.conf文件是 Nginx服务器的主配置文件，其它配置文件是用来配置Nginx 的相关功能的。在此目录下，所有的配置文件都提供了以.default结尾的默认配置文件，方便我们将配置过的.conf文件恢复到初始状态。
html 目录存放了Nginx服务器在运行过程中调用的一些 html 文件。
logs 目录用来存放Nginx服务器日志的。
sbin 目录，目前只有nginx一个文件，这就是Nginx服务器的主程序了。
</code></pre>

<p>到此就安装好了，当然现在有很多的编译好的包进行下载，也有对应的yum源进行使用，直接就可以安装使用了，不用这么麻烦，除非需要对模块重新编译，所以主要讲一下nginx的使用</p>

<h2 id="启动命令">启动命令</h2>

<p>1.启动</p>

<pre><code>./sbin/nginx -c config
</code></pre>

<p>2.停止</p>

<pre><code>./sbin/nginx -s stop

./sbin/nginx -s quit
</code></pre>

<p>3.重载</p>

<pre><code>nginx -s reload
</code></pre>

<h2 id="配置文件详解">配置文件详解</h2>

<pre><code>##全局模块
#user  nobody;         #用户名和组 user user group 默认都是nobody
worker_processes  1;    #工作进程数，通常和cpu数目相等，或者两倍于cpu，那nginx用的是fork，而不是线程，默认是1

#error_log  logs/error.log;         #错误日志路径，缺省值: ${prefix}/logs/error.log，级别有debug|info|notice|warn|error|crit|alert|emerg，常用前几个
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;         #进程id指定nginx进程运行文件存放地址，应该也用上面的${prefix}

#worker_rlimit_nofile 204800;

#指定进程可以打开的最大描述符：数目。

#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。

#现在在Linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。

#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。


##事件模块
events {
    worker_connections  1024;       #单个进程的最大连接数,默认512,max_client=worker_processes*worker_connections,但是在反向代理的情况下要除4，这是一个经验值，在浏览器连接的情况下，最大连接数必须小于最大文件数cat /proc/sys/fs/file-max

    #accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on
    #multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off
    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport，linux下建议使用epoll

    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。
    #分页大小可以用命令getconf PAGESIZE 取得。
    #[root@web001 ~]# getconf PAGESIZE
    #4096
    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。
    #client_header_buffer_size 4k;

    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。
    #open_file_cache max=65535 inactive=60s;


    #这个是指多长时间检查一次缓存的有效信息。
    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.
    #open_file_cache_valid 80s;

    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。
    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.
    #open_file_cache_min_uses 1;

    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.
    #open_file_cache_errors on;


}

##http模块,利用它的反向代理功能提供负载均衡支持，这个访问的地址是：http模块名://server_name的地址:listen的端口+local的路径
http {
    include       mime.types;      #包含这个文件，这个文件主要是文件扩展名和文件类型映射表
    default_type  application/octet-stream; #默认类型，也就是二进制类型，可以去mime.types中看

    #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '      #自定义日志的格式
    #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
    #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #日志格式设置。
    #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；

    #$remote_user：用来记录客户端用户名称；

    #$time_local： 用来记录访问时间与时区；

    #$request： 用来记录请求的url与http协议；

    #$status： 用来记录请求状态；成功是200，

    #$body_bytes_sent ：记录发送给客户端文件主体内容大小；

    #$http_referer：用来记录从那个页面链接访问过来的；

    #$http_user_agent：记录客户浏览器的相关信息；


    #access_log  logs/access.log  main;     #日志名和路径，可以用上面的配置指定格式

    sendfile        on;     #允许sendfile方式传输文件，默认为off，指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.
    #tcp_nopush     on;     #是否允许使用socket的TCP_NOPUSH或TCP_CORK选项,在 nginx 中，tcp_nopush 配置和 tcp_nodelay &quot;互斥&quot;。它可以配置一次发送数据的包大小。也就是说，它不是按时间累计  0.2 秒后发送包，而是当包累计到一定大小后就发送。在 nginx 中，tcp_nopush 必须和 sendfile 搭配使用。

    #keepalive_timeout  0;  #连接超时时间，默认为75s
    keepalive_timeout  65;
    #tcp_nodelay        on;

    #gzip  on;      #压缩文件

    #设定负载均衡的服务器列表
    #upstream load_balance_server {
    #    server 192.168.1.11:80   weight=5;
    #    server 192.168.1.12:80   weight=1;
    #    server 192.168.1.13:80   weight=6;

    #设定负载均衡的服务器列表,默认一台台服务器轮询
    #ip_hash; nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session
    #1.down  表示单前的 server 暂时不参与负载
    #2.weight  默认为 1.weight 越大，负载的权重就越大。
    #3.backup： 其它所有的非 backup 机器 down 或者忙的时候，请求 backup机器。所以这台机器压力会最轻。
    #upstream allserver {
    #
    #   #ip_hash;
    #
    #   server 127.0.0.1:8083 down;
    #
    #   server 127.0.0.1:8084 weight=3;     #weigth参数表示权值，权值越高被分配到的几率越大
    #
    #   server 127.0.0.1:8001;
    #
    #   server 127.0.0.1:8002 backup;       #热备
    #}

    #error_page 404 https://www.baidu.com; #错误页


    ## server模块，也就是服务器，可以做转发，到上面的的负载均衡真实服务器
    server {
        listen       80;            #监听端口
        server_name  localhost;         #监听地址

        #charset koi8-r;            #编码格式

        #access_log  logs/host.access.log  main; #日志

    ##local模块,http://localhost:80/ 访问的就是这个地址，然后下面可以转向upstream
        location / {
            root   html;            #根目录
            index  index.html index.htm;    #默认index

        #proxy_pass  http://allserver;  #请求转向allserver定义的服务器列表，就是上面的负载均衡
        #以下是一些反向代理的配置(可选择性配置)
            #proxy_redirect off;
            #proxy_set_header Host $host;
            #proxy_set_header X-Real-IP $remote_addr;
            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
            #proxy_set_header X-Forwarded-For $remote_addr;
            #proxy_connect_timeout 90;          #nginx跟后端服务器连接超时时间(代理连接超时)
            #proxy_send_timeout 90;             #后端服务器数据回传时间(代理发送超时)
            #proxy_read_timeout 90;             #连接成功后，后端服务器响应时间(代理接收超时)
            #proxy_buffer_size 4k;              #设置代理服务器（nginx）保存用户头信息的缓冲区大小
            #proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
            #proxy_busy_buffers_size 64k;       #高负荷下缓冲大小（proxy_buffers*2）
            #proxy_temp_file_write_size 64k;    #设定缓存文件夹大小，大于这个值，将从upstream服务器传


            #deny 127.0.0.1;  #拒绝的ip
            #allow 172.18.5.54; #允许的ip
        }


    #设定查看Nginx状态的地址   http://localhost:80//NginxStatus
        #location /NginxStatus {
        #    stub_status on;
        #    access_log on;
        #    #auth_basic &quot;NginxStatus&quot;;
        #    #auth_basic_user_file confpasswd;
        #    #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。
        #}


    location /stub_status {
                          stub_status on;
                          access_log   off;
                          allow 127.0.0.1;
                          deny all;
                          }

        #error_page  404              /404.html; #错误页面

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.h是服务器
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
</code></pre>

<h2 id="常规使用">常规使用</h2>

<p>1.没有权限问题</p>

<p>You don&rsquo;t have permission to access /server-status/ on this server.</p>

<pre><code>selinux没有关
/var/www文件夹没有权限
</code></pre>

<p>重新加载：</p>

<pre><code>./nginx -s reload
</code></pre>

<p>2.日志切割：</p>

<p>方式一：</p>

<p>nginx cronolog日志分割配置文档，根据下面方法，每分钟分割一次NGINX访问日志。</p>

<p>1.nginx日志配置</p>

<pre><code>access_log access_log /data/access_log_pipe main;
</code></pre>

<p>2.先创建一个命名管道</p>

<pre><code>mkfifo /www/log/access_log_pipe
</code></pre>

<p>3.配置cronolog：</p>

<pre><code>nohup cat /data/access_log_pipe | /usr/local/sbin/cronolog /data/log/domain.access_%Y%m%d%H%M.log &amp;
</code></pre>

<p>4.启动Nginx</p>

<pre><code>/usr/local/nginx/sbin/nginx
</code></pre>

<p>注意：</p>

<p>cronolog必须在nginx启动前启动，没有安装cronolog的话，需要先安装</p>

<pre><code>wget http://cronolog.org/download/cronolog-1.6.2.tar.gz
tar zxvf cronolog-1.6.2.tar.gz
cd cronolog-1.6.2
./configure
 make
make install
</code></pre>

<p>方式二：</p>

<p>定时任务中每小时添加定时任务，执行一下脚本，可以实现小时日志分割</p>

<pre><code>log_dir=&quot;/var/log/nginx&quot;
date_dir=`date +%Y/%m/%d/%H`
/bin/mkdir -p ${log_dir}/${date_dir} &gt; /dev/null 2&gt;&amp;1
/bin/mv ${log_dir}/access.log   ${log_dir}/${date_dir}/access.log
kill -USR1 `cat /opt/nginx/logs/nginx.pid`
</code></pre>

<p>方式三：</p>

<p>使用logrotate做nginx日志轮询</p>

<p>logrotate看名字就知道是专门做日志轮询的，只把任务配置放在/etc/logrotate.d/下，任务就会自动完成，而且无需安装，系统自带，比较推荐使用.</p>

<pre><code>vi /etc/logrotate.d/nginx

/usr/local/nginx/logs/www.willko.cn.log /usr/local/nginx/logs/nginx_error.log {
notifempty
daily
sharedscripts
postrotate
/bin/kill -USR1 `/bin/cat /usr/local/nginx/nginx.pid`
endscript
}

多个日志以空格分开，
notifempty 如果日志为空则不做轮询
daily 每天执行一次
postrotate 日志轮询后执行的脚本
</code></pre>

<p>这样，每天都会自动轮询，生成nginx.log.1-n</p>

<ol>
<li>定时清理日志</li>
</ol>

<p>直接使用定时任务crontab</p>

<pre><code>每小时清理一次
0 * * * *  truncate -s 0 /data/rsync_log/access_http.log
</code></pre>

<p>4.nginx代理使用参数</p>

<p>ngx_http_core_module 模块在处理请求时，会有大量的变量，这些变量可以通过访问日志来记录下来，也可以用于其它nginx 模块。在我们对请求做策略如改写等等都会使用到一些变量，顺便对 ngx_http_core_module 模块提供的变量总结了下，如下所示：</p>

<pre><code>$arg_PARAMETER
</code></pre>

<p>HTTP请求中某个参数的值，如/index.php?site=www.ttlsa.com，可以用$arg_site 取得 www.ttlsa.com 这个值.</p>

<pre><code>$args HTTP
</code></pre>

<p>请求中的完整参数。例如，在请求/index.php?width=400&amp;height=200 中， $args 表示字符串 width=400&amp;height=200.</p>

<pre><code>$binary_remote_addr
</code></pre>

<p>二进制格式的客户端地址。例如： \x0A\xE0B\x0E</p>

<pre><code>$body_bytes_sent
</code></pre>

<p>表示在向客户端发送的 http 响应中，包体部分的字节数</p>

<pre><code>$content_length
</code></pre>

<p>表示客户端请求头部中的 Content-Length 字段</p>

<pre><code>$content_type
</code></pre>

<p>表示客户端请求头部中的 Content-Type 字段</p>

<pre><code>$cookie_COOKIE
</code></pre>

<p>表示在客户端请求头部中的 cookie 字段</p>

<pre><code>$document_root
</code></pre>

<p>表示当前请求所使用的 root 配置项的值</p>

<pre><code>$uri
</code></pre>

<p>表示当前请求的 URI，不带任何参数</p>

<pre><code>$document_uri
</code></pre>

<p>与$uri 含义相同</p>

<pre><code>$request_uri
</code></pre>

<p>表示客户端发来的原始请求 URI，带完整的参数。 $uri 和$document_uri 未必是用户的原始请求，在内部重定向后可能是重定向后的 URI，而$request_uri 永远不会改变，始终是客户端的原始 URI.</p>

<pre><code>$host
</code></pre>

<p>表示客户端请求头部中的 Host 字段。如果 Host 字段不存在，则以实际处理的 server（虚拟主机）名称代替。如果 Host 字段中带有端口，如 IP:PORT，那么$host 是去掉端口的，它的值为 IP。 $host是全小写的。这些特性与 http_HEADER 中的 http_host 不同， http_host 只取出 Host 头部对应的值。</p>

<pre><code>$hostname
</code></pre>

<p>表示 Nginx 所在机器的名称，与 gethostbyname 调用返回的值相同</p>

<pre><code>$http_HEADER
</code></pre>

<p>表示当前 HTTP 请求中相应头部的值。 HEADER 名称全小写。例如，示请求中 Host 头部对应的值 用 $http_host 表</p>

<pre><code>$sent_http_HEADER
</code></pre>

<p>表示返回客户端的 HTTP 响应中相应头部的值。 HEADER 名称全小写。例如，用 $sent_</p>

<pre><code>http_content_type
</code></pre>

<p>表示响应中 Content-Type 头部对应的值</p>

<pre><code>$is_args
</code></pre>

<p>表示请求中的 URI 是否带参数，如果带参数， $is_args 值为 ?，如果不带参数，则是空字符串</p>

<pre><code>$limit_rate
</code></pre>

<p>表示当前连接的限速是多少， 0 表示无限速</p>

<pre><code>$nginx_version
</code></pre>

<p>表示当前 Nginx 的版本号</p>

<pre><code>$query_string
</code></pre>

<p>请求 URI 中的参数，与 $args 相同，然而 $query_string 是只读的不会改变</p>

<pre><code>$remote_addr
</code></pre>

<p>表示客户端的地址</p>

<pre><code>$remote_port
</code></pre>

<p>表示客户端连接使用的端口</p>

<pre><code>$remote_user
</code></pre>

<p>表示使用 Auth Basic Module 时定义的用户名</p>

<pre><code>$request_filename
</code></pre>

<p>表示用户请求中的 URI 经过 root 或 alias 转换后的文件路径</p>

<pre><code>$request_body
</code></pre>

<p>表示 HTTP 请求中的包体，该参数只在 proxy_pass 或 fastcgi_pass 中有意义</p>

<pre><code>$request_body_file
</code></pre>

<p>表示 HTTP 请求中的包体存储的临时文件名</p>

<pre><code>$request_completion
</code></pre>

<p>当请求已经全部完成时，其值为 “ok”。若没有完成，就要返回客户端，则其值为空字符串；或者在断点续传等情况下使用 HTTP range 访问的并不是文件的最后一块，那么其值也是空字符串。</p>

<pre><code>$request_method
</code></pre>

<p>表示 HTTP 请求的方法名，如 GET、 PUT、 POST 等</p>

<pre><code>$scheme
</code></pre>

<p>表示 HTTP scheme，如在请求 <a href="https://nginx.com/中表示">https://nginx.com/中表示</a> https</p>

<pre><code>$server_addr
</code></pre>

<p>表示服务器地址</p>

<pre><code>$server_name
</code></pre>

<p>表示服务器名称</p>

<pre><code>$server_port
</code></pre>

<p>表示服务器端口</p>

<pre><code>$server_protocol
</code></pre>

<p>表示服务器向客户端发送响应的协议，如 HTTP/1.1 或 HTTP/1.0</p>

<p>5.返回报文中增加报文头</p>

<p>nginx配置文件通过使用add_header指令来设置response header。</p>

<p>用以改变Content-Type时比较特殊，可以在它设置了类型的同时还会指定charset，不过Content-Type和charset之间有分号，所以我们需要这样来添加。</p>

<pre><code>add_header  Content-Type 'text/html; charset=utf-8';
</code></pre>

<p>这样就可以给responent header的Content-Type添加指定的属性了。</p>

<p>6.请求报文url的长度</p>

<p>由于现在项目中主要用到nginx，所以强调下它的设置参数：large_client_header_buffers</p>

<p>该参数对nginx服务器接受客户端请求的头信息时所分配的最大缓冲区的大小做了限制，也就是nginx服务器一次接受一个客户端请求可就收的最大头信息大小。这个头不仅包含 request-line，还包括通用信息头、请求头域、响应头域的长度总和。这也相当程度的限制了url的长度。</p>

<p>nginx服务器默认的限制是4K或者8K，这是根据服务器的硬件配置有关的，一般为内存一页的大小，目前大部分为4K，即4096字节。</p>

<pre><code>client_header_buffer_size
</code></pre>

<p>定义了正常情况下Nginx接收用户请求中HTTP header部分（包括HTTP行和HTTP头部）时分配的内存buffer大小。有时，请求中的HTTP header部分可能会超过这个大小，这时large_client_header_buffers定义的buffer将会生效。</p>

<p>正常这两个参数需要配置再http中而不是server的head处理，才能生效。</p>

<p>7.反向代理【proxy_pass】</p>

<p>所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p>

<p>反向代理，上面已经说了，过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。</p>

<p>常用的有http和tcp反向代理，下面我们举例说明</p>

<p>http</p>

<pre><code>http {
    // 当通过 face.danoolive.com:80 端口访问这个服务器时
    // 该请求会被转发到 127.0.0.1:9992
    server {
        listen 80;
        server_name face.danoolive.com;
        // 通过访问的路径来处理转发 ...
        location / {
            // 也不一定是内网 127.0.0.1 ，也可以是另外一个服务器的某个端口等 ...
            proxy_pass http://127.0.0.1:9992;
        }
    }

    // 当通过 res.danoolive.com:80 端口访问这个服务器时
    // 该请求会被转发到 127.0.0.1:9991
    server {
        listen 80;
        server_name res.danoolive.com;
        location / {
            proxy_pass http://127.0.0.1:9991;
        }
    }

}
</code></pre>

<p>tcp</p>

<pre><code>stream {
    #将12345端口转发到192.168.1.23的3306端口
    server {
        listen 12345;
        proxy_connect_timeout 5s;
        proxy_timeout 20s;
        proxy_pass 192.168.1.23:3306;
    }
    #将udp 53端口转发到192.168.1.23 53端口
    server {
        listen 53 udp reuseport;
        proxy_timeout 20s;
        proxy_pass 192.168.1.23:53;
    }
    #ipv4转发到ipv6
    server {
        listen 9135;
        proxy_connect_timeout 10s;
        proxy_timeout 30s;
        proxy_pass [2607:fcd0:107:3cc::1]:9135;
    }
}
</code></pre>

<p>可见开头是不同的模块。</p>

<p>场景</p>

<p>同时监听相同端口，可以通过匹配server_name 来决定最终匹配跳转哪个server</p>

<pre><code>    #server1
    server {
        listen       80;
        #server_name  localhost;

        location  / {
            rewrite / http://www.baidu.com;
        }                
    }    
    #server2
    server {
        listen       80;
        #uc-center.m.szy.net 在本地的hosts文件 解析到 127.0.0.1
        server_name  uc-center.m.szy.net;

        location  ~* ^\/(.*)$ {
           rewrite ^\/(.*)$ http://www.sina.com;        
        }                
    }
</code></pre>

<p>访问   <a href="http://uc-center.m.szy.net">http://uc-center.m.szy.net</a>  不会因为server1的配置，而导致跳转到“百度首页”。nginx会优先匹配 配置有server_name的server2,最终跳转到&rdquo;新浪首页&rdquo;。</p>

<p>相同url，根据请求host进行反向代理</p>

<pre><code>http {
    include       mime.types;
    default_type  application/octet-stream;
    fastcgi_connect_timeout 300;
    fastcgi_send_timeout 300;
    fastcgi_read_timeout 300;

    sendfile        on;
    keepalive_timeout  65;
    gzip  on;


     server {
        listen 80;
        server_name server1.host.com;
        location / {
            proxy_pass http://server1.com/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            client_max_body_size 10m;
        }
    }
     server {
        listen 80;
        server_name server2.host.com;
        location / {
            proxy_pass http://server2.com/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            client_max_body_size 10m;
        }
    }
}
</code></pre>

<p>8.负载均衡【upstream】</p>

<p>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p>

<p>第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</p>

<p>第二，将proxy_pass替换成upstream指定的值即可。</p>

<p>负载均衡可能带来的问题？</p>

<p>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</p>

<p>http和tcp常用的负载均衡如下：</p>

<p>http</p>

<pre><code>http {
    upstream myapp1 {
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://myapp1;
        }
    }
}
</code></pre>

<p>tcp</p>

<pre><code>stream{
    upstream tcpssh{
        hash $remote_addr consistent;
        server  8.8.8.8:389 max_fails=3 fail_timeout=10s;
    }
    server{
        listen 3389;
        proxy_connect_timeout 20s;
        proxy_timeout 5m;
        proxy_pass tcpssh;
    }
}
</code></pre>

<p>9.缓存</p>

<p>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。具体配置，大家可以参考Nginx官方文档，这里就不在展开了。</p>

<h1 id="实现原理">实现原理</h1>

<p>1.Master进程的作用是？</p>

<pre><code>读取并验证配置文件nginx.conf；管理worker进程；
</code></pre>

<p>2.Worker进程的作用是？</p>

<pre><code>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。
</code></pre>

<p>3.Nginx如何做到热部署？</p>

<p>所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载/nginx -t检查配置/nginx -s stop）</p>

<p>通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p>

<p>方案一：</p>

<p>修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点valatile的味道）</p>

<p>方案二：</p>

<p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p>

<p>Nginx采用的就是方案二来达到热部署的！</p>

<p>4.Nginx如何做到高并发下的高效处理？</p>

<p>上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p>

<p>作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞&hellip;</p>

<p>要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</p>

<p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</p>

<p>5.Nginx挂了怎么办？</p>

<p>Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p>

<p>答案是：Keepalived+Nginx实现高可用。</p>

<p>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</p>

<p>Keepalived+Nginx实现高可用的思路：</p>

<p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p>

<p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</p>

<p>6.Nginx作为web server来处理静态资源。</p>

<p>第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</p>

<p>第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。</p>

<p>第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</p>

<p>第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。</p>

<p>7.性能</p>

<p>2c2g的机器nginx在直接return 200的情况1.5W/s的请求消耗1c。</p>

<pre><code>server {
    listen 8082;
    server_name _;

    location = /api/register {
        # 设定默认类型
        default_type application/json;
        # 返回状态码与JSON
        return 200 '{&quot;code&quot;: 0,&quot;messge&quot;:&quot;注册成功&quot;,&quot;data&quot;:[]}';
    }
}
</code></pre>

<p>红包实例配置</p>

<pre><code>    location /springRed/getRewards.do {
       return 200 '{&quot;success&quot;:true,&quot;time&quot;:1,&quot;LatestVersion&quot;:&quot;xx&quot;,&quot;message&quot;:&quot;test&quot;}';
    }
</code></pre>

<p>8.使用nginx sticky实现基于cookie的负载均衡</p>

<p>9.check用法</p>

<p>interval间隔5s，连续失败5次，连续成功2次，超时时间1s，使用http协议，发送一个请求头，如果是2xx或者3xx状态（比如200,302等）表示服务正常运行。</p>

<pre><code>upstream portals {
    server 172.16.68.134:8082;
    server 172.16.68.135:8082;
    server 172.16.68.136:8082;
    server 172.16.68.137:8082;
    check interval=5000 rise=2 fall=5 timeout=1000 type=http;
    check_http_send &quot;HEAD / HTTP/1.0\r\n\r\n&quot;;
    check_http_expect_alive http_2xx http_3xx;
}

server {
    listen       80;
    server_name  localhost;

    location /ng_status {
        stub_status on;
        access_log off;
    }

    location /status {
        check_status;
        access_log off;
    }
}
</code></pre>

<p>10.基于 Upsync 模块实现 Nginx 动态配置</p>

<p>Upsync是新浪微博开源的基于Nginx实现动态配置的三方模块。Nginx-Upsync-Module的功能是拉取Consul的后端server的列表，并动态更新Nginx的路由信息。此模块不依赖于任何第三方模块。Consul作为Nginx的DB，利用Consul的KV服务，每个Nginx Work进程独立的去拉取各个upstream的配置，并更新各自的路由。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/middleware/network/proxy/nginx/">https://kingjcy.github.io/post/middleware/network/proxy/nginx/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/nginx/">
                            <i class="fa fa-tags"></i>
                            nginx
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/middleware/">
                            <i class="fa fa-tags"></i>
                            middleware
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/proxy/">
                            <i class="fa fa-tags"></i>
                            proxy
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/middleware/mq/emq/">Activemq</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2020年03月19日)</span></li><li id="li-rels"><a href="/post/golang/go-proxy/">golang系列---- Go Proxy</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年10月07日)</span></li><li id="li-rels"><a href="/post/monitor/server/nginx/">Nginx</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年05月15日)</span></li><li id="li-rels"><a href="/post/middleware/mq/activemq/">Activemq</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年03月19日)</span></li><li id="li-rels"><a href="/post/middleware/mq/kafka/">消息队列系列---- Kafka</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2017年07月19日)</span></li><li id="li-rels"><a href="/post/middleware/mq/nsq-principle/">Nsq Principle</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2017年06月20日)</span></li><li id="li-rels"><a href="/post/middleware/mq/nsq/">Nsq</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2017年06月19日)</span></li><li id="li-rels"><a href="/post/linux/server/iptables/">Iptables</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年11月29日)</span></li><li id="li-rels"><a href="/post/cloud/paas/kubernetes/k8s-proxy/">K8s组件系列（五）---- K8s proxy 详解</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年11月24日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/linux/c&#43;&#43;/signal/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/linux/c&#43;&#43;/linuxc/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#proxy">proxy</a></li>
<li><a href="#nginx">nginx</a>
<ul>
<li><a href="#安装">安装</a></li>
<li><a href="#启动命令">启动命令</a></li>
<li><a href="#配置文件详解">配置文件详解</a></li>
<li><a href="#常规使用">常规使用</a></li>
</ul></li>
<li><a href="#实现原理">实现原理</a></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

