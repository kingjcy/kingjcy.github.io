<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="多进程 -&gt; 多线程 -&gt; 线程池-&gt; select/poll -&gt; epoll(I/O多路复用)
ipv4套接字结构 struct sockaddr_in{ uint8_t sin_len; &mdash;&mdash;&mdash;&mdash;结构体长度 sa_family_t sin_family; &mdash;&mdash;&mdash;&mdash;地址家族 AF_INET&mdash;IPV4 AF_INET6&ndash;IPV6 in_port_t sin_port; &mdash;&mdash;&mdash;&mdash;端口 struct in_addr sin_addr; &mdash;&mdash;&mdash;&ndash;ip地址，这个结构体只有这一个成员，无符号的32位 char sin_zero[8]; &mdash;&mdash;&mdash;&ndash;暂不使用 };
&mdash;》 通用套接字结构 struct sockaddR{ uint8_t sin_len; &mdash;&mdash;&mdash;&mdash;结构体长度 sa_family_t sin_family; &mdash;&mdash;&mdash;&mdash;地址家族 AF_INET&mdash;IPV4 char * sa_date[14] &mdash;&mdash;&mdash;14个字节和ipv4里的后三个字节一样 };
字节序： 最高有效位存储于最低内存地址处&mdash;&ndash;》大 网络字节序是大端字节序。
字节序转换函数： uint32_t htonl(uint32_t hostlong) uint16_t htons(uint16_t hostlong) uint32_t ntohl(uint32_t hostlong) uint16_t ntohs(uint16_t hostlong) &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-n==net h=host l==long s==short
地址转换函数： in_addr_t inet_addr（const char *cp） &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-16位十进制地址转化为32位二进制地址 int inet_aton(const char *cp,struct in_addr inp) &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-16位十进制地址转化为32位二进制地址 char inet_ntoa(struct in_addr in) &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-32位二进制地址转化为16位十进制地址">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="计算机网络系列---- 网络通信 - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    计算机网络系列---- 网络通信
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2015年04月28日 
                </div>
                <h1 class="post-title">计算机网络系列---- 网络通信</h1>
            </header>

            <div class="post-content">
                

<p>多进程 -&gt; 多线程 -&gt; 线程池-&gt; select/poll -&gt; epoll(I/O多路复用)</p>

<p>ipv4套接字结构
struct  sockaddr_in{
uint8_t sin_len;                    &mdash;&mdash;&mdash;&mdash;结构体长度
sa_family_t sin_family;             &mdash;&mdash;&mdash;&mdash;地址家族    AF_INET&mdash;IPV4   AF_INET6&ndash;IPV6
in_port_t   sin_port;           &mdash;&mdash;&mdash;&mdash;端口
struct in_addr sin_addr;        &mdash;&mdash;&mdash;&ndash;ip地址，这个结构体只有这一个成员，无符号的32位
char sin_zero[8];                   &mdash;&mdash;&mdash;&ndash;暂不使用
};</p>

<p>&mdash;》
通用套接字结构
struct  sockaddR{
uint8_t sin_len;                    &mdash;&mdash;&mdash;&mdash;结构体长度
sa_family_t sin_family;             &mdash;&mdash;&mdash;&mdash;地址家族    AF_INET&mdash;IPV4
char * sa_date[14]                  &mdash;&mdash;&mdash;14个字节和ipv4里的后三个字节一样
};</p>

<p>字节序：
最高有效位存储于最低内存地址处&mdash;&ndash;》大
网络字节序是大端字节序。</p>

<p>字节序转换函数：
uint32_t htonl(uint32_t hostlong)
uint16_t htons(uint16_t hostlong)
uint32_t ntohl(uint32_t hostlong)
uint16_t ntohs(uint16_t hostlong)       &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-n==net   h=host  l==long  s==short</p>

<p>地址转换函数：
in_addr_t inet_addr（const char *cp）                          &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-16位十进制地址转化为32位二进制地址
int       inet_aton(const char *cp,struct in_addr <em>inp)        &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-16位十进制地址转化为32位二进制地址
char</em>     inet_ntoa(struct in_addr in)                     &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-32位二进制地址转化为16位十进制地址</p>

<p>套接字类型：
SOCK_STREAM     流式    TCP
SOCK_DGRAM      数据报  UDP
SOCK_RAW        原始</p>

<p>c/s模型：
服务端：
创建一个套接字
int socket(int domain,     &mdash;&mdash;-协议族
int type,          &mdash;&mdash;socket类型
int protocol)          &mdash;&mdash;协议类型                          返回值是一个非负整数，失败返回-1</p>

<p>绑定一个本地地址到套接字
int bind(int sockfd,      &mdash;&mdash;&mdash;-创建套接字的描述符
const struct sockaddr *addr, &mdash;&mdash;&ndash;绑定的地址，强制指定struct sockaddr *类型
socklen_t addrlen);    地址的长度</p>

<p>使套接字进入由close进入监听状态
int listen（int sockfd,   &mdash;&mdash;&mdash;&mdash;-创建套接字的描述符
int backlog);              &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-内核为套接字排队的最大连接数，建议用SOMAXCONN这个宏
监听两个队列，一个是未完成三次握手的队列，一个是已完成三次握手的队列</p>

<p>取已完成队列的第一个连接，无则柱塞    &mdash;-已完成套接字，主动套接字
int accept(int sockfd,&mdash;&mdash;&mdash;&mdash;-创建套接字的描述符
struct sockaddr *addr,&mdash;&mdash;&mdash;&ndash;对方套接字地址
socklen_t *addrlen);  &mdash;&mdash;&mdash;&mdash;对方套接字地址的长度</p>

<p>客户端：
建立一个套接字</p>

<p>连接至addr    &mdash;-已连接套接字，主动套接字
int connect(int sockfd,     &mdash;&mdash;&mdash;&mdash;-创建套接字的描述符
const struct sockaddr *addr,   &mdash;&mdash;&mdash;要连接套接字的地址
socklen_t addrlen)            &mdash;&mdash;地址长度</p>

<p>read（int sockfd，char *buf，sizeof（buf））
write（int sockfd，char *buf，sizeof（buf））</p>

<p>完成c/s模型</p>

<p>REUSEADDR选项&mdash;&ndash;使用setsockopt来设置，使得服务器端不必等待TIME_WAIT状态
int setsockopt(int sockfd,&mdash;&mdash;&mdash;&mdash;&mdash;-套接字描述符
int level,&mdash;&mdash;&mdash;&mdash;-level  is  specified  as SOL_SOCKET
int optname,&mdash;&mdash;&mdash;&ndash;
const void *optval,
socklen_t optlen)     &mdash;-长度</p>

<p>套接字选项
#include <sys/types.h>
#include <sys/socket.h>
int getsockopt(int s,
    int level,
    int optname,
    void *optval,
    socklen_t *optlen);
函数参数描述如下：
1 要进行选项检验的套接口s
2 选项检验所在的协议层level&mdash;SOL_SOCKET来访问套接口层选项，SOL_TCP来访问TCP层选项
3 要检验的选项optname
4 指向接收选项值的缓冲区的指针optval
5 指针optlen同时指向输入缓冲区的长度和返回的选项长度值</p>

<p>int setsockopt(int sockfd,&mdash;&mdash;套接口描述字
int level,&mdash;&ndash; 选项协议层级别：SOL_SOCKET基本套接口、IPPROTO_IP: IPv4套接口、IPPROTO_IPV6: IPv6套接口、IPPROTO_TCP: TCP套接口
int optname,&mdash;&mdash;选项名
const void *optval,&mdash;-选项值
socklen_t optlen);&mdash;-选项长度，optval的长度</p>

<p>SOL_SOCKET基本套接口下的选项：
1、SO_KEEPALIVE 保持连接
2、SO_RCVBUF 接收缓冲区大小
3、SO_SNDBUF 发送缓冲区大小
4、SO_REUSERADDR 允许重用本地地址和端口
5、SO_EXCLUSIVEADDRUSE
独占模式使用端口,就是不充许和其它程序使用SO_REUSEADDR共享的使用某一端口。
6、SO_TYPE 获得套接字类型</p>

<p>举例：
1、端口复用
BOOL bReuseaddr=TRUE;
setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&amp;bReuseaddr,sizeof(BOOL));
2、设置收发时限
int nNetTimeout=1000;//1秒
//发送时限
setsockopt(socket，SOL_S0CKET,SO_SNDTIMEO，(char *)&amp;nNetTimeout,sizeof(int));
//接收时限
setsockopt(socket，SOL_S0CKET,SO_RCVTIMEO，(char *)&amp;nNetTimeout,sizeof(int));
3、设置缓存区大小
// 接收缓冲区
int nRecvBuf=32<em>1024;//设置为32K
setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char</em>)&amp;nRecvBuf,sizeof(int));
//发送缓冲区
int nSendBuf=32<em>1024;//设置为32K
setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char</em>)&amp;nSendBuf,sizeof(int));
4、</p>

<p>//本地套接字和对方套接字队列中已完成三次握手，则娶出来返回,这边犯了一个致命的错误，就是=前后木有加括号，那样conn则不是一个int，则是赋值为一个ture or flase，切记切记
 56     int conn;
 57     if((conn = accept(listenfd,(struct sockaddr*)&amp;pcaddr,&amp;strlen)) &lt; 0)</p>

<p>netstat -an | grep TIME_WAIT&mdash;&mdash;-查询网络的状态</p>

<p>kill -l   查询可以传递信号类型</p>

<h1 id="转义字符">转义字符：</h1>

<p>\a 响铃(BEL) 007
  \b 退格(BS) 008
  \f 换页(FF) 012
  \n 换行(LF) 010
  \r 回车(CR) 013
  \t 水平制表(HT) 009
  \v 垂直制表(VT) 011
  \ 反斜杠 092
  \? 问号字符 063
  \&rsquo; 单引号字符 039
  \&rdquo; 双引号字符 034
  \0 空字符(NULL) 000
  \ddd 任意字符 三位八进制
  \xhh 任意字符 二位十六进制
\a:蜂鸣，响铃
\b:回退：向后退一格
\f:换页
\n:换行，光标到下行行首
\r:回车，光标到本行行首
\t:水平制表
\v:垂直制表
\:反斜杠
\&rsquo;:单引号
\&rdquo;:双引号
\?:问号
\ddd:三位八进制
\xhh:二位十六进制</p>

<h1 id="0-空字符-null-什么都不做">\0:空字符(NULL),什么都不做</h1>

<p>================================================================================</p>

<p>1 #include <sys/socket.h>
2 ssize_t recv(int sockfd, void *buff, size_t nbytes, int flags);
3 ssize_t send(int sockfd, const void *buff, size_t nbytes, int flags);
recv 和send的前3个参数等同于read和write。</p>

<p>flags参数值为0或：</p>

<p>flags   说明                                       recv   send
 MSG_DONTROUTE  绕过路由表查找                                   ?
 MSG_DONTWAIT   仅本操作非阻塞                            ?          ?
 MSG_OOB　　　　    发送或接收带外数据          ?      ?
 MSG_PEEK　　 窥看外来消息                         ?
 MSG_WAITALL　　  等待所有数据                 ?
 1. send解析</p>

<p>sockfd：指定发送端套接字描述符。</p>

<p>buff：    存放要发送数据的缓冲区</p>

<p>nbytes:  实际要改善的数据的字节数</p>

<p>flags：   一般设置为0</p>

<p>1) send先比较发送数据的长度nbytes和套接字sockfd的发送缓冲区的长度，如果nbytes &gt; 套接字sockfd的发送缓冲区的长度, 该函数返回SOCKET_ERROR;</p>

<p>2) 如果nbtyes &lt;= 套接字sockfd的发送缓冲区的长度，那么send先检查协议是否正在发送sockfd的发送缓冲区中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送sockfd的发送缓冲区中的数据或者sockfd的发送缓冲区中没有数据，那么send就比较sockfd的发送缓冲区的剩余空间和nbytes</p>

<p>3) 如果 nbytes &gt; 套接字sockfd的发送缓冲区剩余空间的长度，send就一起等待协议把套接字sockfd的发送缓冲区中的数据发送完</p>

<p>4) 如果 nbytes &lt; 套接字sockfd的发送缓冲区剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里(注意并不是send把套接字sockfd的发送缓冲区中的数据传到连接的另一端的，而是协议传送的，send仅仅是把buf中的数据copy到套接字sockfd的发送缓冲区的剩余空间里)。</p>

<p>5) 如果send函数copy成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR; 如果在等待协议传送数据时网络断开，send函数也返回SOCKET_ERROR。</p>

<p>6) send函数把buff中的数据成功copy到sockfd的改善缓冲区的剩余空间后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个socket函数就会返回SOCKET_ERROR。（每一个除send的socket函数在执行的最开始总要先等待套接字的发送缓冲区中的数据被协议传递完毕才能继续，如果在等待时出现网络错误那么该socket函数就返回SOCKET_ERROR）</p>

<p>7) 在unix系统下，如果send在等待协议传送数据时网络断开，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的处理是进程终止。</p>

<p>2.recv函数</p>

<p>sockfd: 接收端套接字描述符</p>

<p>buff：   用来存放recv函数接收到的数据的缓冲区</p>

<p>nbytes: 指明buff的长度</p>

<p>flags:   一般置为0</p>

<p>1) recv先等待s的发送缓冲区的数据被协议传送完毕，如果协议在传送sock的发送缓冲区中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR</p>

<p>2) 如果套接字sockfd的发送缓冲区中没有数据或者数据被协议成功发送完毕后，recv先检查套接字sockfd的接收缓冲区，如果sockfd的接收缓冲区中没有数据或者协议正在接收数据，那么recv就一起等待，直到把数据接收完毕。当协议把数据接收完毕，recv函数就把s的接收缓冲区中的数据copy到buff中（注意协议接收到的数据可能大于buff的长度，所以在这种情况下要调用几次recv函数才能把sockfd的接收缓冲区中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的）</p>

<p>3) recv函数返回其实际copy的字节数，如果recv在copy时出错，那么它返回SOCKET_ERROR。如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</p>

<h1 id="4-在unix系统下-如果recv函数在等待协议接收数据时网络断开了-那么调用-recv的进程会接收到一个sigpipe信号-进程对该信号的默认处理是进程终止">4) 在unix系统下，如果recv函数在等待协议接收数据时网络断开了，那么调用 recv的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。</h1>

<p>stat函数</p>

<p>表头文件:    #include <sys/stat.h>
函数定义:    int stat(const char *file_name, struct stat *buf);
函数说明:    通过文件名filename获取文件信息，并保存在buf所指的结构体stat中
返回值:     执行成功则返回0，失败返回-1，错误代码存于errno（需要include <errno.h>）</p>

<p>定义函数 int pipe(int filedes[2]);
函数说明
   pipe()会建立管道,并将文件描述词由参数 filedes 数组返回。
   filedes[0]为管道里的读取端，所以pipe用read调用的
   filedes[1]则为管道的写入端。</p>

<p>解决粘包问题：</p>

<pre><code>1、发送定长包
2、利用结构体，发送包头为数据的长度
3、使用\r\n来按行读取
</code></pre>

<p>recv/send和read/write的区别，前者只可以用于套接口i/o，后者可以用于所有的i/o；
recv的可以用MSG_PEEK的flag来偷窥缓存区数据，但是不清除；</p>

<p>tcp的十一种状态：</p>

<pre><code>服务端创建一个socket：closing状态
服务端监听这个套接口：listen状态   被动  只能被动接受连接
客户端创建套接字后connect：syn_sent状态
服务端accept：syn_rcvd状态
连接状态：established
</code></pre>

<p>关闭tcp：</p>

<pre><code>客户端的fin_wait_1，fin_wait_2，time_wait
服务端的close_wait，last_ack，closed    状态
</code></pre>

<p>sigpipe信号产生一般是服务器端关闭了，继续向其write，一般都是sig_int忽略</p>

<pre><code>（1）阻塞IO：使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。

　　A从宿舍（用户空间）拿着水瓶去饮水机处（内核空间）打水，等到水打满了之后就离开了。若饮水机没有水则一直阻塞等待杯子装满水为止，才离开去做别的事情。（这种IO模型是阻塞+同步的）

（2）非阻塞IO：

　　改变flags，recv不管有没有获取到数据都返回（如果没有数据那么一段时间后再调用recv看看，如此循环）

　　B也从宿舍（用户空间）拿着水瓶去饮水机处（内核空间）打水，打开水龙头发现没有水之后离开了（回到用户空间）。

　　只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)（这种IO模型是非阻塞+同步的）

　　

（3）同步IO：IO多路复用（select, poll, epoll模型），监听多个IO对象，对象有变化（有数据）的时候就通知用户进程（单个进程可以处理多个socket）

　　select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。

（4）异步IO：当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。
</code></pre>

<p>i/o的五种模型：</p>

<pre><code>阻塞i/o    --------------数据没有到来，就阻塞，等待数据到来，将缓存复制到用户空间buf中
非阻塞   -----------没有数据到来，返回-1加错误码，这样就需要循环调用，这样就是忙等待，不建议使用
i/o复用-------使用select来轮询，有数据到来，调用非阻塞i/o
信号驱动i/o  ----
异步i/o   ---效率最高
</code></pre>

<p>/* According to POSIX.1-2001 */
       #include <sys/select.h></p>

<pre><code>   /* According to earlier standards */
   #include &lt;sys/time.h&gt;
   #include &lt;sys/types.h&gt;
   #include &lt;unistd.h&gt;
</code></pre>

<p>int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);</p>

<p>1:文件描述符的最大值+1
2：文件描述符的读集合，也是最后产生事件的集合
3：文件描述符写集合
4：文件描述符出错集合
5：超时时间</p>

<pre><code>   void FD_CLR(int fd, fd_set *set);
   int  FD_ISSET(int fd, fd_set *set);
   void FD_SET(int fd, fd_set *set);
   void FD_ZERO(fd_set *set);
</code></pre>

<p>并发服务器：还是一个个处理，但是不会时间太长，select就是并发，主要是可以监测多个接口，比如标准i/o，和网络i/o，同时监测，不会因为一个接口阻塞，而导致全部无法监测。多进程也是并发
并行：多核&mdash;可以是多进程，多线程</p>

<p>#include <sys/socket.h></p>

<p>int shutdown(int sockfd, int how);&mdash;-close关闭的是双方的
how :SHUT_RD,SHUT_WR,SHUT_RDWR&mdash;&mdash;-关闭的方向</p>

<p>闹钟信号：关闭&mdash;-alarm(0);</p>

<p>设置超时的几种方法：
alarm
setsockopt&mdash;-选项
select&mdash;&ndash;最常用</p>

<p>线程：线程编译要加-pthread&mdash;-cc thread.c -pthread -o thread</p>

<p>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);</p>

<p>第一个参数：线程id
第二个参数：线程属性
第三个参数：线程开始执行函数地址
第四个参数：新线程参数</p>

<p>参数传递：
1、一个参数的话，直接转换为void*类型进行传递，到线程内再转化过来
2、多个参数时，需要将参数封装成一个结构体，然后把结构体地址穿进去，这边不要强制转化为void*，但是要主要malloc和free空间处理</p>

<p>int</p>

<p>ulimit -n  查看和修改系统打开文件描述符的大小</p>

<p>select使用限制：
系统打开的文件描述符，最多为1024个，需要调用root用户进行修改,可以通过getrlimit函数等来获取
集合FD_SET可以最多有1024个FD_SETSIZE，这个和内核有关</p>

<p>&ndash;所以选用poll&mdash;没有FD_SETSIZE的限制
int poll(struct pollfd *fds, nfds_t nfds, int timeout);</p>

<p>struct pollfd {
               int   fd;         /* file descriptor <em>/&mdash;&mdash;文件描述符
               short events;     /</em> requested events <em>/&mdash;&ndash;请求事件
               short revents;    /</em> returned events */&mdash;&mdash;响应事件
           };</p>

<p>events的值和含义
POLLIN   有数据来文件可读
POLLPRI  有紧急数据可读
POLLOUT  文件可写
POLLERR  错误发生
POLLHUP  关闭</p>

<p>两则共同点
都是要遍历所有的文件描述符来关系事件的发生，这样效率是无法提高的</p>

<p>int epoll_create(int size);&mdash;&mdash;&mdash;&mdash;size是哈希表的大小
int epoll_create1(int flags);&mdash;&mdash;&mdash;&ndash;现在用红黑树</p>

<p>cat /proc/sys/fs/file-max&mdash;可以显示系统可以打开的最大文件描述符</p>

<p>service iptables stop&mdash;关闭服务
linux的防火墙服务</p>

<p>线程是程序执行的最小单位
线程就是进程的不同执行线路，拥有自己的cpu状态：线程id，寄存器，栈，errno，信号状态，优先级。共享文件描述符，共享内存，全局变量等等。
线程优点：
占用资源小，代价小。
线程之间的切换方便。
可以充分利用多核cpu
对于密集型计算和i/o可以搞并发
缺点：
当线程大于cpu核数，会增加调度切换开销。
线程之间缺乏保护
缺乏访问控制
调试难</p>

<p>进程                   线程
fork             pthread_create
waitpid(僵进程)      pthread_join(僵线程)&mdash;&mdash;脱离pthread_detach&mdash;-代码中如果没有pthread_join主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结                                    束了。加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行
exit                 pthread_exit
在main中return       在入口函数中return</p>

<p>kill                 pthread_cancel</p>

<p>getpid               pthread_self</p>

<p>线程：
int pthread_create(pthread_t *thread,&mdash;-线程id
const pthread_attr_t *attr,&mdash;&mdash;&ndash;线程属性
void *(*start_routine) (void *), &mdash;&mdash;入口函数地址&mdash;是void *类型，传参也是void * 类型
void *arg);&mdash;&mdash;&mdash;-传入入口函数的参数</p>

<p>int pthread_join(pthread_t thread,&mdash;&mdash;&mdash;-线程id
void **retval);&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;返回状态</p>

<p>void pthread_exit(void *retval);&mdash;&mdash;&mdash;&ndash;退出状态，类似于return 后面的数据</p>

<p>pthread_t pthread_self(void);</p>

<p>int pthread_cancel(pthread_t thread);</p>

<p>web服务器是用来接收HTTP请求并响应这个请求（典型的如按照客户端的请求去对数据库数据进行操作等），通常在WEB开发中如果客户端发起请求给服务端，那么必须有WEB服务器，否则这个请求是没人收的。CGI是运行在WEB服务器上的应用程序，用来处理用户的请求，可以用任意服务端语言实现（常见的如C，C++等），在早期的WEB开发中都是使用CGI来处理客户端请求的,那时候还没有这种专为WEB开发而设计的语言如PHP，不能够做到HTML代码和后台逻辑代码的分离，所以CGI程序返回的结果通常都会包含一些HTML代码，浏览器接收到整个结果然后进行渲染。后来经过发展有了PHP这种可以将前后端进行分离的WEB开发语言，PHP代码只负责处理后台逻辑，将大量的HTML代码放在静态HTML文件中，浏览器最后渲染的结果是服务器返回的HTML代码加JS代码加CSS代码以及PHP模板输出的综合结果。
综上所述：
WEB服务器就是服务端代码运行的一个容器和环境；
CGI就是早期的服务端应用程序，处理用户请求并直接输出浏览器能够识别的HTML代码；
PHP是在CGI基础上发展起来的，主要用于WEB开发的，可以使前后端分离的一种开发语言。</p>

<p>接受http协议，必须要将请求行和头结点接受到，不然会返回reset信号&mdash;-压测有点问题</p>

<p>cgi,通用网关接口
使用fork+execl来执行另外一段程序，通过管道pipe来进行通信返回，最后得到想要的结果</p>

            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/middleware/io/netcomminicate/">https://kingjcy.github.io/post/middleware/io/netcomminicate/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/net-communication/">
                            <i class="fa fa-tags"></i>
                            net Communication
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/network/">
                            <i class="fa fa-tags"></i>
                            network
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/middleware/network/ip/">计算机网络系列---- Ip</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年09月19日)</span></li><li id="li-rels"><a href="/post/middleware/network/tcp/">计算机网络系列---- tcp/ip</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年06月13日)</span></li><li id="li-rels"><a href="/post/middleware/network/http/">计算机网络系列---- Http/https</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年06月13日)</span></li><li id="li-rels"><a href="/post/linux/c&#43;&#43;/process-communication/">计算机网络系列---- Process Communication</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2015年04月28日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/linux/c&#43;&#43;/process-communication/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/language/java/spring/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#转义字符">转义字符：</a></li>
<li><a href="#0-空字符-null-什么都不做">\0:空字符(NULL),什么都不做</a></li>
<li><a href="#4-在unix系统下-如果recv函数在等待协议接收数据时网络断开了-那么调用-recv的进程会接收到一个sigpipe信号-进程对该信号的默认处理是进程终止">4) 在unix系统下，如果recv函数在等待协议接收数据时网络断开了，那么调用 recv的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。</a></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

