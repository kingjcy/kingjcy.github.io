<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="一直想整理一下平时使用的工具，都没有时间，但是还是要带着整理的，备忘也便于查看。">
<meta property="og:url" content="https://kingjcy.github.io/"><meta property="og:type" content="article">
<meta property="og:title" content="工具系列(一)：git和github的使用总结 - kingjcy blog"><meta property="og:site_name" content="kingjcy blog">

<title>
    
    工具系列(一)：git和github的使用总结
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">kingjcy blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/读书笔记/">读书笔记</a></li>
                        <li><a href="/categories/人生感悟/">人生感悟</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="kingjcy.github.io"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2014年11月18日 
                </div>
                <h1 class="post-title">工具系列(一)：git和github的使用总结</h1>
            </header>

            <div class="post-content">
                <p>一直想整理一下平时使用的工具，都没有时间，但是还是要带着整理的，备忘也便于查看。</p>

<h1 id="git"><em>git</em></h1>

<p>git是一个分布式版本控制系统，它没有中央服务器，本地便是一个版本库。不需要联网就能开发，它是通过推送自己修改的内容给对方来实现版本控制的。开发者可以从本地库查看完整的历史版本记录，无需从中心库加载；创建分支，提交修改也是本地行为，从而加快操作速度，让使用者感觉GIT各种操作都很高效。</p>

<p>svn则与之相反，svn是一种集中式的版本控制系统，它拥有中央服务器，需要先从中央服务器中下载最新的版本，然后进行修改，最后在将修改的推送到中央服务器上，所以必须能连接上服务器，不然不利于开发。开发者所做的任何操作都会对中央仓库发生数据同步，会导致网络负载增加，导致网络抖动；任何分支数据都会产生在服务器上，导致中央仓库容量暴增。</p>

<p>相对而言，git适用于随时随地的本地开发。</p>

<h3 id="安装">安装</h3>

<p>linux下安装（centos）</p>

<p>1.yum基础软件包管理工具</p>

<p><code>yum install git</code></p>

<p>目前的yum源安装最高版本应该是1.7.1</p>

<p>2.编译安装</p>

<p>首先到github[<a href="https://github.com/git/git/releases">https://github.com/git/git/releases</a>] 上下载最新的release版本。安装之前需要先安装git的依赖包：：curl、zlib、openssl、expat，还有libiconv。</p>

<p><code>$ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code></p>

<pre><code>$ tar -zxf git-2.0.0.tar.gz
$ cd git-2.0.0
$ make configure
$ ./configure --prefix=/usr
$ make all doc info
$ sudo make install install-doc install-html install-info
</code></pre>

<p>然后就可以检查版本安装是否成功了<code>git --version</code></p>

<h3 id="本地操作使用">本地操作使用</h3>

<p>git是一个本地管理的软件，首先要掌握本地的使用命令：</p>

<p>1.在当前目录建立仓库，也就是初始化本地目录环境，可以看见有一个隐藏文件.git 要输出这个仓库，直接删除这个目录（暴力方法）。</p>

<pre><code>git init
</code></pre>

<p>2.新建文件</p>

<pre><code>git touch t
</code></pre>

<p>3.加版本</p>

<pre><code>git add t
</code></pre>

<p>4.提交版本  git commit t -m &ldquo;版本说明日志&rdquo;</p>

<pre><code>git commit -a -m &quot;&quot;  提交所有文件
</code></pre>

<p>5.版本比较 git diff t</p>

<pre><code>也可以查看不同commit版本的之间的差距

git diff commit-id1 commit-id2
</code></pre>

<p>6.显示版本日志</p>

<pre><code>git log

可以切换到对应的commit，使用git checkout commit-id去查看对应的当时状态的文件。这个时候是以指定的提交节点创建了一个临时性分支，此临时性分支可用于做实验性修改
</code></pre>

<p>7.恢复上一个版本</p>

<pre><code>git reset --hard 版本号，可以在git log中显示
--hard会删除文件，--soft只是改变head，不会删除文件
</code></pre>

<p>8.查看状态</p>

<pre><code>git status
</code></pre>

<p>9.分支</p>

<pre><code>创建分支:执行git branch &lt;branchname&gt;命令创建新分支

切换分支:执行git checkout &lt;branchname&gt;命令切换到新分支---合一步  git checkout -b XXXX

git branch -a   查看远程分支

git branch 查看本地分支

删除本地分支   git branch -d xxxxx
</code></pre>

<p>关联分支</p>

<p>1.一个本地分支：   git branch fz1</p>

<p>If you wish to set tracking information for this branch you can do so with:</p>

<pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; master
</code></pre>

<p>2.一个新的和远程关联的分支：</p>

<pre><code>git checkout -b &lt;本地分支&gt; --track origin/&lt;远程分支&gt;
git checkout -b level0step1 --track origin/level0step1
</code></pre>

<p>拉去分支</p>

<pre><code>git pull &lt;remote&gt; &lt;branch&gt;
</code></pre>

<p>合并分支</p>

<pre><code>$ git checkout -b [branch]                //新建一个分支，并切换到该分支
$ git branch                              //命令会列出所有分支，当前分支前面会标一个*号。
$ git add .
$ git commit -m &quot;提交分支branch&quot;
$ git checkout master                     //切换回master分支
$ git merge [branch]                      //把branch分支合并到master分支
$ git branch -d branch                     //合并完成后删除branch分支
</code></pre>

<p>将新分支修改内容合并的其他分支</p>

<pre><code>$ git checkout [branch]                      //切换回拉取的分支
$ git merge master                   //把master合并到branch分支
</code></pre>

<p>解决合并冲突</p>

<pre><code>Auto-merging .gitignore
CONFLICT (content): Merge conflict in .gitignore
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>

<p>Simply edit .gitignore file to resolve conflict:</p>

<pre><code>Before

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
public/img/ignore
=======
public/img/profiles
public/blog
public/recommendation
&gt;&gt;&gt;&gt;&gt;&gt;&gt; newfeature
After

public/img/ignore
public/img/profiles
public/blog
public/recommendation
Then:
</code></pre>

<p>需要做如下操作</p>

<pre><code>git add .gitignore

git commit
</code></pre>

<p>如何去解决这些最常见的冲突。</p>

<p>当两个改动发生在同一个文件的同一些行上，我们就要看看发生冲突的文件的内容了。Git 会非常友好地把文件中那些有问题的区域在 “&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD” 和 “&gt;&gt;&gt;&gt;&gt;&gt;&gt; [other/branch/name]” 之间标记出来。</p>

<p>第一个标记后的内容源于当前分支。在尖括号之后，Git 会告诉我们这些改动是从哪里（哪个分支）来的。然后有冲突的改动会被 “=======” 分割起来。</p>

<p>现在我们的工作是要清理这些问题行。当我们完成这些清理后，这个文件应该看起来和我们预期的完全一样。在过程中你也可能需要咨询一下那个和你的代码发生冲突的同事，从而更好地决定哪些改动才是最终正确的，哪些改动是需要被放弃掉的。可能是你的改动，也可能是他的，或者可能是你们两个改动的组合。</p>

<p>最终，当所有的冲突被解决后，你必须通过一个正常的提交操作来完成这个清理合并冲突的工作。</p>

<p>分支结构</p>

<p>查看各个branch之间的关系图使用git log命令</p>

<pre><code>git log --graph --decorate --oneline --simplify-by-decoration --all


说明：

--decorate 标记会让git log显示每个commit的引用(如:分支、tag等)

--oneline 一行显示
--simplify-by-decoration 只显示被branch或tag引用的commit

--all 表示显示所有的branch，这里也可以选择，比如我指向显示分支ABC的关系，则将--all替换为branchA branchB branchC
</code></pre>

<p>git如何不commit当前分支的修改而切换到其它分支</p>

<p>“切换分支的时候最好保持一个清洁的工作区域。”</p>

<p>有如下几种处理方式：</p>

<ol>
<li>git add并且git commit，再git checkout，提交到当前分支</li>
<li>git add但不git commit，可以git stash，然后git checkout到新分支，做修改，然后git checkout回到之前的分支之后git stash apply，再git commit，提交到之前的分支</li>
<li>git add但不git commit，也不git stash，直接git checkout到新分支，做修改，然后再git commit的话，记录就在切换后的分支下面。</li>
</ol>

<p>其背后的原因：一个本地的git repo只有一个工作区和暂存区，但是有多个分支的提交区，而我们的checkout只是将HEAD指针从一个分支切换到另一个分支。</p>

<p>10.删除本地仓库</p>

<pre><code>rm -rf .git
</code></pre>

<p>11.变基</p>

<p>Rebase 场景一：如何合并多次提交纪录？</p>

<p>1.我们来合并最近的 4 次提交纪录，执行：</p>

<pre><code>git rebase -i HEAD~4
</code></pre>

<p>2.这时候，会自动进入 vi 编辑模式：</p>

<pre><code>s cacc52da add: qrcode
s f072ef48 update: indexeddb hack
s 4e84901a feat: add indexedDB floder
s 8f33126c feat: add test2.js

# Rebase 5f2452b2..8f33126c onto 5f2452b2 (4 commands)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like &quot;squash&quot;, but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
</code></pre>

<p>有几个命令需要注意一下：</p>

<pre><code>p, pick = use commit    p 就是你要保留注释的 commit
r, reword = use commit, but edit the commit message
e, edit = use commit, but stop for amending
s, squash = use commit, but meld into previous commit   s 就是会合并进 p
f, fixup = like “squash”, but discard this commit’s log message
x, exec = run command (the rest of the line) using shell
d, drop = remove commit
</code></pre>

<p>按照如上命令来修改你的提交纪录，比较正常使用的r，s等</p>

<pre><code>s cacc52da add: qrcode
s f072ef48 update: indexeddb hack
s 4e84901a feat: add indexedDB floder
p 8f33126c feat: add test2.js
</code></pre>

<p>3.如果保存的时候，你碰到了这个错误：</p>

<pre><code>error: cannot 'squash' without a previous commit
</code></pre>

<p>注意不要合并先前提交的东西，也就是已经提交远程分支的纪录。如果需要合并，就将后来commit的合并到这个已经提交到远程到commit上，注意要合并注释。不要出现重复的注释。</p>

<p>还有一个错误，不能rebase，就是存在问题处于没有commit的状态，这个只能将全部commit，或者移走了。保持commit整洁。</p>

<p>4.如果你异常退出了 vi 窗口，不要紧张：</p>

<pre><code>git rebase --edit-todo
</code></pre>

<p>这时候会一直处在这个编辑的模式里，我们可以回去继续编辑，修改完保存一下：</p>

<pre><code>git rebase --continue
</code></pre>

<p>5.查看结果</p>

<pre><code>git log
</code></pre>

<p>三次提交合并成了一次，减少了无用的提交信息。</p>

<p>Rebase 场景二：分支合并</p>

<p>1.我们先从 master 分支切出一个 dev 分支，进行开发：</p>

<pre><code>git:(master) git checkout -b feature1
</code></pre>

<p><img src="/media/tool/github/git1.png" alt="" /></p>

<p>2.这时候，你的同事完成了一次 hotfix，并合并入了 master 分支，此时 master 已经领先于你的 feature1 分支了：</p>

<p><img src="/media/tool/github/git2.png" alt="" /></p>

<p>3.恰巧，我们想要同步 master 分支的改动，首先想到了 merge，执行：</p>

<pre><code>git:(feature1) git merge master
</code></pre>

<p><img src="/media/tool/github/git3.png" alt="" /></p>

<p>图中绿色的点就是我们合并之后的结果，执行：</p>

<pre><code>git:(feature1) git log
</code></pre>

<p>就会在记录里发现一些 merge 的信息，但是我们觉得这样污染了 commit 记录，想要保持一份干净的 commit，怎么办呢？这时候，git rebase 就派上用场了。</p>

<p>4.让我们来试试 git rebase ，先回退到同事 hotfix 后合并 master 的步骤：</p>

<p><img src="/media/tool/github/git4.png" alt="" /></p>

<p>5.使用 rebase 后来看看结果：</p>

<pre><code>git:(feature1) git rebase master
</code></pre>

<p>这里补充一点：rebase 做了什么操作呢？</p>

<pre><code>首先，git 会把 feature1 分支里面的每个 commit 取消掉；
其次，把上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下；
然后，把 feature1 分支更新到最新的 master 分支；
最后，把上面保存的 patch 文件应用到 feature1 分支上；
</code></pre>

<p><img src="/media/tool/github/git5.png" alt="" /></p>

<p>从 commit 记录我们可以看出来，feature1 分支是基于 hotfix 合并后的 master ，自然而然的成为了最领先的分支，而且没有 merge 的 commit 记录，是不是感觉很舒服了。</p>

<p>6.在 rebase 的过程中，也许会出现冲突 conflict。在这种情况，git 会停止 rebase 并会让你去解决冲突。在解决完冲突后，用 git add 命令去更新这些内容。</p>

<p>注意，你无需执行 git-commit，只要执行 continue</p>

<pre><code>git rebase --continue
</code></pre>

<p>这样 git 会继续应用余下的 patch 补丁文件。</p>

<p>7.在任何时候，我们都可以用 &ndash;abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。</p>

<pre><code>git rebase —abort
</code></pre>

<p>12.commit合并</p>

<p>cherry-pick其实在工作中还挺常用的，一种常见的场景就是，比如我在A分支做了几次commit以后，发现其实我并不应该在A分支上工作，应该在B分支上工作，这时就需要将这些commit从A分支复制到B分支去了，这时候就需要cherry-pick命令了</p>

<p>git cherry-pick可以选择某一个分支中的一个或几个commit(s)来进行操作。例如，假设我们有个稳定版本的分支，叫v2.0，另外还有个开发版本的分支v3.0，我们不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个v3.0中的功能到v2.0中，这里就可以使用cherry-pick了,其实也就是对已经存在的commit 进行再次提交.</p>

<p>简单用法：</p>

<pre><code>git cherry-pick &lt;commit id&gt;
</code></pre>

<p>注意：当执行完 cherry-pick 以后，将会生成一个新的提交；这个新的提交的哈希值和原来的不同，但标识名一样；</p>

<p>例如：</p>

<pre><code>$ git checkout v2.0分支
$ git cherry-pick 38361a55 # 这个 38361a55 号码，位于v3.0分支中：

$ git log
commit 38361a55138140827b31b72f8bbfd88b3705d77a
Author: Justin Justin@xxx.com
Date: Sat Dec 10 00:11:44 2016 +0800
</code></pre>

<ol>
<li><p>如果顺利，就会正常提交。结果：</p>

<p>Finished one cherry-pick.
On branch v2.0分支
Your branch is ahead of &lsquo;origin/old_cc&rsquo; by 3 commits.</p></li>

<li><p>如果在cherry-pick 的过程中出现了冲突</p>

<p>Automatic cherry-pick failed.
After resolving the conflicts,mark the corrected paths with &lsquo;git add <paths>&rsquo; or &lsquo;git rm <paths>&lsquo;and commit the result with:
git commit -c 15a2b6c61927e5aed6111de89ad9dafba939a90b
或者:
error: could not apply 0549563&hellip; dev
hint: after resolving the conflicts, mark the corrected paths
hint: with &lsquo;git add <paths>&rsquo; or &lsquo;git rm <paths>&lsquo;
hint: and commit the result with &lsquo;git commit&rsquo;</p></li>
</ol>

<p>就跟普通的冲突一样，手工解决：</p>

<p>2.1 $ git status # 看哪些文件出现冲突</p>

<pre><code>both modified: app/models/MainActivity.java
</code></pre>

<p>2.2 $ vim app/models/MainActivity.java # 手动解决它。 **</p>

<p>2.3 $ git add app/models/MainActivity.java</p>

<p>2.4 git commit -c &lt;新的commit号码&gt;</p>

<p>2.5 再次cherry-pick剩余commit</p>

<p>若提示:</p>

<pre><code>error: a cherry-pick or revert is already in progress
hint: try &quot;git cherry-pick (--continue | --quit | --abort)&quot;
fatal: cherry-pick failed
</code></pre>

<p>则执行对应操作:</p>

<pre><code>git cherry-pick --continue
git cherry-pick --quit
git cherry-pick --abort
</code></pre>

<p>命令集合:</p>

<pre><code>git cherry-pick &lt;commit id&gt;:单独合并一个提交
git cherry-pick -x &lt;commit id&gt;：同上，不同点：保留原提交者信息。
Git从1.7.2版本开始支持批量cherry-pick，就是一次可以cherry-pick一个区间的commit。
git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;
git cherry-pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt;
前者表示把&lt;start-commit-id&gt;到&lt;end-commit-id&gt;之间(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支；
后者有&quot;^&quot;标志的表示把&lt;start-commit-id&gt;到&lt;end-commit-id&gt;之间(闭区间，包含start-commit-id)的提交cherry-pick到当前分支。
其中，&lt;start-commit-id&gt;到&lt;end-commit-id&gt;只需要commit-id的前6位即可，并且&lt;start-commit-id&gt;在时间上必须早于&lt;end-commit-id&gt;
注：以上合并，需要手动push代码。
</code></pre>

<p>1</p>

<h1 id="github"><em>github</em></h1>

<p>GTI托管平台有：GitLab，GitHub，BitBucket。</p>

<p>github是一个git版本的远程服务器仓库，很多开源的项目都会将代码保存在这个托管平台上，是一个类似于dockerhub的存储功能的公共仓库。</p>

<p>这边主要记录一些github和本地的git仓库的交互：</p>

<p>首先创建ssh key</p>

<pre><code>ssh-keygen -t rsa -C &quot;574209987@qq.com&quot;----生成家目录下的.ssh/XXX 秘钥文件
</code></pre>

<p>然后到github的settings中设置ssh key把公共密码贴进去</p>

<p>设置配置信息</p>

<pre><code>git config --global 注册用户信息
git config --global user.name &quot;jcy&quot;
git config --global user.email &quot;574209987@qq.com&quot;
git config --global core.editor vim-----commit后用vim编辑
</code></pre>

<p>review</p>

<p>在review change 中选择comment来说出自己的想法，如果没有问题的话选择approve来结束，一般直接写上LGTM（look good to me）</p>

<h1 id="正常流程">正常流程：</h1>

<p>开发的规范的如下：</p>

<h3 id="管理员">管理员</h3>

<p>1.新建gitlab，github项目</p>

<p>首先把管理员直接push的权限关掉，即设置成Read。这样可以防止队友误操作，未经审核就把代码push到团队项目上。</p>

<p><img src="/media/tool/github/20141118.png" alt="" /></p>

<p>2.创建开发分支</p>

<p>master分支一般用来发布稳定版本，dev分支（开发分支）用来发布开发版本。
输入分支名称后，下面会跳出Create branch，点击即可创建。</p>

<p><img src="/media/tool/github/20181118-1.png" alt="" /></p>

<p>以上的都是管理员做的事情，在cd平台中一般创建项目的的时候就已经分配好了。</p>

<h3 id="团队成员操作">团队成员操作</h3>

<p>3.Fork项目到个人的仓库，这个开始以下属于github项目的开发模式</p>

<p>4.Clone项目到本地</p>

<p>一般只是clone到master，然后使用 git branch -a 查看所有分支，就能看到远程分支。</p>

<p>根据远程分支，我们可以创建一个新的本地分支dev，并把该项目的dev分支的内容放到本地dev分支。</p>

<pre><code>git checkout -b dev origin/dev
</code></pre>

<p>可以在本地进行开发了。</p>

<p>5.基于分支的特性，开发也讲究流程</p>

<pre><code>1.每次开发都从 dev 分支重新 check out 一个新的分支出来
2.就在这个分支上开发，提交到自己项目，需要在远程新建分支
    git push --set-upstream origin 分支名
3.提交 PR
3.dev 上的更新，如果没有冲突的话，就不用管,不需要同步 dev 的代码到最新,没有冲突的话，可以直接合并
4.如果有冲突的话，就需要更新到最新的代码,最理想的方式如下
5.更新 dev 分支，再 check out 一个新的分支出来，然后把你的旧分支上的修改 cherry-pick（需要用到rebase） 到这个新的分支上来，再解决冲突，再 force-push 到远端
</code></pre>

<p>一些本地操作和下面远程关联说明</p>

<p>首先每个项目都是可以设置user信息</p>

<pre><code>chunyindeMacBook-Pro:.git chunyinjiang$ git config user.name &quot;kingjcy&quot;
chunyindeMacBook-Pro:.git chunyinjiang$ git config user.email &quot;574209987@qq.com&quot;
chunyindeMacBook-Pro:.git chunyinjiang$ vi config
</code></pre>

<p>当然可以设置全局的。生成的文件都是在对应项目的.git下面的config</p>

<p>1.什么都不存在</p>

<pre><code>git clone http://git.cnsuning.com/promes/sndp_exporter.git
cd sndp_exporter
touch README.md
git add README.md
git commit -m &quot;add README&quot;
git push -u origin master
</code></pre>

<p>2.已存在的文件夹</p>

<pre><code>cd existing_folder
git init
git remote add origin http://git.cnsuning.com/promes/sndp_exporter.git
git add .
git commit
git push -u origin master
</code></pre>

<p>3.已存在的 Git 版本库</p>

<pre><code>cd existing_repo
git remote add origin http://git.cnsuning.com/promes/sndp_exporter.git
git push -u origin --all
git push -u origin --tags
</code></pre>

<p>但是如果要将你修改完的代码合并到团队项目上，还需要进行下面的操作。</p>

<p>6.和团队项目保持同步</p>

<p>直接建立和源项目的链接，然后重这个来pull（git pull upstream），在push到自己的项目中，然后进行pr</p>

<pre><code>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
如拉取远程的master分支到本地wy分支：
git pull origin master:wy
</code></pre>

<p>查看有没有设置远程连接，使用 git remote -v 命令来查看</p>

<p>如果没有显示，则使用 git remote add  团队项目地址 命令</p>

<p>在上传代码前，需要同步分支内容，git pull，当然也可以git fetch ,然后git merge</p>

<p>push修改到自己的项目上git push</p>

<pre><code>默认提交分支
git push

提交分支到指定分支
git push是&lt;本地分支&gt;:&lt;远程分支&gt;。
git push origin level0step1:level0step1
或者直接把当前提交到远程的一个分支
git push origin level0step1
</code></pre>

<p>6.请求合并到团队项目上</p>

<p>首先到你的GitHub上，进入你Fork的仓库里。点击红框处的Pull request</p>

<p><img src="/media/tool/github/20181118-2.png" alt="" /></p>

<p>下图左边红框，表示要合并到fzu2015/CourseManagement项目的dev分支。
下图右边红框，表示要从自己仓库的dev分支发起合并请求。
点击红框处的 Create pull request就可以发送合并请求了。</p>

<p><img src="/media/tool/github/20181118-3.png" alt="" /></p>

<p>当然，在发送请求之前，你可以检查一下你都改了哪些东西。在上面那个页面往下拉，就可以看到两者的对比。如下图</p>

<p><img src="/media/tool/github/20181118-4.png" alt="" /></p>

<p>7.团队项目负责人审核及同意合并请求,界面上直接有merge</p>

<p>8.有问题comment，pr开着，你把对应的修改推到你的项目上就会自动关联到对方的项目中去，不需要做任何的动作，等待对方review，反复操作。</p>

<p>9.对应一个pr多次commit，需要使用rebase来合并commit，减少无意义的commit的提交。</p>

<h1 id="公司流程">公司流程</h1>

<p>本地开发的时候需要从分支进行pull，本地开发完毕，必须重新进行一次pull，之后才能push到分支，同时本地提交的要写清楚提交内容和影响的范围。</p>

<p>当大家都开发完毕后，做代码评审、测试环境发布对应的功能，修改bug、分支确定没有问题之后，由代码管理员push到master。之后master打出tag，用tag发布。</p>

<p>新的功能从master 再次创建branch，进行开发、测试、发布</p>

<p>如果开发中发现有bug，可以从master再次创建一个分支，在上面进行bug的修改、测试、发布。</p>

<p>发布的tag需要有严格命名规范，以va.b.c的方式命名。abc命名时候都是数字，从0开始累加</p>

<pre><code>a为大的版本。核心功能发生变化才进行变动
b为日常迭代功能版本。
c为bug和小功能版本
</code></pre>

<p>目前我们使用了两种开发模式规范</p>

<ol>
<li>分支模式</li>
</ol>

<p>分支模式包含三种分支类型：开发分支、特性分支、紧急分支</p>

<pre><code>1）Master分支(主干分支)
此分支创建代码库时默认生成，这个分支只能从其他分支合并代码，不能在这个分支上直接操作。Master保持和当前生产运行的代码同步，所以每次版本发布后要将代码合并到Master。
2）Develop 分支（开发分支）
开发分支也是发布分支，一般一个独立项目或者一个版本需要拉取一个开发分支，开发分支主要接收特性分支合并的代码，不能被直接提交代码。develop分支可多个并存，应用负责人、版本经理和技术经理拥有创建权限。
3）Feature 分支(特性分支)
特性分支主要是进行具体功能或任务开发，功能一旦开发完成，要及时合并到Develop分支进行集成测试。所有开发人员都拥有拉取特性分支的权限。开发团队可针对每个独立的子任务拉取一个特性分支，亦可每人使用一个特性分支，建议每个开发人员使用一个特性分支。
4）Hotfix分支(紧急分支)
这是一个特殊的开发分支，当我们在生产环境发现Bug的时候，我们需要创建一个Hotfix,来紧急修复缺陷，完成Hotfix后，需要合并到Master和Develop分支，所以Hotfix的改动会进入下一个Release。
</code></pre>

<ol>
<li><p>正常模式</p>

<p>自由模式为比较自由的一种，只包含两种分支类型：主干分支（master）、开发分支。
master默认为受保护分支，创建代码库时默认生成，无法直接提交代码，只能通过合并请求来合并代码，master分支无法被关联到版本进行发布，master永远和生产最新版本的代码保持同步。
开发分支可以做发布和质量构建，开发分支可以多个并存，一般在多个版本并行开发的情况下会有多个开发分支并存。开发分支的拉取和使用有项目组自行设定策略，开发人员都有拉取开发分支的权限，项目组可共用一个开发分支，亦可根据需要每人拉取一个分支。
一般在实际开发过程技术经理会拉出一个分支作为主开发分支，每个开发人员拉出一个自己的开发分支，版本发布前将其他开发分支的内容最终合并到此主开发分支一起进行发布。（就是上面的模式）</p></li>
</ol>

<h1 id="git-工具-子模块">Git 工具 - 子模块</h1>

<p>子模块允许你将一个 Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>

<p>通过git submodule add将外部项目加为子模块</p>

<p>你将克隆一个带子模块的项目。当你接收到这样一个项目，你将得到了包含子项目的目录，但里面没有文件，你必须运行两个命令：git submodule init来初始化你的本地配置文件，git submodule update来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交。</p>

<h1 id="git打标签与版本控制规范">Git打标签与版本控制规范</h1>

<p>使用Git做VCS（版本控制系统）的场景</p>

<p>用过Git的程序猿，都喜欢其分布式架构带来的commit快感。不用像使用SVN这种集中式版本管理系统，每一次提交代码，都要为代码冲突捏一把冷汗。频繁commit的背后，带来的结果是一长串密密麻麻的提交记录。一旦项目出现问题，需要检查某个节点的代码问题，就会有点头疼。虽然有commit message，但还是有存在查找困难和描述不清的问题。</p>

<p>一、打标签</p>

<p>打标签的作用，就是给项目的开发节点，加上语义化的名字，也即功能版本的别名。打上标签名的同时，写上附带信息，可以方便项目日后维护过程中的回溯和复查。另外，也可以通过标签记录，大致了解当前项目的向下兼容性、API的修改和迭代情况。</p>

<p>1.1 打标签命令</p>

<p>一般推荐打带附注信息的标签，这样可以最大限度查看标签版本的修改情况。</p>

<pre><code>// 命令格式
git tag -a 标签名 -m &quot;附注信息&quot;

// 示例
git tag -a v0.1.0 -m &quot;完成了文章a和文章b的撰写，耗费时间2h，感觉棒棒的！&quot;
</code></pre>

<p>实例</p>

<p>一份文集等待出版，有a、b、c、d四篇。
现在通过Git管理进度。</p>

<p>经过两次commit操作，添加a.txt和b.txt后，将代码修改push到远程仓库。</p>

<p>仓库图表如下：</p>

<pre><code>master -&gt; * 添加b.txt
          | 
          * 添加a.txt
          |
          * 初始化
</code></pre>

<p>给当前文集打个标签，顺便留个心情</p>

<pre><code>// 打标签
git tag -a v0.1.0 -m &quot;完成了文章a和文章b的撰写，耗费时间2h，感觉棒棒的！&quot;

// push 标签到远程仓库
git push origin v0.1.0
</code></pre>

<p>复制代码仓库图表如下：</p>

<pre><code>    master v0.1.0 -&gt; * 添加b.txt
                     | 
                     * 添加a.txt
                     |
                     * 初始化
</code></pre>

<p>再经过两次commit操作，添加c.txt和d.txt后，将代码修改push到远程仓库。</p>

<p>仓库图表如下：</p>

<pre><code>       master -&gt; * 添加d.txt
                 |
                 * 添加c.txt
                 |
       v0.1.0 -&gt; * 添加b.txt
                 | 
                 * 添加a.txt
                 |
                 * 初始化
</code></pre>

<p>文集已经写完，打个完结版的标签</p>

<pre><code>// 打标签
git tag -a v1.0.0 -m &quot;文集完成，共4篇文章，等出版。&quot;

// push 标签到远程仓库
git push origin v1.0.0
复制代码仓库图表如下：
    master v1.0.0 -&gt; * 添加d.txt
                     |
                     * 添加c.txt
                     |
           v0.1.0 -&gt; * 添加b.txt
                     | 
                     * 添加a.txt
                     |
                     * 初始化
</code></pre>

<p>过了段时间，我想知道文集在v0.1.0版本的情况</p>

<pre><code>// 输出v0.1.0的详情
git show v0.1.0

// 输出结果
tag v0.1.0
Tagger: wall &lt;582104384@qq.com&gt;
Date:   Wed May 23 15:57:13 2018 +0800

完成了文章a和文章b的撰写，耗费时间2h，感觉棒棒的！

commit 7107eb8b3f870cd864e3eb5b14f26184d73dd1e6 (tag: v0.1.0)
Author: wall &lt;582104384@qq.com&gt;
Date:   Wed May 23 15:27:10 2018 +0800

添加b.txt

diff --git a/src/b.txt b/src/b.txt
new file mode 100644
index 0000000..f9ee20e
--- /dev/null
+++ b/src/b.txt
</code></pre>

<p>这里，可以清晰地看到当时打标签的内容和附注信息。还有另外一个方便的点，就是不需要用hash字符串表示的版本号去查看更改。</p>

<p>以下是用版本号查询的结果：
    // 用版本号查看
    git show 7107eb8b3f870cd864e3eb5b14f26184d73dd1e6</p>

<pre><code>// 输出结果
commit 7107eb8b3f870cd864e3eb5b14f26184d73dd1e6 (tag: v0.1.0)
Author: wall &lt;582104384@qq.com&gt;
Date:   Wed May 23 15:27:10 2018 +0800

    添加b.txt

diff --git a/src/b.txt b/src/b.txt
new file mode 100644
index 0000000..f9ee20e
--- /dev/null
+++ b/src/b.txt
@@ -0,0 +1 @@
+This is B.
\ No newline at end of file
</code></pre>

<p>优缺点</p>

<pre><code>1. 版本号hash字符串不友好，不方便记忆
2. 标签语义化，对开发人员友好，方便提取附注的开发信息
</code></pre>

<p>二、语义化版本控制规范</p>

<p>像上文的栗子，可以看出使用了v0.1.0和v1.0.0打标签。其实，这里遵循了一套语义化版本控制规范（Semantic Versioning）。</p>

<p>规范的概要如下：</p>

<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>

<pre><code>主版本号：当你做了不兼容的 API 修改，
次版本号：当你做了向下兼容的功能性新增，
修订号：当你做了向下兼容的问题修正。
</code></pre>

<p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸</p>

<p>以上都是git的本地版本控制操作，下面我们是使用github平台的使用</p>

<h1 id="问题记录">问题记录</h1>

<p>问题1：error: The requested URL returned error: 403 Forbidden while accessing <a href="https://github.com/kingjcy/kingjcy.github.io.git/info/refs">https://github.com/kingjcy/kingjcy.github.io.git/info/refs</a></p>

<pre><code>修改vim .git/config
url = https://@github.com/kingjcy/kingjcy.github.io.git改为url = https://kingjcy@github.com/kingjcy/kingjcy.github.io.git
</code></pre>

<p>问题2：(gnome-ssh-askpass:23502): Gtk-WARNING **: cannot open display:</p>

<pre><code>执行unset SSH_ASKPASS，不用输用户名，直接输入密码。
</code></pre>

<p>问题3:
git为不同的项目设置不同的用户名</p>

<p>公司内部的项目提交时设置的用户名为自己的真实姓名，但是在github上提交时，可能不想暴露真实姓名，这时候就不能采用通用的配置了，就要单独设置每个项目的git配置。</p>

<p>由于每个git项目下都会有一个隐藏的.git文件夹 ，将终端的工作目录设置到相应的项目根目录下，执行ls -a</p>

<p>命令，显示所有文件，即可看到.git的隐藏文件夹。通过cd .git 进入该目录，发现该目录下有个config文件，采用</p>

<p>open config 命令打开，添加如下配置：</p>

<p>[user]
    name = XXX(自己的名称英文)
    email = XXXX(邮箱)
保存，command+s 即可。这时候就为该项目配置了独立的用户名和邮箱，这时提交代码时，提交日志上显示的就是设置的名称，当然github这种会根据设置的邮箱来设置对应的用户名。</p>

<p>当然也可以通过命令行的方式(即要去掉&ndash;global参数)去设置单独的git配置，只需要在 .git 文件夹下。 例如执行如下命令：</p>

<p>git  config  user.name  &ldquo;xxxxx&rdquo;
来修改当前项目提交代码时用到的用户名。</p>

<p>ps：如果全局的配置和当前项目的单独配置中出现相同的配置选项，比如全局和项目都设置了user.name ，那么在该项目中进行git操作时，会默认采用该项目配置的用户名。</p>

<p>问题四：
（Non-fast-forward）的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。于是你有2个选择方式：</p>

<p>1，强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容</p>

<p>git push -f</p>

<p>如果远程分支是受保护的，就不能强推</p>

<p>2，先把git的东西fetch到你本地然后merge后再push</p>

<p>$ git fetch</p>

<p>$ git merge</p>

<p>这2句命令等价于</p>

<p>$ git pull</p>

<p>也支持强拉 $ git pull -f</p>

<p>问题五：
本文讲的是把git在最新2.9.2，合并pull两个不同的项目，出现的问题如何去解决</p>

<p>如果合并了两个不同的开始提交的仓库，在新的 git 会发现这两个仓库可能不是同一个，为了防止开发者上传错误，于是就给下面的提示</p>

<p>fatal: refusing to merge unrelated histories</p>

<p>如我在Github新建一个仓库，写了License，然后把本地一个写了很久仓库上传。这时会发现 github 的仓库和本地的没有一个共同的 commit 所以 git 不让提交，认为是写错了 origin ，如果开发者确定是这个 origin 就可以使用 &ndash;allow-unrelated-histories 告诉 git 自己确定</p>

<p>遇到无法提交的问题，一般先pull 也就是使用 git pull origin master 这里的 origin 就是仓库，而 master 就是需要上传的分支，因为两个仓库不同，发现 git 输出 refusing to merge unrelated histories 无法 pull 内容</p>

<p>因为他们是两个不同的项目，要把两个不同的项目合并，git需要添加一句代码，在 git pull 之后，这句代码是在git 2.9.2版本发生的，最新的版本需要添加 &ndash;allow-unrelated-histories 告诉 git 允许不相关历史合并</p>

<p>假如我们的源是origin，分支是master，那么我们需要这样写git pull origin master &ndash;allow-unrelated-histories 如果有设置了默认上传分支就可以用下面代码</p>

<p>git pull &ndash;allow-unrelated-histories
1
这里写图片描述</p>

<p>这个方法只解决因为两个仓库有不同的开始点，也就是两个仓库没有共同的 commit 出现的无法提交。如果使用本文的方法还无法提交，需要看一下是不是发生了冲突，解决冲突再提交</p>

<p>问题六：
一、为什么要使用 .gitignore
当你使用git add .的时候有没有遇到把你不想提交的文件也添加到了缓存中去？比如项目的本地配置信息，如果你上传到Git中去其他人pull下来的时候就会和他本地的配置有冲突，所以这样的个性化配置文件我们一般不把它推送到git服务器中，但是又为了偷懒每次添加缓存的时候都想用git add .而不是手动一个一个文件添加，该怎么办呢？很简单，git为我们提供了一个.gitignore文件只要在这个文件中申明那些文件你不希望添加到git中去，这样当你使用git add .的时候这些文件就会被自动忽略掉。</p>

<p>二、忽略文件的原则
忽略操作系统自动生成的文件，比如缩略图等；
忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；
忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。
三、使用方法
首先，在你的工作区新建一个名称为.gitignore的文件。
然后，把要忽略的文件名填进去，Git就会自动忽略这些文件。
不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>

<p>比如你的项目是java项目，.java文件编译后会生成.class文件，这些文件多数情况下是不想被传到仓库中的文件。这时候你可以直接适用github的.gitignore文件模板 <a href="https://github.com/github/gitignore/blob/master/Java.gitignore">https://github.com/github/gitignore/blob/master/Java.gitignore</a> 将这些忽略文件信息复制到你的.gitignore文件中去：</p>

<p>*.class</p>

<h1 id="mobile-tools-for-java-j2me">Mobile Tools for Java (J2ME)</h1>

<p>.mtj.tmp/</p>

<h1 id="package-files">Package Files</h1>

<p>*.jar
*.war
*.ear</p>

<h1 id="virtual-machine-crash-logs-see-http-www-java-com-en-download-help-error-hotspot-xml">virtual machine crash logs, see <a href="http://www.java.com/en/download/help/error_hotspot.xml">http://www.java.com/en/download/help/error_hotspot.xml</a></h1>

<p>hs_err_pid*
可以看到github为我们提供了最流行的.gitignore文件配置。
保存.ignore文件后我们查看下git status，检查下是否还有我们不需要的文件会被添加到git中去：</p>

<p>$ git status
On branch master</p>

<p>Initial commit</p>

<p>Changes to be committed:
  (use &ldquo;git rm &ndash;cached <file>&hellip;&rdquo; to unstage)</p>

<pre><code>    new file:   .gitignore
    new file:   HelloWorld.java
</code></pre>

<p>Untracked files:
  (use &ldquo;git add <file>&hellip;&rdquo; to include in what will be committed)</p>

<pre><code>    Config.ini
</code></pre>

<p>比如我的项目目录下有一个Config.ini文件，这个是个本地配置文件我不希望上传到git中去，我们可以在gitignore文件中添加这样的配置：</p>

<p>Config.ini
或者你想忽略所有的.ini文件你可以这样写：</p>

<p><em>.ini
如果有些文件已经被你忽略了，当你使用git add时是无法添加的，比如我忽略了</em>.class，现在我想把HelloWorld.class添加到git中去：</p>

<p>$ git add HelloWorld.class
The following paths are ignored by one of your .gitignore files:
HelloWorld.class
Use -f if you really want to add them.
git会提示我们这个文件已经被我们忽略了，需要加上-f参数才能强制添加到git中去：</p>

<p>$ git status
On branch master</p>

<p>Initial commit</p>

<p>Changes to be committed:
  (use &ldquo;git rm &ndash;cached <file>&hellip;&rdquo; to unstage)</p>

<pre><code>    new file:   .gitignore
    new file:   HelloWorld.class
    new file:   HelloWorld.java
</code></pre>

<p>这样就能强制添加到缓存中去了。
如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用rm命令将其从中移除：</p>

<p>$ git rm HelloWorld.class &ndash;cached
rm &lsquo;HelloWorld.class&rsquo;
如果你已经把不想上传的文件上传到了git仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后pull代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore文件中添加这些你想忽略的文件，然后再push到远程仓库。</p>

<p>四、查看gitignore规则
如果你发下.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：</p>

<p>$ git check-ignore -v HelloWorld.class
.gitignore:1:<em>.class    HelloWorld.class
可以看到HelloWorld.class匹配到了我们的第一条</em>.class的忽略规则所以文件被忽略了。</p>

<p>五、忽略规则文件语法
a.忽略指定文件/目录</p>

<h1 id="忽略指定文件">忽略指定文件</h1>

<p>HelloWrold.class</p>

<h1 id="忽略指定文件夹">忽略指定文件夹</h1>

<p>bin/
bin/gen/
b.通配符忽略规则
通配符规则如下：</p>

<h1 id="忽略-class的所有文件">忽略.class的所有文件</h1>

<p>*.class</p>

<h1 id="忽略名称中末尾为ignore的文件夹">忽略名称中末尾为ignore的文件夹</h1>

<p>*ignore/</p>

<h1 id="忽略名称中间包含ignore的文件夹">忽略名称中间包含ignore的文件夹</h1>

<p><em>ignore</em>/</p>

<p>可以使用git add -f来强制忽略这个文件</p>

<p>问题七：
git clean命令用来从你的工作目录中删除所有没有tracked过的文件</p>

<p>git clean经常和git reset &ndash;hard一起结合使用. 记住reset只影响被track过的文件, 所以需要clean来删除没有track过的文件. 结合使用这两个命令能让你的工作目录完全回到一个指定的<commit>的状态</p>

<p>用法</p>

<p>git clean -n</p>

<p>是一次clean的演习, 告诉你哪些文件会被删除. 记住他不会真正的删除文件, 只是一个提醒</p>

<p>git clean -f　　</p>

<p>删除当前目录下所有没有track过的文件. 他不会删除.gitignore文件里面指定的文件夹和文件, 不管这些文件有没有被track过</p>

<p>git clean -f <path></p>

<p>删除指定路径下的没有被track过的文件</p>

<p>git clean -df</p>

<p>删除当前目录下没有被track过的文件和文件夹</p>

<p>git clean -xf</p>

<p>删除当前目录下所有没有track过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件</p>

<p>讨论</p>

<p>git reset &ndash;hard和git clean -f是一对好基友. 结合使用他们能让你的工作目录完全回退到最近一次commit的时候</p>

<p>git clean对于刚编译过的项目也非常有用. 如, 他能轻易删除掉编译后生成的.o和.exe等文件. 这个在打包要发布一个release的时候非常有用</p>

<p>git reset &ndash;soft
git reset &ndash;hard
前者表示只是改变了HEAD的指向，本地代码不会变化，我们使用git status依然可以看到，同时也可以git commit提交。后者直接回改变本地源码，不仅仅指向变化了，代码也回到了那个版本时的代码，所以使用是一定要小心，想清楚。</p>

<p>过后可能需要使用这个</p>

<p>也可以取消git add 命令，指令如下
git rm &ndash;cached xxx文件名xxx git rm</p>

<p>这个时候再次push可以将远程github仓库回归，因为web界面没有这个降级功能</p>

<p>提交失败，因为当前分支的版本低于远程分支的版本，所以要想覆盖掉它，必须使用force
git push origin 分支 &ndash;force ok，大功告成</p>

<p>例子</p>

<p>下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发</p>

<p>git reset &ndash;hard</p>

<p>git clean -df</p>

<p>运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态，git status会告诉你这是一个干净的工作目录, 又是一个新的开始了！</p>

<p>git reset</p>

<p>git reset &ndash;soft</p>

<p>将HEAD引用指向给定提交。索引和工作目录的内容是不变的，在三个命令中对现有版本库状态改动最小。</p>

<p>git reset &ndash;mixed（git reset默认的模式）</p>

<p>HEAD引用指向给定提交，并且索引内容也跟着改变，工作目录内容不变。这个命令会将索引变成你刚刚暂存该提交全部变化是的状态，会显示工作目录中有什么修改。</p>

<p>git reset &ndash;hard</p>

<p>HEAD引用指向给定提交，索引内容和工作目录内容都会变给定提交时的状态。也就是在给定提交后所修改的内容都会丢失(新文件会被删除，不在工作目录中的文件恢复，未清除回收站的前提)。</p>

<p>描述错了，修改</p>

<p>只是本地进行了commit，并且没有进行新的commit，只需要git commit &ndash;amend;如果进行了新的commit，只需要git reset &ndash;soft xxx （xxx有问题那次提交的commit id），然后在进行git commit就行</p>

<p>问题九：
src refspec v0.9.5 matches more than one</p>

<p>本地tag和远程一样，删除本地tag
git tag -d v0.9.5</p>

<p>10.在你操作命令后面加&ndash;allow-unrelated-histories
例如：
git merge master &ndash;allow-unrelated-histories</p>

<p>~/SpringSpace/newframe on  druid ⌚ 11:36:49
$ git merge master &ndash;allow-unrelated-histories
Auto-merging .gitignore
CONFLICT (add/add): Merge conflict in .gitignore
Automatic merge failed; fix conflicts and then commit the result.</p>

<p>如果你是git pull或者git push报fatal: refusing to merge unrelated histories
同理：
git pull origin master &ndash;allow-unrelated-histories</p>

<p>11.记录一次操作</p>

<p>我dev分支有一个release版本，我在这这个基础上进行开发，突然这个releaase版本出现bug，需要修改，由于没有按着规范，导致需要切回到release的commit，比较麻烦，我这是时候checkout了一个新分支，进行commit，再切回原来分支，就可以还原了。修改的东西都可以保存，最好还是按着规范来，新建分支进行开发。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">kingjcy</a>
                    <br />本文出处：<a target="_blank" href="https://kingjcy.github.io/post/tool/gitandgithub/">https://kingjcy.github.io/post/tool/gitandgithub/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/tool/">
                            <i class="fa fa-tags"></i>
                            tool
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/git/">
                            <i class="fa fa-tags"></i>
                            git
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/github/">
                            <i class="fa fa-tags"></i>
                            github
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/post/tool/vpn/">工具系列---- Vpn</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2017年12月12日)</span></li><li id="li-rels"><a href="/post/linux/tool/yum/">Yum</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2015年12月10日)</span></li><li id="li-rels"><a href="/post/tool/vi-vim/">Vi Vim</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2015年11月22日)</span></li><li id="li-rels"><a href="/post/linux/tool/shell/">linux工具系列---- Shell</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2015年03月12日)</span></li><li id="li-rels"><a href="/post/tool/hugo-blog-build/">用hugo&#43;github构建自己的blog</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2014年08月29日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/post/tool/markdown/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/post/computerbase/ip/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li><a href="#git"><em>git</em></a>
<ul>
<li>
<ul>
<li><a href="#安装">安装</a></li>
<li><a href="#本地操作使用">本地操作使用</a></li>
</ul></li>
</ul></li>
<li><a href="#github"><em>github</em></a></li>
<li><a href="#正常流程">正常流程：</a>
<ul>
<li>
<ul>
<li><a href="#管理员">管理员</a></li>
<li><a href="#团队成员操作">团队成员操作</a></li>
</ul></li>
</ul></li>
<li><a href="#公司流程">公司流程</a></li>
<li><a href="#git-工具-子模块">Git 工具 - 子模块</a></li>
<li><a href="#git打标签与版本控制规范">Git打标签与版本控制规范</a></li>
<li><a href="#问题记录">问题记录</a></li>
<li><a href="#mobile-tools-for-java-j2me">Mobile Tools for Java (J2ME)</a></li>
<li><a href="#package-files">Package Files</a></li>
<li><a href="#virtual-machine-crash-logs-see-http-www-java-com-en-download-help-error-hotspot-xml">virtual machine crash logs, see <a href="http://www.java.com/en/download/help/error_hotspot.xml">http://www.java.com/en/download/help/error_hotspot.xml</a></a></li>
<li><a href="#忽略指定文件">忽略指定文件</a></li>
<li><a href="#忽略指定文件夹">忽略指定文件夹</a></li>
<li><a href="#忽略-class的所有文件">忽略.class的所有文件</a></li>
<li><a href="#忽略名称中末尾为ignore的文件夹">忽略名称中末尾为ignore的文件夹</a></li>
<li><a href="#忽略名称中间包含ignore的文件夹">忽略名称中间包含ignore的文件夹</a></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2020  kingjcy blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

