<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>随笔杂记 on kingjcy blog</title>
    <link>https://kingjcy.github.io/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%AE%B0/</link>
    <description>Recent content in 随笔杂记 on kingjcy blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2020. All rights reserved.</copyright>
    <lastBuildDate>Mon, 07 Oct 2019 16:16:25 +0800</lastBuildDate>
    
	<atom:link href="https://kingjcy.github.io/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Node</title>
      <link>https://kingjcy.github.io/post/web/language/node/</link>
      <pubDate>Mon, 07 Oct 2019 16:16:25 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/web/language/node/</guid>
      <description>npm run 运行脚本是在package.json中定义的
比如编译
npm run build
^CchunyindeMacBook-Pro:web chunyinjiang$ npm run Scripts available in web via `npm run-script`: serve vue-cli-service serve build vue-cli-service build lint vue-cli-service lint  文件中
 &amp;quot;scripts&amp;quot;: { &amp;quot;serve&amp;quot;: &amp;quot;vue-cli-service serve&amp;quot;, &amp;quot;build&amp;quot;: &amp;quot;vue-cli-service build&amp;quot;, &amp;quot;lint&amp;quot;: &amp;quot;vue-cli-service lint&amp;quot; },  问题
 Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 12.x  这段代码就是告诉你，node-sass 不兼容 node v8 的版本。那就很好解决了。在当前项目下面执行
npm i node-sass -D</description>
    </item>
    
    <item>
      <title>Go Net Http Cgi</title>
      <link>https://kingjcy.github.io/post/golang/go-net-http-cgi/</link>
      <pubDate>Thu, 26 Sep 2019 17:05:54 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-net-http-cgi/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go Net Cgi</title>
      <link>https://kingjcy.github.io/post/golang/go-net-cgi/</link>
      <pubDate>Thu, 26 Sep 2019 17:05:29 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-net-cgi/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Socket</title>
      <link>https://kingjcy.github.io/post/middleware/network/socket/</link>
      <pubDate>Thu, 19 Sep 2019 11:30:01 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/middleware/network/socket/</guid>
      <description>&lt;p&gt;socket原理详解&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Containerlogcollect</title>
      <link>https://kingjcy.github.io/post/programe/log/containerlogcollect/</link>
      <pubDate>Fri, 30 Aug 2019 14:55:28 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/programe/log/containerlogcollect/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Oracle</title>
      <link>https://kingjcy.github.io/post/database/oracle/</link>
      <pubDate>Thu, 18 Apr 2019 20:13:52 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/database/oracle/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://kingjcy.github.io/post/database/orm/mybatis/</link>
      <pubDate>Wed, 17 Apr 2019 20:46:44 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/database/orm/mybatis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Mycat</title>
      <link>https://kingjcy.github.io/post/database/mysql/mycat/</link>
      <pubDate>Wed, 17 Apr 2019 20:45:34 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/database/mysql/mycat/</guid>
      <description>如今随着互联网的发展，数据的量级也是撑指数的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求。这个时候NoSQL的出现暂时解决了这一危机。它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升。但是，在有些场合NoSQL一些折衷是无法满足使用场景的，就比如有些使用场景是绝对要有事务与安全指标的。这个时候NoSQL肯定是无法满足的，所以还是需要使用关系性数据库。如何使用关系型数据库解决海量存储的问题呢？此时就需要做数据库集群，为了提高查询性能将一个数据库的数据分散到不同的数据库中存储，为应对此问题就出现了——MyCat
关系型数据库分布式处理方案，目前支持mysql，sqlserver，mongoDB，pg，oracle等
mycat原理：可以用“拦截”一词形容，它拦截了用户发送过来的SQL语句，首先对SQL语句做了一些特定的分析，如分片分析，路由分析，读写分离分析，缓存分析等，然后将此sql发往后端的真实数据库，并将返回的结果做适当处理，最终返回给用户
分片
 数据库分片指：通过某种特定的条件，将我们存放在一个数据库中的数据分散存放在不同的多个数据库（主机）中，这样来达到分散单台设备的负载，根据切片规则，可分为以下两种切片模式：
 垂直切片 将不同的表切分到不同的数据库中
 水平切片 将同一种表按照某种条件切分到不同的数据库中（这种方式最常用）
  应用场景
Mycat发展到现在，适用的场景已经很丰富，而且不断有新用户给出新的创新性的方案，以下是几个典型的应用场景：
单纯的读写分离，此时配置最为简单，支持读写分离，主从切换
分表分库，对于超过1000万的表进行分片，最大支持1000亿的单表分片
多租户应用，每个应用一个库，但应用程序只连接Mycat，从而不改造程序本身，实现多租户化
报表系统，借助于Mycat的分表能力，处理大规模报表的统计
替代Hbase，分析大数据
作为海量数据实时查询的一种简单有效方案，比如100亿条频繁查询的记录需要在3秒内查询出来结果，除了基于主键的查询，还可能存在范围查询或其他属性查询，此时Mycat可能是最简单有效的选择</description>
    </item>
    
    <item>
      <title>Mha</title>
      <link>https://kingjcy.github.io/post/database/mysql/mha/</link>
      <pubDate>Wed, 17 Apr 2019 20:45:25 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/database/mysql/mha/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Linux Deamon</title>
      <link>https://kingjcy.github.io/post/linux/tool/linux-deamon/</link>
      <pubDate>Wed, 17 Apr 2019 20:25:07 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/linux/tool/linux-deamon/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Kickstart</title>
      <link>https://kingjcy.github.io/post/linux/tool/kickstart/</link>
      <pubDate>Wed, 17 Apr 2019 20:15:54 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/linux/tool/kickstart/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Gpu_exporter</title>
      <link>https://kingjcy.github.io/post/monitor/prometheus/exporter/gpu_exporter/</link>
      <pubDate>Mon, 15 Apr 2019 19:21:01 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/monitor/prometheus/exporter/gpu_exporter/</guid>
      <description>&lt;p&gt;随着区块链、人工智能的盛行，越来越多的场景开始使用GPU，而其监控也随之受到重视。目前生产环境中大部分GPU为NVIDIA厂商，今天就聊聊公司内部如何进行GPU的监控。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gin</title>
      <link>https://kingjcy.github.io/post/golang/frame/gin/</link>
      <pubDate>Wed, 13 Mar 2019 09:51:04 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/frame/gin/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Subscribe</title>
      <link>https://kingjcy.github.io/post/architecture/subscribe/</link>
      <pubDate>Mon, 11 Mar 2019 10:14:55 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/architecture/subscribe/</guid>
      <description>实例：可靠消息通知系统。
可靠消息通知系统实际上是一个非常常见的系统。最常用的一个例子就是数据库的master slave 模式。master里面的事件要非常可靠的通知到slave，中间不能有任何的丢失。还有一种比如交易系统中，我们会调用银行或者交易所的接口，银行在交易成功后会给我们一个通知，这个通知的消息必须可靠的被通知到目标，不能有任何的丢失。在我们的系统中，行情数据的复制也是不能有任何数据丢失的情景，为了保证A 服务器 和 B服务器有相同的行情，在从A服务器的消息要被B服务器准确的接收。当然，你也可以做一个聊天系统，这个聊天系统不会丢失任何消息。
那么如何实现这个系统呢，首先，为了保证不在内存中丢失消息，那么消息必须写盘，并且为了检测消息是否丢失，必须给消息编号。消息写盘也可以用我们开发的事务日志系统，如果消息非常的大量，那么还需要批量提交模式（Group Commit）。大部分情况下，消息丢失不是因为服务器崩溃，而且网络意外中断，这些中断往往时间很短，在1分钟以内，所以，有必要在内存中缓存部分的消息，如果网络中断，客户端再次请求时，发送当时的消息序号，这样就可以补全网络中断丢失的数据。如果时间太长了，内存中的数据不够补了，那么首先要从消息源数据库中下载历史消息，然后再接受实时的消息。整体的思路就是这样的，在这里，我们就看看我们的消息通知系统的实时广播部分的设计。
 消息广播基本流程： 订阅 –&amp;gt; 广播：  首先客户端向服务器说明，我要订阅哪些消息，比如，master slave 中，我只要写消息就好了，读消息就不需要了。然后，再向服务器请求数据，服务器广播数据给我们。注意，我们这里把订阅 和 广播分成两个部分，两个请求，那么怎么知道这两个请求是同一个人发出的呢？或者，怎么关联起来呢？这里，我用了一个session的概念，订阅的时候，把订阅的消息类型保存到session，广播的时候，从session中读取消息类型，然后发送对应的数据。
这部分的代码如下：
var bmu sync.Mutex var defaultBroadcast = make(map[int64]*Broadcast) var ErrNotRingItemer = errors.New(&amp;quot;ErrNotRingItemer&amp;quot;) //基本上可以保证有1个小时的数据 const btickSize = 3600 * 4 //可以传递任意的数据 func GetBroadcast(name int64, n int) (*Broadcast, error) { bmu.Lock() defer bmu.Unlock() b, ok := defaultBroadcast[name] if ok { return b, nil } b , err := NewBroadcast(name, n) if err !</description>
    </item>
    
    <item>
      <title>Pressure_test</title>
      <link>https://kingjcy.github.io/post/tool/pressure_test/</link>
      <pubDate>Thu, 28 Feb 2019 20:52:32 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/tool/pressure_test/</guid>
      <description>ab
webbench
go bench
负载生成器是一些生成用于测试的流量的程序。它们可以向你展示服务器在高负载的情况下的性能，以及让你能够找出服务器可能存在的问题。通过负载测试了解服务器的缺点，是测试服务器弹性以及未雨绸缪的好方法。
负载生成工具（Load-Generating Tools） 在进行负责测试时要牢记一件重要的事：你能在 Linux 上建立多少个 socket 连接。这个限制是硬编码在内核里的，最典型的就是临时 W 端口的限制。（在某种程度上）你可以在 /etc/sysctl.conf 里扩展它。但是基本上，一台 Linux 机器只能同时打开大约 64,000 个 socket（65535） 。因此在负载测试时，我们不得不通过在单一的连接上尽可能多地发出请求来充分利用 socket 。 除此之外，我们还需要不止一台的机器来产生负载。否则，负载生成器会把可用的 socket 占用导致不能产生足够的负载。
我一开始用的是‘ab’，Apache Bench 。它是我所知道的 http 基准测试工具中最简单、最通用的。并且它是 Apache 附带的产品，因此它可能已经存在于你的系统中。不幸的是，我在使用它的时候每秒大约只能生成 900 个请求。虽然我见过其他人使用它每秒能达到 2,000 个请求，但我可以立即告诉你，‘ab’并不适合我们的基准测试。
Httperf 接着，我尝试了 ‘httperf’。这个工具更强大，但是它依然相对简单并且功能有限。要算出每秒生产了多少个请求并不是仅传递参数那么简单。经过我的多次尝试，获取了每秒超过几百请求的结果。例如：
它以每秒 1,000 个的速率创建了 100,000 个会话（session）。每次会话发起 5 次请求，时间间隔为 2 秒。
httperf &amp;ndash;hog &amp;ndash;server=192.168.122.10 &amp;ndash;wsess=100000,5,2 &amp;ndash;rate 1000 &amp;ndash;timeout 5
Total: connections 117557 requests 219121 replies 116697 test-duration 111.423 s
Connection rate: 1055.</description>
    </item>
    
    <item>
      <title>Clickhouse</title>
      <link>https://kingjcy.github.io/post/database/clickhouse/</link>
      <pubDate>Fri, 22 Feb 2019 10:16:38 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/database/clickhouse/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Alertmanager</title>
      <link>https://kingjcy.github.io/post/monitor/prometheus/alertmanager/</link>
      <pubDate>Tue, 12 Feb 2019 16:00:11 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/monitor/prometheus/alertmanager/</guid>
      <description>&lt;p&gt;告警生态系统&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pushgateway</title>
      <link>https://kingjcy.github.io/post/monitor/prometheus/pushgateway/</link>
      <pubDate>Tue, 12 Feb 2019 16:00:00 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/monitor/prometheus/pushgateway/</guid>
      <description>Pushgateway 简介 Pushgateway 是 Prometheus 生态中一个重要工具，使用它的原因主要是：
1、Prometheus 采用 pull 模式，可能由于不在一个子网或者防火墙原因，或者prometheus不能确定到哪个节点上去拉去数据，导致 Prometheus 无法直接拉取各个 target 数据。在监控业务数据的时候，需要将不同数据汇总, 由 Prometheus 统一收集。 2、数据采集还没有完成，进程就停止了，所以使用网关，先让应用把自身的指标push到pushgetway中让prometheus去采集  由于以上原因，不得不使用 pushgateway，但在使用之前，有必要了解一下它的一些弊端：
1. 将多个节点数据汇总到 pushgateway, 如果 pushgateway 挂了，受影响比多个 target 大。 2. Prometheus 拉取状态 up 只针对 pushgateway, 无法做到对每个节点有效。 3. Pushgateway 可以持久化推送给它的所有监控数据。因此，即使你的监控已经下线，prometheus 还会拉取到旧的监控数据，需要手动清理 pushgateway 不要的数据。  安装
https://github.com/prometheus/pushgateway/releases/download/v0.4.0/pushgateway-0.4.0.linux-amd64.tar.gz
我们可以使用 ./pushgateway -h 查看运行选项，./pushgateway 运行 pushgateway
docker
docker pull prom/pushgateway docker run -d -p 9091:9091 prom/pushgateway  可以发现 pushgateway 中的数据我们通常按照 job 和 instance 分组分类，所以这两个参数不可缺少。因为 Prometheus 配置 pushgateway 的时候，也会指定 job 和 instance, 但是它只表示 pushgateway 实例，不能真正表达收集数据的含义。所以在 prometheus 中配置 pushgateway 的时候，需要添加 honor_labels: true 参数， 从而避免收集数据本身的 job 和 instance 被覆盖。</description>
    </item>
    
    <item>
      <title>Exporter</title>
      <link>https://kingjcy.github.io/post/monitor/prometheus/exporter/</link>
      <pubDate>Tue, 12 Feb 2019 15:59:42 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/monitor/prometheus/exporter/</guid>
      <description>exporter 文本格式
在讨论 Exporter 之前，有必要先介绍一下 Prometheus 文本数据格式，因为一个 Exporter 本质上就是将收集的数据，转化为对应的文本格式，并提供 http 请求。
Exporter 收集的数据转化的文本内容以行 (\n) 为单位，空行将被忽略, 文本内容最后一行为空行。
注释
文本内容，如果以 # 开头通常表示注释。
以 # HELP 开头表示 metric 帮助说明。 以 # TYPE 开头表示定义 metric 类型，包含 counter, gauge, histogram, summary, 和 untyped 类型。  其他表示一般注释，供阅读使用，将被 Prometheus 忽略。
采样数据的样式
内容如果不以 # 开头，表示采样数据。它通常紧挨着类型定义行，满足以下格式：
metric_name [ &amp;quot;{&amp;quot; label_name &amp;quot;=&amp;quot; `&amp;quot;` label_value `&amp;quot;` { &amp;quot;,&amp;quot; label_name &amp;quot;=&amp;quot; `&amp;quot;` label_value `&amp;quot;` } [ &amp;quot;,&amp;quot; ] &amp;quot;}&amp;quot; ] value [ timestamp ]  下面是一个完整的例子：</description>
    </item>
    
    <item>
      <title>Go Process</title>
      <link>https://kingjcy.github.io/post/golang/go-process/</link>
      <pubDate>Fri, 01 Feb 2019 12:00:29 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-process/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go Dbsql</title>
      <link>https://kingjcy.github.io/post/golang/go-dbsql/</link>
      <pubDate>Fri, 01 Feb 2019 11:57:36 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-dbsql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2018 Summary</title>
      <link>https://kingjcy.github.io/post/summary/2018-summary/</link>
      <pubDate>Thu, 24 Jan 2019 19:48:35 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/summary/2018-summary/</guid>
      <description>2018年
反思：自己是不是真的要离职，假如不离职，在老东家接下来应该做什么才能继续提升？ 定位：我在硬性技能（编码、架构）上的长处在哪？我在软技能（沟通，团队）上的长处在哪？这步顺带写了简历 寻找平台：哪些平台能同时满足：1、有挑战有上升空间；2、符合我的定位方向；3、团队氛围和老东家一样好（或更好） 找人内推：基本都是在 v2 上找的（诚挚感谢各位帮助我内推的大佬）</description>
    </item>
    
    <item>
      <title>Go Clinet</title>
      <link>https://kingjcy.github.io/post/golang/go-clinet/</link>
      <pubDate>Sun, 24 Apr 2016 14:50:29 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/golang/go-clinet/</guid>
      <description>&lt;h1 id=&#34;go命令行工具&#34;&gt;go命令行工具&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Self Discipline</title>
      <link>https://kingjcy.github.io/post/worklife/self-discipline/</link>
      <pubDate>Wed, 12 Dec 2012 19:11:40 +0800</pubDate>
      
      <guid>https://kingjcy.github.io/post/worklife/self-discipline/</guid>
      <description>自律 其实这些我一直都知道，只不过是懂的越多越来越迷茫了，感觉人力有时尽，其实我现在缺少的就是行动和坚持行动（并不代表迂腐的一层不变，特殊情况特殊对待，知变通），合理安排时间，不浪费自己认为毫无意义的时间。
 目标太大，那就重小目标开始，重头开始，一个个养成，先坚持自己极度不想做的事情开始 克服自卑&amp;ndash;只要上面做到了也就自信了，哪怕自信被打的一蹶不振，我依旧用勇气 控制人生先重控制自己身体开始，目前最大的毛病是肥胖。   leetcode 目标：一天一题 每天坚持运动  目标    year life work     2019     2020         year quarter life work     2019 4     2020 1         year mouth life work     2019 11 1.</description>
    </item>
    
  </channel>
</rss>